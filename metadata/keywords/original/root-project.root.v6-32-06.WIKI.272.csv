id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html602/RooPullVar.html:3700,Usability,clear,clearValueAndShapeDirty,3700,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = Roo",MatchSource.WIKI,root/html602/RooPullVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooPullVar.html
https://root.cern/root/html602/RooPullVar.html:3748,Usability,clear,clearValueDirty,3748,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html602/RooPullVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooPullVar.html
https://root.cern/root/html602/RooQuasiRandomGenerator.html:596,Deployability,release,release,596,". RooQuasiRandomGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooQuasiRandomGenerator. class RooQuasiRandomGenerator. This class generates the quasi-random (aka ""low discrepancy""); sequence for dimensions up to 12 using the Niederreiter base 2; algorithm described in Bratley, Fox, Niederreiter, ACM Trans.; Model. Comp. Sim. 2, 195 (1992). This implementation was adapted; from the 0.9 beta release of the GNU scientific library.; Quasi-random number sequences are useful for improving the; convergence of a Monte Carlo integration.; . Function Members (Methods); public:. virtual~RooQuasiRandomGenerator(); static TClass*Class(); Bool_tgenerate(UInt_t dimension, Double_t[] vector); virtual TClass*IsA() const; RooQuasiRandomGenerator&operator=(const RooQuasiRandomGenerator&); voidreset(); RooQuasiRandomGenerator(); RooQuasiRandomGenerator(const RooQuasiRandomGenerator&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. Int_tadd(Int_t x, Int_t y) const; voidcalculateCoefs(UInt_t dimension); voidcalculateV(const int[] px, int px_degree, int[] pb, int* pb_degree, int[] v, int maxv); Int_tmul(Int_t x, Int_t y) const; voidpolyMultiply(const int[] pa, int pa_degree, const int[] pb, int pb_degree, int[] pc, int* pc_degree); Int_tsub(Int_t x, Int_t y) const. Data Members; public:. static RooQuasiRandomGenerator::(anonymous)MaxDegree; static RooQuasiRandomGenerator::(anonymous)MaxDimension; static RooQuasiRandomGenerator::(anonymous)MaxPrimitiveDegree; static RooQuasiRandomGenerator::(anonymous)NBits. private:. static Int_t_cj[31][12]; static Bool_t_coefsCalculated; Int_t*_nextq; static const Int_t_polyDegree[13]; static const Int_t_primitivePoly[13][6]; Int_t_sequenceCount.",MatchSource.WIKI,root/html602/RooQuasiRandomGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooQuasiRandomGenerator.html
https://root.cern/root/html602/RooQuasiRandomGenerator.html:725,Deployability,integrat,integration,725,". RooQuasiRandomGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooQuasiRandomGenerator. class RooQuasiRandomGenerator. This class generates the quasi-random (aka ""low discrepancy""); sequence for dimensions up to 12 using the Niederreiter base 2; algorithm described in Bratley, Fox, Niederreiter, ACM Trans.; Model. Comp. Sim. 2, 195 (1992). This implementation was adapted; from the 0.9 beta release of the GNU scientific library.; Quasi-random number sequences are useful for improving the; convergence of a Monte Carlo integration.; . Function Members (Methods); public:. virtual~RooQuasiRandomGenerator(); static TClass*Class(); Bool_tgenerate(UInt_t dimension, Double_t[] vector); virtual TClass*IsA() const; RooQuasiRandomGenerator&operator=(const RooQuasiRandomGenerator&); voidreset(); RooQuasiRandomGenerator(); RooQuasiRandomGenerator(const RooQuasiRandomGenerator&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. Int_tadd(Int_t x, Int_t y) const; voidcalculateCoefs(UInt_t dimension); voidcalculateV(const int[] px, int px_degree, int[] pb, int* pb_degree, int[] v, int maxv); Int_tmul(Int_t x, Int_t y) const; voidpolyMultiply(const int[] pa, int pa_degree, const int[] pb, int pb_degree, int[] pc, int* pc_degree); Int_tsub(Int_t x, Int_t y) const. Data Members; public:. static RooQuasiRandomGenerator::(anonymous)MaxDegree; static RooQuasiRandomGenerator::(anonymous)MaxDimension; static RooQuasiRandomGenerator::(anonymous)MaxPrimitiveDegree; static RooQuasiRandomGenerator::(anonymous)NBits. private:. static Int_t_cj[31][12]; static Bool_t_coefsCalculated; Int_t*_nextq; static const Int_t_polyDegree[13]; static const Int_t_primitivePoly[13][6]; Int_t_sequenceCount.",MatchSource.WIKI,root/html602/RooQuasiRandomGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooQuasiRandomGenerator.html
https://root.cern/root/html602/RooQuasiRandomGenerator.html:569,Energy Efficiency,adapt,adapted,569,". RooQuasiRandomGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooQuasiRandomGenerator. class RooQuasiRandomGenerator. This class generates the quasi-random (aka ""low discrepancy""); sequence for dimensions up to 12 using the Niederreiter base 2; algorithm described in Bratley, Fox, Niederreiter, ACM Trans.; Model. Comp. Sim. 2, 195 (1992). This implementation was adapted; from the 0.9 beta release of the GNU scientific library.; Quasi-random number sequences are useful for improving the; convergence of a Monte Carlo integration.; . Function Members (Methods); public:. virtual~RooQuasiRandomGenerator(); static TClass*Class(); Bool_tgenerate(UInt_t dimension, Double_t[] vector); virtual TClass*IsA() const; RooQuasiRandomGenerator&operator=(const RooQuasiRandomGenerator&); voidreset(); RooQuasiRandomGenerator(); RooQuasiRandomGenerator(const RooQuasiRandomGenerator&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. Int_tadd(Int_t x, Int_t y) const; voidcalculateCoefs(UInt_t dimension); voidcalculateV(const int[] px, int px_degree, int[] pb, int* pb_degree, int[] v, int maxv); Int_tmul(Int_t x, Int_t y) const; voidpolyMultiply(const int[] pa, int pa_degree, const int[] pb, int pb_degree, int[] pc, int* pc_degree); Int_tsub(Int_t x, Int_t y) const. Data Members; public:. static RooQuasiRandomGenerator::(anonymous)MaxDegree; static RooQuasiRandomGenerator::(anonymous)MaxDimension; static RooQuasiRandomGenerator::(anonymous)MaxPrimitiveDegree; static RooQuasiRandomGenerator::(anonymous)NBits. private:. static Int_t_cj[31][12]; static Bool_t_coefsCalculated; Int_t*_nextq; static const Int_t_polyDegree[13]; static const Int_t_primitivePoly[13][6]; Int_t_sequenceCount.",MatchSource.WIKI,root/html602/RooQuasiRandomGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooQuasiRandomGenerator.html
https://root.cern/root/html602/RooQuasiRandomGenerator.html:725,Integrability,integrat,integration,725,". RooQuasiRandomGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooQuasiRandomGenerator. class RooQuasiRandomGenerator. This class generates the quasi-random (aka ""low discrepancy""); sequence for dimensions up to 12 using the Niederreiter base 2; algorithm described in Bratley, Fox, Niederreiter, ACM Trans.; Model. Comp. Sim. 2, 195 (1992). This implementation was adapted; from the 0.9 beta release of the GNU scientific library.; Quasi-random number sequences are useful for improving the; convergence of a Monte Carlo integration.; . Function Members (Methods); public:. virtual~RooQuasiRandomGenerator(); static TClass*Class(); Bool_tgenerate(UInt_t dimension, Double_t[] vector); virtual TClass*IsA() const; RooQuasiRandomGenerator&operator=(const RooQuasiRandomGenerator&); voidreset(); RooQuasiRandomGenerator(); RooQuasiRandomGenerator(const RooQuasiRandomGenerator&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. Int_tadd(Int_t x, Int_t y) const; voidcalculateCoefs(UInt_t dimension); voidcalculateV(const int[] px, int px_degree, int[] pb, int* pb_degree, int[] v, int maxv); Int_tmul(Int_t x, Int_t y) const; voidpolyMultiply(const int[] pa, int pa_degree, const int[] pb, int pb_degree, int[] pc, int* pc_degree); Int_tsub(Int_t x, Int_t y) const. Data Members; public:. static RooQuasiRandomGenerator::(anonymous)MaxDegree; static RooQuasiRandomGenerator::(anonymous)MaxDimension; static RooQuasiRandomGenerator::(anonymous)MaxPrimitiveDegree; static RooQuasiRandomGenerator::(anonymous)NBits. private:. static Int_t_cj[31][12]; static Bool_t_coefsCalculated; Int_t*_nextq; static const Int_t_polyDegree[13]; static const Int_t_primitivePoly[13][6]; Int_t_sequenceCount.",MatchSource.WIKI,root/html602/RooQuasiRandomGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooQuasiRandomGenerator.html
https://root.cern/root/html602/RooQuasiRandomGenerator.html:569,Modifiability,adapt,adapted,569,". RooQuasiRandomGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooQuasiRandomGenerator. class RooQuasiRandomGenerator. This class generates the quasi-random (aka ""low discrepancy""); sequence for dimensions up to 12 using the Niederreiter base 2; algorithm described in Bratley, Fox, Niederreiter, ACM Trans.; Model. Comp. Sim. 2, 195 (1992). This implementation was adapted; from the 0.9 beta release of the GNU scientific library.; Quasi-random number sequences are useful for improving the; convergence of a Monte Carlo integration.; . Function Members (Methods); public:. virtual~RooQuasiRandomGenerator(); static TClass*Class(); Bool_tgenerate(UInt_t dimension, Double_t[] vector); virtual TClass*IsA() const; RooQuasiRandomGenerator&operator=(const RooQuasiRandomGenerator&); voidreset(); RooQuasiRandomGenerator(); RooQuasiRandomGenerator(const RooQuasiRandomGenerator&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. Int_tadd(Int_t x, Int_t y) const; voidcalculateCoefs(UInt_t dimension); voidcalculateV(const int[] px, int px_degree, int[] pb, int* pb_degree, int[] v, int maxv); Int_tmul(Int_t x, Int_t y) const; voidpolyMultiply(const int[] pa, int pa_degree, const int[] pb, int pb_degree, int[] pc, int* pc_degree); Int_tsub(Int_t x, Int_t y) const. Data Members; public:. static RooQuasiRandomGenerator::(anonymous)MaxDegree; static RooQuasiRandomGenerator::(anonymous)MaxDimension; static RooQuasiRandomGenerator::(anonymous)MaxPrimitiveDegree; static RooQuasiRandomGenerator::(anonymous)NBits. private:. static Int_t_cj[31][12]; static Bool_t_coefsCalculated; Int_t*_nextq; static const Int_t_polyDegree[13]; static const Int_t_primitivePoly[13][6]; Int_t_sequenceCount.",MatchSource.WIKI,root/html602/RooQuasiRandomGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooQuasiRandomGenerator.html
https://root.cern/root/html602/RooRandom.html:309,Integrability,interface,interface,309,". RooRandom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRandom. class RooRandom. This class provides a static interface for generating random numbers.; By default a private copy of TRandom3 is used to generate all random numbers.; . Function Members (Methods); public:. virtual~RooRandom(); static TClass*Class(); static Double_tgaussian(TRandom* generator = randomGenerator()); static UInt_tinteger(UInt_t max, TRandom* generator = randomGenerator()); virtual TClass*IsA() const; RooRandom&operator=(const RooRandom&); static Bool_tquasi(UInt_t dimension, Double_t[] vector, RooQuasiRandomGenerator* generator = quasiGenerator()); static RooQuasiRandomGenerator*quasiGenerator(); static TRandom*randomGenerator(); RooRandom(const RooRandom&); static voidsetRandomGenerator(TRandom* gen); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static Double_tuniform(TRandom* generator = randomGenerator()); static voiduniform(UInt_t dimension, Double_t[] vector, TRandom* generator = randomGenerator()). private:. RooRandom(). Data Members; private:. static TRandom*_theGeneratorrandom number generator; static RooQuasiRandomGenerator*_theQuasiGeneratorquasi random number sequence generator; static struct Guardguard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom * randomGenerator(); Return a pointer to a singleton random-number generator; implementation. Creates the object the first time it is called. void setRandomGenerator(TRandom* gen); set the random number generator; takes ownership of the object passed as parameter. RooQuasiRandomGenerator * quasiGenerator(); Return a pointer to a singleton quasi-random generator; implementation. Creates th",MatchSource.WIKI,root/html602/RooRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRandom.html
https://root.cern/root/html602/RooRandom.html:2523,Modifiability,variab,variable,2523,"f_StreamerNVirtual_b); static Double_tuniform(TRandom* generator = randomGenerator()); static voiduniform(UInt_t dimension, Double_t[] vector, TRandom* generator = randomGenerator()). private:. RooRandom(). Data Members; private:. static TRandom*_theGeneratorrandom number generator; static RooQuasiRandomGenerator*_theQuasiGeneratorquasi random number sequence generator; static struct Guardguard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom * randomGenerator(); Return a pointer to a singleton random-number generator; implementation. Creates the object the first time it is called. void setRandomGenerator(TRandom* gen); set the random number generator; takes ownership of the object passed as parameter. RooQuasiRandomGenerator * quasiGenerator(); Return a pointer to a singleton quasi-random generator; implementation. Creates the object the first time it is called. Double_t uniform(TRandom* generator = randomGenerator()); Return a number uniformly distributed from (0,1). void uniform(UInt_t dimension, Double_t[] vector, TRandom* generator = randomGenerator()); Fill the vector provided with random numbers uniformly distributed from (0,1). UInt_t integer(UInt_t max, TRandom* generator = randomGenerator()); Return an integer uniformly distributed from [0,n-1]. Double_t gaussian(TRandom* generator = randomGenerator()); Return a Gaussian random variable with mean 0 and variance 1. Bool_t quasi(UInt_t dimension, Double_t[] vector, RooQuasiRandomGenerator* generator = quasiGenerator()); Return a quasi-random number in the range (0,1) using the; Niederreiter base 2 generator described in Bratley, Fox, Niederreiter,; ACM Trans. Model. Comp. Sim. 2, 195 (1992). virtual ~RooRandom(); {}. RooRandom(). » Last changed: Tue Jun 30 14:35:10 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRandom.html
https://root.cern/root/html602/RooRandomizeParamMCSModule.html:2186,Availability,error,error,2186,"izeParamMCSModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tRooAbsMCStudyModule::doInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataSet*finalizeRun(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char*",MatchSource.WIKI,root/html602/RooRandomizeParamMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRandomizeParamMCSModule.html
https://root.cern/root/html602/RooRandomizeParamMCSModule.html:2270,Availability,error,error,2270,"voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tRooAbsMCStudyModule::doInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataSet*finalizeRun(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vi",MatchSource.WIKI,root/html602/RooRandomizeParamMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRandomizeParamMCSModule.html
https://root.cern/root/html602/RooRandomizeParamMCSModule.html:6597,Integrability,depend,dependents,6597,"Object::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooArgSet*RooAbsMCStudyModule::allDependents(); Bool_tRooAbsMCStudyModule::binGenData(); RooArgSet*RooAbsMCStudyModule::dependents(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tRooAbsMCStudyModule::extendedGen(); RooArgSet*RooAbsMCStudyModule::fitInitParams(); RooAbsPdf*RooAbsMCStudyModule::fitModel(); const char*RooAbsMCStudyModule::fitOptions(); RooLinkedList*RooAbsMCStudyModule::fitOptList(); RooArgSet*RooAbsMCStudyModule::fitParams(); RooAbsGenContext*RooAbsMCStudyModule::genContext(); RooArgSet*RooAbsMCStudyModule::genInitParams(); RooAbsPdf*RooAbsMCStudyModule::genModel(); RooArgSet*RooAbsMCStudyModule::genParams(); const RooDataSet*RooAbsMCStudyModule::genProtoData(); RooAbsData*RooAbsMCStudyModule::genSample(); voidTObject::MakeZombie(); RooRealVar*RooAbsMCStudyModule::nllVar(); Double_tRooAbsMCStudyModule::numExpGen(); RooArgSet*RooAbsMCStudyModule::projDeps(); Bool_tRooAbsMCStudyModule::randProto(); RooFitResult*RooAbsMCStudyModule::refit(RooAbsData* inGenSample = 0); Bool_tRooAbsMCStudyModule::verboseGen(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoC",MatchSource.WIKI,root/html602/RooRandomizeParamMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRandomizeParamMCSModule.html
https://root.cern/root/html602/RooRandomizeParamMCSModule.html:612,Modifiability,variab,variable,612,". RooRandomizeParamMCSModule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRandomizeParamMCSModule. class RooRandomizeParamMCSModule: public RooAbsMCStudyModule. RooRandomizeParamMCSModule is an add-on modules to RooMCStudy that; allows you to randomize input generation parameters. Randomized generation; parameters can be sampled from a uniform or Gaussian distribution.; For every randomized parameter, an extra variable is added to ; RooMCStudy::fitParDataSet() named _gen that indicates the actual; value used for generation for each trial. ; ; You can also choose to randomize the sum of N parameters, rather; than a single parameter. In that case common multiplicative scale; factor is applied to each component to bring the sum to the desired; target value taken from either uniform or Gaussian sampling. This; latter option is for example useful if you want to change the total; number of expected events of an extended p.d.f; . Function Members (Methods); public:. virtual~RooRandomizeParamMCSModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tRooAbsMCStudyModule::doInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtu",MatchSource.WIKI,root/html602/RooRandomizeParamMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRandomizeParamMCSModule.html
https://root.cern/root/html602/RooRandomizeParamMCSModule.html:1117,Modifiability,extend,extended,1117,"ex; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRandomizeParamMCSModule. class RooRandomizeParamMCSModule: public RooAbsMCStudyModule. RooRandomizeParamMCSModule is an add-on modules to RooMCStudy that; allows you to randomize input generation parameters. Randomized generation; parameters can be sampled from a uniform or Gaussian distribution.; For every randomized parameter, an extra variable is added to ; RooMCStudy::fitParDataSet() named _gen that indicates the actual; value used for generation for each trial. ; ; You can also choose to randomize the sum of N parameters, rather; than a single parameter. In that case common multiplicative scale; factor is applied to each component to bring the sum to the desired; target value taken from either uniform or Gaussian sampling. This; latter option is for example useful if you want to change the total; number of expected events of an extended p.d.f; . Function Members (Methods); public:. virtual~RooRandomizeParamMCSModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tRooAbsMCStudyModule::doInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const ",MatchSource.WIKI,root/html602/RooRandomizeParamMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRandomizeParamMCSModule.html
https://root.cern/root/html602/RooRandomizeParamMCSModule.html:6736,Modifiability,extend,extendedGen,6736,"Object::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooArgSet*RooAbsMCStudyModule::allDependents(); Bool_tRooAbsMCStudyModule::binGenData(); RooArgSet*RooAbsMCStudyModule::dependents(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tRooAbsMCStudyModule::extendedGen(); RooArgSet*RooAbsMCStudyModule::fitInitParams(); RooAbsPdf*RooAbsMCStudyModule::fitModel(); const char*RooAbsMCStudyModule::fitOptions(); RooLinkedList*RooAbsMCStudyModule::fitOptList(); RooArgSet*RooAbsMCStudyModule::fitParams(); RooAbsGenContext*RooAbsMCStudyModule::genContext(); RooArgSet*RooAbsMCStudyModule::genInitParams(); RooAbsPdf*RooAbsMCStudyModule::genModel(); RooArgSet*RooAbsMCStudyModule::genParams(); const RooDataSet*RooAbsMCStudyModule::genProtoData(); RooAbsData*RooAbsMCStudyModule::genSample(); voidTObject::MakeZombie(); RooRealVar*RooAbsMCStudyModule::nllVar(); Double_tRooAbsMCStudyModule::numExpGen(); RooArgSet*RooAbsMCStudyModule::projDeps(); Bool_tRooAbsMCStudyModule::randProto(); RooFitResult*RooAbsMCStudyModule::refit(RooAbsData* inGenSample = 0); Bool_tRooAbsMCStudyModule::verboseGen(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoC",MatchSource.WIKI,root/html602/RooRandomizeParamMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRandomizeParamMCSModule.html
https://root.cern/root/html602/RooRangeBinning.html:2020,Availability,error,error,2020,"ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsBinning*clone(const char* name = 0) const; virtual TObject*RooAbsBinning::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Double_thighBound() const; virtual RooAbsReal*RooAbsBinning::highBoundFunc() const;",MatchSource.WIKI,root/html602/RooRangeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBinning.html
https://root.cern/root/html602/RooRangeBinning.html:2104,Availability,error,error,2104,"inning*clone(const char* name = 0) const; virtual TObject*RooAbsBinning::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Double_thighBound() const; virtual RooAbsReal*RooAbsBinning::highBoundFunc() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bo",MatchSource.WIKI,root/html602/RooRangeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBinning.html
https://root.cern/root/html602/RooRangeBoolean.html:9897,Availability,error,error,9897,,MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:9981,Availability,error,error,9981,,MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:34770,Deployability,integrat,integration,34770,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:36327,Deployability,integrat,integrator,36327,"labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRangeBoolean(); Default constructor. RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName). Ro",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:36338,Deployability,configurat,configuration,36338,"labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRangeBoolean(); Default constructor. RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName). Ro",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:7226,Integrability,depend,dependentVars,7226,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:8468,Integrability,depend,dependentOverlaps,8468,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:8560,Integrability,depend,dependentOverlaps,8560,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:8654,Integrability,depend,dependsOn,8654,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:8783,Integrability,depend,dependsOn,8783,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:8901,Integrability,depend,dependsOnValue,8901,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:9008,Integrability,depend,dependsOnValue,9008,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:17191,Integrability,message,message,17191,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:17342,Integrability,message,message,17342,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:34770,Integrability,integrat,integration,34770,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:36327,Integrability,integrat,integrator,36327,"labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRangeBoolean(); Default constructor. RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName). Ro",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:24227,Modifiability,config,config,24227,"e(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:36338,Modifiability,config,configuration,36338,"labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRangeBoolean(); Default constructor. RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName). Ro",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:1872,Performance,cache,cacheUniqueSuffix,1872,"iqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:10715,Performance,cache,cacheList,10715,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:10803,Performance,cache,cacheList,10803,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:19153,Performance,optimiz,optimizeCacheMode,19153,"ErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRangeBoolean&operator=(const RooRangeBoolean&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:19225,Performance,optimiz,optimizeCacheMode,19225,"observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRangeBoolean&operator=(const RooRangeBoolean&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:22699,Performance,cache,cache,22699,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRangeBoolean(); RooRangeBoolean(const RooRangeBoolean& other, const char* name = 0); RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual ",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:24070,Performance,cache,cache,24070,"Value& x, const char* rangeName); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:26165,Performance,cache,cache,26165,"voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:29222,Performance,optimiz,optimizeDirtyHook,29222,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:33680,Performance,cache,cache,33680,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:33763,Performance,cache,cache,33763,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:33961,Performance,cache,caches,33961,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:34493,Performance,cache,cache,34493,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:34672,Performance,cache,cache,34672,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:35085,Performance,cache,cache,35085,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:35980,Performance,cache,cache,35980,"labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRangeBoolean(); Default constructor. RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName). Ro",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:36522,Performance,cache,cache,36522,"labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRangeBoolean(); Default constructor. RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName). Ro",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:11647,Security,hash,hash,11647,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::ge",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:11798,Security,hash,hash,11798,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption()",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:33857,Security,validat,validate,33857,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:34593,Security,access,access,34593,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:8527,Testability,test,testArg,8527,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:8621,Testability,test,testArg,8621,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:17166,Testability,log,logEvalError,17166,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:17265,Testability,log,logEvalError,17265,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:18294,Testability,test,testArg,18294,"iginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRangeBoolean&operator=(const RooRangeBoolean&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:18389,Testability,test,testArg,18389,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRangeBoolean&operator=(const RooRangeBoolean&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnl",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:19369,Testability,test,testArg,19369,"ooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRangeBoolean&operator=(const RooRangeBoolean&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:3327,Usability,clear,clearEvalErrorLog,3327,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg:",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:3363,Usability,clear,clearShapeDirty,3363,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:3403,Usability,clear,clearValueAndShapeDirty,3403,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = Roo",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRangeBoolean.html:3451,Usability,clear,clearValueDirty,3451,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html602/RooRangeBoolean.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html
https://root.cern/root/html602/RooRealAnalytic.html:354,Energy Efficiency,adapt,adaptor,354,". RooRealAnalytic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealAnalytic. class RooRealAnalytic: public RooRealBinding. Lightweight RooAbsFunc interface adaptor that binds an analytic integral of a; RooAbsReal object (specified by a code) to a set of dependent variables.; . Function Members (Methods); public:. virtual~RooRealAnalytic(); virtual list<Double_t>*RooRealBinding::binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealAnalytic&operator=(const RooRealAnalytic&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooRealAnalytic(const RooRealAnalytic&); RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbs",MatchSource.WIKI,root/html602/RooRealAnalytic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealAnalytic.html
https://root.cern/root/html602/RooRealAnalytic.html:344,Integrability,interface,interface,344,". RooRealAnalytic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealAnalytic. class RooRealAnalytic: public RooRealBinding. Lightweight RooAbsFunc interface adaptor that binds an analytic integral of a; RooAbsReal object (specified by a code) to a set of dependent variables.; . Function Members (Methods); public:. virtual~RooRealAnalytic(); virtual list<Double_t>*RooRealBinding::binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealAnalytic&operator=(const RooRealAnalytic&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooRealAnalytic(const RooRealAnalytic&); RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbs",MatchSource.WIKI,root/html602/RooRealAnalytic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealAnalytic.html
https://root.cern/root/html602/RooRealAnalytic.html:452,Integrability,depend,dependent,452,". RooRealAnalytic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealAnalytic. class RooRealAnalytic: public RooRealBinding. Lightweight RooAbsFunc interface adaptor that binds an analytic integral of a; RooAbsReal object (specified by a code) to a set of dependent variables.; . Function Members (Methods); public:. virtual~RooRealAnalytic(); virtual list<Double_t>*RooRealBinding::binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealAnalytic&operator=(const RooRealAnalytic&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooRealAnalytic(const RooRealAnalytic&); RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbs",MatchSource.WIKI,root/html602/RooRealAnalytic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealAnalytic.html
https://root.cern/root/html602/RooRealAnalytic.html:2483,Integrability,depend,dependents,2483,"sValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealAnalytic&operator=(const RooRealAnalytic&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooRealAnalytic(const RooRealAnalytic&); RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t operator()(const Double_t[] xvector) const; Evaluate our analytic integral at the specified values of the dependents. inline RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); { }. virtual ~RooRealAnalytic(); { }. » Last changed: Tue Jun 30 14:35:15 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealAnalytic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealAnalytic.html
https://root.cern/root/html602/RooRealAnalytic.html:354,Modifiability,adapt,adaptor,354,". RooRealAnalytic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealAnalytic. class RooRealAnalytic: public RooRealBinding. Lightweight RooAbsFunc interface adaptor that binds an analytic integral of a; RooAbsReal object (specified by a code) to a set of dependent variables.; . Function Members (Methods); public:. virtual~RooRealAnalytic(); virtual list<Double_t>*RooRealBinding::binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealAnalytic&operator=(const RooRealAnalytic&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooRealAnalytic(const RooRealAnalytic&); RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbs",MatchSource.WIKI,root/html602/RooRealAnalytic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealAnalytic.html
https://root.cern/root/html602/RooRealAnalytic.html:462,Modifiability,variab,variables,462,". RooRealAnalytic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealAnalytic. class RooRealAnalytic: public RooRealBinding. Lightweight RooAbsFunc interface adaptor that binds an analytic integral of a; RooAbsReal object (specified by a code) to a set of dependent variables.; . Function Members (Methods); public:. virtual~RooRealAnalytic(); virtual list<Double_t>*RooRealBinding::binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealAnalytic&operator=(const RooRealAnalytic&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooRealAnalytic(const RooRealAnalytic&); RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbs",MatchSource.WIKI,root/html602/RooRealAnalytic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealAnalytic.html
https://root.cern/root/html602/RooRealAnalytic.html:1658,Performance,load,loadValues,1658," virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealAnalytic&operator=(const RooRealAnalytic&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooRealAnalytic(const RooRealAnalytic&); RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_tRooRealBinding::_clipInvalid; Int_t_code; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t operator()(const Double_t[] xvector) const; Evaluate our analytic integral at the specified values of the dependents. inline RooRealAnalytic(const RooAbsReal& func, const RooArgSet& vars, Int_t code, const RooArgSet* normSet = 0, const TNamed* rangeName = 0); { }. virtual ~RooRealAnalytic();",MatchSource.WIKI,root/html602/RooRealAnalytic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealAnalytic.html
https://root.cern/root/html602/RooRealBinding.html:336,Energy Efficiency,adapt,adaptor,336,". RooRealBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealBinding. class RooRealBinding: public RooAbsFunc. Lightweight interface adaptor that binds a RooAbsReal object to a subset; of its servers and present it as a simple array oriented interface.; . Function Members (Methods); public:. virtual~RooRealBinding(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealBinding&operator=(const RooRealBinding&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidrestoreXVec() const; RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidloadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_t_clipInvalid; list<RooAbsReal*>_compList!; list<Double_t>_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_func; Double_t_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nset; const TNamed*_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:326,Integrability,interface,interface,326,". RooRealBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealBinding. class RooRealBinding: public RooAbsFunc. Lightweight interface adaptor that binds a RooAbsReal object to a subset; of its servers and present it as a simple array oriented interface.; . Function Members (Methods); public:. virtual~RooRealBinding(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealBinding&operator=(const RooRealBinding&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidrestoreXVec() const; RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidloadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_t_clipInvalid; list<RooAbsReal*>_compList!; list<Double_t>_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_func; Double_t_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nset; const TNamed*_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:445,Integrability,interface,interface,445,". RooRealBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealBinding. class RooRealBinding: public RooAbsFunc. Lightweight interface adaptor that binds a RooAbsReal object to a subset; of its servers and present it as a simple array oriented interface.; . Function Members (Methods); public:. virtual~RooRealBinding(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealBinding&operator=(const RooRealBinding&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidrestoreXVec() const; RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidloadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_t_clipInvalid; list<RooAbsReal*>_compList!; list<Double_t>_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_func; Double_t_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nset; const TNamed*_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:336,Modifiability,adapt,adaptor,336,". RooRealBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealBinding. class RooRealBinding: public RooAbsFunc. Lightweight interface adaptor that binds a RooAbsReal object to a subset; of its servers and present it as a simple array oriented interface.; . Function Members (Methods); public:. virtual~RooRealBinding(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealBinding&operator=(const RooRealBinding&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidrestoreXVec() const; RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidloadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_t_clipInvalid; list<RooAbsReal*>_compList!; list<Double_t>_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_func; Double_t_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nset; const TNamed*_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:2304,Modifiability,variab,variables,2304,"ArgSet* nset = 0); RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidloadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_t_clipInvalid; list<RooAbsReal*>_compList!; list<Double_t>_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_func; Double_t_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nset; const TNamed*_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:2492,Modifiability,variab,variables,2492,"spector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidloadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_t_clipInvalid; list<RooAbsReal*>_compList!; list<Double_t>_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_func; Double_t_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nset; const TNamed*_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:2637,Modifiability,variab,variables,2637,"ers; protected:. Bool_t_clipInvalid; list<RooAbsReal*>_compList!; list<Double_t>_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_func; Double_t_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nset; const TNamed*_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) con",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:2825,Modifiability,variab,variables,2825,"l*_func; Double_t_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nset; const TNamed*_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variab",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3013,Modifiability,variab,variables,3013,"bsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(R",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3158,Modifiability,variab,variables,3158,"c, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3282,Modifiability,variab,variables,3282,"nction binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3340,Modifiability,variab,variables,3340,"nding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3461,Modifiability,variab,variable,3461,"nding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3513,Modifiability,variab,variables,3513,"nding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3649,Modifiability,variab,variable,3649,"nding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3759,Modifiability,variab,variable,3759,"nding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3842,Modifiability,variab,variable,3842,"nding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:3398,Performance,load,loadValues,3398,"nding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t[] xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t[] xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealBinding.html:423,Usability,simpl,simple,423,". RooRealBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealBinding. class RooRealBinding: public RooAbsFunc. Lightweight interface adaptor that binds a RooAbsReal object to a subset; of its servers and present it as a simple array oriented interface.; . Function Members (Methods); public:. virtual~RooRealBinding(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooRealBinding&operator=(const RooRealBinding&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidrestoreXVec() const; RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); RooRealBinding(const RooAbsReal& func, const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE, const TNamed* rangeName = 0); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidloadValues(const Double_t[] xvector) const. Data Members; protected:. Bool_t_clipInvalid; list<RooAbsReal*>_compList!; list<Double_t>_compSave!; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_func; Double_t_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nset; const TNamed*_rangeName!; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_vars; Double_t*_xsave; Bool_t_xvecValid. ",MatchSource.WIKI,root/html602/RooRealBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealBinding.html
https://root.cern/root/html602/RooRealConstant.html:1666,Availability,avail,available,1666,"tions:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealConstant. class RooRealConstant. RooRealConstant provides static functions to create and keep track; of RooRealVar constants. Instead of creating such constants by; hand (e.g. RooRealVar one(""one"",""one"",1)), simply use; ; RooRealConstant::value(1.0); ; whenever a reference to RooRealVar with constant value 1.0 is needed.; RooRealConstant keeps an internal database of previously created; RooRealVar objects and will recycle them as appropriate.; . Function Members (Methods); public:. virtual~RooRealConstant(); static TClass*Class(); static voidcleanup(); virtual TClass*IsA() const; RooRealConstant&operator=(const RooRealConstant&); static RooConstVar&removalDummy(); RooRealConstant(); RooRealConstant(const RooRealConstant&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static RooConstVar&value(Double_t value). protected:. static voidinit(). Data Members; protected:. static RooArgList*_constDBList of already instantiated constants; static TIterator*_constDBIterIterator over constants list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup function register with RooSentinel for cleanup in atexit(). RooConstVar& value(Double_t value); Return a constant value object with given value.; Return previously created object if available,; otherwise create a new one on the fly. RooConstVar& removalDummy(); Create a dummy node used in node-removal operations. void init(); One-time initialization of constants database. inline RooRealConstant(); {}. virtual ~RooRealConstant(); {}. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealConstant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealConstant.html
https://root.cern/root/html602/RooRealConstant.html:473,Usability,simpl,simply,473,". RooRealConstant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealConstant. class RooRealConstant. RooRealConstant provides static functions to create and keep track; of RooRealVar constants. Instead of creating such constants by; hand (e.g. RooRealVar one(""one"",""one"",1)), simply use; ; RooRealConstant::value(1.0); ; whenever a reference to RooRealVar with constant value 1.0 is needed.; RooRealConstant keeps an internal database of previously created; RooRealVar objects and will recycle them as appropriate.; . Function Members (Methods); public:. virtual~RooRealConstant(); static TClass*Class(); static voidcleanup(); virtual TClass*IsA() const; RooRealConstant&operator=(const RooRealConstant&); static RooConstVar&removalDummy(); RooRealConstant(); RooRealConstant(const RooRealConstant&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static RooConstVar&value(Double_t value). protected:. static voidinit(). Data Members; protected:. static RooArgList*_constDBList of already instantiated constants; static TIterator*_constDBIterIterator over constants list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup function register with RooSentinel for cleanup in atexit(). RooConstVar& value(Double_t value); Return a constant value object with given value.; Return previously created object if available,; otherwise create a new one on the fly. RooConstVar& removalDummy(); Create a dummy node used in node-removal operations. void init(); One-time initialization of constants database. inline RooRealConstant(); {}. virtual ~RooRealConstant(); {}. » Last changed: Tue Jun 30 14:35:16 2015 » Last generated: 2015-06-30 14:35; Thi",MatchSource.WIKI,root/html602/RooRealConstant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealConstant.html
https://root.cern/root/html602/RooRealIntegral.html:9570,Availability,error,error,9570,,MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:9654,Availability,error,error,9654,,MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:441,Deployability,integrat,integration,441,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:507,Deployability,integrat,integrated,507,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:597,Deployability,integrat,integrations,597,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:692,Deployability,integrat,integrations,692,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:761,Deployability,integrat,integration,761,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:34053,Deployability,integrat,integrated,34053,,MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35356,Deployability,integrat,integrated,35356," for byte values from tree branches; static Int_t_cacheAllNDim! Cache all integrals with given numeric dimension; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branche",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35706,Deployability,integrat,integration,35706,"ntListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35836,Deployability,integrat,integration,35836,"ion; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbs",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:36153,Deployability,continuous,continuous,36153,"::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:36190,Deployability,integrat,integrated,36190,"::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:36493,Deployability,integrat,integration,36493,"::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:38013,Deployability,integrat,integrator,38013,"RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherite",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:38024,Deployability,configurat,configuration,38024,"RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherite",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39393,Deployability,integrat,integrations,39393,"ringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; ca",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39490,Deployability,integrat,integrations,39490,"oAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39951,Deployability,integrat,integration,39951,"* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustRepla",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40514,Deployability,integrat,integration,40514,"igured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of t",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40644,Deployability,integrat,integration,40644,"ding on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global swit",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40734,Deployability,integrat,integrated,40734," const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCache",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40755,Deployability,integrat,integrate,40755,"s true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40810,Deployability,integrat,integration,40810,"s true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:41366,Deployability,integrat,integration,41366,"getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->Ge",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:41639,Deployability,integrat,integrate,41639,"ginating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). std::list<Double_t>* plotSa",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:41752,Deployability,integrat,integration,41752,"rated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward plot sampling hint of integrand. » Last ch",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:441,Integrability,integrat,integration,441,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:507,Integrability,integrat,integrated,507,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:597,Integrability,integrat,integrations,597,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:692,Integrability,integrat,integrations,692,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:761,Integrability,integrat,integration,761,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:6899,Integrability,depend,dependentVars,6899,"const; TH1*RooAbsReal::createHistogram(const char* name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual RooAbsReal*createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:8141,Integrability,depend,dependentOverlaps,8141,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:8233,Integrability,depend,dependentOverlaps,8233,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:8327,Integrability,depend,dependsOn,8327,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:8456,Integrability,depend,dependsOn,8456,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:8574,Integrability,depend,dependsOnValue,8574,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:8681,Integrability,depend,dependsOnValue,8681,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:17027,Integrability,message,message,17027,"ual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tisValid() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:17178,Integrability,message,message,17178,"_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tisValid() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); const RooArgSet&numIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsDa",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:34053,Integrability,integrat,integrated,34053,,MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35337,Integrability,depend,depends,35337,"lue! Transient cache for byte values from tree branches; static Int_t_cacheAllNDim! Cache all integrals with given numeric dimension; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer val",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35356,Integrability,integrat,integrated,35356," for byte values from tree branches; static Int_t_cacheAllNDim! Cache all integrals with given numeric dimension; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branche",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35706,Integrability,integrat,integration,35706,"ntListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35836,Integrability,integrat,integration,35836,"ion; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbs",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:36190,Integrability,integrat,integrated,36190,"::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:36493,Integrability,integrat,integration,36493,"::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:38013,Integrability,integrat,integrator,38013,"RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherite",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39393,Integrability,integrat,integrations,39393,"ringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; ca",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39490,Integrability,integrat,integrations,39490,"oAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39597,Integrability,depend,depending,39597,"ulating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; R",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39951,Integrability,integrat,integration,39951,"* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustRepla",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40514,Integrability,integrat,integration,40514,"igured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of t",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40644,Integrability,integrat,integration,40644,"ding on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global swit",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40717,Integrability,depend,dependents,40717," const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCache",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40734,Integrability,integrat,integrated,40734," const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCache",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40755,Integrability,integrat,integrate,40755,"s true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40810,Integrability,integrat,integration,40810,"s true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40843,Integrability,depend,dependents,40843,"s true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:41366,Integrability,integrat,integration,41366,"getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->Ge",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:41639,Integrability,integrat,integrate,41639,"ginating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). std::list<Double_t>* plotSa",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:41752,Integrability,integrat,integration,41752,"rated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward plot sampling hint of integrand. » Last ch",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:490,Modifiability,variab,variables,490,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:22973,Modifiability,config,config,22973,"t* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRealIntegral(); RooRealIntegral(const RooRealIntegral& other, const char* name = 0); RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:24210,Modifiability,config,config,24210," const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:38024,Modifiability,config,configuration,38024,"RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherite",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39075,Modifiability,config,config,39075,">RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, co",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39447,Modifiability,config,config,39447,"oAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39507,Modifiability,config,configured,39507,"oAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:333,Performance,perform,performs,333,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:413,Performance,perform,performs,413,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:776,Performance,perform,performed,776,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:2427,Performance,cache,cacheUniqueSuffix,2427,"anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:10388,Performance,cache,cacheList,10388,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:10476,Performance,cache,cacheList,10476,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:19068,Performance,optimiz,optimizeCacheMode,19068,"tVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealIntegral&operator=(const RooRealIntegral&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:19140,Performance,optimiz,optimizeCacheMode,19140,"observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealIntegral&operator=(const RooRealIntegral&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:22499,Performance,cache,cache,22499,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRealIntegral(); RooRealIntegral(const RooRealIntegral& other, const char* name = 0); RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static void",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:24053,Performance,cache,cache,24053,"ename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:26148,Performance,cache,cache,26148,"voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:29275,Performance,optimiz,optimizeDirtyHook,29275,"eal(Double_t value, Bool_t printError = kFALSE) const; virtual Double_tjacobianProduct() const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidoperModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); const RooArgSet&parameters() const; virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual Bool_tredirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:34273,Performance,cache,cache,34273,,MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:34356,Performance,cache,cache,34356,,MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:34631,Performance,cache,caches,34631,,MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35205,Performance,cache,cache,35205,"es (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Int_t_cacheAllNDim! Cache all integrals with given numeric dimension; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numeric",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35608,Performance,cache,cache,35608,"::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TSt",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:36320,Performance,cache,cache,36320,"::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:37178,Performance,cache,cache,37178,"RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherite",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:37666,Performance,cache,cache,37666,"RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherite",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:38349,Performance,cache,cache,38349,"RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherite",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39280,Performance,perform,performed,39280,"sReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const Ro",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39410,Performance,perform,performed,39410,"ringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; ca",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39563,Performance,cache,cache,39563,"ulating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; R",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:39610,Performance,cache,cache,39610,"ulating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; R",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40377,Performance,cache,cache,40377,"umerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40405,Performance,cache,cached,40405,"umerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:40468,Performance,cache,cache,40468,"umerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:41608,Performance,cache,cache,41608,"ginating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). std::list<Double_t>* plotSa",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:41785,Performance,cache,cached,41785,"rated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward plot sampling hint of integrand. » Last ch",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:42459,Performance,cache,cached,42459," Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward plot sampling hint of integrand. » Last changed: Tue Jun 30 14:35:18 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:42556,Performance,cache,cached,42556," Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward plot sampling hint of integrand. » Last changed: Tue Jun 30 14:35:18 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:11320,Security,hash,hash,11320,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; static Int_tgetCacheAllNumeric(); Bool_tgetCacheNumeric(); RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDepe",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:11471,Security,hash,hash,11471,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; static Int_tgetCacheAllNumeric(); Bool_tgetCacheNumeric(); RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:34527,Security,validat,validate,34527,,MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:35529,Security,access,access,35529,"ate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobia",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:475,Testability,log,logic,475,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:8200,Testability,test,testArg,8200,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:8294,Testability,test,testArg,8294,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:17002,Testability,log,logEvalError,17002,":IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tisValid() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:17101,Testability,log,logEvalError,17101,"tical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tisValid() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); const RooArgSet&numIntCatVars() const; const RooArgSet&",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:18209,Testability,test,testArg,18209,"ing = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); const RooArgSet&numIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealIntegral&operator=(const RooRealIntegral&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:18304,Testability,test,testArg,18304,"al(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); const RooArgSet&numIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealIntegral&operator=(const RooRealIntegral&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnl",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:19284,Testability,test,testArg,19284,"ooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealIntegral&operator=(const RooRealIntegral&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:3882,Usability,clear,clearEvalErrorLog,3882,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg:",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:3918,Usability,clear,clearShapeDirty,3918,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:3958,Usability,clear,clearValueAndShapeDirty,3958,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = Roo",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:4006,Usability,clear,clearValueDirty,4006,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealIntegral.html:41325,Usability,intuit,intuitively,41325,"getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->Ge",MatchSource.WIKI,root/html602/RooRealIntegral.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html
https://root.cern/root/html602/RooRealMPFE.html:660,Availability,avail,available,660,". RooRealMPFE. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealMPFE. class RooRealMPFE: public RooAbsReal. RooRealMPFE is the multi-processor front-end for parallel calculation; of RooAbsReal objects. Each RooRealMPFE forks a process that calculates; the value of the proxies RooAbsReal object. The (re)calculation of; the proxied object is started asynchronously with the calculate() option.; A subsequent call to getVal() will return the calculated value when available; If the calculation is still in progress when getVal() is called it blocks; the calling process until the calculation is done. The forked calculation process ; is terminated when the front-end object is deleted; Simple use demonstration; ; RooAbsReal* slowFunc ;; Double_t val = slowFunc->getVal() // Evaluate slowFunc in current process; RooRealMPFE mpfe(""mpfe"",""frontend to slowFunc"",*slowFunc) ;; mpfe.calculate() ; // Start calculation of slow-func in remote process; // .. do other stuff here ..; Double_t val = mpfe.getVal() // Wait for remote calculation to finish and retrieve value; . Function Members (Methods); public:. virtual~RooRealMPFE(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normS",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:10761,Availability,error,error,10761,,MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:10845,Availability,error,error,10845,,MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:40862,Availability,error,error,40862,"tance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) co",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:40930,Availability,error,errors,40930,"tance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) co",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:40955,Availability,error,error,40955,"tance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) co",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:36278,Deployability,update,update,36278,"calculate in parallel process; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhib",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:36728,Deployability,integrat,integration,36728,"ient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:38490,Deployability,integrat,integrator,38490,"ed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:38501,Deployability,configurat,configuration,38501,"ed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:38969,Deployability,update,update,38969,"ed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:8097,Integrability,depend,dependentVars,8097,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:9339,Integrability,depend,dependentOverlaps,9339,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:9431,Integrability,depend,dependentOverlaps,9431,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:9525,Integrability,depend,dependsOn,9525,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:9654,Integrability,depend,dependsOn,9654,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:9772,Integrability,depend,dependsOnValue,9772,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:9879,Integrability,depend,dependsOnValue,9879,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:18084,Integrability,message,message,18084,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:18235,Integrability,message,message,18235,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:36728,Integrability,integrat,integration,36728,"ient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:38490,Integrability,integrat,integrator,38490,"ed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:40097,Integrability,message,message,40097,"arsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealMPFE(const char* name, const char* title, RooAbsReal& arg, Bool_t calcInline = kFALSE); Construct front-end object for object 'arg' whose evaluation will be calculated; asynchronously in a separate process. If calcInline is true the value of 'arg'; is calculate synchronously in the current process. RooRealMPFE(const RooRealMPFE& other, const char* name = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; ",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:40275,Integrability,message,message,40275,"seServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealMPFE(const char* name, const char* title, RooAbsReal& arg, Bool_t calcInline = kFALSE); Construct front-end object for object 'arg' whose evaluation will be calculated; asynchronously in a separate process. If calcInline is true the value of 'arg'; is calculate synchronously in the current process. RooRealMPFE(const RooRealMPFE& other, const char* name = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE)",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:40807,Integrability,message,message,40807,"tance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) co",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:25082,Modifiability,config,config,25082,"e(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; voidsetVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); TIterator*RooAbsArg::shapeClientIterator() const; RooFIterR",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:36263,Modifiability,variab,variable,36263,"rgFunction to calculate in parallel process; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg:",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:38060,Modifiability,variab,variables,38060,"ed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:38501,Modifiability,config,configuration,38501,"ed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:38954,Modifiability,variab,variable,38954,"ed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:39978,Modifiability,variab,variables,39978," server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealMPFE(const char* name, const char* title, RooAbsReal& arg, Bool_t calcInline = kFALSE); Construct front-end object for object 'arg' whose evaluation will be calculated; asynchronously in a separate process. If calcInline is true the value of 'arg'; is calculate synchronously in the current process. RooRealMPFE(const RooRealMPFE& other, const char* name = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standb",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:2836,Performance,cache,cacheUniqueSuffix,2836,"bsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyNLLWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidcalculate() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& ar",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:11579,Performance,cache,cacheList,11579,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:11667,Performance,cache,cacheList,11667,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:20038,Performance,optimiz,optimizeCacheMode,20038,":numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealMPFE&operator=(const RooRealMPFE&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:20110,Performance,optimiz,optimizeCacheMode,20110,"AbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealMPFE&operator=(const RooRealMPFE&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:23584,Performance,cache,cache,23584,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRealMPFE(const RooRealMPFE& other, const char* name = 0); RooRealMPFE(const char* name, const char* title, RooAbsReal& arg, Bool_t calcInline = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooA",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:24925,Performance,cache,cache,24925,"arg, Bool_t calcInline = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:27105,Performance,cache,cache,27105," key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; voidsetVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); voidstandby(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:30363,Performance,optimiz,optimizeDirtyHook,30363,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidserverLoop(); voidRooAbsArg::setProx",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:35500,Performance,cache,cache,35500,,MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:35583,Performance,cache,cache,35583,,MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:35781,Performance,cache,caches,35781,"RealMPFE::StateClient; static RooRealMPFE::MessageConstOpt; static RooRealMPFE::MessageEnableOffset; static RooRealMPFE::StateInitialize; static RooRealMPFE::StateInline; static RooRealMPFE::MessageLogEvalError; static RooRealMPFE::MessageRetrieve; static RooRealMPFE::MessageReturnValue; static RooRealMPFE::MessageSendCat; static RooRealMPFE::MessageSendReal; static RooRealMPFE::StateServer; static RooRealMPFE::MessageTerminate; static RooRealMPFE::MessageVerbose; RooRealProxy_argFunction to calculate in parallel process; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_global",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:36412,Performance,cache,cache,36412,"ent boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:36612,Performance,cache,cache,36612,"ient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:37062,Performance,cache,cache,37062,"ient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:38112,Performance,cache,cache,38112,"ed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:38711,Performance,cache,cache,38711,"ed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:40961,Performance,queue,queue,40961,"tance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) co",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:41275,Performance,optimiz,optimize,41275,"ction will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. void followAsSlave(RooRealMPFE& master); { _updateMaster = &master ; }. » Last changed: Tue Jun 30 14:35:20 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:12511,Security,hash,hash,12511,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); voidfollowAsSlave(RooRealMPFE& master); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArg",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:12662,Security,hash,hash,12662,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); voidfollowAsSlave(RooRealMPFE& master); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; v",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:35677,Security,validat,validate,35677,"lyNLLW2; static RooRealMPFE::MessageCalculate; static RooRealMPFE::MessageCalculateNoOffset; static RooRealMPFE::StateClient; static RooRealMPFE::MessageConstOpt; static RooRealMPFE::MessageEnableOffset; static RooRealMPFE::StateInitialize; static RooRealMPFE::StateInline; static RooRealMPFE::MessageLogEvalError; static RooRealMPFE::MessageRetrieve; static RooRealMPFE::MessageReturnValue; static RooRealMPFE::MessageSendCat; static RooRealMPFE::MessageSendReal; static RooRealMPFE::StateServer; static RooRealMPFE::MessageTerminate; static RooRealMPFE::MessageVerbose; RooRealProxy_argFunction to calculate in parallel process; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; ",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:36533,Security,access,access,36533,"ient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:9398,Testability,test,testArg,9398,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:9492,Testability,test,testArg,9492,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:18059,Testability,log,logEvalError,18059,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:18158,Testability,log,logEvalError,18158,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:19187,Testability,test,testArg,19187,"iginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealMPFE&operator=(const RooRealMPFE&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedLis",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:19282,Testability,test,testArg,19282,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealMPFE&operator=(const RooRealMPFE&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFAL",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:20254,Testability,test,testArg,20254,"(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealMPFE&operator=(const RooRealMPFE&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:40873,Testability,log,logged,40873,"tance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) co",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:40884,Testability,log,logEvalError,40884,"tance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) co",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:41301,Testability,test,test,41301,"ction will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. void followAsSlave(RooRealMPFE& master); { _updateMaster = &master ; }. » Last changed: Tue Jun 30 14:35:20 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:4314,Usability,clear,clearEvalErrorLog,4314,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:4350,Usability,clear,clearShapeDirty,4350,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:4390,Usability,clear,clearValueAndShapeDirty,4390,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealMPFE.html:4438,Usability,clear,clearValueDirty,4438,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooRealMPFE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html
https://root.cern/root/html602/RooRealProxy.html:1636,Availability,error,error,1636,"irtual~RooRealProxy(); RooAbsArg*RooArgProxy::absArg() const; voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const RooAbsReal&arg() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newName = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; Bool_thasMax(const char* rname = 0) const; Bool_thasMin(const char* rname = 0) const; virtu",MatchSource.WIKI,root/html602/RooRealProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealProxy.html
https://root.cern/root/html602/RooRealProxy.html:1720,Availability,error,error,1720,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const RooAbsReal&arg() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newName = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; Bool_thasMax(const char* rname = 0) const; Bool_thasMin(const char* rname = 0) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTO",MatchSource.WIKI,root/html602/RooRealProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealProxy.html
https://root.cern/root/html602/RooRealSumPdf.html:10327,Availability,error,error,10327,,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:10411,Availability,error,error,10411,,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:42431,Availability,error,errors,42431,"itle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:42749,Deployability,integrat,integration,42749,oefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAb,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:43778,Deployability,integrat,integration,43778,,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:44949,Deployability,configurat,configuration,44949,"integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:45046,Deployability,integrat,integrator,45046,"integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:45057,Deployability,configurat,configuration,45057,"integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:47859,Deployability,integrat,integrations,47859,"ar* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:47885,Deployability,integrat,integration,47885,"ar* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:47924,Deployability,integrat,integrators,47924,"ar* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:710,Integrability,depend,dependents,710,". RooRealSumPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealSumPdf. class RooRealSumPdf: public RooAbsPdf. Class RooRealSumPdf implements a PDF constructed from a sum of; functions:. Sum(i=1,n-1) coef_i * func_i(x) + [ 1 - (Sum(i=1,n-1) coef_i ] * func_n(x); pdf(x) = ------------------------------------------------------------------------------; Sum(i=1,n-1) coef_i * Int(func_i)dx + [ 1 - (Sum(i=1,n-1) coef_i ] * Int(func_n)dx. where coef_i and func_i are RooAbsReal objects, and x is the collection of dependents.; In the present version coef_i may not depend on x, but this limitation may be removed in the future. Function Members (Methods); public:. virtual~RooRealSumPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Do",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:761,Integrability,depend,depend,761,". RooRealSumPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealSumPdf. class RooRealSumPdf: public RooAbsPdf. Class RooRealSumPdf implements a PDF constructed from a sum of; functions:. Sum(i=1,n-1) coef_i * func_i(x) + [ 1 - (Sum(i=1,n-1) coef_i ] * func_n(x); pdf(x) = ------------------------------------------------------------------------------; Sum(i=1,n-1) coef_i * Int(func_i)dx + [ 1 - (Sum(i=1,n-1) coef_i ] * Int(func_n)dx. where coef_i and func_i are RooAbsReal objects, and x is the collection of dependents.; In the present version coef_i may not depend on x, but this limitation may be removed in the future. Function Members (Methods); public:. virtual~RooRealSumPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Do",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:7337,Integrability,depend,dependentVars,7337,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:8827,Integrability,depend,dependentOverlaps,8827,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:8919,Integrability,depend,dependentOverlaps,8919,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:9013,Integrability,depend,dependsOn,9013,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:9142,Integrability,depend,dependsOn,9142,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:9260,Integrability,depend,dependsOnValue,9260,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:9367,Integrability,depend,dependsOnValue,9367,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:21364,Integrability,message,message,21364,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::n",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:21515,Integrability,message,message,21515,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAb",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:42749,Integrability,integrat,integration,42749,oefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAb,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:43778,Integrability,integrat,integration,43778,,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:45046,Integrability,integrat,integrator,45046,"integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:47859,Integrability,integrat,integrations,47859,"ar* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:47885,Integrability,integrat,integration,47885,"ar* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:47924,Integrability,integrat,integrators,47924,"ar* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:48169,Integrability,depend,depend,48169,"tation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { return _coefList ; }. Double_t expectedEvents(const RooArgSet* nset) const. Bool_t selfNormalized() const; { return getAttribute(""BinnedLikelihoodActive"") ; }. void setFloor(Bool_t flag); { _doFloor = flag ; }. Bool_t getFloor() const; { return _doFloor ; }. void setFloorGlobal(Bool_t flag); { ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:10705,Modifiability,extend,extendedTerm,10705,"_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual Double_tevaluate() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObj",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:14343,Modifiability,extend,extended,14343,"ec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& o",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:14497,Modifiability,extend,extended,14497,"ProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooA",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:28399,Modifiability,extend,extended,28399,"t RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); RooRealSumPdf(); RooRealSumPdf(const char* name, const char* title); RooRealSumPdf(const RooRealSumPdf& other, const char* name = 0); RooRealSumPdf(const char* name, const char* title, const RooArgList& funcList, const RooArgList& coefList, Bool_t extended = kFALSE); RooRealSumPdf(const char* name, const char* title, RooAbsReal& func1, RooAbsReal& func2, RooAbsReal& coef1); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLog",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:29687,Modifiability,config,config,29687," virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetFloor(Bool_t flag); static voidsetFloorGlobal(Bool_t flag); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFAL",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:29845,Modifiability,config,config,29845,"ameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetFloor(Bool_t flag); static voidsetFloorGlobal(Bool_t flag); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(con",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:34431,Modifiability,extend,extended,34431,"ooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tR",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:42522,Modifiability,extend,extended,42522,"itle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:44949,Modifiability,config,configuration,44949,"integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:45057,Modifiability,config,configuration,45057,"integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:46426,Modifiability,extend,extended,46426,"it for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealSumPdf(); Default constructor; coverity[UNINIT_CTOR]. RooRealSumPdf(const char* name, const char* title); Constructor with name and title. RooRealSumPdf(const char* name, const char* title, RooAbsReal& func1, RooAbsReal& func2, RooAbsReal& coef1); Construct p.d.f consisting of coef1*func1 + (1-coef1)*func2; The input coefficients and functions are allowed to be negative; but the resulting sum is not, which is enforced at runtime. RooRealSumPdf(const char* name, const char* title, const RooArgList& funcList, const RooArgList& coefList, Bool_t extended = kFALSE); Constructor p.d.f implementing sum_i [ coef_i * func_i ], if N_coef==N_func; or sum_i [ coef_i * func_i ] + (1 - sum_i [ coef_i ] )* func_N if Ncoef==N_func-1. All coefficients and functions are allowed to be negative; but the sum is not, which is enforced at runtime. RooRealSumPdf(const RooRealSumPdf& other, const char* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnal",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:46850,Modifiability,extend,extendMode,46850,"unction documentation; RooRealSumPdf(); Default constructor; coverity[UNINIT_CTOR]. RooRealSumPdf(const char* name, const char* title); Constructor with name and title. RooRealSumPdf(const char* name, const char* title, RooAbsReal& func1, RooAbsReal& func2, RooAbsReal& coef1); Construct p.d.f consisting of coef1*func1 + (1-coef1)*func2; The input coefficients and functions are allowed to be negative; but the resulting sum is not, which is enforced at runtime. RooRealSumPdf(const char* name, const char* title, const RooArgList& funcList, const RooArgList& coefList, Bool_t extended = kFALSE); Constructor p.d.f implementing sum_i [ coef_i * func_i ], if N_coef==N_func; or sum_i [ coef_i * func_i ] + (1 - sum_i [ coef_i ] )* func_N if Ncoef==N_func-1. All coefficients and functions are allowed to be negative; but the sum is not, which is enforced at runtime. RooRealSumPdf(const RooRealSumPdf& other, const char* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:2334,Performance,cache,cacheUniqueSuffix,2334,"AbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList(",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:11415,Performance,cache,cacheList,11415,"); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:11503,Performance,cache,cacheList,11503,"xpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:23404,Performance,optimiz,optimizeCacheMode,23404,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealSumPdf&operator=(const RooRealSumPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:23476,Performance,optimiz,optimizeCacheMode,23476,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealSumPdf&operator=(const RooRealSumPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:27863,Performance,cache,cache,27863,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); RooRealSumPdf(); RooRealSumPdf(const char* name, const char* title); RooRealSumPdf(const RooRealSumPdf& other, const char* name = 0); RooRealSumPdf(const char* name, const char* title, const RooArgList& funcList, const RooArgList& coefList, Bool_t extended = kFALSE); RooRealSumPdf(const char* name, const char* title, RooAbsReal& func1, RooAbsReal& func2, RooAbsReal& coef1); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(cons",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:29518,Performance,cache,cache,29518,"oef1); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetFloor(Bool_t flag); static voidsetFloorGlobal(Bool_t flag); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttrib",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:32214,Performance,cache,cache,32214,"r* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:36071,Performance,optimiz,optimizeDirtyHook,36071,"t* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:41295,Performance,cache,cache,41295,"itle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:41378,Performance,cache,cache,41378,"itle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:41576,Performance,cache,caches,41576,"itle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:42327,Performance,cache,cache,42327,"itle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:42651,Performance,cache,cache,42651,oefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAb,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:43177,Performance,cache,cache,43177,oefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAb,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:43790,Performance,cache,cache,43790,,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:43846,Performance,cache,cache,43846,,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:44517,Performance,cache,cache,44517,,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:45305,Performance,cache,cache,45305,"integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:48393,Performance,cache,cache-and-track,48393,"out << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { return _coefList ; }. Double_t expectedEvents(const RooArgSet* nset) const. Bool_t selfNormalized() const; { return getAttribute(""BinnedLikelihoodActive"") ; }. void setFloor(Bool_t flag); { _doFloor = flag ; }. Bool_t getFloor() const; { return _doFloor ; }. void setFloorGlobal(Bool_t flag); { _doFloorGlobal = flag ; }. Bool_t getFloorGlobal(); { return _doFloorGlobal ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. » Last changed: Tue Jun 30 14:35:23 2015 » Last gene",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:12835,Security,hash,hash,12835,"Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& arg) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); const RooArgList&funcList() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSe",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:12986,Security,hash,hash,12986,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& arg) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); const RooArgList&funcList() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg&",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:41472,Security,validat,validate,41472,"itle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:42572,Security,access,access,42572,oefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAb,MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:8886,Testability,test,testArg,8886,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:8980,Testability,test,testArg,8980,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:21339,Testability,log,logEvalError,21339,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notif",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:21438,Testability,log,logEvalError,21438,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRo",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:22549,Testability,test,testArg,22549," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealSumPdf&operator=(const RooRealSumPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:22644,Testability,test,testArg,22644,"Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealSumPdf&operator=(const RooRealSumPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:23620,Testability,test,testArg,23620,"nt(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealSumPdf&operator=(const RooRealSumPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:2896,Usability,clear,clearEvalError,2896,"ooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmd",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:2937,Usability,clear,clearEvalErrorLog,2937,"Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCm",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:2973,Usability,clear,clearShapeDirty,2973,"Value&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:3013,Usability,clear,clearValueAndShapeDirty,3013,"c*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 ",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:3061,Usability,clear,clearValueDirty,3061,", const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 =",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealSumPdf.html:48509,Usability,intuit,intuitively,48509,"?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { return _coefList ; }. Double_t expectedEvents(const RooArgSet* nset) const. Bool_t selfNormalized() const; { return getAttribute(""BinnedLikelihoodActive"") ; }. void setFloor(Bool_t flag); { _doFloor = flag ; }. Bool_t getFloor() const; { return _doFloor ; }. void setFloorGlobal(Bool_t flag); { _doFloorGlobal = flag ; }. Bool_t getFloorGlobal(); { return _doFloorGlobal ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. » Last changed: Tue Jun 30 14:35:23 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root/html602/RooRealSumPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html
https://root.cern/root/html602/RooRealVar.html:417,Availability,error,error,417,". RooRealVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealVar. class RooRealVar: public RooAbsRealLValue. RooRealVar represents a fundamental (non-derived) real valued object; ; This class also holds an (asymmetic) error, a default range and; a optionally series of alternate named ranges.; . Function Members (Methods); public:. virtual~RooRealVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtu",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:11109,Availability,error,errorVar,11109,,MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:11335,Availability,error,error,11335,,MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:11419,Availability,error,error,11419,,MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:39351,Availability,error,error,39351,,MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:39429,Availability,error,error,39429,,MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:40582,Availability,error,error,40582,"ring>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:44431,Availability,error,errorVar,44431,"le_t value, const char* unit = """"); Constructor with value and unit. RooRealVar(const char* name, const char* title, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with range and unit. Initial value is center of range. RooRealVar(const char* name, const char* title, Double_t value, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with value, range and unit. RooRealVar(const RooRealVar& other, const char* name = 0); Copy Constructor. ~RooRealVar(); Destructor; cout << ""RooRealVar::dtor("" << this << "")"" << endl ;. Double_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is cre",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:44492,Availability,error,error,44492,"le_t value, const char* unit = """"); Constructor with value and unit. RooRealVar(const char* name, const char* title, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with range and unit. Initial value is center of range. RooRealVar(const char* name, const char* title, Double_t value, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with value, range and unit. RooRealVar(const RooRealVar& other, const char* name = 0); Copy Constructor. ~RooRealVar(); Destructor; cout << ""RooRealVar::dtor("" << this << "")"" << endl ;. Double_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is cre",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:46894,Availability,error,error,46894,"tMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t value); Set maximum of name range to given value. If name is null; maximum of default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,max]. If name is null; range of default range is adjusted. If no range with; 'name' exists it is created on the fly. void setRange(const char* name, RooAbsReal& min, RooAbsReal& max); Create or modify a parameterized range named 'name' that has external functions; min and max parameterizing its boundaries. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = ",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:47598,Availability,error,error,47598,"romStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError ",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:47718,Availability,error,error,47718,"; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:47745,Availability,error,error,47745,"; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:47772,Availability,error,error,47772,"; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:47782,Availability,avail,available,47782,"; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:47981,Availability,error,error,47981,"nd binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48164,Availability,error,error,48164,"s, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printSc",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48283,Availability,error,errors,48283,"ar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits ",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48308,Availability,error,errors,48308,"ar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits ",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48483,Availability,error,errors,48483,"ts, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits to show when printing RooRealVars. TObject* clone(const char* newname) const; { return new RooRealVar(*this,newname); }. Double_t getError() const; { return _error>=0?_error:0. ; }. Bool_t hasError(",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48508,Availability,error,errors,48508,"ts, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits to show when printing RooRealVars. TObject* clone(const char* newname) const; { return new RooRealVar(*this,newname); }. Double_t getError() const; { return _error>=0?_error:0. ; }. Bool_t hasError(",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48681,Availability,error,errors,48681,"ol what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits to show when printing RooRealVars. TObject* clone(const char* newname) const; { return new RooRealVar(*this,newname); }. Double_t getError() const; { return _error>=0?_error:0. ; }. Bool_t hasError(Bool_t allowZero = kTRUE) const; { return allowZero ? (_error>=0) : (_error>0) ; }. void setError(Double_t value); { _error= value ; }. void removeError(); { _error = -",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:40829,Deployability,integrat,integration,40829,"ring>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:42662,Deployability,integrat,integrator,42662,"mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:42673,Deployability,configurat,configuration,42673,"mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:45835,Deployability,install,installed,45835,"nning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning and; a NULL pointer should be passed to getBinning in this case. void setBinning(const RooAbsBinning& binning, const char* name = 0); Add given binning under name 'name' with this variable. If name is null; the binning is installed as the default binning. void setMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t value); Set maximum of name range to given value. If name is null; maximum of default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,max]. If name is null; range of default range is adjusted. If no range with; 'name' exists it is created on the fly. void setRange(const char* name, RooAbsReal& min, RooAbsReal& max); Create or modify a parameterized range named 'name' that has external functions; min and max parameterizing its boundaries. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:8615,Integrability,depend,dependentVars,8615,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; sta",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:9876,Integrability,depend,dependentOverlaps,9876,"ePlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteSharedProperties(); Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:9968,Integrability,depend,dependentOverlaps,9968,"ePlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteSharedProperties(); Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:10062,Integrability,depend,dependsOn,10062,"ePlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteSharedProperties(); Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:10191,Integrability,depend,dependsOn,10191,"ePlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteSharedProperties(); Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:10309,Integrability,depend,dependsOnValue,10309,"ePlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteSharedProperties(); Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:10416,Integrability,depend,dependsOnValue,10416,"ePlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteSharedProperties(); Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:21130,Integrability,message,message,21130,"depList) const; virtual Bool_tRooAbsRealLValue::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tRooAbsRealLValue::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; virtual Double_tRooAbsRealLValue::jacobian() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLVa",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:21281,Integrability,message,message,21281,"_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tRooAbsRealLValue::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; virtual Double_tRooAbsRealLValue::jacobian() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsRea",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:40829,Integrability,integrat,integration,40829,"ring>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:42662,Integrability,integrat,integrator,42662,"mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:45033,Integrability,message,message,45033,"_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning and; a NULL pointer should be passed to getBinning in this case. void setBinning(const RooAbsBinning& binning, const char* name = 0); Add given binning under name 'name' with this variable. If name is null; the binning is installed as the default binning. void setMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t val",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:45434,Integrability,message,message,45434,"eturn a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning and; a NULL pointer should be passed to getBinning in this case. void setBinning(const RooAbsBinning& binning, const char* name = 0); Add given binning under name 'name' with this variable. If name is null; the binning is installed as the default binning. void setMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t value); Set maximum of name range to given value. If name is null; maximum of default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,max]. If name is null; range of default range is adjusted. If no range with; 'name' exists it is created on the fly. void setRange(const char* name, RooAbsReal& min, RooAbsReal& max); Create or modify a parameteri",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:47179,Integrability,interface,interface,47179,"f default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,max]. If name is null; range of default range is adjusted. If no range with; 'name' exists it is created on the fly. void setRange(const char* name, RooAbsReal& min, RooAbsReal& max); Create or modify a parameterized range named 'name' that has external functions; min and max parameterizing its boundaries. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of ",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:29261,Modifiability,config,config,29261,"l voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidsetBinning(const RooAbsBinning& binning, const char* name = 0); voidsetBins(Int_t nBins, const char* name = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetError(Double_t value); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; voidsetMax(Double_t value); voidsetMax(const char* name, Double_t value); voidsetMin(Double_t value); voidsetMin(const char* name, Double_t value); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(Double_t min, Double_t max); voidsetRange(RooAbsReal& min, RooAbsReal& max); voidsetRange(const char* name, Double_t min, Double_t max); voidsetRange(const char* name, RooAbsReal& min, RooAbsReal& max); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(co",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:42673,Modifiability,config,configuration,42673,"mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:44110,Modifiability,variab,variable,44110,"ating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar(); Default constructor. RooRealVar(const char* name, const char* title, Double_t value, const char* unit = """"); Constructor with value and unit. RooRealVar(const char* name, const char* title, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with range and unit. Initial value is center of range. RooRealVar(const char* name, const char* title, Double_t value, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with value, range and unit. RooRealVar(const RooRealVar& other, const char* name = 0); Copy Constructor. ~RooRealVar(); Destructor; cout << ""RooRealVar::dtor("" << this << "")"" << endl ;. Double_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on t",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:44162,Modifiability,variab,variable,44162,"irtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar(); Default constructor. RooRealVar(const char* name, const char* title, Double_t value, const char* unit = """"); Constructor with value and unit. RooRealVar(const char* name, const char* title, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with range and unit. Initial value is center of range. RooRealVar(const char* name, const char* title, Double_t value, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with value, range and unit. RooRealVar(const RooRealVar& other, const char* name = 0); Copy Constructor. ~RooRealVar(); Destructor; cout << ""RooRealVar::dtor("" << this << "")"" << endl ;. Double_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:44311,Modifiability,variab,variable,44311,"title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar(); Default constructor. RooRealVar(const char* name, const char* title, Double_t value, const char* unit = """"); Constructor with value and unit. RooRealVar(const char* name, const char* title, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with range and unit. Initial value is center of range. RooRealVar(const char* name, const char* title, Double_t value, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with value, range and unit. RooRealVar(const RooRealVar& other, const char* name = 0); Copy Constructor. ~RooRealVar(); Destructor; cout << ""RooRealVar::dtor("" << this << "")"" << endl ;. Double_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:44520,Modifiability,variab,variable,44520,"le_t value, const char* unit = """"); Constructor with value and unit. RooRealVar(const char* name, const char* title, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with range and unit. Initial value is center of range. RooRealVar(const char* name, const char* title, Double_t value, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with value, range and unit. RooRealVar(const RooRealVar& other, const char* name = 0); Copy Constructor. ~RooRealVar(); Destructor; cout << ""RooRealVar::dtor("" << this << "")"" << endl ;. Double_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is cre",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:44640,Modifiability,variab,variable,44640," const char* unit = """"); Constructor with range and unit. Initial value is center of range. RooRealVar(const char* name, const char* title, Double_t value, Double_t minValue, Double_t maxValue, const char* unit = """"); Constructor with value, range and unit. RooRealVar(const RooRealVar& other, const char* name = 0); Copy Constructor. ~RooRealVar(); Destructor; cout << ""RooRealVar::dtor("" << this << "")"" << endl ;. Double_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning and; a NULL poi",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:45793,Modifiability,variab,variable,45793,"rbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning and; a NULL pointer should be passed to getBinning in this case. void setBinning(const RooAbsBinning& binning, const char* name = 0); Add given binning under name 'name' with this variable. If name is null; the binning is installed as the default binning. void setMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t value); Set maximum of name range to given value. If name is null; maximum of default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,max]. If name is null; range of default range is adjusted. If no range with; 'name' exists it is created on the fly. void setRange(const char* name, RooAbsReal& min, RooAbsReal& max); Create or modify a parameterized range named 'name' that has external functions; min and max parameterizing its boundaries. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents ",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:46441,Modifiability,parameteriz,parameterized,46441,"nted if a binning is created on the gly. std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning and; a NULL pointer should be passed to getBinning in this case. void setBinning(const RooAbsBinning& binning, const char* name = 0); Add given binning under name 'name' with this variable. If name is null; the binning is installed as the default binning. void setMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t value); Set maximum of name range to given value. If name is null; maximum of default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,max]. If name is null; range of default range is adjusted. If no range with; 'name' exists it is created on the fly. void setRange(const char* name, RooAbsReal& min, RooAbsReal& max); Create or modify a parameterized range named 'name' that has external functions; min and max parameterizing its boundaries. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::for",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:46515,Modifiability,parameteriz,parameterizing,46515,"nted if a binning is created on the gly. std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning and; a NULL pointer should be passed to getBinning in this case. void setBinning(const RooAbsBinning& binning, const char* name = 0); Add given binning under name 'name' with this variable. If name is null; the binning is installed as the default binning. void setMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t value); Set maximum of name range to given value. If name is null; maximum of default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,max]. If name is null; range of default range is adjusted. If no range with; 'name' exists it is created on the fly. void setRange(const char* name, RooAbsReal& min, RooAbsReal& max); Create or modify a parameterized range named 'name' that has external functions; min and max parameterizing its boundaries. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::for",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:46808,Modifiability,variab,variable,46808,"h this variable. If name is null; the binning is installed as the default binning. void setMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t value); Set maximum of name range to given value. If name is null; maximum of default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,max]. If name is null; range of default range is adjusted. If no range with; 'name' exists it is created on the fly. void setRange(const char* name, RooAbsReal& min, RooAbsReal& max); Create or modify a parameterized range named 'name' that has external functions; min and max parameterizing its boundaries. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if avail",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:46871,Modifiability,variab,variable,46871,"tMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t value); Set maximum of name range to given value. If name is null; maximum of default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,max]. If name is null; range of default range is adjusted. If no range with; 'name' exists it is created on the fly. void setRange(const char* name, RooAbsReal& min, RooAbsReal& max); Create or modify a parameterized range named 'name' that has external functions; min and max parameterizing its boundaries. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printValue(ostream& os) const; Print value of variable. void printExtras(ostream& os) const; Print extras of variable: (asymmetric) error, constant flag, limits and binning. Int_t defaultPrintContents(Option_t* opt) const; Mapping of Print() option string to RooPrintable contents specifications. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. TString* format(const RooCmdArg& formatArg) const; Format contents of RooRealVar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = ",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:2026,Performance,cache,cacheUniqueSuffix,2026,"iqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:12153,Performance,cache,cacheList,12153,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:12241,Performance,cache,cacheList,12241,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:23231,Performance,optimiz,optimizeCacheMode,23231,"l::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealVar&operator=(const RooRealVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:23303,Performance,optimiz,optimizeCacheMode,23303,"ooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealVar&operator=(const RooRealVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:26959,Performance,cache,cache,26959,""""") const; virtual voidprintValue(ostream& os) const; virtual voidRooAbsRealLValue::randomize(const char* rangeName = 0); virtual voidRooAbsRealLValue::randomize(const RooAbsBinning& binning); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidremoveAsymError(); voidremoveError(); voidremoveMax(const char* name = 0); voidremoveMin(const char* name = 0); voidremoveRange(const char* name = 0); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRealVar(); RooRealVar(const RooRealVar& other, const char* name = 0); RooRealVar(const char* name, const char* title, Double_t value, const char* unit = """"); RooRealVar(const char* name, const char* title, Double_t minValue, Double_t maxValue, const char* unit = """"); RooRealVar(const char* name, const char* title, Double_t value, Double_t minValue, Double_t maxValue, const char* unit = """"); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::se",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:31599,Performance,cache,cache,31599,"oidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tRooAbsRealLValue::volume(const char* rangeName) const; virtual Double_tRooAbsRealLValue::volume(const RooAbsBinning& binning) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:34761,Performance,optimiz,optimizeDirtyHook,34761,"Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); virtual voidsetExpensiveObjectCache(RooE",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:39678,Performance,cache,cache,39678,,MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:39761,Performance,cache,cache,39761,,MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:39959,Performance,cache,caches,39959,,MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:40491,Performance,cache,cache,40491,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persi",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:40731,Performance,cache,cache,40731,"ring>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:41144,Performance,cache,cache,41144,"ring>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:42137,Performance,cache,cache,42137,"mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:42857,Performance,cache,cache,42857,"mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties associated with this instance; static RooSharedPropertiesList_sharedPropListList of properties shared among clone sets; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealVar",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48808,Performance,cache,cached,48808,"hese options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits to show when printing RooRealVars. TObject* clone(const char* newname) const; { return new RooRealVar(*this,newname); }. Double_t getError() const; { return _error>=0?_error:0. ; }. Bool_t hasError(Bool_t allowZero = kTRUE) const; { return allowZero ? (_error>=0) : (_error>0) ; }. void setError(Double_t value); { _error= value ; }. void removeError(); { _error = -1 ; }. Double_t getAsymErrorLo() const; { return _asymErrLo<=0?_asymErrLo:0. ; }. Double_t getAsymErrorHi() const; { return _asymErrHi>=0?_asymErrHi:0. ; }. Bool_t hasAsymError(Bool_t allowZero = kTRUE) cons",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48849,Performance,cache,cache,48849,"hese options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits to show when printing RooRealVars. TObject* clone(const char* newname) const; { return new RooRealVar(*this,newname); }. Double_t getError() const; { return _error>=0?_error:0. ; }. Bool_t hasError(Bool_t allowZero = kTRUE) const; { return allowZero ? (_error>=0) : (_error>0) ; }. void setError(Double_t value); { _error= value ; }. void removeError(); { _error = -1 ; }. Double_t getAsymErrorLo() const; { return _asymErrLo<=0?_asymErrLo:0. ; }. Double_t getAsymErrorHi() const; { return _asymErrHi>=0?_asymErrHi:0. ; }. Bool_t hasAsymError(Bool_t allowZero = kTRUE) cons",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48890,Performance,cache,cached,48890,"hese options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits to show when printing RooRealVars. TObject* clone(const char* newname) const; { return new RooRealVar(*this,newname); }. Double_t getError() const; { return _error>=0?_error:0. ; }. Bool_t hasError(Bool_t allowZero = kTRUE) const; { return allowZero ? (_error>=0) : (_error>0) ; }. void setError(Double_t value); { _error= value ; }. void removeError(); { _error = -1 ; }. Double_t getAsymErrorLo() const; { return _asymErrLo<=0?_asymErrLo:0. ; }. Double_t getAsymErrorHi() const; { return _asymErrHi>=0?_asymErrHi:0. ; }. Bool_t hasAsymError(Bool_t allowZero = kTRUE) cons",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:48966,Performance,cache,cache,48966,"hese options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits to show when printing RooRealVars. TObject* clone(const char* newname) const; { return new RooRealVar(*this,newname); }. Double_t getError() const; { return _error>=0?_error:0. ; }. Bool_t hasError(Bool_t allowZero = kTRUE) const; { return allowZero ? (_error>=0) : (_error>0) ; }. void setError(Double_t value); { _error= value ; }. void removeError(); { _error = -1 ; }. Double_t getAsymErrorLo() const; { return _asymErrLo<=0?_asymErrLo:0. ; }. Double_t getAsymErrorHi() const; { return _asymErrHi>=0?_asymErrHi:0. ; }. Bool_t hasAsymError(Bool_t allowZero = kTRUE) cons",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:13085,Security,hash,hash,13085,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); TString*format(const RooCmdArg& formatArg) const; TString*format(Int_t sigDigits, const char* options) const; RooPlot*RooAbsRealLValue::frame() const; RooPlot*RooAbsRealLValue::frame(const RooLinkedList& cmdList) const; RooPlot*RooAbsRealLValue::frame(Int_t nbins) const; RooPlot*RooAbsRealLValue::frame(Double_t lo, Double_t hi) const; RooPlot*RooAbsRealLValue::frame(Double_t lo, Double_t hi, Int_t nbins) const; RooPlot*RooAbsRealLValue::frame(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& ",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:13236,Security,hash,hash,13236,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); TString*format(const RooCmdArg& formatArg) const; TString*format(Int_t sigDigits, const char* options) const; RooPlot*RooAbsRealLValue::frame() const; RooPlot*RooAbsRealLValue::frame(const RooLinkedList& cmdList) const; RooPlot*RooAbsRealLValue::frame(Int_t nbins) const; RooPlot*RooAbsRealLValue::frame(Double_t lo, Double_t hi) const; RooPlot*RooAbsRealLValue::frame(Double_t lo, Double_t hi, Int_t nbins) const; RooPlot*RooAbsRealLValue::frame(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& par",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:39855,Security,validat,validate,39855,,MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:40652,Security,access,access,40652,"ring>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:9935,Testability,test,testArg,9935,"ePlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteSharedProperties(); Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:10029,Testability,test,testArg,10029,"ePlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteSharedProperties(); Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:21105,Testability,log,logEvalError,21105,"ianOK(const RooArgSet& depList) const; virtual Bool_tRooAbsRealLValue::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tRooAbsRealLValue::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; virtual Double_tRooAbsRealLValue::jacobian() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:21204,Testability,log,logEvalError,21204,"ol_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tRooAbsRealLValue::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; virtual Double_tRooAbsRealLValue::jacobian() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches()",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:22382,Testability,test,testArg,22382," Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealVar&operator=(const RooRealVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:22477,Testability,test,testArg,22477,"; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealVar&operator=(const RooRealVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:23447,Testability,test,testArg,23447,"ps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealVar&operator=(const RooRealVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:3481,Usability,clear,clearEvalErrorLog,3481,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooA",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:3517,Usability,clear,clearShapeDirty,3517,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& dat",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:3557,Usability,clear,clearValueAndShapeDirty,3557,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none()",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVar.html:3605,Usability,clear,clearValueDirty,3605,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooRealVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVar.html
https://root.cern/root/html602/RooRealVarSharedProperties.html:1686,Availability,error,error,1686,"r* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TStringRooSharedProperties::asString(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual RooSharedProperties*clone(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidRooSharedProperties::decreaseRefCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidRooSharedProperties::increaseRefCount(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTOb",MatchSource.WIKI,root/html602/RooRealVarSharedProperties.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVarSharedProperties.html
https://root.cern/root/html602/RooRealVarSharedProperties.html:1770,Availability,error,error,1770,"haredProperties::asString(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual RooSharedProperties*clone(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidRooSharedProperties::decreaseRefCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidRooSharedProperties::increaseRefCount(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom",MatchSource.WIKI,root/html602/RooRealVarSharedProperties.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRealVarSharedProperties.html
https://root.cern/root/html602/RooRecursiveFraction.html:10138,Availability,error,error,10138,,MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:10222,Availability,error,error,10222,,MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:35024,Deployability,integrat,integration,35024,"et<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:36618,Deployability,integrat,integrator,36618,"rgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRecursiveFraction(); Default constructor. RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); Constructor of plain RooAd",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:36629,Deployability,configurat,configuration,36629,"rgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRecursiveFraction(); Default constructor. RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); Constructor of plain RooAd",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:7467,Integrability,depend,dependentVars,7467,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:8709,Integrability,depend,dependentOverlaps,8709,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:8801,Integrability,depend,dependentOverlaps,8801,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:8895,Integrability,depend,dependsOn,8895,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:9024,Integrability,depend,dependsOn,9024,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:9142,Integrability,depend,dependsOnValue,9142,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:9249,Integrability,depend,dependsOnValue,9249,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:17432,Integrability,message,message,17432,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:17583,Integrability,message,message,17583,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:35024,Integrability,integrat,integration,35024,"et<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:36618,Integrability,integrat,integrator,36618,"rgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRecursiveFraction(); Default constructor. RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); Constructor of plain RooAd",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:24481,Modifiability,config,config,24481,"e(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:36629,Modifiability,config,configuration,36629,"rgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRecursiveFraction(); Default constructor. RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); Constructor of plain RooAd",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:2113,Performance,cache,cacheUniqueSuffix,2113,"iqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:10956,Performance,cache,cacheList,10956,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:11044,Performance,cache,cacheList,11044,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:19404,Performance,optimiz,optimizeCacheMode,19404,"(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRecursiveFraction&operator=(const RooRecursiveFraction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:19476,Performance,optimiz,optimizeCacheMode,19476,"Overlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRecursiveFraction&operator=(const RooRecursiveFraction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:22950,Performance,cache,cache,22950,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRecursiveFraction(); RooRecursiveFraction(const RooRecursiveFraction& other, const char* name = 0); RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtu",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:24324,Performance,cache,cache,24324,"itle, const RooArgList& fracSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:26419,Performance,cache,cache,26419,"voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:29476,Performance,optimiz,optimizeDirtyHook,29476,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:33934,Performance,cache,cache,33934,,MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:34017,Performance,cache,cache,34017,,MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:34215,Performance,cache,caches,34215,,MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:34747,Performance,cache,cache,34747,"et<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:34926,Performance,cache,cache,34926,"et<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:35339,Performance,cache,cache,35339,"et<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:36271,Performance,cache,cache,36271,"rgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRecursiveFraction(); Default constructor. RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); Constructor of plain RooAd",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:36813,Performance,cache,cache,36813,"rgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRecursiveFraction(); Default constructor. RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); Constructor of plain RooAd",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:11888,Security,hash,hash,11888,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::ge",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:12039,Security,hash,hash,12039,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption()",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:34111,Security,validat,validate,34111,,MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:34847,Security,access,access,34847,"et<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:8768,Testability,test,testArg,8768,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:8862,Testability,test,testArg,8862,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:17407,Testability,log,logEvalError,17407,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:17506,Testability,log,logEvalError,17506,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:18535,Testability,test,testArg,18535,"iginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRecursiveFraction&operator=(const RooRecursiveFraction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optN",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:18630,Testability,test,testArg,18630,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRecursiveFraction&operator=(const RooRecursiveFraction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:19620,Testability,test,testArg,19620," dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRecursiveFraction&operator=(const RooRecursiveFraction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:3568,Usability,clear,clearEvalErrorLog,3568,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg:",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:3604,Usability,clear,clearShapeDirty,3604,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:3644,Usability,clear,clearValueAndShapeDirty,3644,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = Roo",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRecursiveFraction.html:3692,Usability,clear,clearValueDirty,3692,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html602/RooRecursiveFraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html
https://root.cern/root/html602/RooRefArray.html:3187,Availability,error,error,3187,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjArray::Expand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObjArra",MatchSource.WIKI,root/html602/RooRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefArray.html
https://root.cern/root/html602/RooRefArray.html:3271,Availability,error,error,3271,"ray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjArray::Expand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObjArray::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); vi",MatchSource.WIKI,root/html602/RooRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefArray.html
https://root.cern/root/html602/RooRefArray.html:433,Integrability,depend,depends,433,". RooRefArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRefArray. class RooRefArray: public TObjArray. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods); public:. virtual~RooRefArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidTObjArray::AddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t idx) const; virtual TObject*TObjArray::Before(const TObject* obj) const; TIte",MatchSource.WIKI,root/html602/RooRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefArray.html
https://root.cern/root/html602/RooRefArray.html:702,Integrability,depend,depends,702,". RooRefArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRefArray. class RooRefArray: public TObjArray. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods); public:. virtual~RooRefArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidTObjArray::AddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t idx) const; virtual TObject*TObjArray::Before(const TObject* obj) const; TIte",MatchSource.WIKI,root/html602/RooRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefArray.html
https://root.cern/root/html602/RooRefArray.html:959,Integrability,interface,interfaces,959,". RooRefArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRefArray. class RooRefArray: public TObjArray. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods); public:. virtual~RooRefArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidTObjArray::AddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t idx) const; virtual TObject*TObjArray::Before(const TObject* obj) const; TIte",MatchSource.WIKI,root/html602/RooRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefArray.html
https://root.cern/root/html602/RooRefArray.html:1036,Testability,test,testing,1036,". RooRefArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRefArray. class RooRefArray: public TObjArray. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods); public:. virtual~RooRefArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidTObjArray::AddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t idx) const; virtual TObject*TObjArray::Before(const TObject* obj) const; TIte",MatchSource.WIKI,root/html602/RooRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefArray.html
https://root.cern/root/html602/RooRefArray.html:1027,Usability,clear,clearing,1027,". RooRefArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRefArray. class RooRefArray: public TObjArray. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods); public:. virtual~RooRefArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidTObjArray::AddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t idx) const; virtual TObject*TObjArray::Before(const TObject* obj) const; TIte",MatchSource.WIKI,root/html602/RooRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefArray.html
https://root.cern/root/html602/RooRefCountList.html:1698,Availability,error,error,1698,"har* method) const; virtual voidAdd(TObject* arg); virtual voidAdd(TObject* obj, Int_t count); virtual voidTObject::AppendPad(Option_t* option = """"); TObject*RooLinkedList::At(Int_t index) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidRooLinkedList::Clear(Option_t* o = 0); virtual TObject*RooLinkedList::Clone(const char* = 0) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidRooLinkedList::Delete(Option_t* o = 0); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TObject*RooLinkedList::find(const char* name) const; RooAbsArg*RooLinkedList::findArg(const RooAbsArg*) const; virtual TObject*RooLinkedList::FindObject(const char* name) const; virtual TObject*RooLinkedList::FindObject(const TObject* obj) const; TObject*RooLinkedList::First() const; RooFIterRooLinkedList::fwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooLinkedList::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooLinkedList::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tRooLinkedList::GetSize() const; virtual const char*T",MatchSource.WIKI,root/html602/RooRefCountList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefCountList.html
https://root.cern/root/html602/RooRefCountList.html:1782,Availability,error,error,1782,"_t count); virtual voidTObject::AppendPad(Option_t* option = """"); TObject*RooLinkedList::At(Int_t index) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidRooLinkedList::Clear(Option_t* o = 0); virtual TObject*RooLinkedList::Clone(const char* = 0) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidRooLinkedList::Delete(Option_t* o = 0); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TObject*RooLinkedList::find(const char* name) const; RooAbsArg*RooLinkedList::findArg(const RooAbsArg*) const; virtual TObject*RooLinkedList::FindObject(const char* name) const; virtual TObject*RooLinkedList::FindObject(const TObject* obj) const; TObject*RooLinkedList::First() const; RooFIterRooLinkedList::fwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooLinkedList::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooLinkedList::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tRooLinkedList::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_t",MatchSource.WIKI,root/html602/RooRefCountList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefCountList.html
https://root.cern/root/html602/RooRefCountList.html:7247,Security,hash,hashing,7247,"::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedListElem*RooLinkedList::_first! Link to first element of list; Int_tRooLinkedList::_hashThreshSize threshold for hashing; RooHashTable*RooLinkedList::_htableLink! Hash table by link pointer; RooHashTable*RooLinkedList::_htableName! Hash table by name; RooLinkedListElem*RooLinkedList::_last! Link to last element of list; TStringRooLinkedList::_name; Int_tRooLinkedList::_sizeCurrent size of list; Bool_tRooLinkedList::_useNptr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRefCountList(); Default constructor construct lists with initial hash table size of 17. void Add(TObject* obj, Int_t count); Add object to list with given reference count increment; List takes ownership of object. Bool_t Remove(TObject* obj); Remove object from list and if reference count; reaches zero delete object itself as well. Bool_t RemoveAll(TObject* obj); Remove object from list and delete object itself; regardless of reference count. Int_t refCount(TObject* obj); Return reference count associated with 'obj'. RooRefCountList(). virtual ~RooRefCountList(); {}. void Add(TObject* arg); { Add(arg,1) ; }. » Last changed: Tue Jun 30 14:35:31 2015 » Last generated: 2015-06-30 ",MatchSource.WIKI,root/html602/RooRefCountList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefCountList.html
https://root.cern/root/html602/RooRefCountList.html:7723,Security,hash,hash,7723,"ject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedListElem*RooLinkedList::_first! Link to first element of list; Int_tRooLinkedList::_hashThreshSize threshold for hashing; RooHashTable*RooLinkedList::_htableLink! Hash table by link pointer; RooHashTable*RooLinkedList::_htableName! Hash table by name; RooLinkedListElem*RooLinkedList::_last! Link to last element of list; TStringRooLinkedList::_name; Int_tRooLinkedList::_sizeCurrent size of list; Bool_tRooLinkedList::_useNptr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRefCountList(); Default constructor construct lists with initial hash table size of 17. void Add(TObject* obj, Int_t count); Add object to list with given reference count increment; List takes ownership of object. Bool_t Remove(TObject* obj); Remove object from list and if reference count; reaches zero delete object itself as well. Bool_t RemoveAll(TObject* obj); Remove object from list and delete object itself; regardless of reference count. Int_t refCount(TObject* obj); Return reference count associated with 'obj'. RooRefCountList(). virtual ~RooRefCountList(); {}. void Add(TObject* arg); { Add(arg,1) ; }. » Last changed: Tue Jun 30 14:35:31 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooRefCountList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooRefCountList.html
https://root.cern/root/html602/RooResolutionModel.html:2199,Availability,avail,available,2199,"of the; supported basis functions. RooResolutionModel objects can be used as regular; PDFs (They inherit from RooAbsPdf), or as resolution model convoluted with; a basis function. The implementation of evaluate() can identify the requested; from of use from the basisCode() function. If zero, the regular PDF value; should be calculated. If non-zero, the models value convoluted with the; basis function identified by the code should be calculated. Optionally, analytical integrals can be advertised and implemented, in the; same way as done for regular PDFS (see RooAbsPdf for further details).; Also in getAnalyticalIntegral()/analyticalIntegral() the implementation; should use basisCode() to determine for which scenario the integral is; requested. The choice of basis returned by basisCode() is guaranteed not to change; of the lifetime of a RooResolutionModel object. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooResolutionModel(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(cons",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:11938,Availability,error,error,11938,,MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:12022,Availability,error,error,12022,,MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:44032,Availability,error,errors,44032,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:49305,Availability,error,error,49305,"trings (see derived class implementation of method basisCode(); for those strings. void changeBasis(RooFormulaVar* basis); Change the basis function we convolute with.; For one-time use by convolution() only. const RooRealVar& basisConvVar() const; Return the convolution variable of the selection basis function.; This is, by definition, the first parameter of the basis function. RooRealVar& convVar() const; Return the convolution variable of the resolution model. Double_t getValV(const RooArgSet* nset = 0) const; Modified version of RooAbsPdf::getValF(). If used as regular PDF,; call RooAbsPdf::getValF(), otherwise return unnormalized value; regardless of specified normalization set. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward redirectServers call to our basis function, which is not connected to either resolution; model or the physics model. Bool_t traceEvalHook(Double_t value) const; Floating point error checking and tracing for given float value. void normLeafServerList(RooArgSet& list) const; Return the list of servers used by our normalization integral. Double_t getNorm(const RooArgSet* nset = 0) const; Return the integral of this PDF over all elements of 'nset'. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : value, units, plot range; Verbose : default binning and print label. inline RooResolutionModel(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const. RooAbsGenContext* modelGenContext(const RooAbsAnaConvPdf& , const RooArgSet& , const RooDataSet* , const RooArgSet* , Bool_t ) const. Bool_t isBasisSupported(const char* name) const; { return basisCode(name)?kTRUE:kFALSE ; }. Int_t basisCode(const char* name) const. const RooFormulaVar& basis() const; { return _basis?",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:44305,Deployability,integrat,integration,44305,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:46446,Deployability,configurat,configuration,46446,"df::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:46543,Deployability,integrat,integrator,46543,"df::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:46554,Deployability,configurat,configuration,46554,"df::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:8982,Integrability,depend,dependentVars,8982,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:10472,Integrability,depend,dependentOverlaps,10472,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:10564,Integrability,depend,dependentOverlaps,10564,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:10658,Integrability,depend,dependsOn,10658,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:10787,Integrability,depend,dependsOn,10787,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:10905,Integrability,depend,dependsOnValue,10905,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:11012,Integrability,depend,dependsOnValue,11012,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:22972,Integrability,message,message,22972,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLe",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:23123,Integrability,message,message,23123,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bo",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:44305,Integrability,integrat,integration,44305,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:46543,Integrability,integrat,integrator,46543,"df::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:584,Modifiability,variab,variable,584,". RooResolutionModel. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooResolutionModel. class RooResolutionModel: public RooAbsPdf. RooResolutionModel is the base class of for PDFs that represent a; resolution model that can be convoluted with physics a physics model of the form. Phys(x,a,b) = Sum_k coef_k(a) * basis_k(x,b). where basis_k are a limited number of functions in terms of the variable; to be convoluted and coef_k are coefficients independent of the convolution; variable. Classes derived from RooResolutionModel implement; _ _ _ _; R_k(x,b,c) = Int(dx') basis_k(x',b) * resModel(x-x',c). which RooAbsAnaConvPdf uses to construct the pdf for [ Phys (x) R ] :; _ _ _ _ _ _; PDF(x,a,b,c) = Sum_k coef_k(a) * R_k(x,b,c). A minimal implementation of a RooResolutionModel consists of a. Int_t basisCode(const char* name). function indication which basis functions this resolution model supports, and. Double_t evaluate(). Implementing the resolution model, optionally convoluted with one of the; supported basis functions. RooResolutionModel objects can be used as regular; PDFs (They inherit from RooAbsPdf), or as resolution model convoluted with; a basis function. The implementation of evaluate() can identify the requested; from of use from the basisCode() function. If zero, the regular PDF value; should be calculated. If non-zero, the models value convoluted with the; basis function identified by the code should be calculated. Optionally, analytical integrals can be advertised and implemented, in the; same way as done for regular PDFS (see RooAbsPdf for further details).; Also in getAnalyticalIntegral()/analyticalIntegral() the implementation; should use basisCode() to determine for which scenario the integral is; requested. The choice of basis returned by basisCode() is guaranteed",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:671,Modifiability,variab,variable,671,". RooResolutionModel. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooResolutionModel. class RooResolutionModel: public RooAbsPdf. RooResolutionModel is the base class of for PDFs that represent a; resolution model that can be convoluted with physics a physics model of the form. Phys(x,a,b) = Sum_k coef_k(a) * basis_k(x,b). where basis_k are a limited number of functions in terms of the variable; to be convoluted and coef_k are coefficients independent of the convolution; variable. Classes derived from RooResolutionModel implement; _ _ _ _; R_k(x,b,c) = Int(dx') basis_k(x',b) * resModel(x-x',c). which RooAbsAnaConvPdf uses to construct the pdf for [ Phys (x) R ] :; _ _ _ _ _ _; PDF(x,a,b,c) = Sum_k coef_k(a) * R_k(x,b,c). A minimal implementation of a RooResolutionModel consists of a. Int_t basisCode(const char* name). function indication which basis functions this resolution model supports, and. Double_t evaluate(). Implementing the resolution model, optionally convoluted with one of the; supported basis functions. RooResolutionModel objects can be used as regular; PDFs (They inherit from RooAbsPdf), or as resolution model convoluted with; a basis function. The implementation of evaluate() can identify the requested; from of use from the basisCode() function. If zero, the regular PDF value; should be calculated. If non-zero, the models value convoluted with the; basis function identified by the code should be calculated. Optionally, analytical integrals can be advertised and implemented, in the; same way as done for regular PDFS (see RooAbsPdf for further details).; Also in getAnalyticalIntegral()/analyticalIntegral() the implementation; should use basisCode() to determine for which scenario the integral is; requested. The choice of basis returned by basisCode() is guaranteed",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:1288,Modifiability,inherit,inherit,1288,"ionModel: public RooAbsPdf. RooResolutionModel is the base class of for PDFs that represent a; resolution model that can be convoluted with physics a physics model of the form. Phys(x,a,b) = Sum_k coef_k(a) * basis_k(x,b). where basis_k are a limited number of functions in terms of the variable; to be convoluted and coef_k are coefficients independent of the convolution; variable. Classes derived from RooResolutionModel implement; _ _ _ _; R_k(x,b,c) = Int(dx') basis_k(x',b) * resModel(x-x',c). which RooAbsAnaConvPdf uses to construct the pdf for [ Phys (x) R ] :; _ _ _ _ _ _; PDF(x,a,b,c) = Sum_k coef_k(a) * R_k(x,b,c). A minimal implementation of a RooResolutionModel consists of a. Int_t basisCode(const char* name). function indication which basis functions this resolution model supports, and. Double_t evaluate(). Implementing the resolution model, optionally convoluted with one of the; supported basis functions. RooResolutionModel objects can be used as regular; PDFs (They inherit from RooAbsPdf), or as resolution model convoluted with; a basis function. The implementation of evaluate() can identify the requested; from of use from the basisCode() function. If zero, the regular PDF value; should be calculated. If non-zero, the models value convoluted with the; basis function identified by the code should be calculated. Optionally, analytical integrals can be advertised and implemented, in the; same way as done for regular PDFS (see RooAbsPdf for further details).; Also in getAnalyticalIntegral()/analyticalIntegral() the implementation; should use basisCode() to determine for which scenario the integral is; requested. The choice of basis returned by basisCode() is guaranteed not to change; of the lifetime of a RooResolutionModel object. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooResolutionModel(); voidTObject::AbstractMethod(const c",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:12338,Modifiability,extend,extendedTerm,12338,"nt_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; v",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:12450,Modifiability,extend,extendMode,12450,"U ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Doubl",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:15960,Modifiability,extend,extended,15960,"ec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& o",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:16114,Modifiability,extend,extended,16114,"ProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooA",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:31251,Modifiability,config,config,31251,"imitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFAL",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:31409,Modifiability,config,config,31409,":serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(con",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:36026,Modifiability,extend,extended,36026,"ngRooAbsArg::cleanBranchName() const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tR",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:46446,Modifiability,config,configuration,46446,"df::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:46554,Modifiability,config,configuration,46554,"df::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:47312,Modifiability,variab,variable,47312,"df::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:47575,Modifiability,variab,variable,47575,"onfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup hook for RooSentinel atexit handler. RooResolutionModel(const char* name, const char* title, RooRealVar& x); Constructor with convolution variable 'x'. RooResolutionModel(const RooResolutionModel& other, const char* name = 0); Copy constructor. ~RooResolutionModel(); Destructor. RooFormulaVar* identity(); Return identity formula pointer. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. Note: The 'inBasis' formula expression must be a RooFormulaVar that encodes the formula; in the title of the object and this expression must be an exact match against the; implemented basis function strings (see derived class implementation of method basisCode(); for those strings. void changeBasis(RooFormulaVar* basis); Change the basis function we convolute with.; For one-time use by convolution() only. const RooRealVar& basis",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:48571,Modifiability,variab,variable,48571,"ith convolution variable 'x'. RooResolutionModel(const RooResolutionModel& other, const char* name = 0); Copy constructor. ~RooResolutionModel(); Destructor. RooFormulaVar* identity(); Return identity formula pointer. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. Note: The 'inBasis' formula expression must be a RooFormulaVar that encodes the formula; in the title of the object and this expression must be an exact match against the; implemented basis function strings (see derived class implementation of method basisCode(); for those strings. void changeBasis(RooFormulaVar* basis); Change the basis function we convolute with.; For one-time use by convolution() only. const RooRealVar& basisConvVar() const; Return the convolution variable of the selection basis function.; This is, by definition, the first parameter of the basis function. RooRealVar& convVar() const; Return the convolution variable of the resolution model. Double_t getValV(const RooArgSet* nset = 0) const; Modified version of RooAbsPdf::getValF(). If used as regular PDF,; call RooAbsPdf::getValF(), otherwise return unnormalized value; regardless of specified normalization set. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward redirectServers call to our basis function, which is not connected to either resolution; model or the physics model. Bool_t traceEvalHook(Double_t value) const; Floating point error checking and tracing for given float value. void normLeafServerList(RooArgSet& list) const; Return the list of servers used by our normalization integral. Double_t getNorm(const RooArgSet* nset = 0) const; Return the integral of this PDF over all el",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:48733,Modifiability,variab,variable,48733,"mulaVar* identity(); Return identity formula pointer. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. Note: The 'inBasis' formula expression must be a RooFormulaVar that encodes the formula; in the title of the object and this expression must be an exact match against the; implemented basis function strings (see derived class implementation of method basisCode(); for those strings. void changeBasis(RooFormulaVar* basis); Change the basis function we convolute with.; For one-time use by convolution() only. const RooRealVar& basisConvVar() const; Return the convolution variable of the selection basis function.; This is, by definition, the first parameter of the basis function. RooRealVar& convVar() const; Return the convolution variable of the resolution model. Double_t getValV(const RooArgSet* nset = 0) const; Modified version of RooAbsPdf::getValF(). If used as regular PDF,; call RooAbsPdf::getValF(), otherwise return unnormalized value; regardless of specified normalization set. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward redirectServers call to our basis function, which is not connected to either resolution; model or the physics model. Bool_t traceEvalHook(Double_t value) const; Floating point error checking and tracing for given float value. void normLeafServerList(RooArgSet& list) const; Return the list of servers used by our normalization integral. Double_t getNorm(const RooArgSet* nset = 0) const; Return the integral of this PDF over all elements of 'nset'. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specifie",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:3856,Performance,cache,cacheUniqueSuffix,3856,"Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; const RooFormulaVar&basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* ne",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:13059,Performance,cache,cacheList,13059,"ent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:13147,Performance,cache,cacheList,13147,"oArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:25213,Performance,optimiz,optimizeCacheMode,25213,"; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooResolutionModel&operator=(const RooResolutionModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:25285,Performance,optimiz,optimizeCacheMode,25285,"; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooResolutionModel&operator=(const RooResolutionModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:29680,Performance,cache,cache,29680,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); RooResolutionModel(); RooResolutionModel(const RooResolutionModel& other, const char* name = 0); RooResolutionModel(const char* name, const char* title, RooRealVar& x); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsA",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:31149,Performance,cache,cache,31149,"ject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:33716,Performance,cache,cache,33716,"ct::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:37666,Performance,optimiz,optimizeDirtyHook,37666,"t* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:43115,Performance,cache,cache,43115,,MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:43198,Performance,cache,cache,43198,,MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:43396,Performance,cache,caches,43396,,MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:43928,Performance,cache,cache,43928,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:44207,Performance,cache,cache,44207,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:44682,Performance,cache,cache,44682,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:45291,Performance,cache,cache,45291,,MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:46014,Performance,cache,cache,46014,,MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:46802,Performance,cache,cache,46802,"df::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:48018,Safety,avoid,avoid,48018,"ting because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup hook for RooSentinel atexit handler. RooResolutionModel(const char* name, const char* title, RooRealVar& x); Constructor with convolution variable 'x'. RooResolutionModel(const RooResolutionModel& other, const char* name = 0); Copy constructor. ~RooResolutionModel(); Destructor. RooFormulaVar* identity(); Return identity formula pointer. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. Note: The 'inBasis' formula expression must be a RooFormulaVar that encodes the formula; in the title of the object and this expression must be an exact match against the; implemented basis function strings (see derived class implementation of method basisCode(); for those strings. void changeBasis(RooFormulaVar* basis); Change the basis function we convolute with.; For one-time use by convolution() only. const RooRealVar& basisConvVar() const; Return the convolution variable of the selection basis function.; This is, by definition, the first parameter of the basis function. RooRealVar& convVar() const; Return the convolution variable of the resolution model. Double_t getValV(const RooArgSet* nset = 0) const; Modified version of RooAbsPdf::getValF(). If used as regular PDF,; call RooAbsPdf::getValF(), otherwise return unnormalized value; regardless of specified normalization set. Bool_t redirectServersHook(const Ro",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:14479,Security,hash,hash,14479,"Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:14630,Security,hash,hash,14630,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), ",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:43292,Security,validat,validate,43292,,MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:44128,Security,access,access,44128,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:10531,Testability,test,testArg,10531,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:10625,Testability,test,testArg,10625,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:22947,Testability,log,logEvalError,22947,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameF",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:23046,Testability,log,logEvalError,23046,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(R",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:24348,Testability,test,testArg,24348,"an(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooResolutionModel&operator=(const RooResolutionModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:24443,Testability,test,testArg,24443,"tual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooResolutionModel&operator=(const RooResolutionModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t va",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:25429,Testability,test,testArg,25429,"; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooResolutionModel&operator=(const RooResolutionModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:4462,Usability,clear,clearEvalError,4462,"AbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createC",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:4503,Usability,clear,clearEvalErrorLog,4503,"ouble_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg&",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:4539,Usability,clear,clearShapeDirty,4539,"c*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooC",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:4579,Usability,clear,clearValueAndShapeDirty,4579,", const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCm",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooResolutionModel.html:4627,Usability,clear,clearValueDirty,4627,"lid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmd",MatchSource.WIKI,root/html602/RooResolutionModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html
https://root.cern/root/html602/RooSecondMoment.html:10084,Availability,error,error,10084,,MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:10168,Availability,error,error,10168,,MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:35201,Deployability,integrat,integration,35201,"d in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:37029,Deployability,integrat,integrator,37029,"Mean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xf(X-offset)*F; Double_t_xfOffsetoffset; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSecondMoment(); Default cons",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:37040,Deployability,configurat,configuration,37040,"Mean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xf(X-offset)*F; Double_t_xfOffsetoffset; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSecondMoment(); Default cons",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:7413,Integrability,depend,dependentVars,7413,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:8655,Integrability,depend,dependentOverlaps,8655,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:8747,Integrability,depend,dependentOverlaps,8747,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:8841,Integrability,depend,dependsOn,8841,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:8970,Integrability,depend,dependsOn,8970,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:9088,Integrability,depend,dependsOnValue,9088,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:9195,Integrability,depend,dependsOnValue,9195,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:17425,Integrability,message,message,17425,"t; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; const RooAbsReal&ixF(); voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, cons",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:17576,Integrability,message,message,17576,"al Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; const RooAbsReal&ixF(); voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:35201,Integrability,integrat,integration,35201,"d in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:37029,Integrability,integrat,integrator,37029,"Mean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xf(X-offset)*F; Double_t_xfOffsetoffset; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSecondMoment(); Default cons",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:24635,Modifiability,config,config,24635,"e(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:37040,Modifiability,config,configuration,37040,"Mean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xf(X-offset)*F; Double_t_xfOffsetoffset; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSecondMoment(); Default cons",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:2022,Performance,cache,cacheUniqueSuffix,2022,"iqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; Bool_tRooAbsMoment::central() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:10902,Performance,cache,cacheList,10902,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:10990,Performance,cache,cacheList,10990,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:19301,Performance,optimiz,optimizeCacheMode,19301,"ErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSecondMoment&operator=(const RooSecondMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virt",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:19373,Performance,optimiz,optimizeCacheMode,19373,"observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSecondMoment&operator=(const RooSecondMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sli",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:22881,Performance,cache,cache,22881,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooSecondMoment(); RooSecondMoment(const RooSecondMoment& other, const char* name = 0); RooSecondMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, Bool_t central = kFALSE, Bool_t takeRoot = kFALSE); RooSecondMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, const RooArgSet& nset, Bool_t central = kFALSE, Bool_t takeRoot = kFALSE, Bool_t intNSet = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Te",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:24478,Performance,cache,cache,24478,"kFALSE, Bool_t intNSet = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:26573,Performance,cache,cache,26573,"Dirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const; const RooAbsReal&xF().",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:29653,Performance,optimiz,optimizeDirtyHook,29653,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:34111,Performance,cache,cache,34111,,MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:34194,Performance,cache,cache,34194,,MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:34392,Performance,cache,caches,34392,,MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:34924,Performance,cache,cache,34924,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMom",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:35103,Performance,cache,cache,35103,"d in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:35593,Performance,cache,cache,35593,"d in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:36682,Performance,cache,cache,36682,"Mean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xf(X-offset)*F; Double_t_xfOffsetoffset; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSecondMoment(); Default cons",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:37283,Performance,cache,cache,37283,"Mean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xf(X-offset)*F; Double_t_xfOffsetoffset; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSecondMoment(); Default cons",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:11834,Security,hash,hash,11834,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::ge",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:11985,Security,hash,hash,11985,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption()",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:34288,Security,validat,validate,34288,,MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:35024,Security,access,access,35024,"nt boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooA",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:8714,Testability,test,testArg,8714,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:8808,Testability,test,testArg,8808,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:17400,Testability,log,logEvalError,17400,"Object::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; const RooAbsReal&ixF(); voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const ",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:17499,Testability,log,logEvalError,17499,":isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; const RooAbsReal&ixF(); voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArg",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:18442,Testability,test,testArg,18442,"serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSecondMoment&operator=(const RooSecondMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:18537,Testability,test,testArg,18537," const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSecondMoment&operator=(const RooSecondMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const R",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:19551,Testability,test,testArg,19551,"testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSecondMoment&operator=(const RooSecondMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:3514,Usability,clear,clearEvalErrorLog,3514,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg:",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:3550,Usability,clear,clearShapeDirty,3550,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:3590,Usability,clear,clearValueAndShapeDirty,3590,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = Roo",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSecondMoment.html:3638,Usability,clear,clearValueDirty,3638,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html602/RooSecondMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:1791,Availability,error,error,1791,"nIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:1875,Availability,error,error,1875,"teOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:426,Deployability,integrat,integration,426,". RooSegmentedIntegrator1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSegmentedIntegrator1D. class RooSegmentedIntegrator1D: public RooAbsIntegrator. RooSegmentedIntegrator1D implements an adaptive one-dimensional ; numerical integration algorithm.; . Function Members (Methods); public:. virtual~RooSegmentedIntegrator1D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method,",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:6883,Deployability,integrat,integrators,6883,"& fact). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7134,Deployability,integrat,integration,7134,"& fact). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7237,Deployability,integrat,integrator,7237,"& fact). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7753,Deployability,configurat,configuration,7753,"te; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and ot",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7773,Deployability,integrat,integration,7773,"nymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Ev",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8021,Deployability,configurat,configuration,8021,"nPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t fla",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8063,Deployability,integrat,integration,8063,"nPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t fla",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8216,Deployability,configurat,configuration,8216,"_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { ret",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8289,Deployability,integrat,integrator,8289,"_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:35 2015 » Last generate",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8418,Deployability,integrat,integration,8418,"terIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:35 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the doc",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8651,Deployability,integrat,integration,8651,"tor1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:35 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:389,Energy Efficiency,adapt,adaptive,389,". RooSegmentedIntegrator1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSegmentedIntegrator1D. class RooSegmentedIntegrator1D: public RooAbsIntegrator. RooSegmentedIntegrator1D implements an adaptive one-dimensional ; numerical integration algorithm.; . Function Members (Methods); public:. virtual~RooSegmentedIntegrator1D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method,",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:426,Integrability,integrat,integration,426,". RooSegmentedIntegrator1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSegmentedIntegrator1D. class RooSegmentedIntegrator1D: public RooAbsIntegrator. RooSegmentedIntegrator1D implements an adaptive one-dimensional ; numerical integration algorithm.; . Function Members (Methods); public:. virtual~RooSegmentedIntegrator1D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method,",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:6883,Integrability,integrat,integrators,6883,"& fact). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7134,Integrability,integrat,integration,7134,"& fact). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7237,Integrability,integrat,integrator,7237,"& fact). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7486,Integrability,depend,dependencies,7486,"ject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7773,Integrability,integrat,integration,7773,"nymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Ev",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8063,Integrability,integrat,integration,8063,"nPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t fla",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8289,Integrability,integrat,integrator,8289,"_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:35 2015 » Last generate",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8418,Integrability,integrat,integration,8418,"terIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:35 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the doc",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8651,Integrability,integrat,integration,8651,"tor1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:35 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:389,Modifiability,adapt,adaptive,389,". RooSegmentedIntegrator1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSegmentedIntegrator1D. class RooSegmentedIntegrator1D: public RooAbsIntegrator. RooSegmentedIntegrator1D implements an adaptive one-dimensional ; numerical integration algorithm.; . Function Members (Methods); public:. virtual~RooSegmentedIntegrator1D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method,",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:1194,Modifiability,config,config,1194," virtual~RooSegmentedIntegrator1D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method,",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:4536,Modifiability,config,config,4536,"e(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSegmentedIntegrator1D&operator=(const RooSegmentedIntegrator1D&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; Bool_tRooAbsIntegrator::printEvalCounter() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); RooSegmentedIntegrator1D(); RooSegmentedIntegrator1D(const RooSegmentedIntegrator1D&); RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Bool_tsetLimits(Double_t* xmin, Double_t* xmax); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsIntegrator::setPrintEvalCounter(Bool_t value); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Bool_tsetUseIntegrandLimits(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject:",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:4651,Modifiability,config,config,4651,"ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSegmentedIntegrator1D&operator=(const RooSegmentedIntegrator1D&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; Bool_tRooAbsIntegrator::printEvalCounter() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); RooSegmentedIntegrator1D(); RooSegmentedIntegrator1D(const RooSegmentedIntegrator1D&); RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Bool_tsetLimits(Double_t* xmin, Double_t* xmax); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsIntegrator::setPrintEvalCounter(Bool_t value); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Bool_tsetUseIntegrandLimits(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method,",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7679,Modifiability,config,config,7679,"te; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and ot",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7753,Modifiability,config,configuration,7753,"te; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**_arrayArray of segment integrators; RooNumIntConfig_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and ot",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:7953,Modifiability,config,config,7953,"nPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t fla",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8021,Modifiability,config,configuration,8021,"nPointer to function binding of integrand; Int_t_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_t_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t fla",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8157,Modifiability,config,config,8157,"_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { ret",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8216,Modifiability,config,configuration,8216,"_range; Bool_t_useIntegrandLimits; Bool_t_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t_xmax; Double_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { ret",MatchSource.WIKI,root/html602/RooSegmentedIntegrator1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:1799,Availability,error,error,1799,"nIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:1883,Availability,error,error,1883,"teOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:434,Deployability,integrat,integration,434,". RooSegmentedIntegrator2D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSegmentedIntegrator2D. class RooSegmentedIntegrator2D: public RooSegmentedIntegrator1D. RooSegmentedIntegrator2D implements an adaptive one-dimensional ; numerical integration algorithm.; . Function Members (Methods); public:. virtual~RooSegmentedIntegrator2D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:7051,Deployability,integrat,integrators,7051," TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**RooSegmentedIntegrator1D::_arrayArray of segment integrators; RooNumIntConfigRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:7354,Deployability,integrat,integration,7354," TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**RooSegmentedIntegrator1D::_arrayArray of segment integrators; RooNumIntConfigRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:7535,Deployability,integrat,integrator,7535," TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**RooSegmentedIntegrator1D::_arrayArray of segment integrators; RooNumIntConfigRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8145,Deployability,configurat,configuration,8145,"figRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kF",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8165,Deployability,integrat,integration,8165,"; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last gener",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8443,Deployability,configurat,configuration,8443,"ble_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8485,Deployability,integrat,integration,8485,"ble_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8638,Deployability,configurat,configuration,8638,"SegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8765,Deployability,integrat,integration,8765,"SegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:397,Energy Efficiency,adapt,adaptive,397,". RooSegmentedIntegrator2D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSegmentedIntegrator2D. class RooSegmentedIntegrator2D: public RooSegmentedIntegrator1D. RooSegmentedIntegrator2D implements an adaptive one-dimensional ; numerical integration algorithm.; . Function Members (Methods); public:. virtual~RooSegmentedIntegrator2D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:434,Integrability,integrat,integration,434,". RooSegmentedIntegrator2D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSegmentedIntegrator2D. class RooSegmentedIntegrator2D: public RooSegmentedIntegrator1D. RooSegmentedIntegrator2D implements an adaptive one-dimensional ; numerical integration algorithm.; . Function Members (Methods); public:. virtual~RooSegmentedIntegrator2D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:7051,Integrability,integrat,integrators,7051," TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**RooSegmentedIntegrator1D::_arrayArray of segment integrators; RooNumIntConfigRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:7354,Integrability,integrat,integration,7354," TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**RooSegmentedIntegrator1D::_arrayArray of segment integrators; RooNumIntConfigRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:7535,Integrability,integrat,integrator,7535," TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**RooSegmentedIntegrator1D::_arrayArray of segment integrators; RooNumIntConfigRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:7893,Integrability,depend,dependencies,7893,")TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**RooSegmentedIntegrator1D::_arrayArray of segment integrators; RooNumIntConfigRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integra",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8165,Integrability,integrat,integration,8165,"; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last gener",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8485,Integrability,integrat,integration,8485,"ble_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8765,Integrability,integrat,integration,8765,"SegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:397,Modifiability,adapt,adaptive,397,". RooSegmentedIntegrator2D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSegmentedIntegrator2D. class RooSegmentedIntegrator2D: public RooSegmentedIntegrator1D. RooSegmentedIntegrator2D implements an adaptive one-dimensional ; numerical integration algorithm.; . Function Members (Methods); public:. virtual~RooSegmentedIntegrator2D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:1202,Modifiability,config,config,1202," virtual~RooSegmentedIntegrator2D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:4570,Modifiability,config,config,4570,"e(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSegmentedIntegrator2D&operator=(const RooSegmentedIntegrator2D&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; Bool_tRooAbsIntegrator::printEvalCounter() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); RooSegmentedIntegrator2D(); RooSegmentedIntegrator2D(const RooSegmentedIntegrator2D&); RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Bool_tRooSegmentedIntegrator1D::setLimits(Double_t* xmin, Double_t* xmax); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsIntegrator::setPrintEvalCounter(Bool_t value); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Bool_tRooSegmentedIntegrator1D::setUseIntegrandLimits(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:4715,Modifiability,config,config,4715,"lete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSegmentedIntegrator2D&operator=(const RooSegmentedIntegrator2D&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; Bool_tRooAbsIntegrator::printEvalCounter() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); RooSegmentedIntegrator2D(); RooSegmentedIntegrator2D(const RooSegmentedIntegrator2D&); RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Bool_tRooSegmentedIntegrator1D::setLimits(Double_t* xmin, Double_t* xmax); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsIntegrator::setPrintEvalCounter(Bool_t value); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Bool_tRooSegmentedIntegrator1D::setUseIntegrandLimits(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8071,Modifiability,config,config,8071,"figRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kF",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8145,Modifiability,config,configuration,8145,"figRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kF",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8375,Modifiability,config,config,8375,"ble_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8443,Modifiability,config,configuration,8443,"ble_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8579,Modifiability,config,config,8579,"SegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSegmentedIntegrator2D.html:8638,Modifiability,config,configuration,8638,"SegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. RooSegmentedIntegrator2D(); Constructors, assignment etc. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:36 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSegmentedIntegrator2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html
https://root.cern/root/html602/RooSentinel.html:637,Deployability,install,installs,637,. RooSentinel. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSentinel. class RooSentinel. RooSentinel is a special purposes singleton class that terminates; all other RooFit singleton services when the process exists. ; All function RooFit singleton services are created on the heap with; a static wrapper function to avoid the 'static initialization order fiasco'; but are not automatically destroyed at the end of the session. This class; installs an atexit() function that takes care of this; . Function Members (Methods); public:. ~RooSentinel(); static voidactivate(); RooSentinel&operator=(const RooSentinel&). protected:. RooSentinel(); RooSentinel(const RooSentinel&). Data Members; protected:. static Bool_t_active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void activate(); Install atexit handler that calls CleanupRooFitAtExit(); on program termination. RooSentinel(); {}. RooSentinel(const RooSentinel& ); {}. » Last changed: Tue Jun 30 14:35:37 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html602/RooSentinel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSentinel.html
https://root.cern/root/html602/RooSentinel.html:494,Integrability,wrap,wrapper,494,. RooSentinel. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSentinel. class RooSentinel. RooSentinel is a special purposes singleton class that terminates; all other RooFit singleton services when the process exists. ; All function RooFit singleton services are created on the heap with; a static wrapper function to avoid the 'static initialization order fiasco'; but are not automatically destroyed at the end of the session. This class; installs an atexit() function that takes care of this; . Function Members (Methods); public:. ~RooSentinel(); static voidactivate(); RooSentinel&operator=(const RooSentinel&). protected:. RooSentinel(); RooSentinel(const RooSentinel&). Data Members; protected:. static Bool_t_active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void activate(); Install atexit handler that calls CleanupRooFitAtExit(); on program termination. RooSentinel(); {}. RooSentinel(const RooSentinel& ); {}. » Last changed: Tue Jun 30 14:35:37 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html602/RooSentinel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSentinel.html
https://root.cern/root/html602/RooSentinel.html:514,Safety,avoid,avoid,514,. RooSentinel. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSentinel. class RooSentinel. RooSentinel is a special purposes singleton class that terminates; all other RooFit singleton services when the process exists. ; All function RooFit singleton services are created on the heap with; a static wrapper function to avoid the 'static initialization order fiasco'; but are not automatically destroyed at the end of the session. This class; installs an atexit() function that takes care of this; . Function Members (Methods); public:. ~RooSentinel(); static voidactivate(); RooSentinel&operator=(const RooSentinel&). protected:. RooSentinel(); RooSentinel(const RooSentinel&). Data Members; protected:. static Bool_t_active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void activate(); Install atexit handler that calls CleanupRooFitAtExit(); on program termination. RooSentinel(); {}. RooSentinel(const RooSentinel& ); {}. » Last changed: Tue Jun 30 14:35:37 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html602/RooSentinel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSentinel.html
https://root.cern/root/html602/RooSetPair.html:1336,Availability,error,error,1336," virtual~RooSetPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObj",MatchSource.WIKI,root/html602/RooSetPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSetPair.html
https://root.cern/root/html602/RooSetPair.html:1420,Availability,error,error,1420," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect",MatchSource.WIKI,root/html602/RooSetPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSetPair.html
https://root.cern/root/html602/RooSetProxy.html:3313,Availability,error,error,3313,"tual voidTObject::Copy(TObject& object) const; virtual TObject*RooArgSet::create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidRooAbsCollection::dump() const; virtual voidTObject::Dump() constMENU ; Bool_tRooAbsCollection::equals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; RooAbsArg*RooAbsCollection::find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; RooFIterRooAbsCollection::fwdIterator() const; Int_tRooArgSet::getCatIndex(const char* name, Int_t defVal = 0, Bool_t verbose = kFALSE) const; const char*RooArgSet::getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooAbsCollection::GetName()",MatchSource.WIKI,root/html602/RooSetProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSetProxy.html
https://root.cern/root/html602/RooSetProxy.html:3397,Availability,error,error,3397,"st char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidRooAbsCollection::dump() const; virtual voidTObject::Dump() constMENU ; Bool_tRooAbsCollection::equals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; RooAbsArg*RooAbsCollection::find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; RooFIterRooAbsCollection::fwdIterator() const; Int_tRooArgSet::getCatIndex(const char* name, Int_t defVal = 0, Bool_t verbose = kFALSE) const; const char*RooArgSet::getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooAbsCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_t",MatchSource.WIKI,root/html602/RooSetProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSetProxy.html
https://root.cern/root/html602/RooSetProxy.html:707,Deployability,update,update,707,". RooSetProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSetProxy. class RooSetProxy: public RooArgSet, public RooAbsProxy. RooSetProxy is the concrete proxy for RooArgSet objects.; A RooSetProxy is the general mechanism to store a RooArgSet; with RooAbsArgs in a RooAbsArg.; Creating a RooSetProxy adds all members of the proxied RooArgSet to the proxy owners; server list (thus receiving value/shape dirty flags from it) and; registers itself with the owning class. The latter allows the; owning class to update the pointers of RooArgSet contents to reflect; the serverRedirect changes.; . Function Members (Methods); public:. virtual~RooSetProxy(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); virtual RooAbsArg*addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidaddClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tRooAbsCollection::allInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsCollection::assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&RooAbsCollection::assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooArgSet::cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*RooArgSet::clone(const char* newname) cons",MatchSource.WIKI,root/html602/RooSetProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSetProxy.html
https://root.cern/root/html602/RooSetProxy.html:8413,Deployability,release,releaseOwnership,8413,"rtual voidRooAbsCollection::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsCollection::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsCollection::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCollection::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); Bool_tRooArgSet::readFromFile(const char* fileName, const char* flagReadAtt = 0, const char* section = 0, Bool_t verbose = kFALSE); virtual Bool_tRooArgSet::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooArgSet::readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); virtual voidTObject::RecursiveRemove(TObject* obj); voidRooAbsCollection::releaseOwnership(); virtual Bool_tremove(const RooAbsArg& var, Bool_t silent = kFALSE, Bool_t matchByNameOnly = kFALSE); Bool_tremove(const RooAbsCollection& list, Bool_t silent = kFALSE, Bool_t matchByNameOnly = kFALSE); virtual voidremoveAll(); virtual Bool_treplace(const RooAbsArg& var1, const RooAbsArg& var2); voidTObject::ResetBit(UInt_t f); RooSetProxy(); RooSetProxy(const RooSetProxy&); RooSetProxy(const char* name, RooAbsArg* owner, const RooSetProxy& other); RooSetProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); RooAbsCollection*RooAbsCollection::selectByAttrib(const char* name, Bool_t value) const; RooAbsCollection*RooAbsCollection::selectByName(const char* nameList, Bool_t verbose = kFALSE) const; RooAbsCollection*RooAbsCollection::selectCommon(const",MatchSource.WIKI,root/html602/RooSetProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSetProxy.html
https://root.cern/root/html602/RooSetProxy.html:14627,Performance,perform,performed,14627,"VAll contents are RRV; Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nset! Normalization set to be used for evaluation of RooAbsPdf contents; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; RooAbsArg*_owner; static char*RooArgSet::_poolBegin! Start of memory pool; static char*RooArgSet::_poolCur! Next free slot in memory pool; static char*RooArgSet::_poolEnd! End of memory pool; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void* operator new(size_t bytes); Overload new operator must be implemented because it is overloaded; in the RooArgSet base class. Perform standard memory allocation; here instead of memory pool management performed in RooArgSet. void operator delete(void* ptr). RooSetProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); Construct proxy with given name and description, with given owner; The default value and shape dirty propagation of the set contents; to the set owner is controlled by flags defValueServer and defShapeServer. RooSetProxy(const char* name, RooAbsArg* owner, const RooSetProxy& other); Copy constructor. ~RooSetProxy(); Destructor. Bool_t add(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); Overloaded RooArgSet::add() method insert object into set; and registers object as server to owner with given value; and shape dirty flag propagation requests. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Overloaded RooArgSet::addOwned() method insert object into owning set; and registers object as server to owner with default value; and shape dirty flag",MatchSource.WIKI,root/html602/RooSetProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSetProxy.html
https://root.cern/root/html602/RooSetProxy.html:11938,Safety,safe,safeDeleteList,11938,"SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidRooArgSet::writeToFile(const char* fileName) const; virtual voidRooArgSet::writeToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); Bool_tRooArgSet::checkForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::",MatchSource.WIKI,root/html602/RooSetProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSetProxy.html
https://root.cern/root/html602/RooSetProxy.html:11680,Usability,clear,clearStructureTags,11680,"SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidRooArgSet::writeToFile(const char* fileName) const; virtual voidRooArgSet::writeToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); Bool_tRooArgSet::checkForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::",MatchSource.WIKI,root/html602/RooSetProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSetProxy.html
https://root.cern/root/html602/RooSharedProperties.html:577,Availability,avail,available,577,". RooSharedProperties. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSharedProperties. class RooSharedProperties: public TObject. Class RooSharedProperties is the base class for shared properties; that can be stored in RooSharedPropertiesList.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooSharedProperties(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TStringasString(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual RooSharedProperties*clone(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voiddecreaseRefCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtu",MatchSource.WIKI,root/html602/RooSharedProperties.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSharedProperties.html
https://root.cern/root/html602/RooSharedProperties.html:1634,Availability,error,error,1634,"s(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TStringasString(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual RooSharedProperties*clone(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voiddecreaseRefCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidincreaseRefCount(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(co",MatchSource.WIKI,root/html602/RooSharedProperties.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSharedProperties.html
https://root.cern/root/html602/RooSharedProperties.html:1718,Availability,error,error,1718,"endPad(Option_t* option = """"); TStringasString(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual RooSharedProperties*clone(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voiddecreaseRefCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidincreaseRefCount(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) co",MatchSource.WIKI,root/html602/RooSharedProperties.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSharedProperties.html
https://root.cern/root/html602/RooSharedProperties.html:6653,Integrability,interface,interface,6653,":DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_t_inSharedList! Is in shared list; Int_t_refCount! Use count; TUUID_uuidUnique object ID. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSharedProperties(); Default constructor. RooSharedProperties(const char* uuidstr); Constructor with unique-id string. ~RooSharedProperties(); Destructor. Bool_t operator==(const RooSharedProperties& other); Return true of unique id of this property is equal to that of other. void Print(Option_t* opts = 0) const; Printing interface. RooSharedProperties(). RooSharedProperties* clone(). void increaseRefCount(); { _refCount++ ; }. void decreaseRefCount(); { if (_refCount>0) _refCount-- ; }. Int_t refCount() const; { return _refCount ; }. void setInSharedList(); { _inSharedList = kTRUE ; }. Bool_t inSharedList() const; { return _inSharedList ; }. TString asString(); { return TString(_uuid.AsString()); }. » Last changed: Tue Jun 30 14:35:39 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSharedProperties.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSharedProperties.html
https://root.cern/root/html602/RooSharedPropertiesList.html:1445,Availability,error,error,1445," virtual~RooSharedPropertiesList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*T",MatchSource.WIKI,root/html602/RooSharedPropertiesList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSharedPropertiesList.html
https://root.cern/root/html602/RooSharedPropertiesList.html:1529,Availability,error,error,1529," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html602/RooSharedPropertiesList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSharedPropertiesList.html
https://root.cern/root/html602/RooSimGenContext.html:1746,Availability,error,error,1746,"b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsGenContext::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooAbsGenContext::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*RooAbsGenContext::generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); vir",MatchSource.WIKI,root/html602/RooSimGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html
https://root.cern/root/html602/RooSimGenContext.html:1830,Availability,error,error,1830,"idTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsGenContext::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooAbsGenContext::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*RooAbsGenContext::generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, cons",MatchSource.WIKI,root/html602/RooSimGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html
https://root.cern/root/html602/RooSimGenContext.html:11359,Deployability,update,updateFractions,11359,"ontext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate event appropriate for current index state.; The index state is taken either from the prototype; or is generated from the fraction threshold table. void updateFractions(); No action needed if we have a proto index. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype data to that in the; given lookup table. This information is passed to all; component generator contexts. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). » Last changed: Tue Jun 30 14:35:43 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html
https://root.cern/root/html602/RooSimGenContext.html:349,Energy Efficiency,efficient,efficient,349,". RooSimGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimGenContext. class RooSimGenContext: public RooAbsGenContext. RooSimGenContext is an efficient implementation of the generator context; specific for RooSimultaneous PDFs when generating more than one of the; component pdfs.; . Function Members (Methods); public:. virtual~RooSimGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsGenContext::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooAbsGenContext::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTName",MatchSource.WIKI,root/html602/RooSimGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html
https://root.cern/root/html602/RooSimGenContext.html:11723,Integrability,interface,interface,11723,"ontext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate event appropriate for current index state.; The index state is taken either from the prototype; or is generated from the fraction threshold table. void updateFractions(); No action needed if we have a proto index. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype data to that in the; given lookup table. This information is passed to all; component generator contexts. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). » Last changed: Tue Jun 30 14:35:43 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html
https://root.cern/root/html602/RooSimGenContext.html:2256,Modifiability,extend,extendedMode,2256,") const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*RooAbsGenContext::generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; B",MatchSource.WIKI,root/html602/RooSimGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html
https://root.cern/root/html602/RooSimGenContext.html:8707,Modifiability,variab,variables,8707,StatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_allVarsPdfAll pdf variables; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThresh[_numPdf] Fraction threshold array; vector<int>_gcIndexIndex value corresponding to component; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_haveIdxProtoFlag set if generation of index is requested; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; RooDataSet*_protoData! Prototype dataset; Int_t*RooAbsGenCon,MatchSource.WIKI,root/html602/RooSimGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html
https://root.cern/root/html602/RooSimGenContext.html:8788,Modifiability,extend,extended,8788,StatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_allVarsPdfAll pdf variables; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThresh[_numPdf] Fraction threshold array; vector<int>_gcIndexIndex value corresponding to component; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_haveIdxProtoFlag set if generation of index is requested; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; RooDataSet*_protoData! Prototype dataset; Int_t*RooAbsGenCon,MatchSource.WIKI,root/html602/RooSimGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html
https://root.cern/root/html602/RooSimGenContext.html:9515,Performance,load,load,9515,"Verbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_allVarsPdfAll pdf variables; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThresh[_numPdf] Fraction threshold array; vector<int>_gcIndexIndex value corresponding to component; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_haveIdxProtoFlag set if generation of index is requested; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; RooDataSet*_protoData! Prototype dataset; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*_prototypePrototype data set; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. ",MatchSource.WIKI,root/html602/RooSimGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html
https://root.cern/root/html602/RooSimPdfBuilder.html:15220,Availability,error,error,15220," const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; RooArgSet*createProtoBuildConfig(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:15304,Availability,error,error,15304,"onst RooArgSet& buildConfig, const RooAbsData* dataSet, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; RooArgSet*createProtoBuildConfig(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:3504,Deployability,configurat,configuration,3504,"argus"",""argus background"",X,k,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf(""pdf"",""gauss+argus"",RooArgList(gauss,argus),gfrac) ;; RooSimPdfBuilder builder(pdf) ;; RooArgSet* config = builder.createProtoBuildConfig() ;; (*config)[""physModels""] = ""pdf"" ; // Name of the PDF we are going to work with; (*config)[""splitCats""] = ""C"" ; // Category used to differentiate sub-datasets; (*config)[""pdf""] = ""C : k,s"" ; // Prescription to taylor PDF parameters k and s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:4180,Deployability,configurat,configuration,4180,"l; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; differentiate the various subsets of the 'master' input data set. You can enter; a single category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; sup",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:4241,Deployability,configurat,configuration,4241,"prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; differentiate the various subsets of the 'master' input data set. You can enter; a single category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCa",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:4956,Deployability,configurat,configuration,4956,"er to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; differentiate the various subsets of the 'master' input data set. You can enter; a single category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCat} : {parameter} [,{parameter},....]; . Conversely, each parameter can only have one splitting prescription, but it may be split; by multiple categories, e.g.; . pdfName = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimP",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:5675,Deployability,configurat,configuration,5675," category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCat} : {parameter} [,{parameter},....]; . Conversely, each parameter can only have one splitting prescription, but it may be split; by multiple categories, e.g.; . pdfName = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting;",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:5895,Deployability,configurat,configuration,5895,"pear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCat} : {parameter} [,{parameter},....]; . Conversely, each parameter can only have one splitting prescription, but it may be split; by multiple categories, e.g.; . pdfName = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII fi",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:5937,Deployability,configurat,configuration,5937," = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCat} : {parameter} [,{parameter},....]; . Conversely, each parameter can only have one splitting prescription, but it may be split; by multiple categories, e.g.; . pdfName = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over mult",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:6798,Deployability,configurat,configuration,6798,"Block : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdf",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:7691,Deployability,configurat,configuration,7691," literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdfBuilder will look as follows:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB,...)) ;; . The physModels line is now expanded to carry the pdf->state mapping information; that the prototype RooSimultaneous would have. I.e.; . physModels = mode : pdfA=modeA pdfB=modeB; . is equivalent to a prototype RooSimultaneous constructed as; . RooSimultanous simPdf(""simPdf"",""simPdf"",mode);; simPdf.addPdf(pdfA,""modeA"") ;; simPdf.addPdf(pdfB,""modeB"") ;; . The rest of the builder configuration works the same, except that; each prototype PDF now has its own set of splitting rules, e.g.; . physModels = mode : pdfA=modeA pdfB=modeB; splitCats = tagCat; pdfA = tagCat : bogusPar; pdfB = tagCat : fudgeFactor ; . Please note that ; ; The master index category ('mode' above) doesn't have to be listed in ; splitCats, this is implicit.; The number of",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:8296,Deployability,configurat,configuration,8296,"DFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdfBuilder will look as follows:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB,...)) ;; . The physModels line is now expanded to carry the pdf->state mapping information; that the prototype RooSimultaneous would have. I.e.; . physModels = mode : pdfA=modeA pdfB=modeB; . is equivalent to a prototype RooSimultaneous constructed as; . RooSimultanous simPdf(""simPdf"",""simPdf"",mode);; simPdf.addPdf(pdfA,""modeA"") ;; simPdf.addPdf(pdfB,""modeB"") ;; . The rest of the builder configuration works the same, except that; each prototype PDF now has its own set of splitting rules, e.g.; . physModels = mode : pdfA=modeA pdfB=modeB; splitCats = tagCat; pdfA = tagCat : bogusPar; pdfB = tagCat : fudgeFactor ; . Please note that ; ; The master index category ('mode' above) doesn't have to be listed in ; splitCats, this is implicit.; The number of splitting prescriptions goes by the; number of prototype PDFs and not by the number of states of the; master index category (mode in the above and below example). ; ; In the following case:. physModels = mode : pdfA=modeA pdfB=modeB pdfA=modeC pdfB=modeD; . there are still only 2 sets of splitting rules: one for pdfA and one; for pdfB. However, you can differentiate between modeA and modeC in ; the above example. The technique is to use mode as splitting category, e.g.; . physModels = mode : pdfA=modeA pdfB=modeB pdfA=modeC pdfB=modeD; splitCats = tagCat; pdfA = tagCat : bogusPar ; mode : funnyPar; pdfB = mode : kludgeFactor; . will result in an individual set of ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:11436,Deployability,configurat,configuration,11436,". It is possible to make non-trivial parameter splits with RooSimPdfBuilder.; Trivial splits are considered simple splits in one (fundamental) category; in the dataset or a split in a RooSuperCategory 'product' of multiple; fundamental categories in the dataset. Non-trivial splits can be performed; using an intermediate 'category function' (RooMappedCategory,; RooGenericCategory,RooThresholdCategory etc), i.e. any RooAbsCategory; derived objects that calculates its output as function of one or more; input RooRealVars and/or RooCategories.; . Such 'function categories' objects must be constructed by the user prior; to building the PDF. In the RooSimPdfBuilder::buildPdf() function these; objects can be passed in an optional RooArgSet called 'auxiliary categories':; . const RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, ; const RooArgSet& auxSplitCats, Bool_t verbose=kFALSE) {; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; . Objects passed in this argset can subsequently be used in the build configuration, e.g.; . RooMappedCategory tagMap(""tagMap"",""Mapped tagging category"",tagCat,""CutBased"") ;; tagMap.map(""Lep"",""CutBased"") ;; tagMap.map(""Kao"",""CutBased"") ;; tagMap.map(""NT*"",""NeuralNet"") ; ; ...; builder.buildPdf(config,D,tagMap) ;; ^^^^^^. physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes ; tagMap : fudgeFactor ; ^^^^^^; . In the above example signalRes will be split in signalRes_Kao,signalRes_Lep,; signalRes_NT1,signalRes_NT2, while fudgeFactor will be split in fudgeFactor_CutBased; and fudgeFactor_NeuralNet.; . Category functions passed in the auxSplitCats RooArgSet can be used regularly; in the splitting configuration. They should not be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:12086,Deployability,configurat,configuration,12086,"the PDF. In the RooSimPdfBuilder::buildPdf() function these; objects can be passed in an optional RooArgSet called 'auxiliary categories':; . const RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, ; const RooArgSet& auxSplitCats, Bool_t verbose=kFALSE) {; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; . Objects passed in this argset can subsequently be used in the build configuration, e.g.; . RooMappedCategory tagMap(""tagMap"",""Mapped tagging category"",tagCat,""CutBased"") ;; tagMap.map(""Lep"",""CutBased"") ;; tagMap.map(""Kao"",""CutBased"") ;; tagMap.map(""NT*"",""NeuralNet"") ; ; ...; builder.buildPdf(config,D,tagMap) ;; ^^^^^^. physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes ; tagMap : fudgeFactor ; ^^^^^^; . In the above example signalRes will be split in signalRes_Kao,signalRes_Lep,; signalRes_NT1,signalRes_NT2, while fudgeFactor will be split in fudgeFactor_CutBased; and fudgeFactor_NeuralNet.; . Category functions passed in the auxSplitCats RooArgSet can be used regularly; in the splitting configuration. They should not be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = """,MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:20244,Deployability,configurat,configuration,20244,"t::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_compSplitCatSetList of owned composite splitting categories; list<RooSuperCategory*>_fitCatListThe supercategories that we built; RooArgSet_protoPdfSetSet of prototype PDFS; TList_retiredCustomizerListRetired customizer from previous builds (own their PDF branch nodes); list<RooSimultaneous*>_simPdfListThe simpdfs that we built; RooArgSet_splitNodeListList of owned split nodes; RooArgSet_splitNodeListOwnedList of all split nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooArgSet* createProtoBuildConfig(); Make RooArgSet of configuration objects. void addSpecializations(const RooArgSet& specSet). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); Initialize needed components. ~RooSimPdfBuilder(). RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE). return buildPdf(buildConfig,*dataSet->get(),&auxSplitCats,verbose). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE). const RooArgSet& splitLeafList(); { return _splitNodeList; }. » Last changed: Tue Jun 30 14:35:44 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:390,Energy Efficiency,power,powerful,390,". RooSimPdfBuilder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimPdfBuilder. class RooSimPdfBuilder: public TObject. This tool has now been superceded by RooSimWSTool. RooSimPdfBuilder is a powerful tool to build RooSimultaneous; PDFs that are defined in terms component PDFs that are identical in; structure, but have different parameters. ; ; Example. The following example demonstrates the essence of RooSimPdfBuilder:; Given a dataset D with a RooRealVar X and a RooCategory C that has; state C1 and C2. ; ; We want to fit the distribution of X with a Gaussian+ArgusBG PDF, ; We want to fit the data subsets D(C==C1) and D(C==C2) separately and simultaneously. ; The PDFs to fit data subsets D_C1 and D_C2 are identical except for ; ; the kappa parameter of the ArgusBG PDF and ; the sigma parameter of the gaussian PDF; ; where each PDF will have its own copy of the parameter; . Coding this example directly with RooFit classes gives; (we assume dataset D and variables C and X have been declared previously); . RooRealVar m(""m"",""mean of gaussian"",-10,10) ;; RooRealVar s_C1(""s_C1"",""sigma of gaussian C1"",0,20) ;; RooRealVar s_C2(""s_C2"",""sigma of gaussian C2"",0,20) ;; RooGaussian gauss_C1(""gauss_C1"",""gaussian C1"",X,m,s_C1) ;; RooGaussian gauss_C2(""gauss_C2"",""gaussian C2"",X,m,s_C2) ;; RooRealVar k_C1(""k_C1"",""ArgusBG kappa parameter C1"",-50,0) ;; RooRealVar k_C2(""k_C2"",""ArgusBG kappa parameter C2"",-50,0) ;; RooRealVar xm(""xm"",""ArgusBG cutoff point"",5.29) ;; RooArgusBG argus_C1(""argus_C1"",""argus background C1"",X,k_C1,xm) ;; RooArgusBG argus_C2(""argus_C2"",""argus background C2"",X,k_C2,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf_C1(""pdf_C1"",""gauss+argus_C1"",RooArgList(gauss_C1,argus_C1),gfrac) ;; RooAddPdf pdf_C2(""pdf_C2"",""gauss+argus_C2"",RooArgList(gaus",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:3921,Energy Efficiency,reduce,reduce,3921,"s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; differentiate the various subsets of the 'master' input data set. You can enter; a single category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essen",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:3573,Integrability,depend,depend,3573,") ;; RooSimPdfBuilder builder(pdf) ;; RooArgSet* config = builder.createProtoBuildConfig() ;; (*config)[""physModels""] = ""pdf"" ; // Name of the PDF we are going to work with; (*config)[""splitCats""] = ""C"" ; // Category used to differentiate sub-datasets; (*config)[""pdf""] = ""C : k,s"" ; // Prescription to taylor PDF parameters k and s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; diffe",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:13928,Integrability,depend,dependents,13928,,MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:14212,Integrability,depend,dependents,14212,,MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:20391,Integrability,depend,dependents,20391,"t::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_compSplitCatSetList of owned composite splitting categories; list<RooSuperCategory*>_fitCatListThe supercategories that we built; RooArgSet_protoPdfSetSet of prototype PDFS; TList_retiredCustomizerListRetired customizer from previous builds (own their PDF branch nodes); list<RooSimultaneous*>_simPdfListThe simpdfs that we built; RooArgSet_splitNodeListList of owned split nodes; RooArgSet_splitNodeListOwnedList of all split nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooArgSet* createProtoBuildConfig(); Make RooArgSet of configuration objects. void addSpecializations(const RooArgSet& specSet). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); Initialize needed components. ~RooSimPdfBuilder(). RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE). return buildPdf(buildConfig,*dataSet->get(),&auxSplitCats,verbose). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE). const RooArgSet& splitLeafList(); { return _splitNodeList; }. » Last changed: Tue Jun 30 14:35:44 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:20637,Integrability,depend,dependents,20637,"t::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_compSplitCatSetList of owned composite splitting categories; list<RooSuperCategory*>_fitCatListThe supercategories that we built; RooArgSet_protoPdfSetSet of prototype PDFS; TList_retiredCustomizerListRetired customizer from previous builds (own their PDF branch nodes); list<RooSimultaneous*>_simPdfListThe simpdfs that we built; RooArgSet_splitNodeListList of owned split nodes; RooArgSet_splitNodeListOwnedList of all split nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooArgSet* createProtoBuildConfig(); Make RooArgSet of configuration objects. void addSpecializations(const RooArgSet& specSet). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); Initialize needed components. ~RooSimPdfBuilder(). RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE). return buildPdf(buildConfig,*dataSet->get(),&auxSplitCats,verbose). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE). const RooArgSet& splitLeafList(); { return _splitNodeList; }. » Last changed: Tue Jun 30 14:35:44 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:20851,Integrability,depend,dependents,20851,"t::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_compSplitCatSetList of owned composite splitting categories; list<RooSuperCategory*>_fitCatListThe supercategories that we built; RooArgSet_protoPdfSetSet of prototype PDFS; TList_retiredCustomizerListRetired customizer from previous builds (own their PDF branch nodes); list<RooSimultaneous*>_simPdfListThe simpdfs that we built; RooArgSet_splitNodeListList of owned split nodes; RooArgSet_splitNodeListOwnedList of all split nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooArgSet* createProtoBuildConfig(); Make RooArgSet of configuration objects. void addSpecializations(const RooArgSet& specSet). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); Initialize needed components. ~RooSimPdfBuilder(). RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE). return buildPdf(buildConfig,*dataSet->get(),&auxSplitCats,verbose). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE). const RooArgSet& splitLeafList(); { return _splitNodeList; }. » Last changed: Tue Jun 30 14:35:44 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:1166,Modifiability,variab,variables,1166," Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimPdfBuilder. class RooSimPdfBuilder: public TObject. This tool has now been superceded by RooSimWSTool. RooSimPdfBuilder is a powerful tool to build RooSimultaneous; PDFs that are defined in terms component PDFs that are identical in; structure, but have different parameters. ; ; Example. The following example demonstrates the essence of RooSimPdfBuilder:; Given a dataset D with a RooRealVar X and a RooCategory C that has; state C1 and C2. ; ; We want to fit the distribution of X with a Gaussian+ArgusBG PDF, ; We want to fit the data subsets D(C==C1) and D(C==C2) separately and simultaneously. ; The PDFs to fit data subsets D_C1 and D_C2 are identical except for ; ; the kappa parameter of the ArgusBG PDF and ; the sigma parameter of the gaussian PDF; ; where each PDF will have its own copy of the parameter; . Coding this example directly with RooFit classes gives; (we assume dataset D and variables C and X have been declared previously); . RooRealVar m(""m"",""mean of gaussian"",-10,10) ;; RooRealVar s_C1(""s_C1"",""sigma of gaussian C1"",0,20) ;; RooRealVar s_C2(""s_C2"",""sigma of gaussian C2"",0,20) ;; RooGaussian gauss_C1(""gauss_C1"",""gaussian C1"",X,m,s_C1) ;; RooGaussian gauss_C2(""gauss_C2"",""gaussian C2"",X,m,s_C2) ;; RooRealVar k_C1(""k_C1"",""ArgusBG kappa parameter C1"",-50,0) ;; RooRealVar k_C2(""k_C2"",""ArgusBG kappa parameter C2"",-50,0) ;; RooRealVar xm(""xm"",""ArgusBG cutoff point"",5.29) ;; RooArgusBG argus_C1(""argus_C1"",""argus background C1"",X,k_C1,xm) ;; RooArgusBG argus_C2(""argus_C2"",""argus background C2"",X,k_C2,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf_C1(""pdf_C1"",""gauss+argus_C1"",RooArgList(gauss_C1,argus_C1),gfrac) ;; RooAddPdf pdf_C2(""pdf_C2"",""gauss+argus_C2"",RooArgList(gauss_C2,argus_C2),gfrac) ;; RooSimultaneous simPdf(""simPdf"",""simPdf"",C) ; ; simPdf.addPdf(pdf_C1,""C1"") ;; simPdf.addPdf(pdf_C2,""C2"") ;; . Coding this exa",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:2656,Modifiability,config,config,2656,",-50,0) ;; RooRealVar xm(""xm"",""ArgusBG cutoff point"",5.29) ;; RooArgusBG argus_C1(""argus_C1"",""argus background C1"",X,k_C1,xm) ;; RooArgusBG argus_C2(""argus_C2"",""argus background C2"",X,k_C2,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf_C1(""pdf_C1"",""gauss+argus_C1"",RooArgList(gauss_C1,argus_C1),gfrac) ;; RooAddPdf pdf_C2(""pdf_C2"",""gauss+argus_C2"",RooArgList(gauss_C2,argus_C2),gfrac) ;; RooSimultaneous simPdf(""simPdf"",""simPdf"",C) ; ; simPdf.addPdf(pdf_C1,""C1"") ;; simPdf.addPdf(pdf_C2,""C2"") ;; . Coding this example with RooSimPdfBuilder gives; . RooRealVar m(""m"",""mean of gaussian"",-10,10) ;; RooRealVar s(""s"",""sigma of gaussian"",0,20) ;; RooGaussian gauss(""gauss"",""gaussian"",X,m,s) ;; RooRealVar k(""k"",""ArgusBG kappa parameter"",-50,0) ;; RooRealVar xm(""xm"",""ArgusBG cutoff point"",5.29) ;; RooArgusBG argus(""argus"",""argus background"",X,k,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf(""pdf"",""gauss+argus"",RooArgList(gauss,argus),gfrac) ;; RooSimPdfBuilder builder(pdf) ;; RooArgSet* config = builder.createProtoBuildConfig() ;; (*config)[""physModels""] = ""pdf"" ; // Name of the PDF we are going to work with; (*config)[""splitCats""] = ""C"" ; // Category used to differentiate sub-datasets; (*config)[""pdf""] = ""C : k,s"" ; // Prescription to taylor PDF parameters k and s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:2703,Modifiability,config,config,2703,""",0.,1.) ;; RooAddPdf pdf_C1(""pdf_C1"",""gauss+argus_C1"",RooArgList(gauss_C1,argus_C1),gfrac) ;; RooAddPdf pdf_C2(""pdf_C2"",""gauss+argus_C2"",RooArgList(gauss_C2,argus_C2),gfrac) ;; RooSimultaneous simPdf(""simPdf"",""simPdf"",C) ; ; simPdf.addPdf(pdf_C1,""C1"") ;; simPdf.addPdf(pdf_C2,""C2"") ;; . Coding this example with RooSimPdfBuilder gives; . RooRealVar m(""m"",""mean of gaussian"",-10,10) ;; RooRealVar s(""s"",""sigma of gaussian"",0,20) ;; RooGaussian gauss(""gauss"",""gaussian"",X,m,s) ;; RooRealVar k(""k"",""ArgusBG kappa parameter"",-50,0) ;; RooRealVar xm(""xm"",""ArgusBG cutoff point"",5.29) ;; RooArgusBG argus(""argus"",""argus background"",X,k,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf(""pdf"",""gauss+argus"",RooArgList(gauss,argus),gfrac) ;; RooSimPdfBuilder builder(pdf) ;; RooArgSet* config = builder.createProtoBuildConfig() ;; (*config)[""physModels""] = ""pdf"" ; // Name of the PDF we are going to work with; (*config)[""splitCats""] = ""C"" ; // Category used to differentiate sub-datasets; (*config)[""pdf""] = ""C : k,s"" ; // Prescription to taylor PDF parameters k and s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Al",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:2783,Modifiability,config,config,2783,""",0.,1.) ;; RooAddPdf pdf_C1(""pdf_C1"",""gauss+argus_C1"",RooArgList(gauss_C1,argus_C1),gfrac) ;; RooAddPdf pdf_C2(""pdf_C2"",""gauss+argus_C2"",RooArgList(gauss_C2,argus_C2),gfrac) ;; RooSimultaneous simPdf(""simPdf"",""simPdf"",C) ; ; simPdf.addPdf(pdf_C1,""C1"") ;; simPdf.addPdf(pdf_C2,""C2"") ;; . Coding this example with RooSimPdfBuilder gives; . RooRealVar m(""m"",""mean of gaussian"",-10,10) ;; RooRealVar s(""s"",""sigma of gaussian"",0,20) ;; RooGaussian gauss(""gauss"",""gaussian"",X,m,s) ;; RooRealVar k(""k"",""ArgusBG kappa parameter"",-50,0) ;; RooRealVar xm(""xm"",""ArgusBG cutoff point"",5.29) ;; RooArgusBG argus(""argus"",""argus background"",X,k,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf(""pdf"",""gauss+argus"",RooArgList(gauss,argus),gfrac) ;; RooSimPdfBuilder builder(pdf) ;; RooArgSet* config = builder.createProtoBuildConfig() ;; (*config)[""physModels""] = ""pdf"" ; // Name of the PDF we are going to work with; (*config)[""splitCats""] = ""C"" ; // Category used to differentiate sub-datasets; (*config)[""pdf""] = ""C : k,s"" ; // Prescription to taylor PDF parameters k and s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Al",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:2862,Modifiability,config,config,2862,""",0.,1.) ;; RooAddPdf pdf_C1(""pdf_C1"",""gauss+argus_C1"",RooArgList(gauss_C1,argus_C1),gfrac) ;; RooAddPdf pdf_C2(""pdf_C2"",""gauss+argus_C2"",RooArgList(gauss_C2,argus_C2),gfrac) ;; RooSimultaneous simPdf(""simPdf"",""simPdf"",C) ; ; simPdf.addPdf(pdf_C1,""C1"") ;; simPdf.addPdf(pdf_C2,""C2"") ;; . Coding this example with RooSimPdfBuilder gives; . RooRealVar m(""m"",""mean of gaussian"",-10,10) ;; RooRealVar s(""s"",""sigma of gaussian"",0,20) ;; RooGaussian gauss(""gauss"",""gaussian"",X,m,s) ;; RooRealVar k(""k"",""ArgusBG kappa parameter"",-50,0) ;; RooRealVar xm(""xm"",""ArgusBG cutoff point"",5.29) ;; RooArgusBG argus(""argus"",""argus background"",X,k,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf(""pdf"",""gauss+argus"",RooArgList(gauss,argus),gfrac) ;; RooSimPdfBuilder builder(pdf) ;; RooArgSet* config = builder.createProtoBuildConfig() ;; (*config)[""physModels""] = ""pdf"" ; // Name of the PDF we are going to work with; (*config)[""splitCats""] = ""C"" ; // Category used to differentiate sub-datasets; (*config)[""pdf""] = ""C : k,s"" ; // Prescription to taylor PDF parameters k and s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Al",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:3034,Modifiability,config,config,3034,"neous simPdf(""simPdf"",""simPdf"",C) ; ; simPdf.addPdf(pdf_C1,""C1"") ;; simPdf.addPdf(pdf_C2,""C2"") ;; . Coding this example with RooSimPdfBuilder gives; . RooRealVar m(""m"",""mean of gaussian"",-10,10) ;; RooRealVar s(""s"",""sigma of gaussian"",0,20) ;; RooGaussian gauss(""gauss"",""gaussian"",X,m,s) ;; RooRealVar k(""k"",""ArgusBG kappa parameter"",-50,0) ;; RooRealVar xm(""xm"",""ArgusBG cutoff point"",5.29) ;; RooArgusBG argus(""argus"",""argus background"",X,k,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf(""pdf"",""gauss+argus"",RooArgList(gauss,argus),gfrac) ;; RooSimPdfBuilder builder(pdf) ;; RooArgSet* config = builder.createProtoBuildConfig() ;; (*config)[""physModels""] = ""pdf"" ; // Name of the PDF we are going to work with; (*config)[""splitCats""] = ""C"" ; // Category used to differentiate sub-datasets; (*config)[""pdf""] = ""C : k,s"" ; // Prescription to taylor PDF parameters k and s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As th",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:3504,Modifiability,config,configuration,3504,"argus"",""argus background"",X,k,xm) ;; RooRealVar gfrac(""gfrac"",""fraction of gaussian"",0.,1.) ;; RooAddPdf pdf(""pdf"",""gauss+argus"",RooArgList(gauss,argus),gfrac) ;; RooSimPdfBuilder builder(pdf) ;; RooArgSet* config = builder.createProtoBuildConfig() ;; (*config)[""physModels""] = ""pdf"" ; // Name of the PDF we are going to work with; (*config)[""splitCats""] = ""C"" ; // Category used to differentiate sub-datasets; (*config)[""pdf""] = ""C : k,s"" ; // Prescription to taylor PDF parameters k and s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:4180,Modifiability,config,configuration,4180,"l; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; differentiate the various subsets of the 'master' input data set. You can enter; a single category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; sup",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:4241,Modifiability,config,configuration,4241,"prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; differentiate the various subsets of the 'master' input data set. You can enter; a single category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCa",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:4956,Modifiability,config,configuration,4956,"er to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; differentiate the various subsets of the 'master' input data set. You can enter; a single category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCat} : {parameter} [,{parameter},....]; . Conversely, each parameter can only have one splitting prescription, but it may be split; by multiple categories, e.g.; . pdfName = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimP",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:5675,Modifiability,config,configuration,5675," category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCat} : {parameter} [,{parameter},....]; . Conversely, each parameter can only have one splitting prescription, but it may be split; by multiple categories, e.g.; . pdfName = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting;",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:5895,Modifiability,config,configuration,5895,"pear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essence of each build configuration; can be supplied in a third line carrying the name of the pdf listed in physModels. pdfName = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCat} : {parameter} [,{parameter},....]; . Conversely, each parameter can only have one splitting prescription, but it may be split; by multiple categories, e.g.; . pdfName = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII fi",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:5937,Modifiability,config,configuration,5937," = {splitCat} : {parameter} [,{parameter},....]; ; ; Each pdf can have only one line with splitting rules, but multiple rules can be; supplied in each line, e.g.; . pdfName = {splitCat} : {parameter} [,{parameter},....] ; {splitCat} : {parameter} [,{parameter},....]; . Conversely, each parameter can only have one splitting prescription, but it may be split; by multiple categories, e.g.; . pdfName = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over mult",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:6374,Modifiability,config,config,6374,"cription, but it may be split; by multiple categories, e.g.; . pdfName = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:6520,Modifiability,config,config,6520,"y ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don'",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:6798,Modifiability,config,configuration,6798,"Block : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdf",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:7087,Modifiability,config,config,7087,"Models,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdfBuilder will look as follows:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB,...)) ;; . The physModels line is now expanded to carry the pdf->state mapping information; that the prototype RooSimultaneous would have. I.e.; . physModels = mode : pdfA=modeA pdfB=mo",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:7132,Modifiability,config,config,7132,"h; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdfBuilder will look as follows:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB,...)) ;; . The physModels line is now expanded to carry the pdf->state mapping information; that the prototype RooSimultaneous would have. I.e.; . physModels = mode : pdfA=modeA pdfB=modeB; . is equivalent to a prototype RooSimu",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:7154,Modifiability,config,config,7154,"h; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdfBuilder will look as follows:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB,...)) ;; . The physModels line is now expanded to carry the pdf->state mapping information; that the prototype RooSimultaneous would have. I.e.; . physModels = mode : pdfA=modeA pdfB=modeB; . is equivalent to a prototype RooSimu",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:7174,Modifiability,config,config,7174,"s constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdfBuilder will look as follows:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB,...)) ;; . The physModels line is now expanded to carry the pdf->state mapping information; that the prototype RooSimultaneous would have. I.e.; . physModels = mode : pdfA=modeA pdfB=modeB; . is equivalent to a prototype RooSimultaneous constructed as; . RooSimultan",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:7691,Modifiability,config,configuration,7691," literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdfBuilder will look as follows:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB,...)) ;; . The physModels line is now expanded to carry the pdf->state mapping information; that the prototype RooSimultaneous would have. I.e.; . physModels = mode : pdfA=modeA pdfB=modeB; . is equivalent to a prototype RooSimultaneous constructed as; . RooSimultanous simPdf(""simPdf"",""simPdf"",mode);; simPdf.addPdf(pdfA,""modeA"") ;; simPdf.addPdf(pdfB,""modeB"") ;; . The rest of the builder configuration works the same, except that; each prototype PDF now has its own set of splitting rules, e.g.; . physModels = mode : pdfA=modeA pdfB=modeB; splitCats = tagCat; pdfA = tagCat : bogusPar; pdfB = tagCat : fudgeFactor ; . Please note that ; ; The master index category ('mode' above) doesn't have to be listed in ; splitCats, this is implicit.; The number of",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:8296,Modifiability,config,configuration,8296,"DFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where the input prototype PDF would otherwise be ; a RooSimultaneous PDF by itself. In such cases we don't feed a single; RooSimultaneous PDF into RooSimPdfBuilder, instead we feed it its ingredients and; add a prescription to the builder configuration that corresponds to the ; PDF-category state mapping of the prototype RooSimultaneous.; . The constructor of the RooSimPdfBuilder will look as follows:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB,...)) ;; . The physModels line is now expanded to carry the pdf->state mapping information; that the prototype RooSimultaneous would have. I.e.; . physModels = mode : pdfA=modeA pdfB=modeB; . is equivalent to a prototype RooSimultaneous constructed as; . RooSimultanous simPdf(""simPdf"",""simPdf"",mode);; simPdf.addPdf(pdfA,""modeA"") ;; simPdf.addPdf(pdfB,""modeB"") ;; . The rest of the builder configuration works the same, except that; each prototype PDF now has its own set of splitting rules, e.g.; . physModels = mode : pdfA=modeA pdfB=modeB; splitCats = tagCat; pdfA = tagCat : bogusPar; pdfB = tagCat : fudgeFactor ; . Please note that ; ; The master index category ('mode' above) doesn't have to be listed in ; splitCats, this is implicit.; The number of splitting prescriptions goes by the; number of prototype PDFs and not by the number of states of the; master index category (mode in the above and below example). ; ; In the following case:. physModels = mode : pdfA=modeA pdfB=modeB pdfA=modeC pdfB=modeD; . there are still only 2 sets of splitting rules: one for pdfA and one; for pdfB. However, you can differentiate between modeA and modeC in ; the above example. The technique is to use mode as splitting category, e.g.; . physModels = mode : pdfA=modeA pdfB=modeB pdfA=modeC pdfB=modeD; splitCats = tagCat; pdfA = tagCat : bogusPar ; mode : funnyPar; pdfB = mode : kludgeFactor; . will result in an individual set of ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:11436,Modifiability,config,configuration,11436,". It is possible to make non-trivial parameter splits with RooSimPdfBuilder.; Trivial splits are considered simple splits in one (fundamental) category; in the dataset or a split in a RooSuperCategory 'product' of multiple; fundamental categories in the dataset. Non-trivial splits can be performed; using an intermediate 'category function' (RooMappedCategory,; RooGenericCategory,RooThresholdCategory etc), i.e. any RooAbsCategory; derived objects that calculates its output as function of one or more; input RooRealVars and/or RooCategories.; . Such 'function categories' objects must be constructed by the user prior; to building the PDF. In the RooSimPdfBuilder::buildPdf() function these; objects can be passed in an optional RooArgSet called 'auxiliary categories':; . const RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, ; const RooArgSet& auxSplitCats, Bool_t verbose=kFALSE) {; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; . Objects passed in this argset can subsequently be used in the build configuration, e.g.; . RooMappedCategory tagMap(""tagMap"",""Mapped tagging category"",tagCat,""CutBased"") ;; tagMap.map(""Lep"",""CutBased"") ;; tagMap.map(""Kao"",""CutBased"") ;; tagMap.map(""NT*"",""NeuralNet"") ; ; ...; builder.buildPdf(config,D,tagMap) ;; ^^^^^^. physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes ; tagMap : fudgeFactor ; ^^^^^^; . In the above example signalRes will be split in signalRes_Kao,signalRes_Lep,; signalRes_NT1,signalRes_NT2, while fudgeFactor will be split in fudgeFactor_CutBased; and fudgeFactor_NeuralNet.; . Category functions passed in the auxSplitCats RooArgSet can be used regularly; in the splitting configuration. They should not be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:11661,Modifiability,config,config,11661,"t. Non-trivial splits can be performed; using an intermediate 'category function' (RooMappedCategory,; RooGenericCategory,RooThresholdCategory etc), i.e. any RooAbsCategory; derived objects that calculates its output as function of one or more; input RooRealVars and/or RooCategories.; . Such 'function categories' objects must be constructed by the user prior; to building the PDF. In the RooSimPdfBuilder::buildPdf() function these; objects can be passed in an optional RooArgSet called 'auxiliary categories':; . const RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, ; const RooArgSet& auxSplitCats, Bool_t verbose=kFALSE) {; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; . Objects passed in this argset can subsequently be used in the build configuration, e.g.; . RooMappedCategory tagMap(""tagMap"",""Mapped tagging category"",tagCat,""CutBased"") ;; tagMap.map(""Lep"",""CutBased"") ;; tagMap.map(""Kao"",""CutBased"") ;; tagMap.map(""NT*"",""NeuralNet"") ; ; ...; builder.buildPdf(config,D,tagMap) ;; ^^^^^^. physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes ; tagMap : fudgeFactor ; ^^^^^^; . In the above example signalRes will be split in signalRes_Kao,signalRes_Lep,; signalRes_NT1,signalRes_NT2, while fudgeFactor will be split in fudgeFactor_CutBased; and fudgeFactor_NeuralNet.; . Category functions passed in the auxSplitCats RooArgSet can be used regularly; in the splitting configuration. They should not be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (no",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:12086,Modifiability,config,configuration,12086,"the PDF. In the RooSimPdfBuilder::buildPdf() function these; objects can be passed in an optional RooArgSet called 'auxiliary categories':; . const RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, ; const RooArgSet& auxSplitCats, Bool_t verbose=kFALSE) {; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; . Objects passed in this argset can subsequently be used in the build configuration, e.g.; . RooMappedCategory tagMap(""tagMap"",""Mapped tagging category"",tagCat,""CutBased"") ;; tagMap.map(""Lep"",""CutBased"") ;; tagMap.map(""Kao"",""CutBased"") ;; tagMap.map(""NT*"",""NeuralNet"") ; ; ...; builder.buildPdf(config,D,tagMap) ;; ^^^^^^. physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes ; tagMap : fudgeFactor ; ^^^^^^; . In the above example signalRes will be split in signalRes_Kao,signalRes_Lep,; signalRes_NT1,signalRes_NT2, while fudgeFactor will be split in fudgeFactor_CutBased; and fudgeFactor_NeuralNet.; . Category functions passed in the auxSplitCats RooArgSet can be used regularly; in the splitting configuration. They should not be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = """,MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:12906,Modifiability,config,configA,12906,"NT1,signalRes_NT2, while fudgeFactor will be split in fudgeFactor_CutBased; and fudgeFactor_NeuralNet.; . Category functions passed in the auxSplitCats RooArgSet can be used regularly; in the splitting configuration. They should not be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(con",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:12954,Modifiability,config,configA,12954,"ns passed in the auxSplitCats RooArgSet can be used regularly; in the splitting configuration. They should not be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); RooSi",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:12992,Modifiability,config,configA,12992,"ns passed in the auxSplitCats RooArgSet can be used regularly; in the splitting configuration. They should not be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); RooSi",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:13026,Modifiability,config,configA,13026,"ns passed in the auxSplitCats RooArgSet can be used regularly; in the splitting configuration. They should not be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); RooSi",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:13098,Modifiability,config,configA,13098,"t be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, const RooArgSet& auxSplitCats, B",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:13124,Modifiability,config,configB,13124,"t be listed in splitCats,; but must be able to be expressed completely in terms of the splitCats that ; are listed.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, const RooArgSet& auxSplitCats, B",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:13172,Modifiability,config,configA,13172,"isted.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:13210,Modifiability,config,configA,13210,"isted.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:13244,Modifiability,config,configA,13244,"isted.; ; Multiple connected builds. Sometimes you want to build multiple PDFs for independent consecutive fits ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:13316,Modifiability,config,configB,13316,"s ; that share some of their parameters. For example, we have two prototype PDFs ; pdfA(x;p,q) and pdfB(x;p,r) that have a common parameter p. ; We want to build a RooSimultaneous for both pdfA and B, ; which involves a split of parameter p and we would like to build the; simultaneous pdfs simA and simB such that still share their (now split) parameters; p_XXX. This is accomplished by letting a single instance of RooSimPdfBuilder handle; the builds of both pdfA and pdfB, as illustrated in this example:; . RooSimPdfBuilder builder(RooArgSet(pdfA,pdfB)) ;; RooArgSet* configA = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfA"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simA = builder.buildPdf(*configA,&D) ;; RooArgSet* configB = builder.createProtoBuildConfig() ;; (*configA)[""physModels""] = ""pdfB"" ; ; (*configA)[""splitCats""] = ""C"" ; ; (*configA)[""pdf""] = ""C : p"" ; ; RooSimultaneous* simB = builder.buildPdf(*configB,&D) ;; ; Ownership of constructed PDFs. The RooSimPdfBuilder instance owns all the objects it creates, including the top-level; RooSimultaneous returned by buildPdf(). Therefore the builder instance should ; exist as long as the constructed PDFs needs to exist.; . Function Members (Methods); public:. virtual~RooSimPdfBuilder(); voidTObject::AbstractMethod(const char* method) const; voidaddSpecializations(const RooArgSet& specSet); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig,",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:20244,Modifiability,config,configuration,20244,"t::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_compSplitCatSetList of owned composite splitting categories; list<RooSuperCategory*>_fitCatListThe supercategories that we built; RooArgSet_protoPdfSetSet of prototype PDFS; TList_retiredCustomizerListRetired customizer from previous builds (own their PDF branch nodes); list<RooSimultaneous*>_simPdfListThe simpdfs that we built; RooArgSet_splitNodeListList of owned split nodes; RooArgSet_splitNodeListOwnedList of all split nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooArgSet* createProtoBuildConfig(); Make RooArgSet of configuration objects. void addSpecializations(const RooArgSet& specSet). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); Initialize needed components. ~RooSimPdfBuilder(). RooSimPdfBuilder(const RooArgSet& pdfProtoList). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE). return buildPdf(buildConfig,*dataSet->get(),&auxSplitCats,verbose). RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooArgSet& dependents, const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE). const RooArgSet& splitLeafList(); { return _splitNodeList; }. » Last changed: Tue Jun 30 14:35:44 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:10699,Performance,perform,performed,10699,"plitCat that; will be considered in the build. This limitation is requested in the ; each build as follows:; . splitCats = tagCat(Lep,Kao) RunBlock(Run1); . In this example the splitting of tagCat is limited to states Lep,Kao; and the splitting of runBlock is limited to Run1. The splits apply; globally to each build, i.e. every parameter split requested in this; build will be limited according to these specifications. ; ; ; NB: Partial builds have no pdf associated with the unbuilt states of the ; limited splits. Running such a pdf on a dataset that contains data with ; unbuilt states will result in this data being ignored completely.; ; Non-trivial splits. It is possible to make non-trivial parameter splits with RooSimPdfBuilder.; Trivial splits are considered simple splits in one (fundamental) category; in the dataset or a split in a RooSuperCategory 'product' of multiple; fundamental categories in the dataset. Non-trivial splits can be performed; using an intermediate 'category function' (RooMappedCategory,; RooGenericCategory,RooThresholdCategory etc), i.e. any RooAbsCategory; derived objects that calculates its output as function of one or more; input RooRealVars and/or RooCategories.; . Such 'function categories' objects must be constructed by the user prior; to building the PDF. In the RooSimPdfBuilder::buildPdf() function these; objects can be passed in an optional RooArgSet called 'auxiliary categories':; . const RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, ; const RooArgSet& auxSplitCats, Bool_t verbose=kFALSE) {; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; . Objects passed in this argset can subsequently be used in the build configuration, e.g.; . RooMappedCategory tagMap(""tagMap"",""Mapped tagging category"",tagCat,""CutBased"") ;; tagMap.map(""Lep"",""CutBased"") ;; tagMap.map(""Kao"",""CutBased"") ;; tagMap.map(""NT*"",""NeuralNet"") ; ; ...; builder.buildPdf(config,D,tagMap) ;; ^^^^^^. physModels = pdf; splitCats = tagCat runBlock; pdf = tagCa",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:3869,Usability,simpl,simple,3869,"s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; differentiate the various subsets of the 'master' input data set. You can enter; a single category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essen",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:6444,Usability,simpl,simply,6444," = {splitCat1},{splitCat2} : {parameter}; . instructs RooSimPdfBuilder to build a RooSuperCategory ; of {splitCat1} and {splitCat2}; and split {parameter} with that RooSuperCategory. Here is an example of a builder configuration that uses several of the options discussed; above:; . physModels = pdf; splitCats = tagCat runBlock; pdf = tagCat : signalRes,bkgRes ; runBlock : fudgeFactor ; tagCat,runBlock : kludgeParam; ; How to enter configuration data. The prototype builder configuration returned by ; RooSimPdfBuilder::createProtoBuildConfig() is a pointer to a RooArgSet filled with; initially blank RooStringVars named physModels,splitCats and one additional for each; PDF supplied to the RooSimPdfBuilders constructor (with the same name); . In macro code, the easiest way to assign new values to these RooStringVars; is to use RooArgSets array operator and the RooStringVars assignment operator, e.g.; . (*config)[""physModels""] = ""Blah"" ;; . To enter multiple splitting rules simply separate consecutive rules by whitespace; (not newlines), e.g. ; . (*config)[""physModels""] = ""Blah "" // << note trailing space here; ""Blah 2"" ;; . In this example, the C++ compiler will concatenate the two string literals (without inserting; any whitespace), so the extra space after 'Blah' is important here.; ; ; Alternatively, you can read the configuration from an ASCII file, as you can; for any RooArgSet using RooArgSet::readFromFile(). In that case the ASCII file; can follow the syntax of the examples above and the '\\' line continuation ; sequence can be used to fold a long splitting rule over multiple lines.; . RooArgSet* config = builder.createProtoBuildConfig() ;; config->readFromFile(""config.txt"") ;; --- config.txt ---------------- ; physModels = pdf; splitCats = tagCat; pdf = tagCat : bogusPar; -------------------------------; ; Working with multiple prototype PDFs. It is also possible to build a RooSimultaneous PDF from multiple PDF prototypes.; This is appropriate for cases where th",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimPdfBuilder.html:10518,Usability,simpl,simple,10518,"y (mode) only the ; applicable states are built (A,C for pdfA, B,D for pdfB); ; Advanced options; Partial splits. You can request to limit the list of states of each splitCat that; will be considered in the build. This limitation is requested in the ; each build as follows:; . splitCats = tagCat(Lep,Kao) RunBlock(Run1); . In this example the splitting of tagCat is limited to states Lep,Kao; and the splitting of runBlock is limited to Run1. The splits apply; globally to each build, i.e. every parameter split requested in this; build will be limited according to these specifications. ; ; ; NB: Partial builds have no pdf associated with the unbuilt states of the ; limited splits. Running such a pdf on a dataset that contains data with ; unbuilt states will result in this data being ignored completely.; ; Non-trivial splits. It is possible to make non-trivial parameter splits with RooSimPdfBuilder.; Trivial splits are considered simple splits in one (fundamental) category; in the dataset or a split in a RooSuperCategory 'product' of multiple; fundamental categories in the dataset. Non-trivial splits can be performed; using an intermediate 'category function' (RooMappedCategory,; RooGenericCategory,RooThresholdCategory etc), i.e. any RooAbsCategory; derived objects that calculates its output as function of one or more; input RooRealVars and/or RooCategories.; . Such 'function categories' objects must be constructed by the user prior; to building the PDF. In the RooSimPdfBuilder::buildPdf() function these; objects can be passed in an optional RooArgSet called 'auxiliary categories':; . const RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, ; const RooArgSet& auxSplitCats, Bool_t verbose=kFALSE) {; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; . Objects passed in this argset can subsequently be used in the build configuration, e.g.; . RooMappedCategory tagMap(""tagMap"",""Mapped tagging category"",tagCat,""CutBased"") ;; tagMap.map(""Lep"",""CutBased"") ;; tagMap",MatchSource.WIKI,root/html602/RooSimPdfBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimPdfBuilder.html
https://root.cern/root/html602/RooSimSplitGenContext.html:1771,Availability,error,error,1771,"b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsGenContext::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooAbsGenContext::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed",MatchSource.WIKI,root/html602/RooSimSplitGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html
https://root.cern/root/html602/RooSimSplitGenContext.html:1855,Availability,error,error,1855,"idTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsGenContext::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooAbsGenContext::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) co",MatchSource.WIKI,root/html602/RooSimSplitGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html
https://root.cern/root/html602/RooSimSplitGenContext.html:369,Energy Efficiency,efficient,efficient,369,". RooSimSplitGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimSplitGenContext. class RooSimSplitGenContext: public RooAbsGenContext. RooSimSplitGenContext is an efficient implementation of the generator context; specific for RooSimultaneous PDFs when generating more than one of the; component pdfs.; . Function Members (Methods); public:. virtual~RooSimSplitGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsGenContext::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooAbsGenContext::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html602/RooSimSplitGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html
https://root.cern/root/html602/RooSimSplitGenContext.html:11463,Integrability,interface,interface,11463,"ntext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimSplitGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE). void setExpectedData(Bool_t ); Forward to components. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); this method is empty because it is not used by this context. void generateEvent(RooArgSet& theEvent, Int_t remaining); this method is empty because it is not used in this type of context. void setProtoDataOrder(Int_t* lut); this method is empty because proto datasets are not supported by this context. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"). » Last changed: Tue Jun 30 14:35:45 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimSplitGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html
https://root.cern/root/html602/RooSimSplitGenContext.html:2263,Modifiability,extend,extendedMode,2263,"tyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; B",MatchSource.WIKI,root/html602/RooSimSplitGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html
https://root.cern/root/html602/RooSimSplitGenContext.html:8689,Modifiability,variab,variables,8689,StatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_allVarsPdfAll pdf variables; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThreshfraction thresholds; vector<int>_gcIndexIndex value corresponding to component; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; c,MatchSource.WIKI,root/html602/RooSimSplitGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html
https://root.cern/root/html602/RooSimSplitGenContext.html:8770,Modifiability,extend,extended,8770,StatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_allVarsPdfAll pdf variables; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThreshfraction thresholds; vector<int>_gcIndexIndex value corresponding to component; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; c,MatchSource.WIKI,root/html602/RooSimSplitGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html
https://root.cern/root/html602/RooSimSplitGenContext.html:10877,Modifiability,extend,extendedMode,10877,"t*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; generation of events to the appropriate component generator context. ~RooSimSplitGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach the index category clone to the given event buffer. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of generator context. RooDataSet* generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE). void setExpectedData(Bool_t ); Forward to components. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); this method is empty because it is not used by this context. void generateEvent(RooArgSet& theEvent, Int_t remaining); this method is empty because it is not used in this type of context. void setProtoDataOrder(Int_t* lut); this method is empty because proto datasets are not supported by this context. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"). » Last changed: Tue Jun 30 14:35:45 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root/html602/RooSimSplitGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html
https://root.cern/root/html602/RooSimSplitGenContext.html:9417,Performance,load,load,9417,"::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_allVarsPdfAll pdf variables; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThreshfraction thresholds; vector<int>_gcIndexIndex value corresponding to component; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimSplitGenContext(const RooSimultaneous& model, const RooArgSet& vars, Bool_t _verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """"); Constructor of specialized generator context for RooSimultaneous p.d.f.s. This; context creates a dedicated context for each component p.d.f.s and delegates; gener",MatchSource.WIKI,root/html602/RooSimSplitGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimSplitGenContext.html
https://root.cern/root/html602/RooSimultaneous.html:10472,Availability,error,error,10472,,MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:10556,Availability,error,error,10556,,MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:42582,Availability,error,errors,42582,"Transient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:42855,Deployability,integrat,integration,42855,"Transient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:45165,Deployability,configurat,configuration,45165,"ntegral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:45262,Deployability,integrat,integrator,45262,"ntegral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:45273,Deployability,configurat,configuration,45273,"ntegral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:48651,Deployability,integrat,integration,48651,"index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooC",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:48740,Deployability,integrat,integration,48740,"associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, ",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:48913,Deployability,integrat,integration,48913,"ill assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fractio",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:49170,Deployability,integrat,integration,49170,"he current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of ",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:7482,Integrability,depend,dependentVars,7482,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:8972,Integrability,depend,dependentOverlaps,8972,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:9064,Integrability,depend,dependentOverlaps,9064,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:9158,Integrability,depend,dependsOn,9158,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:9287,Integrability,depend,dependsOn,9287,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:9405,Integrability,depend,dependsOnValue,9405,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:9512,Integrability,depend,dependsOnValue,9512,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:21498,Integrability,message,message,21498,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::n",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:21649,Integrability,message,message,21649,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAb",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:42855,Integrability,integrat,integration,42855,"Transient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:45262,Integrability,integrat,integrator,45262,"ntegral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:48651,Integrability,integrat,integration,48651,"index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooC",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:48740,Integrability,integrat,integration,48740,"associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, ",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:48913,Integrability,integrat,integration,48913,"ill assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fractio",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:49170,Integrability,integrat,integration,49170,"he current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of ",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:50908,Integrability,interface,interface,50908," because a RooSimultaneous; works like a RooAddPdf when plotted. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized generator contenxt for simultaneous p.d.f.s. RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. inline RooSimultaneous(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooSimultaneous(*this,newname) ; }. Bool_t selfNormalized() const; { return kTRUE ; }. Double_t expectedEvents(const RooArgSet* nset) const. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const. const RooAbsCategoryLValue& indexCat() const; { return (RooAbsCategoryLValue&) _indexCat.arg() ; }. » Last changed: Tue Jun 30 14:35:56 2015 » Last generated: 2015-06-30 14:35; This page has b",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:766,Modifiability,extend,extended,766,". RooSimultaneous. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimultaneous. class RooSimultaneous: public RooAbsPdf. RooSimultaneous facilitates simultaneous fitting of multiple PDFs; to subsets of a given dataset.; ; The class takes an index category, which is interpreted as; the data subset indicator, and a list of PDFs, each associated; with a state of the index category. RooSimultaneous always returns; the value of the PDF that is associated with the current value; of the index category; ; Extended likelihood fitting is supported if all components support; extended likelihood mode. The expected number of events by a RooSimultaneous; is that of the component p.d.f. selected by the index category; . Function Members (Methods); public:. virtual~RooSimultaneous(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; Bool_taddPdf(const RooAbsPdf& pdf, const char* catLabel); voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:10850,Modifiability,extend,extendedTerm,10850,"_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual Double_tevaluate() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataHist*fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:14445,Modifiability,extend,extended,14445,"ec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables,",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:14599,Modifiability,extend,extended,14599,"ProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& anal",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:30102,Modifiability,config,config,30102,"ect::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFAL",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:30260,Modifiability,config,config,30260,":serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(con",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:34824,Modifiability,extend,extended,34824,"FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidinitialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(c",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:45165,Modifiability,config,configuration,45165,"ntegral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:45273,Modifiability,config,configuration,45273,"ntegral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:46965,Modifiability,variab,variables,46965,"object title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated with the given index category name. Bool_t addPdf(const RooAbsPdf& pdf, const char* catLabel); Associate given PDF with index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with t",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:47966,Modifiability,variab,variables,47966,"e index category (function). RooSimultaneous(const char* name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated with the given index category name. Bool_t addPdf(const RooAbsPdf& pdf, const char* catLabel); Associate given PDF with index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooL",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:48035,Modifiability,extend,extendMode,48035,"name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated with the given index category name. Bool_t addPdf(const RooAbsPdf& pdf, const char* catLabel); Associate given PDF with index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implemen",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:2492,Performance,cache,cacheUniqueSuffix,2492,"egateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:11556,Performance,cache,cacheList,11556," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataHist*fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:11644,Performance,cache,cacheList,11644,"e_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataHist*fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:23542,Performance,optimiz,optimizeCacheMode,23542,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSimultaneous&operator=(const RooSimultaneous&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:23614,Performance,optimiz,optimizeCacheMode,23614,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSimultaneous&operator=(const RooSimultaneous&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:28305,Performance,cache,cache,28305,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); RooSimultaneous(); RooSimultaneous(const RooSimultaneous& other, const char* name = 0); RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); RooSimultaneous(const char* name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat); RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsA",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:30000,Performance,cache,cache,30000,"ual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:32629,Performance,cache,cache,32629,"r* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:36545,Performance,optimiz,optimizeDirtyHook,36545,"ampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidinitialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:41665,Performance,cache,cache,41665,,MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:41748,Performance,cache,cache,41748,,MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:41946,Performance,cache,caches,41946,,MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:42478,Performance,cache,cache,42478,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node;",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:42757,Performance,cache,cache,42757,"Transient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:43211,Performance,cache,cache,43211,"Transient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:43820,Performance,cache,cache,43820,,MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:44733,Performance,cache,cache,44733,"ormalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs ",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:45521,Performance,cache,cache,45521,"ntegral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:46789,Safety,avoid,avoid,46789,"input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated with the given index category name. Bool_t addPdf(const RooAbsPdf& pdf, const char* catLabel); Associate given PDF with index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associated; with ev",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:49198,Safety,abort,abort,49198,"he current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of ",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:12976,Security,hash,hash,12976,"Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& ",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:13127,Security,hash,hash,13127,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:41842,Security,validat,validate,41842,,MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:42678,Security,access,access,42678,"Transient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:9031,Testability,test,testArg,9031,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:9125,Testability,test,testArg,9125,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:21473,Testability,log,logEvalError,21473,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notif",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:21572,Testability,log,logEvalError,21572,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRo",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:22683,Testability,test,testArg,22683," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSimultaneous&operator=(const RooSimultaneous&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:22778,Testability,test,testArg,22778,"Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSimultaneous&operator=(const RooSimultaneous&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnl",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:23758,Testability,test,testArg,23758,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSimultaneous&operator=(const RooSimultaneous&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:46487,Testability,assert,assert,46487,"o not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:47873,Testability,assert,assert,47873,"ate of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated with the given index category name. Bool_t addPdf(const RooAbsPdf& pdf, const char* catLabel); Associate given PDF with index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* ",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:49792,Testability,test,test,49792,".d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized generator contenxt for simultaneous p.d.f.s. RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:50070,Testability,test,test,50070,"taneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized generator contenxt for simultaneous p.d.f.s. RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. inline RooSimultaneous(); Constructors, assignment etc. { }. TObject* clone(con",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:3076,Usability,clear,clearEvalError,3076,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:3117,Usability,clear,clearEvalErrorLog,3117,"s(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:3153,Usability,clear,clearShapeDirty,3153,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:3193,Usability,clear,clearValueAndShapeDirty,3193,"(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimultaneous.html:3241,Usability,clear,clearValueDirty,3241,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooSimultaneous.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html
https://root.cern/root/html602/RooSimWSTool.html:5231,Availability,error,error,5231,"g::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:5315,Availability,error,error,5315,"rtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:2331,Deployability,configurat,configurations,2331,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:3004,Deployability,configurat,configuration,3004,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~RooSimWSTool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); RooSimultaneous*build(const char* simPdfName, const char* protoPdfName, const",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:628,Integrability,depend,depending,628,". RooSimWSTool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool. class RooSimWSTool: public TNamed, public RooPrintable. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;Sta",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:2331,Modifiability,config,configurations,2331,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:2600,Modifiability,config,configures,2600," specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Me",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:3004,Modifiability,config,configuration,3004,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~RooSimWSTool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); RooSimultaneous*build(const char* simPdfName, const char* protoPdfName, const",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:13461,Modifiability,config,configure,13461,"rg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; The following named arguments are supported. SplitParam(varname, catname) -- Split parameter(s) with given name(s) in category(s) with given names; SplitParam(var, cat) -- Split given parameter(s) in givem category(s); SplitParamConstrained(vname, cname, remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; SplitParamConstrained(var,cat,remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; Restrict(catName,stateNameList) -- Restrict build by only considered listed state names of category with given name. RooSimultaneous* build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; Use the provided BuildConfig or MultiBuildConfig object to configure the build. RooSimultaneous* executeBuild(const char* simPdfName, RooSimWSTool::ObjBuildConfig& obc, Bool_t verbose = kTRUE); Internal build driver from validation ObjBuildConfig. std::string makeSplitName(const RooArgSet& splitCatSet); Construct name of composite split. RooSimWSTool(RooWorkspace& ws); Constructors, assignment etc. ObjBuildConfig* validateConfig(RooSimWSTool::BuildConfig& bc). » Last changed: Tue Jun 30 14:35:47 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:1276,Performance,perform,performed,1276,"ublic TNamed, public RooPrintable. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:2973,Performance,perform,performed,2973,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~RooSimWSTool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); RooSimultaneous*build(const char* simPdfName, const char* protoPdfName, const",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:10015,Security,validat,validateConfig,10015,"tic voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooSimultaneous*executeBuild(const char* simPdfName, RooSimWSTool::ObjBuildConfig& obc, Bool_t verbose = kTRUE); stringmakeSplitName(const RooArgSet& splitCatSet); voidTObject::MakeZombie(); RooSimWSTool(const RooSimWSTool&); RooSimWSTool::ObjBuildConfig*validateConfig(RooSimWSTool::BuildConfig& bc). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsO",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:13623,Security,validat,validation,13623,"rg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; The following named arguments are supported. SplitParam(varname, catname) -- Split parameter(s) with given name(s) in category(s) with given names; SplitParam(var, cat) -- Split given parameter(s) in givem category(s); SplitParamConstrained(vname, cname, remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; SplitParamConstrained(var,cat,remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; Restrict(catName,stateNameList) -- Restrict build by only considered listed state names of category with given name. RooSimultaneous* build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; Use the provided BuildConfig or MultiBuildConfig object to configure the build. RooSimultaneous* executeBuild(const char* simPdfName, RooSimWSTool::ObjBuildConfig& obc, Bool_t verbose = kTRUE); Internal build driver from validation ObjBuildConfig. std::string makeSplitName(const RooArgSet& splitCatSet); Construct name of composite split. RooSimWSTool(RooWorkspace& ws); Constructors, assignment etc. ObjBuildConfig* validateConfig(RooSimWSTool::BuildConfig& bc). » Last changed: Tue Jun 30 14:35:47 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:13820,Security,validat,validateConfig,13820,"rg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; The following named arguments are supported. SplitParam(varname, catname) -- Split parameter(s) with given name(s) in category(s) with given names; SplitParam(var, cat) -- Split given parameter(s) in givem category(s); SplitParamConstrained(vname, cname, remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; SplitParamConstrained(var,cat,remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; Restrict(catName,stateNameList) -- Restrict build by only considered listed state names of category with given name. RooSimultaneous* build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; Use the provided BuildConfig or MultiBuildConfig object to configure the build. RooSimultaneous* executeBuild(const char* simPdfName, RooSimWSTool::ObjBuildConfig& obc, Bool_t verbose = kTRUE); Internal build driver from validation ObjBuildConfig. std::string makeSplitName(const RooArgSet& splitCatSet); Construct name of composite split. RooSimWSTool(RooWorkspace& ws); Constructors, assignment etc. ObjBuildConfig* validateConfig(RooSimWSTool::BuildConfig& bc). » Last changed: Tue Jun 30 14:35:47 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:499,Usability,simpl,simplest,499,". RooSimWSTool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool. class RooSimWSTool: public TNamed, public RooPrintable. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;Sta",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:1087,Usability,simpl,simple,1087,"scription; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool. class RooSimWSTool: public TNamed, public RooPrintable. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool.html:3476,Usability,simpl,simple,3476,"""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~RooSimWSTool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); RooSimultaneous*build(const char* simPdfName, const char* protoPdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; vi",MatchSource.WIKI,root/html602/RooSimWSTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:2334,Deployability,configurat,configurations,2334,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:3007,Deployability,configurat,configuration,3007,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~BuildConfig(); RooSimWSTool::BuildConfigBuildConfig(const RooArgSet& legacyBuildConfig); RooSimWSTool::BuildConfigBuildConfig(const RooSimWSTool::BuildConfig&); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5027,Deployability,configurat,configuration,5027,"const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::BuildConfig&operator=(const RooSimWSTool::BuildConfig&); voidrestrictBuild(const char* catName, const char* stateList); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooSimWSTool::BuildConfigBuildConfig(); voidinternalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr). Data Members; protected:. RooCmdArg_conflProtocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict b",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5383,Deployability,configurat,configuration,5383,"ig&operator=(const RooSimWSTool::BuildConfig&); voidrestrictBuild(const char* catName, const char* stateList); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooSimWSTool::BuildConfigBuildConfig(); voidinternalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr). Data Members; protected:. RooCmdArg_conflProtocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict build by only considering state names in stateList for split in category catName. BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr). BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooC",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5698,Deployability,configurat,configuration,5698,"List, RooSimWSTool::SplitRule& sr). Data Members; protected:. RooCmdArg_conflProtocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict build by only considering state names in stateList for split in category catName. BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr). BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). virtual ~BuildConfig(); {}. » Last changed: Tue Jun 30 14:35:49 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions reg",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5952,Deployability,configurat,configuration,5952,"tocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict build by only considering state names in stateList for split in category catName. BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr). BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). virtual ~BuildConfig(); {}. » Last changed: Tue Jun 30 14:35:49 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:631,Integrability,depend,depending,631,". RooSimWSTool::BuildConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::BuildConfig. class RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5509,Integrability,rout,routine,5509," protected:. RooSimWSTool::BuildConfigBuildConfig(); voidinternalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr). Data Members; protected:. RooCmdArg_conflProtocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict build by only considering state names in stateList for split in category catName. BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr). BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). virtual ~BuildConfig(); {}. » Last changed: Tue Jun 30 14:35:49 2015",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5833,Integrability,rout,routine,5833,"tocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict build by only considering state names in stateList for split in category catName. BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr). BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). virtual ~BuildConfig(); {}. » Last changed: Tue Jun 30 14:35:49 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:2334,Modifiability,config,configurations,2334,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:2603,Modifiability,config,configures,2603," specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Me",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:3007,Modifiability,config,configuration,3007,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~BuildConfig(); RooSimWSTool::BuildConfigBuildConfig(const RooArgSet& legacyBuildConfig); RooSimWSTool::BuildConfigBuildConfig(const RooSimWSTool::BuildConfig&); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5027,Modifiability,config,configuration,5027,"const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::BuildConfig&operator=(const RooSimWSTool::BuildConfig&); voidrestrictBuild(const char* catName, const char* stateList); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooSimWSTool::BuildConfigBuildConfig(); voidinternalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr). Data Members; protected:. RooCmdArg_conflProtocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict b",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5383,Modifiability,config,configuration,5383,"ig&operator=(const RooSimWSTool::BuildConfig&); voidrestrictBuild(const char* catName, const char* stateList); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooSimWSTool::BuildConfigBuildConfig(); voidinternalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr). Data Members; protected:. RooCmdArg_conflProtocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict build by only considering state names in stateList for split in category catName. BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr). BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooC",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5698,Modifiability,config,configuration,5698,"List, RooSimWSTool::SplitRule& sr). Data Members; protected:. RooCmdArg_conflProtocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict build by only considering state names in stateList for split in category catName. BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr). BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). virtual ~BuildConfig(); {}. » Last changed: Tue Jun 30 14:35:49 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions reg",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:5952,Modifiability,config,configuration,5952,"tocol; string_masterCatName; map<string,RooSimWSTool::SplitRule>_pdfmap; map<string,string>_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); Add prototype p.d.f pdfName to build configuration with associated split rules 'sr'. BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct build configuration from single prototype 'pdfName' and list of arguments; that can be passed to RooSimWSTool::build() method. This routine parses SplitParam(); SplitParamConstrained() and Restrict() arguments. BuildConfig(const RooArgSet& legacyBuildConfig); Constructor to make BuildConfig from legacy RooSimPdfBuilder configuration; Empty for now. void internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr); Internal routine to add prototype pdf 'pdfName' with list of associated master states 'miStateNameList; and split rules 'sr' to configuration. void restrictBuild(const char* catName, const char* stateList); Restrict build by only considering state names in stateList for split in category catName. BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr). BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). virtual ~BuildConfig(); {}. » Last changed: Tue Jun 30 14:35:49 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:1279,Performance,perform,performed,1279,". class RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:2976,Performance,perform,performed,2976,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~BuildConfig(); RooSimWSTool::BuildConfigBuildConfig(const RooArgSet& legacyBuildConfig); RooSimWSTool::BuildConfigBuildConfig(const RooSimWSTool::BuildConfig&); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:502,Usability,simpl,simplest,502,". RooSimWSTool::BuildConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::BuildConfig. class RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:1090,Usability,simpl,simple,1090,"; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::BuildConfig. class RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__BuildConfig.html:3479,Usability,simpl,simple,3479,"""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~BuildConfig(); RooSimWSTool::BuildConfigBuildConfig(const RooArgSet& legacyBuildConfig); RooSimWSTool::BuildConfigBuildConfig(const RooSimWSTool::BuildConfig&); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::BuildConfig&operator=(const RooSimWSTool::BuildConfig&); voidrestrictBuild(const char* catName, const char* stateList); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirt",MatchSource.WIKI,root/html602/RooSimWSTool__BuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__BuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:2383,Deployability,configurat,configurations,2383,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:3056,Deployability,configurat,configuration,3056,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~MultiBuildConfig(); voidaddPdf(const char* miStateList, const char* pdfName, RooSimWSTool::SplitRule& sr); voidaddPdf(const char* miStateList, const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:5937,Deployability,configurat,configuration,5937,"); RooSimWSTool::MultiBuildConfigMultiBuildConfig(const RooSimWSTool::MultiBuildConfig&); RooSimWSTool::MultiBuildConfig&operator=(const RooSimWSTool::MultiBuildConfig&); voidRooSimWSTool::BuildConfig::restrictBuild(const char* catName, const char* stateList); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooSimWSTool::BuildConfigRooSimWSTool::BuildConfig::BuildConfig(); voidRooSimWSTool::BuildConfig::internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr). Data Members; protected:. RooCmdArgRooSimWSTool::BuildConfig::_conflProtocol; stringRooSimWSTool::BuildConfig::_masterCatName; map<string,RooSimWSTool::SplitRule>RooSimWSTool::BuildConfig::_pdfmap; map<string,string>RooSimWSTool::BuildConfig::_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MultiBuildConfig(const char* masterIndexCat); Construct MultiBuildConfig for build configuration with multiple prototype p.d.f.s; masterIndexCat is the name of the master index category that decides which; prototype is used. void addPdf(const char* miStateList, const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Add protytpe p.d.f 'pdfName' to MultiBuildConfig associated with master indes states 'miStateList'. This; method parses the SplitParam() and SplitParamConstrained() arguments. void addPdf(const char* miStateList, const char* pdfName, RooSimWSTool::SplitRule& sr); Add protytpe p.d.f 'pdfName' to MultiBuildConfig associated with master indes states 'miStateList'. MultiBuildConfig(const char* masterIndexCat). virtual ~MultiBuildConfig(); {}. » Last changed: Tue Jun 30 14:35:50 2015 » Last generated: 2015-",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:680,Integrability,depend,depending,680,". RooSimWSTool::MultiBuildConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::MultiBuildConfig. class RooSimWSTool::MultiBuildConfig: public RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of ",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:2383,Modifiability,config,configurations,2383,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:2652,Modifiability,config,configures,2652," specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Me",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:3056,Modifiability,config,configuration,3056,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~MultiBuildConfig(); voidaddPdf(const char* miStateList, const char* pdfName, RooSimWSTool::SplitRule& sr); voidaddPdf(const char* miStateList, const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:5937,Modifiability,config,configuration,5937,"); RooSimWSTool::MultiBuildConfigMultiBuildConfig(const RooSimWSTool::MultiBuildConfig&); RooSimWSTool::MultiBuildConfig&operator=(const RooSimWSTool::MultiBuildConfig&); voidRooSimWSTool::BuildConfig::restrictBuild(const char* catName, const char* stateList); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooSimWSTool::BuildConfigRooSimWSTool::BuildConfig::BuildConfig(); voidRooSimWSTool::BuildConfig::internalAddPdf(const char* pdfName, const char* miStateList, RooSimWSTool::SplitRule& sr). Data Members; protected:. RooCmdArgRooSimWSTool::BuildConfig::_conflProtocol; stringRooSimWSTool::BuildConfig::_masterCatName; map<string,RooSimWSTool::SplitRule>RooSimWSTool::BuildConfig::_pdfmap; map<string,string>RooSimWSTool::BuildConfig::_restr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MultiBuildConfig(const char* masterIndexCat); Construct MultiBuildConfig for build configuration with multiple prototype p.d.f.s; masterIndexCat is the name of the master index category that decides which; prototype is used. void addPdf(const char* miStateList, const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Add protytpe p.d.f 'pdfName' to MultiBuildConfig associated with master indes states 'miStateList'. This; method parses the SplitParam() and SplitParamConstrained() arguments. void addPdf(const char* miStateList, const char* pdfName, RooSimWSTool::SplitRule& sr); Add protytpe p.d.f 'pdfName' to MultiBuildConfig associated with master indes states 'miStateList'. MultiBuildConfig(const char* masterIndexCat). virtual ~MultiBuildConfig(); {}. » Last changed: Tue Jun 30 14:35:50 2015 » Last generated: 2015-",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:1328,Performance,perform,performed,1328," public RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:3025,Performance,perform,performed,3025,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~MultiBuildConfig(); voidaddPdf(const char* miStateList, const char* pdfName, RooSimWSTool::SplitRule& sr); voidaddPdf(const char* miStateList, const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:551,Usability,simpl,simplest,551,". RooSimWSTool::MultiBuildConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::MultiBuildConfig. class RooSimWSTool::MultiBuildConfig: public RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of ",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:1139,Usability,simpl,simple,1139,"members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::MultiBuildConfig. class RooSimWSTool::MultiBuildConfig: public RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html:3528,Usability,simpl,simple,3528,"""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~MultiBuildConfig(); voidaddPdf(const char* miStateList, const char* pdfName, RooSimWSTool::SplitRule& sr); voidaddPdf(const char* miStateList, const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooSimWSTool::BuildConfigRooSimWSTool::BuildConfig::BuildConfig(const RooArgSet& legacyBuildConfig); RooSimWSTool::BuildConfigRooSimWSTool::BuildConfig::BuildConfig(const RooSimWSTool::BuildConfig&); RooSimWSTool::BuildConfigRooSimWSTool::BuildConfig::BuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); RooSimWSTool::BuildConfigRooSimWSTool::BuildConfig::BuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = ",MatchSource.WIKI,root/html602/RooSimWSTool__MultiBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__MultiBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:2343,Deployability,configurat,configurations,2343,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:3016,Deployability,configurat,configuration,3016,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp) const; virtua",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:4434,Deployability,configurat,configuration,4434," prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. RooCmdArg_conflProtocol; RooCategory*_masterCat; map<RooAbsPdf*,RooSimWSTool::ObjSplitRule>_pdfmap; map<RooAbsCategory*,list<const RooCatType*> >_restr; RooArgSet_usedSplitCats. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void print(); Print details of a validated build configuration. ObjBuildConfig(); {}. virtual ~ObjBuildConfig(); {}. » Last changed: Tue Jun 30 14:35:51 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:640,Integrability,depend,depending,640,". RooSimWSTool::ObjBuildConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::ObjBuildConfig. class RooSimWSTool::ObjBuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:2343,Modifiability,config,configurations,2343,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:2612,Modifiability,config,configures,2612," specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Me",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:3016,Modifiability,config,configuration,3016,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp) const; virtua",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:4434,Modifiability,config,configuration,4434," prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. RooCmdArg_conflProtocol; RooCategory*_masterCat; map<RooAbsPdf*,RooSimWSTool::ObjSplitRule>_pdfmap; map<RooAbsCategory*,list<const RooCatType*> >_restr; RooArgSet_usedSplitCats. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void print(); Print details of a validated build configuration. ObjBuildConfig(); {}. virtual ~ObjBuildConfig(); {}. » Last changed: Tue Jun 30 14:35:51 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:1288,Performance,perform,performed,1288,"lass RooSimWSTool::ObjBuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:2985,Performance,perform,performed,2985,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp) const; virtua",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:4418,Security,validat,validated,4418," prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. RooCmdArg_conflProtocol; RooCategory*_masterCat; map<RooAbsPdf*,RooSimWSTool::ObjSplitRule>_pdfmap; map<RooAbsCategory*,list<const RooCatType*> >_restr; RooArgSet_usedSplitCats. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void print(); Print details of a validated build configuration. ObjBuildConfig(); {}. virtual ~ObjBuildConfig(); {}. » Last changed: Tue Jun 30 14:35:51 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:511,Usability,simpl,simplest,511,". RooSimWSTool::ObjBuildConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::ObjBuildConfig. class RooSimWSTool::ObjBuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:1099,Usability,simpl,simple,1099,"s description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::ObjBuildConfig. class RooSimWSTool::ObjBuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:3488,Usability,simpl,simple,3488,"""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. RooCmdArg_conflProtocol; RooCategory*_masterCat; map<RooAbsPdf*,RooSimWSTool::ObjSplitRule>_pdfmap; map<RooAbsCategory*,list<const RooCatType*> >_restr; RooArgSet_usedSplitCats. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void print(); Print details of a validated build configuration. ObjBuildConfig(); {}. virtual ~ObjBuildConfig(); {}. » Last changed: Tue Jun 30 14:35:51 2015 » La",MatchSource.WIKI,root/html602/RooSimWSTool__ObjBuildConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:2337,Deployability,configurat,configurations,2337,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:3010,Deployability,configurat,configuration,3010,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjSplitRule(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjSplitRuleObjSplitRule(); RooSimWSTool::ObjSplitRuleObjSplitRule(const RooSimWSTool::ObjSplitRule&); RooSimWSTool::ObjSplitRule&operator=(const RooSimWSTool::ObjSplitRule&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voi",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:634,Integrability,depend,depending,634,". RooSimWSTool::ObjSplitRule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::ObjSplitRule. class RooSimWSTool::ObjSplitRule. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{Stat",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:2337,Modifiability,config,configurations,2337,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:2606,Modifiability,config,configures,2606," specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Me",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:3010,Modifiability,config,configuration,3010,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjSplitRule(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjSplitRuleObjSplitRule(); RooSimWSTool::ObjSplitRuleObjSplitRule(const RooSimWSTool::ObjSplitRule&); RooSimWSTool::ObjSplitRule&operator=(const RooSimWSTool::ObjSplitRule&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voi",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:1282,Performance,perform,performed,1282," class RooSimWSTool::ObjSplitRule. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:2979,Performance,perform,performed,2979,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjSplitRule(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjSplitRuleObjSplitRule(); RooSimWSTool::ObjSplitRuleObjSplitRule(const RooSimWSTool::ObjSplitRule&); RooSimWSTool::ObjSplitRule&operator=(const RooSimWSTool::ObjSplitRule&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voi",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:505,Usability,simpl,simplest,505,". RooSimWSTool::ObjSplitRule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::ObjSplitRule. class RooSimWSTool::ObjSplitRule. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{Stat",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:1093,Usability,simpl,simple,1093,"class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::ObjSplitRule. class RooSimWSTool::ObjSplitRule. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:3482,Usability,simpl,simple,3482,"""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjSplitRule(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjSplitRuleObjSplitRule(); RooSimWSTool::ObjSplitRuleObjSplitRule(const RooSimWSTool::ObjSplitRule&); RooSimWSTool::ObjSplitRule&operator=(const RooSimWSTool::ObjSplitRule&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. list<const RooCatType*>_miStateList; map<RooAbsArg*,pair<RooArgSet,string> >_paramSplitMap<paramName,<std::list<splitCatSet>,remainderStateName>>. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~ObjSplitRule(); Destructor. ObjSplitRule(); {}. » Last changed: Tue Jun 30 14:35:53 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentat",MatchSource.WIKI,root/html602/RooSimWSTool__ObjSplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:4584,Availability,error,error,4584,,MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:4668,Availability,error,error,4668,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:2343,Deployability,configurat,configurations,2343,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:3016,Deployability,configurat,configuration,3016,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~SplitRule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const;",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:640,Integrability,depend,depending,640,". RooSimWSTool::SplitRule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::SplitRule. class RooSimWSTool::SplitRule: public TNamed. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:2343,Modifiability,config,configurations,2343,"n the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restri",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:2612,Modifiability,config,configures,2612," specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Me",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:3016,Modifiability,config,configuration,3016,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~SplitRule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const;",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:10536,Modifiability,config,configure,10536,"kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. list<string>_miStateNameList; map<string,pair<list<string>,string> >_paramSplitMap<paramName,<std::list<splitCatSet>,remainderStateName>>; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void splitParameter(const char* paramList, const char* categoryList); Specify that parameters names listed in paramNameList be split in (product of) category(s); listed in categoryNameList. void splitParameterConstrained(const char* paramNameList, const char* categoryNameList, const char* remainderStateName); Specify that parameters names listed in paramNameList be split in constrained way in (product of) category(s); listed in categoryNameList and that remainder fraction formula be put in state with name remainderStateName. void configure(const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Construct the SplitRule object from a list of named arguments past to RooSimWSTool::build; This method parses any SplitParam and SplitParamComstrained argument in the list. SplitRule(const char* pdfName = """"); {}. virtual ~SplitRule(); {}. » Last changed: Tue Jun 30 14:35:54 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:1288,Performance,perform,performed,1288,"mWSTool::SplitRule: public TNamed. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:2985,Performance,perform,performed,2985,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~SplitRule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const;",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:511,Usability,simpl,simplest,511,". RooSimWSTool::SplitRule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::SplitRule. class RooSimWSTool::SplitRule: public TNamed. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:1099,Usability,simpl,simple,1099,"cription; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::SplitRule. class RooSimWSTool::SplitRule: public TNamed. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSimWSTool__SplitRule.html:3488,Usability,simpl,simple,3488,"""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~SplitRule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char",MatchSource.WIKI,root/html602/RooSimWSTool__SplitRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSimWSTool__SplitRule.html
https://root.cern/root/html602/RooSpHarmonic.html:11009,Availability,error,error,11009,,MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:11093,Availability,error,error,11093,,MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:36006,Deployability,integrat,integration,36006,">RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:37628,Deployability,integrat,integrator,37628,"ts value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. double_n; RooRealProxy_phi; int_sgn1; int_sgn2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSpHarmonic(). RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal&",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:37639,Deployability,configurat,configuration,37639,"ts value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. double_n; RooRealProxy_phi; int_sgn1; int_sgn2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSpHarmonic(). RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal&",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:8338,Integrability,depend,dependentVars,8338,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:9580,Integrability,depend,dependentOverlaps,9580,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:9672,Integrability,depend,dependentOverlaps,9672,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:9766,Integrability,depend,dependsOn,9766,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:9895,Integrability,depend,dependsOn,9895,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:10013,Integrability,depend,dependsOnValue,10013,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:10120,Integrability,depend,dependsOnValue,10120,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:18279,Integrability,message,message,18279,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEval",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:18430,Integrability,message,message,18430,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArg",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:36006,Integrability,integrat,integration,36006,">RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:37628,Integrability,integrat,integrator,37628,"ts value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. double_n; RooRealProxy_phi; int_sgn1; int_sgn2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSpHarmonic(). RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal&",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:25419,Modifiability,config,config,25419,"e(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:37639,Modifiability,config,configuration,37639,"ts value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. double_n; RooRealProxy_phi; int_sgn1; int_sgn2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSpHarmonic(). RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal&",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:2984,Performance,cache,cacheUniqueSuffix,2984,"egateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:11827,Performance,cache,cacheList,11827,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:11915,Performance,cache,cacheList,11915,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:20225,Performance,optimiz,optimizeCacheMode,20225,"EvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSpHarmonic&operator=(const RooSpHarmonic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:20297,Performance,optimiz,optimizeCacheMode,20297,"rg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSpHarmonic&operator=(const RooSpHarmonic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:23771,Performance,cache,cache,23771,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooSpHarmonic(); RooSpHarmonic(const RooSpHarmonic& other, const char* name = 0); RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal& phi, int l, int m); RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal& phi, int l1, int m1, int l2, int m2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:25262,Performance,cache,cache,25262," int l1, int m1, int l2, int m2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:27357,Performance,cache,cache,27357,"voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:30380,Performance,optimiz,optimizeDirtyHook,30380,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:34882,Performance,cache,cache,34882,,MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:34965,Performance,cache,cache,34965,,MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:35163,Performance,cache,caches,35163,,MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:35729,Performance,cache,cache,35729,"an attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg:",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:35908,Performance,cache,cache,35908,">RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:36321,Performance,cache,cache,36321,">RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:37281,Performance,cache,cache,37281,"ts value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. double_n; RooRealProxy_phi; int_sgn1; int_sgn2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSpHarmonic(). RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal&",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:37823,Performance,cache,cache,37823,"ts value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. double_n; RooRealProxy_phi; int_sgn1; int_sgn2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSpHarmonic(). RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal&",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:12759,Security,hash,hash,12759,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:12910,Security,hash,hash,12910,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; stat",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:35059,Security,validat,validate,35059,,MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:35829,Security,access,access,35829,">RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:9639,Testability,test,testArg,9639,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:9733,Testability,test,testArg,9733,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:18254,Testability,log,logEvalError,18254,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static In",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:18353,Testability,log,logEvalError,18353,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const R",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:19370,Testability,test,testArg,19370,"oAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSpHarmonic&operator=(const RooSpHarmonic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:19465,Testability,test,testArg,19465,"= 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSpHarmonic&operator=(const RooSpHarmonic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = ",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:20441,Testability,test,testArg,20441,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSpHarmonic&operator=(const RooSpHarmonic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:4439,Usability,clear,clearEvalErrorLog,4439,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg:",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:4475,Usability,clear,clearShapeDirty,4475,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:4515,Usability,clear,clearValueAndShapeDirty,4515,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = Roo",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooSpHarmonic.html:4563,Usability,clear,clearValueDirty,4563,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html602/RooSpHarmonic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html
https://root.cern/root/html602/RooStats__AcceptanceRegion.html:1927,Availability,error,error,1927,"eRegionAcceptanceRegion(const RooStats::AcceptanceRegion&); RooStats::AcceptanceRegionAcceptanceRegion(Int_t lu, Double_t ll, Double_t ul); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLookupIndex(); Double_tGetLowerLimit(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetUpperLimit(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgf",MatchSource.WIKI,root/html602/RooStats__AcceptanceRegion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AcceptanceRegion.html
https://root.cern/root/html602/RooStats__AcceptanceRegion.html:2011,Availability,error,error,2011,"onAcceptanceRegion(Int_t lu, Double_t ll, Double_t ul); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLookupIndex(); Double_tGetLowerLimit(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetUpperLimit(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual",MatchSource.WIKI,root/html602/RooStats__AcceptanceRegion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AcceptanceRegion.html
https://root.cern/root/html602/RooStats__AcceptanceRegion.html:409,Integrability,interface,interface,409,". RooStats::AcceptanceRegion. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::AcceptanceRegion. class RooStats::AcceptanceRegion: public TObject. ConfidenceBelt is a concrete implementation of the ConfInterval interface. ; It implements simple general purpose interval of arbitrary dimensions and shape.; It does not assume the interval is connected.; It uses either a RooDataSet (eg. a list of parameter points in the interval) or; a RooDataHist (eg. a Histogram-like object for small regions of the parameter space) to; store the interval. ; . Function Members (Methods); public:. virtual~AcceptanceRegion(); voidTObject::AbstractMethod(const char* method) const; RooStats::AcceptanceRegionAcceptanceRegion(); RooStats::AcceptanceRegionAcceptanceRegion(const RooStats::AcceptanceRegion&); RooStats::AcceptanceRegionAcceptanceRegion(Int_t lu, Double_t ll, Double_t ul); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* param",MatchSource.WIKI,root/html602/RooStats__AcceptanceRegion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AcceptanceRegion.html
https://root.cern/root/html602/RooStats__AcceptanceRegion.html:6401,Testability,test,test,6401,"(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfLookupIndexwant a small footprint reference to the RooArgSet for particular parameter point; Double_tfLowerLimitlower limit on test statistic; Double_tfUpperLimitupper limit on test statistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetLookupIndex(Double_t cl, Double_t leftside); get index for cl,leftside pair. AcceptanceRegion(); {}. virtual ~AcceptanceRegion(); {}. AcceptanceRegion(Int_t lu, Double_t ll, Double_t ul). Double_t GetLowerLimit(); {return fLowerLimit;}. Double_t GetUpperLimit(); {return fUpperLimit;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__AcceptanceRegion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AcceptanceRegion.html
https://root.cern/root/html602/RooStats__AcceptanceRegion.html:6451,Testability,test,test,6451,"(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfLookupIndexwant a small footprint reference to the RooArgSet for particular parameter point; Double_tfLowerLimitlower limit on test statistic; Double_tfUpperLimitupper limit on test statistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetLookupIndex(Double_t cl, Double_t leftside); get index for cl,leftside pair. AcceptanceRegion(); {}. virtual ~AcceptanceRegion(); {}. AcceptanceRegion(Int_t lu, Double_t ll, Double_t ul). Double_t GetLowerLimit(); {return fLowerLimit;}. Double_t GetUpperLimit(); {return fUpperLimit;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__AcceptanceRegion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AcceptanceRegion.html
https://root.cern/root/html602/RooStats__AcceptanceRegion.html:436,Usability,simpl,simple,436,". RooStats::AcceptanceRegion. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::AcceptanceRegion. class RooStats::AcceptanceRegion: public TObject. ConfidenceBelt is a concrete implementation of the ConfInterval interface. ; It implements simple general purpose interval of arbitrary dimensions and shape.; It does not assume the interval is connected.; It uses either a RooDataSet (eg. a list of parameter points in the interval) or; a RooDataHist (eg. a Histogram-like object for small regions of the parameter space) to; store the interval. ; . Function Members (Methods); public:. virtual~AcceptanceRegion(); voidTObject::AbstractMethod(const char* method) const; RooStats::AcceptanceRegionAcceptanceRegion(); RooStats::AcceptanceRegionAcceptanceRegion(const RooStats::AcceptanceRegion&); RooStats::AcceptanceRegionAcceptanceRegion(Int_t lu, Double_t ll, Double_t ul); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* param",MatchSource.WIKI,root/html602/RooStats__AcceptanceRegion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AcceptanceRegion.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:8715,Deployability,integrat,integration,8715,"bool SetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); set observed value to the expected one; works for Gaussian, Poisson or LogNormal; assumes mean parameter value is the argument not constant and not depoending on observables; (if more than two arguments are not constant will use first one but printr a warning !); need to iterate on the components of the POisson to get n and nu (nu can be a RooAbsReal); (code from G. Petrucciani and extended by L.M.). RooAbsData * GenerateCountingAsimovData(RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); generate counting Asimov data for the case when the pdf cannot be extended; assume pdf is a RooPoisson or can be decomposed in a product of RooPoisson,; otherwise we cannot know how to make the Asimov data sets in the other cases. RooAbsData * GenerateAsimovDataSinglePdf(const RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); compute the asimov data set for an observable of a pdf; use the number of bins sets in the observables; to do : (possibility to change number of bins); implement integration over bin content. RooAbsData * GenerateAsimovData(const RooAbsPdf& pdf, const RooArgSet& observables); generate the asimov data for the observables (not the global ones); need to deal with the case of a sim pdf. RooAbsData * MakeAsimovData(RooAbsData& data, const RooStats::ModelConfig& model, const RooArgSet& poiValues, RooArgSet& globObs, const RooArgSet* genPoiValues = 0); static function to the an Asimov data set; given an observed dat set, a model and a snapshot of poi.; Return the asimov data set + global observables set to values satisfying the constraints. RooAbsData * MakeAsimovData(const RooStats::ModelConfig& model, const RooArgSet& allParamValues, RooArgSet& globObs); static function to the an Asimov data set; given the model and the values of all parameters including the nuisance; Return the asimov data set + global observabl",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:8715,Integrability,integrat,integration,8715,"bool SetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); set observed value to the expected one; works for Gaussian, Poisson or LogNormal; assumes mean parameter value is the argument not constant and not depoending on observables; (if more than two arguments are not constant will use first one but printr a warning !); need to iterate on the components of the POisson to get n and nu (nu can be a RooAbsReal); (code from G. Petrucciani and extended by L.M.). RooAbsData * GenerateCountingAsimovData(RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); generate counting Asimov data for the case when the pdf cannot be extended; assume pdf is a RooPoisson or can be decomposed in a product of RooPoisson,; otherwise we cannot know how to make the Asimov data sets in the other cases. RooAbsData * GenerateAsimovDataSinglePdf(const RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); compute the asimov data set for an observable of a pdf; use the number of bins sets in the observables; to do : (possibility to change number of bins); implement integration over bin content. RooAbsData * GenerateAsimovData(const RooAbsPdf& pdf, const RooArgSet& observables); generate the asimov data for the observables (not the global ones); need to deal with the case of a sim pdf. RooAbsData * MakeAsimovData(RooAbsData& data, const RooStats::ModelConfig& model, const RooArgSet& poiValues, RooArgSet& globObs, const RooArgSet* genPoiValues = 0); static function to the an Asimov data set; given an observed dat set, a model and a snapshot of poi.; Return the asimov data set + global observables set to values satisfying the constraints. RooAbsData * MakeAsimovData(const RooStats::ModelConfig& model, const RooArgSet& allParamValues, RooArgSet& globObs); static function to the an Asimov data set; given the model and the values of all parameters including the nuisance; Return the asimov data set + global observabl",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:8022,Modifiability,extend,extended,8022,"only the; first one. double GetExpectedPValues(double pnull, double palt, double nsigma, bool usecls, bool oneSided = true); function given the null and the alt p value - return the expected one given the N - sigma value. void FillBins(const RooAbsPdf& pdf, const RooArgList& obs, RooAbsData& data, int& index, double& binVolume, int& ibin); fill bins by looping recursivly on observables. bool SetObsToExpected(RooProdPdf& prod, const RooArgSet& obs); iterate a Prod pdf to find all the Poisson or Gaussian part to set the observed value to expected one. bool SetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); set observed value to the expected one; works for Gaussian, Poisson or LogNormal; assumes mean parameter value is the argument not constant and not depoending on observables; (if more than two arguments are not constant will use first one but printr a warning !); need to iterate on the components of the POisson to get n and nu (nu can be a RooAbsReal); (code from G. Petrucciani and extended by L.M.). RooAbsData * GenerateCountingAsimovData(RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); generate counting Asimov data for the case when the pdf cannot be extended; assume pdf is a RooPoisson or can be decomposed in a product of RooPoisson,; otherwise we cannot know how to make the Asimov data sets in the other cases. RooAbsData * GenerateAsimovDataSinglePdf(const RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); compute the asimov data set for an observable of a pdf; use the number of bins sets in the observables; to do : (possibility to change number of bins); implement integration over bin content. RooAbsData * GenerateAsimovData(const RooAbsPdf& pdf, const RooArgSet& observables); generate the asimov data for the observables (not the global ones); need to deal with the case of a sim pdf. RooAbsData * MakeAsimovData(RooAbsData& data, const RooStats::ModelConfig& model, ",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:8244,Modifiability,extend,extended,8244," N - sigma value. void FillBins(const RooAbsPdf& pdf, const RooArgList& obs, RooAbsData& data, int& index, double& binVolume, int& ibin); fill bins by looping recursivly on observables. bool SetObsToExpected(RooProdPdf& prod, const RooArgSet& obs); iterate a Prod pdf to find all the Poisson or Gaussian part to set the observed value to expected one. bool SetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); set observed value to the expected one; works for Gaussian, Poisson or LogNormal; assumes mean parameter value is the argument not constant and not depoending on observables; (if more than two arguments are not constant will use first one but printr a warning !); need to iterate on the components of the POisson to get n and nu (nu can be a RooAbsReal); (code from G. Petrucciani and extended by L.M.). RooAbsData * GenerateCountingAsimovData(RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); generate counting Asimov data for the case when the pdf cannot be extended; assume pdf is a RooPoisson or can be decomposed in a product of RooPoisson,; otherwise we cannot know how to make the Asimov data sets in the other cases. RooAbsData * GenerateAsimovDataSinglePdf(const RooAbsPdf& pdf, const RooArgSet& obs, const RooRealVar& weightVar, RooCategory* channelCat = 0); compute the asimov data set for an observable of a pdf; use the number of bins sets in the observables; to do : (possibility to change number of bins); implement integration over bin content. RooAbsData * GenerateAsimovData(const RooAbsPdf& pdf, const RooArgSet& observables); generate the asimov data for the observables (not the global ones); need to deal with the case of a sim pdf. RooAbsData * MakeAsimovData(RooAbsData& data, const RooStats::ModelConfig& model, const RooArgSet& poiValues, RooArgSet& globObs, const RooArgSet* genPoiValues = 0); static function to the an Asimov data set; given an observed dat set, a model and a snapshot of poi.; Return the asimov",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:5938,Performance,perform,perform,5938,"s::TestStatSampler*RooStats::HypoTestCalculatorGeneric::fTestStatSampler. private:. RooAbsData*fAsimovDataasimov data set; RooArgSetfAsimovGlobObssnapshot of Asimov global observables; RooArgSetfBestFitParamssnapshot of all best fitted Parameter values; RooArgSetfBestFitPoisnapshot of best fitted POI values; doublefNLLAsimov; doublefNLLObs; boolfOneSidedfor one sided PL test statistic (upper limits); boolfOneSidedDiscoveryfor one sided PL test statistic (for discovery); intfUseQTildeflag to indicate if using qtilde or not (-1 (default based on RooRealVar)), 0 false, 1 (true); static intfgPrintLevelcontrol print level (0 minimal, 1 normal, 2 debug). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetPrintLevel(int level); set print level (static function); 0 minimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; By default the nuisance parameters are fitted to the data; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* condObs, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formula",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:6604,Performance,perform,performs,6604,"inimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; By default the nuisance parameters are fitted to the data; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* condObs, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formulae for likelihood- based tests of new physics. Eur. Phys. J., C71:1–19, 2011.; The formulae are valid only for one POI. If more than one POI exists consider as POI only the; first one. double GetExpectedPValues(double pnull, double palt, double nsigma, bool usecls, bool oneSided = true); function given the null and the alt p value - return the expected one given the N - sigma value. void FillBins(const RooAbsPdf& pdf, const RooArgList& obs, RooAbsData& data, int& index, double& binVolume, int& ibin); fill bins by looping recursivly on observables. bool SetObsToExpected(RooProdPdf& prod, const RooArgSet& obs); iterate a Prod pdf to find all the Poisson or Gaussian part to set the observed value to expected one. bool SetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); set observed value to the expected on",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:5230,Testability,test,test,5230,"c boolSetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); static boolSetObsToExpected(RooProdPdf& prod, const RooArgSet& obs). Data Members; protected:. const RooStats::ModelConfig*RooStats::HypoTestCalculatorGeneric::fAltModel; unsigned intRooStats::HypoTestCalculatorGeneric::fAltToysSeedto have same toys for alternate; const RooAbsData*RooStats::HypoTestCalculatorGeneric::fData; RooStats::TestStatSampler*RooStats::HypoTestCalculatorGeneric::fDefaultSampler; RooStats::TestStatistic*RooStats::HypoTestCalculatorGeneric::fDefaultTestStat; const RooStats::ModelConfig*RooStats::HypoTestCalculatorGeneric::fNullModel; RooStats::TestStatSampler*RooStats::HypoTestCalculatorGeneric::fTestStatSampler. private:. RooAbsData*fAsimovDataasimov data set; RooArgSetfAsimovGlobObssnapshot of Asimov global observables; RooArgSetfBestFitParamssnapshot of all best fitted Parameter values; RooArgSetfBestFitPoisnapshot of best fitted POI values; doublefNLLAsimov; doublefNLLObs; boolfOneSidedfor one sided PL test statistic (upper limits); boolfOneSidedDiscoveryfor one sided PL test statistic (for discovery); intfUseQTildeflag to indicate if using qtilde or not (-1 (default based on RooRealVar)), 0 false, 1 (true); static intfgPrintLevelcontrol print level (0 minimal, 1 normal, 2 debug). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetPrintLevel(int level); set print level (static function); 0 minimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values;",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:5300,Testability,test,test,5300,"c boolSetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); static boolSetObsToExpected(RooProdPdf& prod, const RooArgSet& obs). Data Members; protected:. const RooStats::ModelConfig*RooStats::HypoTestCalculatorGeneric::fAltModel; unsigned intRooStats::HypoTestCalculatorGeneric::fAltToysSeedto have same toys for alternate; const RooAbsData*RooStats::HypoTestCalculatorGeneric::fData; RooStats::TestStatSampler*RooStats::HypoTestCalculatorGeneric::fDefaultSampler; RooStats::TestStatistic*RooStats::HypoTestCalculatorGeneric::fDefaultTestStat; const RooStats::ModelConfig*RooStats::HypoTestCalculatorGeneric::fNullModel; RooStats::TestStatSampler*RooStats::HypoTestCalculatorGeneric::fTestStatSampler. private:. RooAbsData*fAsimovDataasimov data set; RooArgSetfAsimovGlobObssnapshot of Asimov global observables; RooArgSetfBestFitParamssnapshot of all best fitted Parameter values; RooArgSetfBestFitPoisnapshot of best fitted POI values; doublefNLLAsimov; doublefNLLObs; boolfOneSidedfor one sided PL test statistic (upper limits); boolfOneSidedDiscoveryfor one sided PL test statistic (for discovery); intfUseQTildeflag to indicate if using qtilde or not (-1 (default based on RooRealVar)), 0 false, 1 (true); static intfgPrintLevelcontrol print level (0 minimal, 1 normal, 2 debug). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetPrintLevel(int level); set print level (static function); 0 minimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values;",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:6627,Testability,test,tests,6627,"inimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; By default the nuisance parameters are fitted to the data; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* condObs, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formulae for likelihood- based tests of new physics. Eur. Phys. J., C71:1–19, 2011.; The formulae are valid only for one POI. If more than one POI exists consider as POI only the; first one. double GetExpectedPValues(double pnull, double palt, double nsigma, bool usecls, bool oneSided = true); function given the null and the alt p value - return the expected one given the N - sigma value. void FillBins(const RooAbsPdf& pdf, const RooArgList& obs, RooAbsData& data, int& index, double& binVolume, int& ibin); fill bins by looping recursivly on observables. bool SetObsToExpected(RooProdPdf& prod, const RooArgSet& obs); iterate a Prod pdf to find all the Poisson or Gaussian part to set the observed value to expected one. bool SetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); set observed value to the expected on",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:6881,Testability,test,tests,6881,"totic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; By default the nuisance parameters are fitted to the data; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* condObs, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formulae for likelihood- based tests of new physics. Eur. Phys. J., C71:1–19, 2011.; The formulae are valid only for one POI. If more than one POI exists consider as POI only the; first one. double GetExpectedPValues(double pnull, double palt, double nsigma, bool usecls, bool oneSided = true); function given the null and the alt p value - return the expected one given the N - sigma value. void FillBins(const RooAbsPdf& pdf, const RooArgList& obs, RooAbsData& data, int& index, double& binVolume, int& ibin); fill bins by looping recursivly on observables. bool SetObsToExpected(RooProdPdf& prod, const RooArgSet& obs); iterate a Prod pdf to find all the Poisson or Gaussian part to set the observed value to expected one. bool SetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); set observed value to the expected one; works for Gaussian, Poisson or LogNormal; assumes mean parameter value is the argument not constant and not depoending on observables; (if more than two arguments are not constant will use firs",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:9862,Testability,test,test,9862,"vables (not the global ones); need to deal with the case of a sim pdf. RooAbsData * MakeAsimovData(RooAbsData& data, const RooStats::ModelConfig& model, const RooArgSet& poiValues, RooArgSet& globObs, const RooArgSet* genPoiValues = 0); static function to the an Asimov data set; given an observed dat set, a model and a snapshot of poi.; Return the asimov data set + global observables set to values satisfying the constraints. RooAbsData * MakeAsimovData(const RooStats::ModelConfig& model, const RooArgSet& allParamValues, RooArgSet& globObs); static function to the an Asimov data set; given the model and the values of all parameters including the nuisance; Return the asimov data set + global observables set to values satisfying the constraints. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); HypoTestCalculatorGeneric(data, altModel, nullModel, 0); {; }. void SetOneSided(bool on); set test statistic for one sided (upper limits). { fOneSided = on; }. void SetTwoSided(); set the test statistics for two sided (in case of upper limits; for discovery does not make really sense). { fOneSided = false; fOneSidedDiscovery = false;}. void SetOneSidedDiscovery(bool on); set the test statistics for one-sided discovery. { fOneSidedDiscovery = on; }. bool IsTwoSided() const; { return (!fOneSided && !fOneSidedDiscovery); }. bool IsOneSidedDiscovery() const; { return fOneSidedDiscovery; }. void SetQTilde(bool on); set using of qtilde, by default is controlled if RoORealVar is limited or not. { fUseQTilde = on; }. const RooArgSet & GetBestFitPoi() const; return snapshot of the best fit parameter. { return fBestFitPoi; }. const RooRealVar * GetMuHat() const; return best fit parameter (firs of poi). { return dynamic_cast<RooRealVar*>(fBestFitPoi.first()); }. const RooArgSet & GetBestFitParams() const; return best fit value for all parameters. { return fBestFitPoi; }. » Author: Sven Kreiss, ",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:9956,Testability,test,test,9956," RooStats::ModelConfig& model, const RooArgSet& poiValues, RooArgSet& globObs, const RooArgSet* genPoiValues = 0); static function to the an Asimov data set; given an observed dat set, a model and a snapshot of poi.; Return the asimov data set + global observables set to values satisfying the constraints. RooAbsData * MakeAsimovData(const RooStats::ModelConfig& model, const RooArgSet& allParamValues, RooArgSet& globObs); static function to the an Asimov data set; given the model and the values of all parameters including the nuisance; Return the asimov data set + global observables set to values satisfying the constraints. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); HypoTestCalculatorGeneric(data, altModel, nullModel, 0); {; }. void SetOneSided(bool on); set test statistic for one sided (upper limits). { fOneSided = on; }. void SetTwoSided(); set the test statistics for two sided (in case of upper limits; for discovery does not make really sense). { fOneSided = false; fOneSidedDiscovery = false;}. void SetOneSidedDiscovery(bool on); set the test statistics for one-sided discovery. { fOneSidedDiscovery = on; }. bool IsTwoSided() const; { return (!fOneSided && !fOneSidedDiscovery); }. bool IsOneSidedDiscovery() const; { return fOneSidedDiscovery; }. void SetQTilde(bool on); set using of qtilde, by default is controlled if RoORealVar is limited or not. { fUseQTilde = on; }. const RooArgSet & GetBestFitPoi() const; return snapshot of the best fit parameter. { return fBestFitPoi; }. const RooRealVar * GetMuHat() const; return best fit parameter (firs of poi). { return dynamic_cast<RooRealVar*>(fBestFitPoi.first()); }. const RooArgSet & GetBestFitParams() const; return best fit value for all parameters. { return fBestFitPoi; }. » Author: Sven Kreiss, Kyle Cranmer Nov 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Las",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:10150,Testability,test,test,10150," given an observed dat set, a model and a snapshot of poi.; Return the asimov data set + global observables set to values satisfying the constraints. RooAbsData * MakeAsimovData(const RooStats::ModelConfig& model, const RooArgSet& allParamValues, RooArgSet& globObs); static function to the an Asimov data set; given the model and the values of all parameters including the nuisance; Return the asimov data set + global observables set to values satisfying the constraints. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); HypoTestCalculatorGeneric(data, altModel, nullModel, 0); {; }. void SetOneSided(bool on); set test statistic for one sided (upper limits). { fOneSided = on; }. void SetTwoSided(); set the test statistics for two sided (in case of upper limits; for discovery does not make really sense). { fOneSided = false; fOneSidedDiscovery = false;}. void SetOneSidedDiscovery(bool on); set the test statistics for one-sided discovery. { fOneSidedDiscovery = on; }. bool IsTwoSided() const; { return (!fOneSided && !fOneSidedDiscovery); }. bool IsOneSidedDiscovery() const; { return fOneSidedDiscovery; }. void SetQTilde(bool on); set using of qtilde, by default is controlled if RoORealVar is limited or not. { fUseQTilde = on; }. const RooArgSet & GetBestFitPoi() const; return snapshot of the best fit parameter. { return fBestFitPoi; }. const RooRealVar * GetMuHat() const; return best fit parameter (firs of poi). { return dynamic_cast<RooRealVar*>(fBestFitPoi.first()); }. const RooArgSet & GetBestFitParams() const; return best fit value for all parameters. { return fBestFitPoi; }. » Author: Sven Kreiss, Kyle Cranmer Nov 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root/html602/RooStats__AsymptoticCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:1910,Availability,robust,robust,1910,"ed from inverting the cumulative posterior distribution. . The interface allows one to construct the class by passing the data set, probability density function for the model, the prior; functions and then the parameter of interest to scan. The nuisance parameters can also be passed to be marginalized when ; computing the posterior. Alternatively, the class can be constructed by passing the data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooS",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:3829,Availability,error,error,3829,"ooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPdf, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceNuisancePdf(RooAbsPdf& pdf); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual RooStats::SimpleInterval*GetInterval() const; doubleGetMode() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; RooAbsReal*GetPosteriorFunction() const; RooAbsPdf*GetPosteriorPdf() const; RooPlot*GetPosteriorPlot(bool norm = false, double precision = 0.",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:3913,Availability,error,error,3913,"ooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPdf, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceNuisancePdf(RooAbsPdf& pdf); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual RooStats::SimpleInterval*GetInterval() const; doubleGetMode() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; RooAbsReal*GetPosteriorFunction() const; RooAbsPdf*GetPosteriorPdf() const; RooPlot*GetPosteriorPlot(bool norm = false, double precision = 0.",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13646,Availability,toler,tolerance,13646,"lass, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoome",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:17551,Availability,error,error,17551,"ance; parameters. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:17816,Availability,error,error,17816,etParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf function will be used. { fNScanBins = nb,MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:601,Deployability,integrat,integrates,601,". RooStats::BayesianCalculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::BayesianCalculator. class RooStats::BayesianCalculator: public RooStats::IntervalCalculator, public TNamed. BayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation ; of a credible interval using a Bayesian method. ; The class works only for one single parameter of interest and it integrates the likelihood function with the given prior; probability density function to compute the posterior probability. The result of the class is a one dimensional interval ; (class SimpleInterval ), which is obtained from inverting the cumulative posterior distribution. . The interface allows one to construct the class by passing the data set, probability density function for the model, the prior; functions and then the parameter of interest to scan. The nuisance parameters can also be passed to be marginalized when ; computing the posterior. Alternatively, the class can be constructed by passing the data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:1785,Deployability,integrat,integration,1785,"ed from inverting the cumulative posterior distribution. . The interface allows one to construct the class by passing the data set, probability density function for the model, the prior; functions and then the parameter of interest to scan. The nuisance parameters can also be passed to be marginalized when ; computing the posterior. Alternatively, the class can be constructed by passing the data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooS",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:2198,Deployability,integrat,integration,2198," data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPdf, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtua",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:2222,Deployability,integrat,integrating,2222," data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPdf, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtua",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:2287,Deployability,integrat,integration,2287,"ameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPdf, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:11623,Deployability,integrat,integrated,11623," is done (default); RooArgSetfNuisanceParametersnuisance parameters; RooAbsPdf*fNuisancePdfnuisance pdf (needed when using nuisance sampling technique); intfNumIterationsnumber of iterations (when using ToyMC); RooArgSetfPOIPOI; RooAbsPdf*fPdfmodel pdf (could contain the nuisance pdf as constraint term); ROOT::Math::IGenFunction*fPosteriorFunctionfunction representing the posterior; RooAbsPdf*fPosteriorPdfnormalized (on the poi) posterior pdf; RooAbsPdf*fPriorPdfprior pdf (typically for the POI); RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPdf,						 const RooArgSet* nuisanceParameters ); Constructor from data set, model pdf, parameter of interests and prior pdf; If nuisance parameters are given they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf objec",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:12605,Deployability,integrat,integration,12605,"en they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it w",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:12910,Deployability,integrat,integration,12910,"or. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Mo",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13255,Deployability,integrat,integration,13255,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13298,Deployability,integrat,integration,13298,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13448,Deployability,integrat,integration,13448,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13580,Deployability,integrat,integration,13580,"lass, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoome",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13666,Deployability,integrat,integration,13666,"lass, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoome",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13835,Deployability,integrat,integration,13835,"lass, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoome",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13995,Deployability,integrat,integration,13995,"ed object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class Integrato",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:14097,Deployability,integrat,integration,14097," with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class IntegratorMultiDimOptions::SetDefaultIntegrator. SimpleInterval* GetInterval() const; Compute the interval. By D",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:14210,Deployability,integrat,integration,14210,"* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class IntegratorMultiDimOptions::SetDefaultIntegrator. SimpleInterval* GetInterval() const; Compute the interval. By Default a central interval is computed; and the result is a SimpleInterval object.; Using the method (to be called before SetInterval)",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:14836,Deployability,integrat,integration,14836,"pling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class IntegratorMultiDimOptions::SetDefaultIntegrator. SimpleInterval* GetInterval() const; Compute the interval. By Default a central interval is computed; and the result is a SimpleInterval object.; Using the method (to be called before SetInterval) SetLeftSideTailFraction the user can choose the type of interval.; By default the returned interval is a central interval with the confidence level specified; previously in the constructor ( LeftSideTailFraction = 0.5).; For lower limit use SetLeftSideTailFraction = 1; For upper limit use SetLeftSideTailFraction = 0; for shortest intervals use SetLeftSideTailFraction = -1 or call the method SetShortestInterval(); NOTE: The BayesianCalculator covers only the case with one; single parameter of interest; NOTE: User takes ownership of the returned object. double GetMode() const; Returns the value of the parameter for the point in; para",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:16263,Deployability,integrat,integration,16263,"led before SetInterval) SetLeftSideTailFraction the user can choose the type of interval.; By default the returned interval is a central interval with the confidence level specified; previously in the constructor ( LeftSideTailFraction = 0.5).; For lower limit use SetLeftSideTailFraction = 1; For upper limit use SetLeftSideTailFraction = 0; for shortest intervals use SetLeftSideTailFraction = -1 or call the method SetShortestInterval(); NOTE: The BayesianCalculator covers only the case with one; single parameter of interest; NOTE: User takes ownership of the returned object. double GetMode() const; Returns the value of the parameter for the point in; parameter-space that is the most likely.; How do we do if there are points that are equi-probable?; use approximate posterior; t.b.d use real function to find the mode. void ComputeIntervalUsingRooFit(double c1, double c2) const; internal function compute the interval using RooFit. void ComputeIntervalFromCdf(double c1, double c2) const; internal function compute the interval using Cdf integration. void ApproximatePosterior() const; approximate posterior in nbins using a TF1; scan the poi values and evaluate the posterior at each point; and save the result in a cloned TF1; For each point the posterior is evaluated by integrating the nuisance; parameters. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditio",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:16499,Deployability,integrat,integrating,16499,"sly in the constructor ( LeftSideTailFraction = 0.5).; For lower limit use SetLeftSideTailFraction = 1; For upper limit use SetLeftSideTailFraction = 0; for shortest intervals use SetLeftSideTailFraction = -1 or call the method SetShortestInterval(); NOTE: The BayesianCalculator covers only the case with one; single parameter of interest; NOTE: User takes ownership of the returned object. double GetMode() const; Returns the value of the parameter for the point in; parameter-space that is the most likely.; How do we do if there are points that are equi-probable?; use approximate posterior; t.b.d use real function to find the mode. void ComputeIntervalUsingRooFit(double c1, double c2) const; internal function compute the interval using RooFit. void ComputeIntervalFromCdf(double c1, double c2) const; internal function compute the interval using Cdf integration. void ApproximatePosterior() const; approximate posterior in nbins using a TF1; scan the poi values and evaluate the posterior at each point; and save the result in a cloned TF1; For each point the posterior is evaluated by integrating the nuisance; parameters. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when comput",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:18713,Deployability,integrat,integrating,18713,"interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf function will be used. { fNScanBins = nbin; }. void SetNumIters(Int_t numIters); set the number of iterations when running a MC integration algorithm; If not set use default algorithmic values; In case of ToyMC sampling of the nuisance the value is 100; In case of using the GSL MCintegrations types the default value is; defined in ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls(). { fNumIterations = numIters; }. void ForceNuisancePdf(RooAbsPdf& pdf); force the nuisance pdf when using the toy mc sampling. { fNuisancePdf = &pdf; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:18900,Deployability,integrat,integration,18900,"interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf function will be used. { fNScanBins = nbin; }. void SetNumIters(Int_t numIters); set the number of iterations when running a MC integration algorithm; If not set use default algorithmic values; In case of ToyMC sampling of the nuisance the value is 100; In case of using the GSL MCintegrations types the default value is; defined in ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls(). { fNumIterations = numIters; }. void ForceNuisancePdf(RooAbsPdf& pdf); force the nuisance pdf when using the toy mc sampling. { fNuisancePdf = &pdf; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13377,Energy Efficiency,adapt,adaptive,13377,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13429,Energy Efficiency,adapt,adaptive,13429,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13560,Energy Efficiency,reduce,reduced,13560,"lass, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoome",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:14354,Energy Efficiency,efficient,efficient,14354,"ive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class IntegratorMultiDimOptions::SetDefaultIntegrator. SimpleInterval* GetInterval() const; Compute the interval. By Default a central interval is computed; and the result is a SimpleInterval object.; Using the method (to be called before SetInterval) SetLeftSideTailFraction the user can choose the type of interval.; By default the returned interval is a central interval with the confidence l",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:601,Integrability,integrat,integrates,601,". RooStats::BayesianCalculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::BayesianCalculator. class RooStats::BayesianCalculator: public RooStats::IntervalCalculator, public TNamed. BayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation ; of a credible interval using a Bayesian method. ; The class works only for one single parameter of interest and it integrates the likelihood function with the given prior; probability density function to compute the posterior probability. The result of the class is a one dimensional interval ; (class SimpleInterval ), which is obtained from inverting the cumulative posterior distribution. . The interface allows one to construct the class by passing the data set, probability density function for the model, the prior; functions and then the parameter of interest to scan. The nuisance parameters can also be passed to be marginalized when ; computing the posterior. Alternatively, the class can be constructed by passing the data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:884,Integrability,interface,interface,884,". RooStats::BayesianCalculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::BayesianCalculator. class RooStats::BayesianCalculator: public RooStats::IntervalCalculator, public TNamed. BayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation ; of a credible interval using a Bayesian method. ; The class works only for one single parameter of interest and it integrates the likelihood function with the given prior; probability density function to compute the posterior probability. The result of the class is a one dimensional interval ; (class SimpleInterval ), which is obtained from inverting the cumulative posterior distribution. . The interface allows one to construct the class by passing the data set, probability density function for the model, the prior; functions and then the parameter of interest to scan. The nuisance parameters can also be passed to be marginalized when ; computing the posterior. Alternatively, the class can be constructed by passing the data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:1785,Integrability,integrat,integration,1785,"ed from inverting the cumulative posterior distribution. . The interface allows one to construct the class by passing the data set, probability density function for the model, the prior; functions and then the parameter of interest to scan. The nuisance parameters can also be passed to be marginalized when ; computing the posterior. Alternatively, the class can be constructed by passing the data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooS",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:2198,Integrability,integrat,integration,2198," data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPdf, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtua",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:2222,Integrability,integrat,integrating,2222," data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPdf, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtua",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:2287,Integrability,integrat,integration,2287,"ameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPdf, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:11623,Integrability,integrat,integrated,11623," is done (default); RooArgSetfNuisanceParametersnuisance parameters; RooAbsPdf*fNuisancePdfnuisance pdf (needed when using nuisance sampling technique); intfNumIterationsnumber of iterations (when using ToyMC); RooArgSetfPOIPOI; RooAbsPdf*fPdfmodel pdf (could contain the nuisance pdf as constraint term); ROOT::Math::IGenFunction*fPosteriorFunctionfunction representing the posterior; RooAbsPdf*fPosteriorPdfnormalized (on the poi) posterior pdf; RooAbsPdf*fPriorPdfprior pdf (typically for the POI); RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPdf,						 const RooArgSet* nuisanceParameters ); Constructor from data set, model pdf, parameter of interests and prior pdf; If nuisance parameters are given they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf objec",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:12605,Integrability,integrat,integration,12605,"en they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it w",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:12910,Integrability,integrat,integration,12910,"or. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Mo",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13255,Integrability,integrat,integration,13255,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13298,Integrability,integrat,integration,13298,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13448,Integrability,integrat,integration,13448,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13580,Integrability,integrat,integration,13580,"lass, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoome",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13666,Integrability,integrat,integration,13666,"lass, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoome",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13835,Integrability,integrat,integration,13835,"lass, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoome",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13995,Integrability,integrat,integration,13995,"ed object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class Integrato",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:14097,Integrability,integrat,integration,14097," with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class IntegratorMultiDimOptions::SetDefaultIntegrator. SimpleInterval* GetInterval() const; Compute the interval. By D",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:14210,Integrability,integrat,integration,14210,"* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class IntegratorMultiDimOptions::SetDefaultIntegrator. SimpleInterval* GetInterval() const; Compute the interval. By Default a central interval is computed; and the result is a SimpleInterval object.; Using the method (to be called before SetInterval)",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:14836,Integrability,integrat,integration,14836,"pling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class IntegratorMultiDimOptions::SetDefaultIntegrator. SimpleInterval* GetInterval() const; Compute the interval. By Default a central interval is computed; and the result is a SimpleInterval object.; Using the method (to be called before SetInterval) SetLeftSideTailFraction the user can choose the type of interval.; By default the returned interval is a central interval with the confidence level specified; previously in the constructor ( LeftSideTailFraction = 0.5).; For lower limit use SetLeftSideTailFraction = 1; For upper limit use SetLeftSideTailFraction = 0; for shortest intervals use SetLeftSideTailFraction = -1 or call the method SetShortestInterval(); NOTE: The BayesianCalculator covers only the case with one; single parameter of interest; NOTE: User takes ownership of the returned object. double GetMode() const; Returns the value of the parameter for the point in; para",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:16263,Integrability,integrat,integration,16263,"led before SetInterval) SetLeftSideTailFraction the user can choose the type of interval.; By default the returned interval is a central interval with the confidence level specified; previously in the constructor ( LeftSideTailFraction = 0.5).; For lower limit use SetLeftSideTailFraction = 1; For upper limit use SetLeftSideTailFraction = 0; for shortest intervals use SetLeftSideTailFraction = -1 or call the method SetShortestInterval(); NOTE: The BayesianCalculator covers only the case with one; single parameter of interest; NOTE: User takes ownership of the returned object. double GetMode() const; Returns the value of the parameter for the point in; parameter-space that is the most likely.; How do we do if there are points that are equi-probable?; use approximate posterior; t.b.d use real function to find the mode. void ComputeIntervalUsingRooFit(double c1, double c2) const; internal function compute the interval using RooFit. void ComputeIntervalFromCdf(double c1, double c2) const; internal function compute the interval using Cdf integration. void ApproximatePosterior() const; approximate posterior in nbins using a TF1; scan the poi values and evaluate the posterior at each point; and save the result in a cloned TF1; For each point the posterior is evaluated by integrating the nuisance; parameters. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditio",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:16499,Integrability,integrat,integrating,16499,"sly in the constructor ( LeftSideTailFraction = 0.5).; For lower limit use SetLeftSideTailFraction = 1; For upper limit use SetLeftSideTailFraction = 0; for shortest intervals use SetLeftSideTailFraction = -1 or call the method SetShortestInterval(); NOTE: The BayesianCalculator covers only the case with one; single parameter of interest; NOTE: User takes ownership of the returned object. double GetMode() const; Returns the value of the parameter for the point in; parameter-space that is the most likely.; How do we do if there are points that are equi-probable?; use approximate posterior; t.b.d use real function to find the mode. void ComputeIntervalUsingRooFit(double c1, double c2) const; internal function compute the interval using RooFit. void ComputeIntervalFromCdf(double c1, double c2) const; internal function compute the interval using Cdf integration. void ApproximatePosterior() const; approximate posterior in nbins using a TF1; scan the poi values and evaluate the posterior at each point; and save the result in a cloned TF1; For each point the posterior is evaluated by integrating the nuisance; parameters. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when comput",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:18713,Integrability,integrat,integrating,18713,"interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf function will be used. { fNScanBins = nbin; }. void SetNumIters(Int_t numIters); set the number of iterations when running a MC integration algorithm; If not set use default algorithmic values; In case of ToyMC sampling of the nuisance the value is 100; In case of using the GSL MCintegrations types the default value is; defined in ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls(). { fNumIterations = numIters; }. void ForceNuisancePdf(RooAbsPdf& pdf); force the nuisance pdf when using the toy mc sampling. { fNuisancePdf = &pdf; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:18900,Integrability,integrat,integration,18900,"interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf function will be used. { fNScanBins = nbin; }. void SetNumIters(Int_t numIters); set the number of iterations when running a MC integration algorithm; If not set use default algorithmic values; In case of ToyMC sampling of the nuisance the value is 100; In case of using the GSL MCintegrations types the default value is; defined in ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls(). { fNumIterations = numIters; }. void ForceNuisancePdf(RooAbsPdf& pdf); force the nuisance pdf when using the toy mc sampling. { fNuisancePdf = &pdf; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:1360,Modifiability,config,configuring,1360,"concrete implementation of IntervalCalculator, providing the computation ; of a credible interval using a Bayesian method. ; The class works only for one single parameter of interest and it integrates the likelihood function with the given prior; probability density function to compute the posterior probability. The result of the class is a one dimensional interval ; (class SimpleInterval ), which is obtained from inverting the cumulative posterior distribution. . The interface allows one to construct the class by passing the data set, probability density function for the model, the prior; functions and then the parameter of interest to scan. The nuisance parameters can also be passed to be marginalized when ; computing the posterior. Alternatively, the class can be constructed by passing the data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). F",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13377,Modifiability,adapt,adaptive,13377,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13429,Modifiability,adapt,adaptive,13429,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:11961,Performance,cache,cached,11961,"; RooAbsPdf*fPriorPdfprior pdf (typically for the POI); RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPdf,						 const RooArgSet* nuisanceParameters ); Constructor from data set, model pdf, parameter of interests and prior pdf; If nuisance parameters are given they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the n",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:12620,Performance,perform,performed,12620,"en they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it w",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:10348,Testability,log,log,10348,"us)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TF1*fApproxPosteriorTF1 representing the scanned posterior function; doublefBrfPrecisionroot finder precision; RooArgSetfConditionalObsconditional observables; RooAbsData*fDatadata set; RooAbsReal*fIntegratedLikelihoodintegrated likelihood function, i.e - unnormalized posterior function; TStringfIntegrationType; doublefLeftSideFractionfraction of probability content on left side of interval; RooAbsReal*fLikelihoodinternal pointer to likelihood function; RooAbsReal*fLogLikeinternal pointer to log likelihood function; Double_tfLowercomputer lower interval bound; Double_tfNLLMinminimum value of Nll; intfNScanBinsnumber of bins to scan, if = -1 no scan is done (default); RooArgSetfNuisanceParametersnuisance parameters; RooAbsPdf*fNuisancePdfnuisance pdf (needed when using nuisance sampling technique); intfNumIterationsnumber of iterations (when using ToyMC); RooArgSetfPOIPOI; RooAbsPdf*fPdfmodel pdf (could contain the nuisance pdf as constraint term); ROOT::Math::IGenFunction*fPosteriorFunctionfunction representing the posterior; RooAbsPdf*fPosteriorPdfnormalized (on the poi) posterior pdf; RooAbsPdf*fPriorPdfprior pdf (typically for the POI); RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPdf,						 const RooArgSet* nuisanceParameters ); Constructor from data set, model pdf, parameter of interests and prior pdf; If nuisance parameters are given they will be integrated ac",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:17530,Testability,test,test,17530,"ance; parameters. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:17791,Testability,test,test,17791,void SetData(RooAbsData& data). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf fu,MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:17910,Testability,test,test,17910,est in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf function will be used. { fNScanBins = nbin; }. void SetNumIters(Int_t numIters); set the number of iteratio,MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:11951,Usability,clear,clear,11951,"; RooAbsPdf*fPriorPdfprior pdf (typically for the POI); RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPdf,						 const RooArgSet* nuisanceParameters ); Constructor from data set, model pdf, parameter of interests and prior pdf; If nuisance parameters are given they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the n",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BayesianCalculator.html:13985,Usability,simpl,simple,13985,"ed object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class Integrato",MatchSource.WIKI,root/html602/RooStats__BayesianCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BayesianCalculator.html
https://root.cern/root/html602/RooStats__BernsteinCorrection.html:1883,Availability,error,error,1883," to be included ; in the correction. This is an emperical algorithm, so in addition to the nominal model it ; needs either a real data set or a simulated one. In the early work, the nominal model was taken; to be a histogram from Monte Carlo simulations, but in this implementation it is generalized to an; arbitrary PDF (which includes a RooHistPdf). The algorithm basically consists of a ; hypothesis test of an nth-order correction (null) against a n+1-th order correction (alternate). ; The quantity q = -2 log LR is used to determine whether the n+1-th order correction is a major ; improvement to the n-th order correction. The distribution of q is expected to be roughly ; \chi^2 with one degree of freedom if the n-th order correction is a good model for the data. ; Thus, one only moves to the n+1-th order correction of q is relatively large. The chance that ; one moves from the n-th to the n+1-th order correction when the n-th order correction ; (eg. a type 1 error) is sufficient is given by the Prob(\chi^2_1 > threshold). The constructor ; of this class allows you to directly set this tolerance (in terms of probability that the n+1-th; term is added unnecessarily). To do:; Add another method to the utility that will make the sampling distribution for -2 log lambda ; for various m vs. m+1 order corrections using a nominal model and perhaps having two ways of ; generating the toys (either via a histogram or via an independent model that is supposed to; reflect reality). That will allow one to make plots like Glen has at the end of his DRAFT; very easily. . Function Members (Methods); public:. virtual~BernsteinCorrection(); RooStats::BernsteinCorrectionBernsteinCorrection(double tolerance = 0.050000000000000003); RooStats::BernsteinCorrectionBernsteinCorrection(const RooStats::BernsteinCorrection&); static TClass*Class(); voidCreateQSamplingDist(RooWorkspace* wks, const char* nominalName, const char* varName, const char* dataName, TH1F*, TH1F*, Int_t degree, Int_t nToy",MatchSource.WIKI,root/html602/RooStats__BernsteinCorrection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BernsteinCorrection.html
https://root.cern/root/html602/RooStats__BernsteinCorrection.html:2012,Availability,toler,tolerance,2012,"needs either a real data set or a simulated one. In the early work, the nominal model was taken; to be a histogram from Monte Carlo simulations, but in this implementation it is generalized to an; arbitrary PDF (which includes a RooHistPdf). The algorithm basically consists of a ; hypothesis test of an nth-order correction (null) against a n+1-th order correction (alternate). ; The quantity q = -2 log LR is used to determine whether the n+1-th order correction is a major ; improvement to the n-th order correction. The distribution of q is expected to be roughly ; \chi^2 with one degree of freedom if the n-th order correction is a good model for the data. ; Thus, one only moves to the n+1-th order correction of q is relatively large. The chance that ; one moves from the n-th to the n+1-th order correction when the n-th order correction ; (eg. a type 1 error) is sufficient is given by the Prob(\chi^2_1 > threshold). The constructor ; of this class allows you to directly set this tolerance (in terms of probability that the n+1-th; term is added unnecessarily). To do:; Add another method to the utility that will make the sampling distribution for -2 log lambda ; for various m vs. m+1 order corrections using a nominal model and perhaps having two ways of ; generating the toys (either via a histogram or via an independent model that is supposed to; reflect reality). That will allow one to make plots like Glen has at the end of his DRAFT; very easily. . Function Members (Methods); public:. virtual~BernsteinCorrection(); RooStats::BernsteinCorrectionBernsteinCorrection(double tolerance = 0.050000000000000003); RooStats::BernsteinCorrectionBernsteinCorrection(const RooStats::BernsteinCorrection&); static TClass*Class(); voidCreateQSamplingDist(RooWorkspace* wks, const char* nominalName, const char* varName, const char* dataName, TH1F*, TH1F*, Int_t degree, Int_t nToys = 500); Int_tImportCorrectedPdf(RooWorkspace*, const char*, const char*, const char*); virtual TClass*IsA() ",MatchSource.WIKI,root/html602/RooStats__BernsteinCorrection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BernsteinCorrection.html
https://root.cern/root/html602/RooStats__BernsteinCorrection.html:2615,Availability,toler,tolerance,2615,"e roughly ; \chi^2 with one degree of freedom if the n-th order correction is a good model for the data. ; Thus, one only moves to the n+1-th order correction of q is relatively large. The chance that ; one moves from the n-th to the n+1-th order correction when the n-th order correction ; (eg. a type 1 error) is sufficient is given by the Prob(\chi^2_1 > threshold). The constructor ; of this class allows you to directly set this tolerance (in terms of probability that the n+1-th; term is added unnecessarily). To do:; Add another method to the utility that will make the sampling distribution for -2 log lambda ; for various m vs. m+1 order corrections using a nominal model and perhaps having two ways of ; generating the toys (either via a histogram or via an independent model that is supposed to; reflect reality). That will allow one to make plots like Glen has at the end of his DRAFT; very easily. . Function Members (Methods); public:. virtual~BernsteinCorrection(); RooStats::BernsteinCorrectionBernsteinCorrection(double tolerance = 0.050000000000000003); RooStats::BernsteinCorrectionBernsteinCorrection(const RooStats::BernsteinCorrection&); static TClass*Class(); voidCreateQSamplingDist(RooWorkspace* wks, const char* nominalName, const char* varName, const char* dataName, TH1F*, TH1F*, Int_t degree, Int_t nToys = 500); Int_tImportCorrectedPdf(RooWorkspace*, const char*, const char*, const char*); virtual TClass*IsA() const; RooStats::BernsteinCorrection&operator=(const RooStats::BernsteinCorrection&); voidSetMaxCorrection(Double_t maxCorr); voidSetMaxDegree(Int_t maxDegree); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. Double_tfMaxCorrectionmaximum correction factor at any point (default is 100); Int_tfMaxDegreemaximum polynomial degree correction (default is 10); Double_tfToleranceprobability to add an unnecessary term. Class Charts. Inheri",MatchSource.WIKI,root/html602/RooStats__BernsteinCorrection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BernsteinCorrection.html
https://root.cern/root/html602/RooStats__BernsteinCorrection.html:3678,Availability,toler,tolerance,3678,"ts::BernsteinCorrectionBernsteinCorrection(const RooStats::BernsteinCorrection&); static TClass*Class(); voidCreateQSamplingDist(RooWorkspace* wks, const char* nominalName, const char* varName, const char* dataName, TH1F*, TH1F*, Int_t degree, Int_t nToys = 500); Int_tImportCorrectedPdf(RooWorkspace*, const char*, const char*, const char*); virtual TClass*IsA() const; RooStats::BernsteinCorrection&operator=(const RooStats::BernsteinCorrection&); voidSetMaxCorrection(Double_t maxCorr); voidSetMaxDegree(Int_t maxDegree); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. Double_tfMaxCorrectionmaximum correction factor at any point (default is 100); Int_tfMaxDegreemaximum polynomial degree correction (default is 10); Double_tfToleranceprobability to add an unnecessary term. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BernsteinCorrection(Double_t tolerance). Int_t ImportCorrectedPdf(RooWorkspace* , const char* , const char* , const char* ); Main method for Bernstein correction.; get ingredients out of workspace. void CreateQSamplingDist(RooWorkspace* wks, const char* nominalName, const char* varName, const char* dataName, TH1F* , TH1F* , Int_t degree, Int_t nToys = 500); Create sampling distribution for q given degree-1 vs. degree corrections; get ingredients out of workspace. BernsteinCorrection(double tolerance = 0.050000000000000003). virtual ~BernsteinCorrection(); {}. void SetMaxCorrection(Double_t maxCorr); {fMaxCorrection = maxCorr;}. void SetMaxDegree(Int_t maxDegree); {fMaxDegree = maxDegree;}. » Author: Kyle Cranmer » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support.",MatchSource.WIKI,root/html602/RooStats__BernsteinCorrection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BernsteinCorrection.html
https://root.cern/root/html602/RooStats__BernsteinCorrection.html:4144,Availability,toler,tolerance,4144,"::BernsteinCorrectionBernsteinCorrection(const RooStats::BernsteinCorrection&); static TClass*Class(); voidCreateQSamplingDist(RooWorkspace* wks, const char* nominalName, const char* varName, const char* dataName, TH1F*, TH1F*, Int_t degree, Int_t nToys = 500); Int_tImportCorrectedPdf(RooWorkspace*, const char*, const char*, const char*); virtual TClass*IsA() const; RooStats::BernsteinCorrection&operator=(const RooStats::BernsteinCorrection&); voidSetMaxCorrection(Double_t maxCorr); voidSetMaxDegree(Int_t maxDegree); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. Double_tfMaxCorrectionmaximum correction factor at any point (default is 100); Int_tfMaxDegreemaximum polynomial degree correction (default is 10); Double_tfToleranceprobability to add an unnecessary term. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BernsteinCorrection(Double_t tolerance). Int_t ImportCorrectedPdf(RooWorkspace* , const char* , const char* , const char* ); Main method for Bernstein correction.; get ingredients out of workspace. void CreateQSamplingDist(RooWorkspace* wks, const char* nominalName, const char* varName, const char* dataName, TH1F* , TH1F* , Int_t degree, Int_t nToys = 500); Create sampling distribution for q given degree-1 vs. degree corrections; get ingredients out of workspace. BernsteinCorrection(double tolerance = 0.050000000000000003). virtual ~BernsteinCorrection(); {}. void SetMaxCorrection(Double_t maxCorr); {fMaxCorrection = maxCorr;}. void SetMaxDegree(Int_t maxDegree); {fMaxDegree = maxDegree;}. » Author: Kyle Cranmer » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__BernsteinCorrection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BernsteinCorrection.html
https://root.cern/root/html602/RooStats__BernsteinCorrection.html:1313,Testability,test,test,1313,"rection. BernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial ; correction term. This is useful for incorporating systematic variations to the nominal PDF. ; The Bernstein basis polynomails are particularly appropriate because they are positive definite. . This tool was inspired by the work of Glen Cowan together with Stephan Horner, Sascha Caron, ; Eilam Gross, and others. ; The initial implementation is independent work. The major step forward in the approach was ; to provide a well defined algorithm that specifies the order of polynomial to be included ; in the correction. This is an emperical algorithm, so in addition to the nominal model it ; needs either a real data set or a simulated one. In the early work, the nominal model was taken; to be a histogram from Monte Carlo simulations, but in this implementation it is generalized to an; arbitrary PDF (which includes a RooHistPdf). The algorithm basically consists of a ; hypothesis test of an nth-order correction (null) against a n+1-th order correction (alternate). ; The quantity q = -2 log LR is used to determine whether the n+1-th order correction is a major ; improvement to the n-th order correction. The distribution of q is expected to be roughly ; \chi^2 with one degree of freedom if the n-th order correction is a good model for the data. ; Thus, one only moves to the n+1-th order correction of q is relatively large. The chance that ; one moves from the n-th to the n+1-th order correction when the n-th order correction ; (eg. a type 1 error) is sufficient is given by the Prob(\chi^2_1 > threshold). The constructor ; of this class allows you to directly set this tolerance (in terms of probability that the n+1-th; term is added unnecessarily). To do:; Add another method to the utility that will make the sampling distribution for -2 log lambda ; for various m vs. m+1 order corrections using a nominal model and perhaps having two ways of ; generating the toys (either via a hist",MatchSource.WIKI,root/html602/RooStats__BernsteinCorrection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BernsteinCorrection.html
https://root.cern/root/html602/RooStats__BernsteinCorrection.html:1421,Testability,log,log,1421,"rporating systematic variations to the nominal PDF. ; The Bernstein basis polynomails are particularly appropriate because they are positive definite. . This tool was inspired by the work of Glen Cowan together with Stephan Horner, Sascha Caron, ; Eilam Gross, and others. ; The initial implementation is independent work. The major step forward in the approach was ; to provide a well defined algorithm that specifies the order of polynomial to be included ; in the correction. This is an emperical algorithm, so in addition to the nominal model it ; needs either a real data set or a simulated one. In the early work, the nominal model was taken; to be a histogram from Monte Carlo simulations, but in this implementation it is generalized to an; arbitrary PDF (which includes a RooHistPdf). The algorithm basically consists of a ; hypothesis test of an nth-order correction (null) against a n+1-th order correction (alternate). ; The quantity q = -2 log LR is used to determine whether the n+1-th order correction is a major ; improvement to the n-th order correction. The distribution of q is expected to be roughly ; \chi^2 with one degree of freedom if the n-th order correction is a good model for the data. ; Thus, one only moves to the n+1-th order correction of q is relatively large. The chance that ; one moves from the n-th to the n+1-th order correction when the n-th order correction ; (eg. a type 1 error) is sufficient is given by the Prob(\chi^2_1 > threshold). The constructor ; of this class allows you to directly set this tolerance (in terms of probability that the n+1-th; term is added unnecessarily). To do:; Add another method to the utility that will make the sampling distribution for -2 log lambda ; for various m vs. m+1 order corrections using a nominal model and perhaps having two ways of ; generating the toys (either via a histogram or via an independent model that is supposed to; reflect reality). That will allow one to make plots like Glen has at the end of his ",MatchSource.WIKI,root/html602/RooStats__BernsteinCorrection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BernsteinCorrection.html
https://root.cern/root/html602/RooStats__BernsteinCorrection.html:2184,Testability,log,log,2184,"imulations, but in this implementation it is generalized to an; arbitrary PDF (which includes a RooHistPdf). The algorithm basically consists of a ; hypothesis test of an nth-order correction (null) against a n+1-th order correction (alternate). ; The quantity q = -2 log LR is used to determine whether the n+1-th order correction is a major ; improvement to the n-th order correction. The distribution of q is expected to be roughly ; \chi^2 with one degree of freedom if the n-th order correction is a good model for the data. ; Thus, one only moves to the n+1-th order correction of q is relatively large. The chance that ; one moves from the n-th to the n+1-th order correction when the n-th order correction ; (eg. a type 1 error) is sufficient is given by the Prob(\chi^2_1 > threshold). The constructor ; of this class allows you to directly set this tolerance (in terms of probability that the n+1-th; term is added unnecessarily). To do:; Add another method to the utility that will make the sampling distribution for -2 log lambda ; for various m vs. m+1 order corrections using a nominal model and perhaps having two ways of ; generating the toys (either via a histogram or via an independent model that is supposed to; reflect reality). That will allow one to make plots like Glen has at the end of his DRAFT; very easily. . Function Members (Methods); public:. virtual~BernsteinCorrection(); RooStats::BernsteinCorrectionBernsteinCorrection(double tolerance = 0.050000000000000003); RooStats::BernsteinCorrectionBernsteinCorrection(const RooStats::BernsteinCorrection&); static TClass*Class(); voidCreateQSamplingDist(RooWorkspace* wks, const char* nominalName, const char* varName, const char* dataName, TH1F*, TH1F*, Int_t degree, Int_t nToys = 500); Int_tImportCorrectedPdf(RooWorkspace*, const char*, const char*, const char*); virtual TClass*IsA() const; RooStats::BernsteinCorrection&operator=(const RooStats::BernsteinCorrection&); voidSetMaxCorrection(Double_t maxCorr); voidSetM",MatchSource.WIKI,root/html602/RooStats__BernsteinCorrection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__BernsteinCorrection.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1915,Availability,avail,available,1915," set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); RooStats::CombinedCalculatorCombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0); virtual Double_tConfidenceLevel() const; virtual RooStats::HypoTestResult*GetHypoTest() const; virtual RooStats::ConfInterval*GetInterval() const; RooStats::HypoTestCalculatorRooStats::HypoTestCalculator::HypoTestCalculator(); RooStats::HypoTestCalculatorRooStats::HypoTestCalculator::HypoTestCalculator(const RooStats::HypoTestCalculator&); RooStats::IntervalCalculatorRooStats",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:4647,Availability,error,error,4647,"& set); virtual voidSetNullModel(const RooStats::ModelConfig&); virtual voidSetNullParameters(const RooArgSet& set); virtual voidSetParameters(const RooArgSet& set); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooAbsData*GetData() const; RooAbsPdf*GetPdf() const. Data Members; protected:. RooArgSetfAlternateParamsRooArgSet specifying alternate parameters for hypothesis test // Is it used ????; RooArgSetfConditionalObsRooArgSet specifying the conditional observables; RooAbsData*fData; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:5664,Availability,error,error,5664,"s Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetNullModel(const RooStats::ModelConfig& ). void SetAlternateModel(const RooStats::ModelConfig& ). void SetPdf(RooAbsPdf& pdf); specific setting - keep for convenience- some of them could be removed; Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetNullParameters(const RooArgSet& set); set parameter values for the null if using a common PDF. {fNullParams.removeAll(); fNullParams.add(set);}. void SetAlternateParameters(const RooArgSet& set); set parameter values for the alternate if u",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1538,Deployability,integrat,integration,1538,"ny such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); RooStats::CombinedCalculatorCombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0); virtual Double_",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:5169,Deployability,configurat,configuration,5169,"ooArgSetfAlternateParamsRooArgSet specifying alternate parameters for hypothesis test // Is it used ????; RooArgSetfConditionalObsRooArgSet specifying the conditional observables; RooAbsData*fData; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetNullModel(const RooStats::ModelConfig& ). void SetAlternateModel(const RooStats::ModelConfig& ). void SetPdf(RooAbsPdf& pdf); specific setting - keep for convenience- some of them could be removed; Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet&",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:410,Integrability,interface,interface,410,". RooStats::CombinedCalculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::CombinedCalculator. class RooStats::CombinedCalculator: public RooStats::IntervalCalculator, public RooStats::HypoTestCalculator. CombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals. ; The interface currently assumes that any such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class();",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:511,Integrability,interface,interface,511,". RooStats::CombinedCalculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::CombinedCalculator. class RooStats::CombinedCalculator: public RooStats::IntervalCalculator, public RooStats::HypoTestCalculator. CombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals. ; The interface currently assumes that any such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class();",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1000,Integrability,interface,interface,1000,"omepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::CombinedCalculator. class RooStats::CombinedCalculator: public RooStats::IntervalCalculator, public RooStats::HypoTestCalculator. CombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals. ; The interface currently assumes that any such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); R",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1116,Integrability,interface,interface,1116,"nction members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::CombinedCalculator. class RooStats::CombinedCalculator: public RooStats::IntervalCalculator, public RooStats::HypoTestCalculator. CombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals. ; The interface currently assumes that any such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); RooStats::CombinedCalculatorCombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorCombin",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1447,Integrability,interface,interface,1447,"oTestResults and ConfIntervals. ; The interface currently assumes that any such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); RooStats::CombinedCalculatorCombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const Roo",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1538,Integrability,integrat,integration,1538,"ny such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); RooStats::CombinedCalculatorCombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0); virtual Double_",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1635,Integrability,interface,interface,1635," model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); RooStats::CombinedCalculatorCombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0); virtual Double_tConfidenceLevel() const; virtual RooStats::HypoTestRes",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1671,Integrability,interface,interface,1671," set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); RooStats::CombinedCalculatorCombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0); virtual Double_tConfidenceLevel() const; virtual RooStats::HypoTestResult*GetHypoTest() const; virtual RooStats::ConfInterval*GetInterval() const; RooStats::HypoTestCalculatorRooStats",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:5318,Integrability,interface,interface,5318,"rvables; RooAbsData*fData; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetNullModel(const RooStats::ModelConfig& ). void SetAlternateModel(const RooStats::ModelConfig& ). void SetPdf(RooAbsPdf& pdf); specific setting - keep for convenience- some of them could be removed; Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance par",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:5407,Integrability,interface,interface,5407,"or interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetNullModel(const RooStats::ModelConfig& ). void SetAlternateModel(const RooStats::ModelConfig& ). void SetPdf(RooAbsPdf& pdf); specific setting - keep for convenience- some of them could be removed; Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:571,Modifiability,config,configured,571,". RooStats::CombinedCalculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::CombinedCalculator. class RooStats::CombinedCalculator: public RooStats::IntervalCalculator, public RooStats::HypoTestCalculator. CombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals. ; The interface currently assumes that any such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class();",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1239,Modifiability,config,configuring,1239,"oStats::IntervalCalculator, public RooStats::HypoTestCalculator. CombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals. ; The interface currently assumes that any such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); RooStats::CombinedCalculatorCombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); RooStats::CombinedCalculatorCombinedCalculat",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:5169,Modifiability,config,configuration,5169,"ooArgSetfAlternateParamsRooArgSet specifying alternate parameters for hypothesis test // Is it used ????; RooArgSetfConditionalObsRooArgSet specifying the conditional observables; RooAbsData*fData; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetNullModel(const RooStats::ModelConfig& ). void SetAlternateModel(const RooStats::ModelConfig& ). void SetPdf(RooAbsPdf& pdf); specific setting - keep for convenience- some of them could be removed; Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet&",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:1575,Testability,test,test-statistic,1575," model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); RooStats::CombinedCalculatorCombinedCalculator(); RooStats::CombinedCalculatorCombinedCalculator(const RooStats::CombinedCalculator&); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); RooStats::CombinedCalculatorCombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0); virtual Double_tConfidenceLevel() const; virtual RooStats::HypoTestRes",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:4230,Testability,test,test,4230," virtual voidSetConditionalObservables(const RooArgSet& set); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); virtual voidSetModel(const RooStats::ModelConfig& model); virtual voidSetNuisanceParameters(const RooArgSet& set); virtual voidSetNullModel(const RooStats::ModelConfig&); virtual voidSetNullParameters(const RooArgSet& set); virtual voidSetParameters(const RooArgSet& set); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooAbsData*GetData() const; RooAbsPdf*GetPdf() const. Data Members; protected:. RooArgSetfAlternateParamsRooArgSet specifying alternate parameters for hypothesis test // Is it used ????; RooArgSetfConditionalObsRooArgSet specifying the conditional observables; RooAbsData*fData; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* Get",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:4494,Testability,test,test,4494," virtual voidSetConditionalObservables(const RooArgSet& set); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); virtual voidSetModel(const RooStats::ModelConfig& model); virtual voidSetNuisanceParameters(const RooArgSet& set); virtual voidSetNullModel(const RooStats::ModelConfig&); virtual voidSetNullParameters(const RooArgSet& set); virtual voidSetParameters(const RooArgSet& set); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooAbsData*GetData() const; RooAbsPdf*GetPdf() const. Data Members; protected:. RooArgSetfAlternateParamsRooArgSet specifying alternate parameters for hypothesis test // Is it used ????; RooArgSetfConditionalObsRooArgSet specifying the conditional observables; RooAbsData*fData; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* Get",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:4612,Testability,test,test,4612," virtual voidSetConditionalObservables(const RooArgSet& set); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); virtual voidSetModel(const RooStats::ModelConfig& model); virtual voidSetNuisanceParameters(const RooArgSet& set); virtual voidSetNullModel(const RooStats::ModelConfig&); virtual voidSetNullParameters(const RooArgSet& set); virtual voidSetParameters(const RooArgSet& set); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. RooAbsData*GetData() const; RooAbsPdf*GetPdf() const. Data Members; protected:. RooArgSetfAlternateParamsRooArgSet specifying alternate parameters for hypothesis test // Is it used ????; RooArgSetfConditionalObsRooArgSet specifying the conditional observables; RooAbsData*fData; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* Get",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:5639,Testability,test,test,5639," specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetNullModel(const RooStats::ModelConfig& ). void SetAlternateModel(const RooStats::ModelConfig& ). void SetPdf(RooAbsPdf& pdf); specific setting - keep for convenience- some of them could be removed; Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetNullParameters(const RooArgSet& set); set parameter values for the null if using a common PDF. {fNullParams.removeAll(); fNullParams.add(set);}. void SetAlternateParameters(const RooArgSet& set); set p",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__CombinedCalculator.html:5756,Testability,test,test,5756,"nction documentation; CombinedCalculator(); {}. CombinedCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0, const RooArgSet* altParams = 0, const RooArgSet* nuisParams = 0). SetTestSize(Double_t size). CombinedCalculator(RooAbsData& data, const RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); constructor from data and model configuration. SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetNullModel(const RooStats::ModelConfig& ). void SetAlternateModel(const RooStats::ModelConfig& ). void SetPdf(RooAbsPdf& pdf); specific setting - keep for convenience- some of them could be removed; Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetNullParameters(const RooArgSet& set); set parameter values for the null if using a common PDF. {fNullParams.removeAll(); fNullParams.add(set);}. void SetAlternateParameters(const RooArgSet& set); set parameter values for the alternate if using a common PDF. {fAlternateParams.removeAll(); fAlternateParam",MatchSource.WIKI,root/html602/RooStats__CombinedCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__CombinedCalculator.html
https://root.cern/root/html602/RooStats__ConfidenceBelt.html:2464,Availability,error,error,2464,"ndex, Double_t lower, Double_t upper, Double_t cl = -1., Double_t leftside = -1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckParameters(RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; RooStats::ConfidenceBeltConfidenceBelt(); RooStats::ConfidenceBeltConfidenceBelt(const char* name); RooStats::ConfidenceBeltConfidenceBelt(const RooStats::ConfidenceBelt&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title); RooStats::ConfidenceBeltConfidenceBelt(const char* name, RooAbsData&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title, RooAbsData&); vector<Double_t>ConfidenceLevels() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooStats::AcceptanceRegion*GetAcceptanceRegion(RooArgSet&, Double_t cl = -1., Double_t leftside = -1.); Double_tGetAcceptanceRegionMax(RooArgSet&, Double_t ",MatchSource.WIKI,root/html602/RooStats__ConfidenceBelt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfidenceBelt.html
https://root.cern/root/html602/RooStats__ConfidenceBelt.html:2548,Availability,error,error,2548,"ndex, Double_t lower, Double_t upper, Double_t cl = -1., Double_t leftside = -1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckParameters(RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; RooStats::ConfidenceBeltConfidenceBelt(); RooStats::ConfidenceBeltConfidenceBelt(const char* name); RooStats::ConfidenceBeltConfidenceBelt(const RooStats::ConfidenceBelt&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title); RooStats::ConfidenceBeltConfidenceBelt(const char* name, RooAbsData&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title, RooAbsData&); vector<Double_t>ConfidenceLevels() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooStats::AcceptanceRegion*GetAcceptanceRegion(RooArgSet&, Double_t cl = -1., Double_t leftside = -1.); Double_tGetAcceptanceRegionMax(RooArgSet&, Double_t ",MatchSource.WIKI,root/html602/RooStats__ConfidenceBelt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfidenceBelt.html
https://root.cern/root/html602/RooStats__ConfidenceBelt.html:402,Integrability,interface,interface,402,". RooStats::ConfidenceBelt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ConfidenceBelt. class RooStats::ConfidenceBelt: public TNamed. ConfidenceBelt is a concrete implementation of the ConfInterval interface. ; It implements simple general purpose interval of arbitrary dimensions and shape.; It does not assume the interval is connected.; It uses either a RooDataSet (eg. a list of parameter points in the interval) or; a RooDataHist (eg. a Histogram-like object for small regions of the parameter space) to; store the interval. ; . Function Members (Methods); public:. virtual~ConfidenceBelt(); voidTObject::AbstractMethod(const char* method) const; voidAddAcceptanceRegion(RooArgSet&, RooStats::AcceptanceRegion region, Double_t cl = -1., Double_t leftside = -1.); voidAddAcceptanceRegion(RooArgSet& point, Int_t dataSetIndex, Double_t lower, Double_t upper, Double_t cl = -1., Double_t leftside = -1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckParameters(RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; RooStats::ConfidenceBeltConfidenceBelt(); RooStats::ConfidenceBeltConfidenceBelt(const char* name); RooStats::ConfidenceBeltConfidenceBelt(const RooStats::ConfidenceBelt&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title); RooStats::ConfidenceBeltConfidenceBelt(const char* name, RooAbsData&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title, RooAbsData&); vector<Double_t>ConfidenceLevels() const; virtual voidTNamed::Copy(TObject& named) const; virtual void",MatchSource.WIKI,root/html602/RooStats__ConfidenceBelt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfidenceBelt.html
https://root.cern/root/html602/RooStats__ConfidenceBelt.html:429,Usability,simpl,simple,429,". RooStats::ConfidenceBelt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ConfidenceBelt. class RooStats::ConfidenceBelt: public TNamed. ConfidenceBelt is a concrete implementation of the ConfInterval interface. ; It implements simple general purpose interval of arbitrary dimensions and shape.; It does not assume the interval is connected.; It uses either a RooDataSet (eg. a list of parameter points in the interval) or; a RooDataHist (eg. a Histogram-like object for small regions of the parameter space) to; store the interval. ; . Function Members (Methods); public:. virtual~ConfidenceBelt(); voidTObject::AbstractMethod(const char* method) const; voidAddAcceptanceRegion(RooArgSet&, RooStats::AcceptanceRegion region, Double_t cl = -1., Double_t leftside = -1.); voidAddAcceptanceRegion(RooArgSet& point, Int_t dataSetIndex, Double_t lower, Double_t upper, Double_t cl = -1., Double_t leftside = -1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckParameters(RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; RooStats::ConfidenceBeltConfidenceBelt(); RooStats::ConfidenceBeltConfidenceBelt(const char* name); RooStats::ConfidenceBeltConfidenceBelt(const RooStats::ConfidenceBelt&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title); RooStats::ConfidenceBeltConfidenceBelt(const char* name, RooAbsData&); RooStats::ConfidenceBeltConfidenceBelt(const char* name, const char* title, RooAbsData&); vector<Double_t>ConfidenceLevels() const; virtual voidTNamed::Copy(TObject& named) const; virtual void",MatchSource.WIKI,root/html602/RooStats__ConfidenceBelt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfidenceBelt.html
https://root.cern/root/html602/RooStats__ConfInterval.html:1037,Availability,avail,available,1037,"ck Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ConfInterval. class RooStats::ConfInterval: public TNamed. ConfInterval is an interface class for a generic interval in the RooStats framework.; Any tool inheriting from IntervalCalculator can return a ConfInterval.; There are many types of intervals, they may be a simple range [a,b] in 1 dimension,; or they may be disconnected regions in multiple dimensions.; So the common interface is simply to ask the interval if a given point ""IsInInterval"".; The Interval also knows what confidence level it was constructed at and the space of ; parameters for which it was constructed.; Note, one could use the same class for a Bayesian ""credible interval"".; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ConfInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; RooStats::ConfIntervalConfInterval(const char* name = 0); RooStats::ConfIntervalConfInterval(const RooStats::ConfInterval&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") co",MatchSource.WIKI,root/html602/RooStats__ConfInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfInterval.html
https://root.cern/root/html602/RooStats__ConfInterval.html:2230,Availability,error,error,2230,"TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; RooStats::ConfIntervalConfInterval(const char* name = 0); RooStats::ConfIntervalConfInterval(const RooStats::ConfInterval&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual RooArgSet*GetParameters() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, cons",MatchSource.WIKI,root/html602/RooStats__ConfInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfInterval.html
https://root.cern/root/html602/RooStats__ConfInterval.html:2314,Availability,error,error,2314,"lass(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; RooStats::ConfIntervalConfInterval(const char* name = 0); RooStats::ConfIntervalConfInterval(const RooStats::ConfInterval&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual RooArgSet*GetParameters() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) co",MatchSource.WIKI,root/html602/RooStats__ConfInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfInterval.html
https://root.cern/root/html602/RooStats__ConfInterval.html:327,Integrability,interface,interface,327,". RooStats::ConfInterval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ConfInterval. class RooStats::ConfInterval: public TNamed. ConfInterval is an interface class for a generic interval in the RooStats framework.; Any tool inheriting from IntervalCalculator can return a ConfInterval.; There are many types of intervals, they may be a simple range [a,b] in 1 dimension,; or they may be disconnected regions in multiple dimensions.; So the common interface is simply to ask the interval if a given point ""IsInInterval"".; The Interval also knows what confidence level it was constructed at and the space of ; parameters for which it was constructed.; Note, one could use the same class for a Bayesian ""credible interval"".; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ConfInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; RooStats::ConfIntervalConfInterval(const char* name = 0); RooStats::ConfIntervalConfInterval(const RooStats::ConfInterval&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawCl",MatchSource.WIKI,root/html602/RooStats__ConfInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfInterval.html
https://root.cern/root/html602/RooStats__ConfInterval.html:626,Integrability,interface,interface,626,". RooStats::ConfInterval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ConfInterval. class RooStats::ConfInterval: public TNamed. ConfInterval is an interface class for a generic interval in the RooStats framework.; Any tool inheriting from IntervalCalculator can return a ConfInterval.; There are many types of intervals, they may be a simple range [a,b] in 1 dimension,; or they may be disconnected regions in multiple dimensions.; So the common interface is simply to ask the interval if a given point ""IsInInterval"".; The Interval also knows what confidence level it was constructed at and the space of ; parameters for which it was constructed.; Note, one could use the same class for a Bayesian ""credible interval"".; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ConfInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; RooStats::ConfIntervalConfInterval(const char* name = 0); RooStats::ConfIntervalConfInterval(const RooStats::ConfInterval&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawCl",MatchSource.WIKI,root/html602/RooStats__ConfInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfInterval.html
https://root.cern/root/html602/RooStats__ConfInterval.html:403,Modifiability,inherit,inheriting,403,". RooStats::ConfInterval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ConfInterval. class RooStats::ConfInterval: public TNamed. ConfInterval is an interface class for a generic interval in the RooStats framework.; Any tool inheriting from IntervalCalculator can return a ConfInterval.; There are many types of intervals, they may be a simple range [a,b] in 1 dimension,; or they may be disconnected regions in multiple dimensions.; So the common interface is simply to ask the interval if a given point ""IsInInterval"".; The Interval also knows what confidence level it was constructed at and the space of ; parameters for which it was constructed.; Note, one could use the same class for a Bayesian ""credible interval"".; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ConfInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; RooStats::ConfIntervalConfInterval(const char* name = 0); RooStats::ConfIntervalConfInterval(const RooStats::ConfInterval&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawCl",MatchSource.WIKI,root/html602/RooStats__ConfInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfInterval.html
https://root.cern/root/html602/RooStats__ConfInterval.html:515,Usability,simpl,simple,515,". RooStats::ConfInterval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ConfInterval. class RooStats::ConfInterval: public TNamed. ConfInterval is an interface class for a generic interval in the RooStats framework.; Any tool inheriting from IntervalCalculator can return a ConfInterval.; There are many types of intervals, they may be a simple range [a,b] in 1 dimension,; or they may be disconnected regions in multiple dimensions.; So the common interface is simply to ask the interval if a given point ""IsInInterval"".; The Interval also knows what confidence level it was constructed at and the space of ; parameters for which it was constructed.; Note, one could use the same class for a Bayesian ""credible interval"".; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ConfInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; RooStats::ConfIntervalConfInterval(const char* name = 0); RooStats::ConfIntervalConfInterval(const RooStats::ConfInterval&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawCl",MatchSource.WIKI,root/html602/RooStats__ConfInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfInterval.html
https://root.cern/root/html602/RooStats__ConfInterval.html:639,Usability,simpl,simply,639,". RooStats::ConfInterval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ConfInterval. class RooStats::ConfInterval: public TNamed. ConfInterval is an interface class for a generic interval in the RooStats framework.; Any tool inheriting from IntervalCalculator can return a ConfInterval.; There are many types of intervals, they may be a simple range [a,b] in 1 dimension,; or they may be disconnected regions in multiple dimensions.; So the common interface is simply to ask the interval if a given point ""IsInInterval"".; The Interval also knows what confidence level it was constructed at and the space of ; parameters for which it was constructed.; Note, one could use the same class for a Bayesian ""credible interval"".; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ConfInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; RooStats::ConfIntervalConfInterval(const char* name = 0); RooStats::ConfIntervalConfInterval(const RooStats::ConfInterval&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawCl",MatchSource.WIKI,root/html602/RooStats__ConfInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__ConfInterval.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:748,Availability,avail,available,748,". RooStats::DebuggingSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::DebuggingSampler. class RooStats::DebuggingSampler: public RooStats::TestStatSampler. DebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingSampler(); static TClass*Class(); virtual Double_tConfidenceLevel() const; RooStats::DebuggingSamplerDebuggingSampler(); RooStats::DebuggingSamplerDebuggingSampler(const RooStats::DebuggingSampler&); virtual Double_tEvaluateTestStatistic(RooAbsData&, RooArgSet&); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramsOfInterest); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; RooStats::DebuggingSampler&operator=(const RooStats::DebuggingSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidRooStats::TestStatSampler::SetObservables(const RooArgSet&); virtual voidSetParameters(RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidRooStats::TestStatSampler::SetPriorNuisance(RooAbsPdf*); virtual voidRooStats::TestStatSampler::SetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberIn",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:3574,Availability,error,error,3574,"mpler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (want the argument to be a function of the data & parameter points. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:410,Integrability,interface,interface,410,". RooStats::DebuggingSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::DebuggingSampler. class RooStats::DebuggingSampler: public RooStats::TestStatSampler. DebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingSampler(); static TClass*Class(); virtual Double_tConfidenceLevel() const; RooStats::DebuggingSamplerDebuggingSampler(); RooStats::DebuggingSamplerDebuggingSampler(const RooStats::DebuggingSampler&); virtual Double_tEvaluateTestStatistic(RooAbsData&, RooArgSet&); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramsOfInterest); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; RooStats::DebuggingSampler&operator=(const RooStats::DebuggingSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidRooStats::TestStatSampler::SetObservables(const RooArgSet&); virtual voidSetParameters(RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidRooStats::TestStatSampler::SetPriorNuisance(RooAbsPdf*); virtual voidRooStats::TestStatSampler::SetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberIn",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:2591,Integrability,interface,interface,2591,"ables(const RooArgSet&); virtual voidSetParameters(RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidRooStats::TestStatSampler::SetPriorNuisance(RooAbsPdf*); virtual voidRooStats::TestStatSampler::SetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(const RooStats::TestStatSampler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:2702,Integrability,interface,interface,2702,"tual voidSetPdf(RooAbsPdf&); virtual voidRooStats::TestStatSampler::SetPriorNuisance(RooAbsPdf*); virtual voidRooStats::TestStatSampler::SetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(const RooStats::TestStatSampler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:575,Testability,test,tests,575,". RooStats::DebuggingSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::DebuggingSampler. class RooStats::DebuggingSampler: public RooStats::TestStatSampler. DebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingSampler(); static TClass*Class(); virtual Double_tConfidenceLevel() const; RooStats::DebuggingSamplerDebuggingSampler(); RooStats::DebuggingSamplerDebuggingSampler(const RooStats::DebuggingSampler&); virtual Double_tEvaluateTestStatistic(RooAbsData&, RooArgSet&); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramsOfInterest); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; RooStats::DebuggingSampler&operator=(const RooStats::DebuggingSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidRooStats::TestStatSampler::SetObservables(const RooArgSet&); virtual voidSetParameters(RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidRooStats::TestStatSampler::SetPriorNuisance(RooAbsPdf*); virtual voidRooStats::TestStatSampler::SetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberIn",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:2728,Testability,test,test,2728,"tual voidSetPdf(RooAbsPdf&); virtual voidRooStats::TestStatSampler::SetPriorNuisance(RooAbsPdf*); virtual voidRooStats::TestStatSampler::SetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(const RooStats::TestStatSampler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:2888,Testability,test,test,2888,"st char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(const RooStats::TestStatSampler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (wan",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:3393,Testability,test,test,3393,"mpler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (want the argument to be a function of the data & parameter points. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:3553,Testability,test,test,3553,"mpler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (want the argument to be a function of the data & parameter points. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingSampler.html:361,Usability,simpl,simple,361,". RooStats::DebuggingSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::DebuggingSampler. class RooStats::DebuggingSampler: public RooStats::TestStatSampler. DebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingSampler(); static TClass*Class(); virtual Double_tConfidenceLevel() const; RooStats::DebuggingSamplerDebuggingSampler(); RooStats::DebuggingSamplerDebuggingSampler(const RooStats::DebuggingSampler&); virtual Double_tEvaluateTestStatistic(RooAbsData&, RooArgSet&); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramsOfInterest); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; RooStats::DebuggingSampler&operator=(const RooStats::DebuggingSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidRooStats::TestStatSampler::SetObservables(const RooArgSet&); virtual voidSetParameters(RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidRooStats::TestStatSampler::SetPriorNuisance(RooAbsPdf*); virtual voidRooStats::TestStatSampler::SetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberIn",MatchSource.WIKI,root/html602/RooStats__DebuggingSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html
https://root.cern/root/html602/RooStats__DebuggingTestStat.html:750,Availability,avail,available,750,". RooStats::DebuggingTestStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::DebuggingTestStat. class RooStats::DebuggingTestStat: public RooStats::TestStatistic. DebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingTestStat(); static TClass*Class(); RooStats::DebuggingTestStatDebuggingTestStat(); RooStats::DebuggingTestStatDebuggingTestStat(const RooStats::DebuggingTestStat&); virtual Double_tEvaluate(RooAbsData&, RooArgSet&); virtual const RooArgSet*RooStats::TestStatistic::GetDetailedOutput() const; virtual const TStringRooStats::TestStatistic::GetVarName() const; virtual TClass*IsA() const; RooStats::DebuggingTestStat&operator=(const RooStats::DebuggingTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(const RooStats::TestStatistic&). Data Members; private:. TRandom*fRand; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingTestStat(). virtual ~DebuggingTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. » Author: Kyle ",MatchSource.WIKI,root/html602/RooStats__DebuggingTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingTestStat.html
https://root.cern/root/html602/RooStats__DebuggingTestStat.html:412,Integrability,interface,interface,412,". RooStats::DebuggingTestStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::DebuggingTestStat. class RooStats::DebuggingTestStat: public RooStats::TestStatistic. DebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingTestStat(); static TClass*Class(); RooStats::DebuggingTestStatDebuggingTestStat(); RooStats::DebuggingTestStatDebuggingTestStat(const RooStats::DebuggingTestStat&); virtual Double_tEvaluate(RooAbsData&, RooArgSet&); virtual const RooArgSet*RooStats::TestStatistic::GetDetailedOutput() const; virtual const TStringRooStats::TestStatistic::GetVarName() const; virtual TClass*IsA() const; RooStats::DebuggingTestStat&operator=(const RooStats::DebuggingTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(const RooStats::TestStatistic&). Data Members; private:. TRandom*fRand; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingTestStat(). virtual ~DebuggingTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. » Author: Kyle ",MatchSource.WIKI,root/html602/RooStats__DebuggingTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingTestStat.html
https://root.cern/root/html602/RooStats__DebuggingTestStat.html:1931,Integrability,interface,interface,1931,"gingTestStat is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingTestStat(); static TClass*Class(); RooStats::DebuggingTestStatDebuggingTestStat(); RooStats::DebuggingTestStatDebuggingTestStat(const RooStats::DebuggingTestStat&); virtual Double_tEvaluate(RooAbsData&, RooArgSet&); virtual const RooArgSet*RooStats::TestStatistic::GetDetailedOutput() const; virtual const TStringRooStats::TestStatistic::GetVarName() const; virtual TClass*IsA() const; RooStats::DebuggingTestStat&operator=(const RooStats::DebuggingTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(const RooStats::TestStatistic&). Data Members; private:. TRandom*fRand; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingTestStat(). virtual ~DebuggingTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__DebuggingTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingTestStat.html
https://root.cern/root/html602/RooStats__DebuggingTestStat.html:577,Testability,test,tests,577,". RooStats::DebuggingTestStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::DebuggingTestStat. class RooStats::DebuggingTestStat: public RooStats::TestStatistic. DebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingTestStat(); static TClass*Class(); RooStats::DebuggingTestStatDebuggingTestStat(); RooStats::DebuggingTestStatDebuggingTestStat(const RooStats::DebuggingTestStat&); virtual Double_tEvaluate(RooAbsData&, RooArgSet&); virtual const RooArgSet*RooStats::TestStatistic::GetDetailedOutput() const; virtual const TStringRooStats::TestStatistic::GetVarName() const; virtual TClass*IsA() const; RooStats::DebuggingTestStat&operator=(const RooStats::DebuggingTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(const RooStats::TestStatistic&). Data Members; private:. TRandom*fRand; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingTestStat(). virtual ~DebuggingTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. » Author: Kyle ",MatchSource.WIKI,root/html602/RooStats__DebuggingTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingTestStat.html
https://root.cern/root/html602/RooStats__DebuggingTestStat.html:1957,Testability,test,test,1957,"gingTestStat is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingTestStat(); static TClass*Class(); RooStats::DebuggingTestStatDebuggingTestStat(); RooStats::DebuggingTestStatDebuggingTestStat(const RooStats::DebuggingTestStat&); virtual Double_tEvaluate(RooAbsData&, RooArgSet&); virtual const RooArgSet*RooStats::TestStatistic::GetDetailedOutput() const; virtual const TStringRooStats::TestStatistic::GetVarName() const; virtual TClass*IsA() const; RooStats::DebuggingTestStat&operator=(const RooStats::DebuggingTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(const RooStats::TestStatistic&). Data Members; private:. TRandom*fRand; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingTestStat(). virtual ~DebuggingTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__DebuggingTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingTestStat.html
https://root.cern/root/html602/RooStats__DebuggingTestStat.html:363,Usability,simpl,simple,363,". RooStats::DebuggingTestStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::DebuggingTestStat. class RooStats::DebuggingTestStat: public RooStats::TestStatistic. DebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingTestStat(); static TClass*Class(); RooStats::DebuggingTestStatDebuggingTestStat(); RooStats::DebuggingTestStatDebuggingTestStat(const RooStats::DebuggingTestStat&); virtual Double_tEvaluate(RooAbsData&, RooArgSet&); virtual const RooArgSet*RooStats::TestStatistic::GetDetailedOutput() const; virtual const TStringRooStats::TestStatistic::GetVarName() const; virtual TClass*IsA() const; RooStats::DebuggingTestStat&operator=(const RooStats::DebuggingTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(const RooStats::TestStatistic&). Data Members; private:. TRandom*fRand; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingTestStat(). virtual ~DebuggingTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. » Author: Kyle ",MatchSource.WIKI,root/html602/RooStats__DebuggingTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingTestStat.html
https://root.cern/root/html602/RooStats__DetailedOutputAggregator.html:1591,Modifiability,variab,variable,1591,"torDetailedOutputAggregator(); RooStats::DetailedOutputAggregatorDetailedOutputAggregator(const RooStats::DetailedOutputAggregator&); const RooArgList*GetAsArgList() const; static RooArgSet*GetAsArgSet(RooFitResult* result, TString prefix = """", bool withErrorsAndPulls = false); RooDataSet*GetAsDataSet(TString name, TString title); virtual TClass*IsA() const; RooStats::DetailedOutputAggregator&operator=(const RooStats::DetailedOutputAggregator&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. RooArgList*fBuiltSet; RooDataSet*fResult. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~DetailedOutputAggregator(); destructor. RooArgSet * GetAsArgSet(RooFitResult* result, TString prefix = """", bool withErrorsAndPulls = false); static function to translate the given fit result to a RooArgSet in a generic way.; Prefix is prepended to all variable names.; LM: caller is responsible to delete the returned list and eventually also the content of the list; Note that the returned list is not owning the returned content. void AppendArgSet(const RooAbsCollection* aset, TString prefix = """"); For each variable in aset, prepend prefix to its name and add; to the internal store. Note this will not appear in the produced; dataset unless CommitSet is called. void CommitSet(double weight = 1.). RooDataSet * GetAsDataSet(TString name, TString title); Returns all detailed output as a dataset.; Ownership of the dataset is transferred to the caller. DetailedOutputAggregator(). const RooArgList* GetAsArgList() const; Returns this set of detailed output.; Note that the ownership of the returned list is not transfered; It is managed by the DetailedOutputAggregator class. » Author: Sven Kreiss, Kyle Cranmer Nov 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-0",MatchSource.WIKI,root/html602/RooStats__DetailedOutputAggregator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DetailedOutputAggregator.html
https://root.cern/root/html602/RooStats__DetailedOutputAggregator.html:1850,Modifiability,variab,variable,1850,"onst; static RooArgSet*GetAsArgSet(RooFitResult* result, TString prefix = """", bool withErrorsAndPulls = false); RooDataSet*GetAsDataSet(TString name, TString title); virtual TClass*IsA() const; RooStats::DetailedOutputAggregator&operator=(const RooStats::DetailedOutputAggregator&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. RooArgList*fBuiltSet; RooDataSet*fResult. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~DetailedOutputAggregator(); destructor. RooArgSet * GetAsArgSet(RooFitResult* result, TString prefix = """", bool withErrorsAndPulls = false); static function to translate the given fit result to a RooArgSet in a generic way.; Prefix is prepended to all variable names.; LM: caller is responsible to delete the returned list and eventually also the content of the list; Note that the returned list is not owning the returned content. void AppendArgSet(const RooAbsCollection* aset, TString prefix = """"); For each variable in aset, prepend prefix to its name and add; to the internal store. Note this will not appear in the produced; dataset unless CommitSet is called. void CommitSet(double weight = 1.). RooDataSet * GetAsDataSet(TString name, TString title); Returns all detailed output as a dataset.; Ownership of the dataset is transferred to the caller. DetailedOutputAggregator(). const RooArgList* GetAsArgList() const; Returns this set of detailed output.; Note that the ownership of the returned list is not transfered; It is managed by the DetailedOutputAggregator class. » Author: Sven Kreiss, Kyle Cranmer Nov 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooStats__DetailedOutputAggregator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__DetailedOutputAggregator.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:4105,Availability,error,error,4105,"fer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t Confi",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:5090,Availability,error,error,5090,"fied rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. RooAbsData* GetPointsToScan(). ConfidenceBelt* GetConfidenceBelt(); {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true);",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:5747,Availability,error,error,5747,"the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. RooAbsData* GetPointsToScan(). ConfidenceBelt* GetConfidenceBelt(); {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true); {fAdaptiveSampling=flag;}. void AdditionalNToysFactor(double fact); {fAdditionalNToysFactor = fact;}. void SetNBins(Int_t bins); {fNbins = bins;}. void FluctuateNumDataEntries(bool flag = true); {fFluctuateData = flag;}. void SaveBeltToFile(bool flag = true). void CreateConfBelt(bool flag = true); {fCreateBelt = flag;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:448,Deployability,configurat,configuration,448,". RooStats::FeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::FeldmanCousins. class RooStats::FeldmanCousins: public RooStats::IntervalCalculator. The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a specific configuration; of the more general NeymanConstruction. It is a concrete implementation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFlu",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:1033,Deployability,integrat,integration,1033,". RooStats::FeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::FeldmanCousins. class RooStats::FeldmanCousins: public RooStats::IntervalCalculator. The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a specific configuration; of the more general NeymanConstruction. It is a concrete implementation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFlu",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:3350,Energy Efficiency,adapt,adaptive,3350,"tNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramete",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:561,Integrability,interface,interface,561,". RooStats::FeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::FeldmanCousins. class RooStats::FeldmanCousins: public RooStats::IntervalCalculator. The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a specific configuration; of the more general NeymanConstruction. It is a concrete implementation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFlu",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:799,Integrability,interface,interface,799,". RooStats::FeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::FeldmanCousins. class RooStats::FeldmanCousins: public RooStats::IntervalCalculator. The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a specific configuration; of the more general NeymanConstruction. It is a concrete implementation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFlu",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:1033,Integrability,integrat,integration,1033,". RooStats::FeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::FeldmanCousins. class RooStats::FeldmanCousins: public RooStats::IntervalCalculator. The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a specific configuration; of the more general NeymanConstruction. It is a concrete implementation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFlu",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:4831,Integrability,interface,interface,4831,"able; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfiden",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:448,Modifiability,config,configuration,448,". RooStats::FeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::FeldmanCousins. class RooStats::FeldmanCousins: public RooStats::IntervalCalculator. The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a specific configuration; of the more general NeymanConstruction. It is a concrete implementation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFlu",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:1126,Modifiability,config,configured,1126," source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::FeldmanCousins. class RooStats::FeldmanCousins: public RooStats::IntervalCalculator. The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a specific configuration; of the more general NeymanConstruction. It is a concrete implementation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFluctuateNumDataEntries(bool flag = true); RooStats::ConfidenceBelt*GetConfidenceBelt(); virtual RooStats::PointSetInterval*GetInterval() const; RooAbsD",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:3350,Modifiability,adapt,adaptive,3350,"tNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramete",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:3825,Modifiability,variab,variable,3825,"tNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramete",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:1469,Performance,perform,perform,1469,"mentation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFluctuateNumDataEntries(bool flag = true); RooStats::ConfidenceBelt*GetConfidenceBelt(); virtual RooStats::PointSetInterval*GetInterval() const; RooAbsData*GetPointsToScan(); RooStats::TestStatSampler*GetTestStatSampler() const; RooStats::IntervalCalculatorRooStats::IntervalCalculator::IntervalCalculator(); RooStats::IntervalCalculatorRooStats::IntervalCalculator::IntervalCalculator(const RooStats::IntervalCalculator&); virtual TClass*IsA() const; RooStats::FeldmanCousins&operator=(const RooStats::FeldmanCousins&); voidSa",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:3879,Performance,perform,perform,3879,"tNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramete",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:3939,Performance,perform,perform,3939,"tNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramete",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:4707,Performance,perform,perform,4707,"_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTest",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:1004,Testability,test,test,1004,". RooStats::FeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::FeldmanCousins. class RooStats::FeldmanCousins: public RooStats::IntervalCalculator. The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a specific configuration; of the more general NeymanConstruction. It is a concrete implementation of the IntervalCalculator interface that, which uses the NeymanConstruction in a particular way. As the name suggests, it returns a ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. . In the case of the Feldman-Cousins approach, the ordering principle is the likelihood ratio -- motivated; by the Neyman-Pearson lemma. When nuisance parameters are involved, the profile likelihood ratio is the natural generalization. One may either choose to perform the construction over the full space of the nuisance parameters, or restrict the nusiance parameters to their conditional MLE (eg. profiled values). . Function Members (Methods); public:. virtual~FeldmanCousins(); voidAdditionalNToysFactor(double fact); static TClass*Class(); virtual Double_tConfidenceLevel() const; voidCreateConfBelt(bool flag = true); RooStats::FeldmanCousinsFeldmanCousins(const RooStats::FeldmanCousins&); RooStats::FeldmanCousinsFeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); voidFlu",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:4070,Testability,test,test,4070,"tNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramete",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
https://root.cern/root/html602/RooStats__FeldmanCousins.html:4156,Testability,test,test,4156,"fer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t Confi",MatchSource.WIKI,root/html602/RooStats__FeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html
