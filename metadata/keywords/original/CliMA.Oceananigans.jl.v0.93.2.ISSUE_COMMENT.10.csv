id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983809077:165,Availability,mask,mask,165,I am in favor of not doing 979c2a7. It hardcodes a change in the source code that is only required for aesthetic reasons. I would wait for #3092 and in the meantime mask the output in the example,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983809077
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983852170:259,Availability,mask,mask,259,"> I am in favor of not doing [979c2a7](https://github.com/CliMA/Oceananigans.jl/commit/979c2a7cd10c1f2054cad996622cafd2e3fb3ffa). It hardcodes a change in the source code that is only required for aesthetic reasons. I would wait for #3092 and in the meantime mask the output in the example. Deal, done",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983852170
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986373058:259,Availability,mask,mask,259,"> I am in favor of not doing [979c2a7](https://github.com/CliMA/Oceananigans.jl/commit/979c2a7cd10c1f2054cad996622cafd2e3fb3ffa). It hardcodes a change in the source code that is only required for aesthetic reasons. I would wait for #3092 and in the meantime mask the output in the example. I agree with @simone-silvestri that we want this feature, but that it should be done properly",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986373058
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358:209,Availability,mask,mask,209,"> > Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that.; > ; > We can.; > ; > We can also mask the output after we load it, e.g, via; > ; > using something like; > ; > ```julia; > using Oceananigans.ImmersedBoundaries: mask_immersed_field!; > ; > function mask_and_get_interior(φ_t, n; value=NaN); > mask_immersed_field!(φ_t[n], value); > return interior(φ_t[n], :, 1, :); > end; > ; > u′ₙ = @lift mask_and_get_interior(u′_t, $n); > ```; > ; > which gives; > ; > internal_tide.mp4 ; > But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that. I think we should mask the solution during visualization in the script. This is actually what users will need to do currently to make decent visualizations, so it is good to illustrate how to do it --- even if, hopefully, we will eventually have a better solution. As for plotting a shape on top, I'm inclined to encourage visualization that directly represents the domain / data for the purposes of an Oceananigans example. I think its ok if people want to incorporate visualizations like that in their own work but we may not want to promote it as ""the best"" way to visualize complex domains in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358:876,Availability,mask,mask,876,"> > Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that.; > ; > We can.; > ; > We can also mask the output after we load it, e.g, via; > ; > using something like; > ; > ```julia; > using Oceananigans.ImmersedBoundaries: mask_immersed_field!; > ; > function mask_and_get_interior(φ_t, n; value=NaN); > mask_immersed_field!(φ_t[n], value); > return interior(φ_t[n], :, 1, :); > end; > ; > u′ₙ = @lift mask_and_get_interior(u′_t, $n); > ```; > ; > which gives; > ; > internal_tide.mp4 ; > But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that. I think we should mask the solution during visualization in the script. This is actually what users will need to do currently to make decent visualizations, so it is good to illustrate how to do it --- even if, hopefully, we will eventually have a better solution. As for plotting a shape on top, I'm inclined to encourage visualization that directly represents the domain / data for the purposes of an Oceananigans example. I think its ok if people want to incorporate visualizations like that in their own work but we may not want to promote it as ""the best"" way to visualize complex domains in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358:234,Performance,load,load,234,"> > Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that.; > ; > We can.; > ; > We can also mask the output after we load it, e.g, via; > ; > using something like; > ; > ```julia; > using Oceananigans.ImmersedBoundaries: mask_immersed_field!; > ; > function mask_and_get_interior(φ_t, n; value=NaN); > mask_immersed_field!(φ_t[n], value); > return interior(φ_t[n], :, 1, :); > end; > ; > u′ₙ = @lift mask_and_get_interior(u′_t, $n); > ```; > ; > which gives; > ; > internal_tide.mp4 ; > But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that. I think we should mask the solution during visualization in the script. This is actually what users will need to do currently to make decent visualizations, so it is good to illustrate how to do it --- even if, hopefully, we will eventually have a better solution. As for plotting a shape on top, I'm inclined to encourage visualization that directly represents the domain / data for the purposes of an Oceananigans example. I think its ok if people want to incorporate visualizations like that in their own work but we may not want to promote it as ""the best"" way to visualize complex domains in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986843094:0,Availability,Mask,Masking,0,Masking is done:. https://github.com/CliMA/Oceananigans.jl/blob/ca437145013e82380bbbc8b1d700656eeba78607/examples/internal_tide.jl#L213-L217,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986843094
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986919343:2,Availability,Mask,Masking,2,> Masking is done:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/ca437145013e82380bbbc8b1d700656eeba78607/examples/internal_tide.jl#L213-L217. That's great.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986919343
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920020:273,Modifiability,parameteriz,parameterizations,273,"> Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`.... Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures). I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920020
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920817:368,Modifiability,parameteriz,parameterizations,368,"> > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > ; > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > ; > Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures).; > ; > I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically. True true. Any idea how to deal with the dz(b) that vanishes at the top? Or should we live with it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920817
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986931063:390,Modifiability,parameteriz,parameterizations,390,"> > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > > ; > > ; > > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > > ; > > ; > > Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures).; > > I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically.; > ; > True true.; > ; > Any idea how to deal with the dz(b) that vanishes at the top? Or should we live with it?. Because of the no-flux boundary condition? I think that's correct, ok to have. You could have a mixed layer at the top too!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986931063
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1987303814:360,Usability,simpl,simple,360,"> hm... I don't know about a mixed layer...; > ; > let's just ignore the dz(b)=0 at the top&bottom _or_ we can add a remark in the example about it?. Yes definitely ignore. What we want to focus on is providing an example that is a useful starting point for other, new simulations. This is the key priority. This is why it makes sense to prioritize relatively simple examples (and also simple visualization) that can be quickly digested and are amenable to generalization. We want to _deprioritize_ bespoke or niche cases that are a dead-end. For example, if we use `GradientBoundaryCondition` at the top in this case, then most users will have to delete / change that line in order to generalize this example into the case they are interested in using.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1987303814
https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1987303814:386,Usability,simpl,simple,386,"> hm... I don't know about a mixed layer...; > ; > let's just ignore the dz(b)=0 at the top&bottom _or_ we can add a remark in the example about it?. Yes definitely ignore. What we want to focus on is providing an example that is a useful starting point for other, new simulations. This is the key priority. This is why it makes sense to prioritize relatively simple examples (and also simple visualization) that can be quickly digested and are amenable to generalization. We want to _deprioritize_ bespoke or niche cases that are a dead-end. For example, if we use `GradientBoundaryCondition` at the top in this case, then most users will have to delete / change that line in order to generalize this example into the case they are interested in using.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1987303814
https://github.com/CliMA/Oceananigans.jl/issues/3134#issuecomment-1575643780:156,Usability,clear,clearer,156,"I like the idea of having the same ""name"" for all grids when it comes to length, number of points, and halos. . Having different descriptors might be a tad clearer but much more of a nuisance. Maybe instead of `x`, `y` and `z` we can generalize the names with `1` `2` and `3` referring to the three directions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3134#issuecomment-1575643780
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576419495:303,Availability,error,error,303,"@fredrikekre, @mortenpi. We tried here what we were chatting on slack about parallelizing the execution of literated examples but we got this:. https://buildkite.com/clima/oceananigans/builds/11572#01888a04-bcd4-490b-a0d9-c69d6586c3ca. Any ideas?. (When I tried to build the docs locally I got the same error...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576419495
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576427498:113,Modifiability,variab,variable,113,"As we also discussed on slack, using threads (or tasks) won't work since to capture the output the global stdout variable is changed. You need `pmap` or launch new processes with `run`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576427498
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246:115,Modifiability,variab,variable,115,"> As we also discussed on slack, using threads (or tasks) won't work since to capture the output the global stdout variable is changed. You need `pmap` or launch new processes with `run`. So what we did here was; https://github.com/CliMA/Oceananigans.jl/blob/5d9836398cb49cf2eea38ec6da505b03d9a94a66/docs/make.jl#L46-L53; which is equivalent to `pmap`, right?. But now I see. I thought the `run('...')` was only if I wanted to carry out global variables from one example to the other.; So you are saying that . ```Julia; asyncmap(1:length(example_scripts)) do n ; example = example_scripts[n] ; example_filepath = joinpath(EXAMPLES_DIR, example) ; withenv(""JULIA_DEBUG"" => ""Literate"") do ; run(`julia --project=docs -e'Literate.markdown(example_filepath, OUTPUT_DIR; flavor = Literate.DocumenterFlavor(), execute = true)'`; end ; end; ```; right? I'll try that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246:444,Modifiability,variab,variables,444,"> As we also discussed on slack, using threads (or tasks) won't work since to capture the output the global stdout variable is changed. You need `pmap` or launch new processes with `run`. So what we did here was; https://github.com/CliMA/Oceananigans.jl/blob/5d9836398cb49cf2eea38ec6da505b03d9a94a66/docs/make.jl#L46-L53; which is equivalent to `pmap`, right?. But now I see. I thought the `run('...')` was only if I wanted to carry out global variables from one example to the other.; So you are saying that . ```Julia; asyncmap(1:length(example_scripts)) do n ; example = example_scripts[n] ; example_filepath = joinpath(EXAMPLES_DIR, example) ; withenv(""JULIA_DEBUG"" => ""Literate"") do ; run(`julia --project=docs -e'Literate.markdown(example_filepath, OUTPUT_DIR; flavor = Literate.DocumenterFlavor(), execute = true)'`; end ; end; ```; right? I'll try that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:901,Availability,avail,available,901,"```; julia> using Distributed. help?> addprocs; search: addprocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1000,Availability,error,error,1000,"ocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4115,Availability,error,error,4115,"ies the maximum number of workers connected to in parallel at a host. Defaults to 10. • shell: specifies the type of shell to which ssh connects on the workers.; • shell=:posix: a POSIX-compatible Unix/Linux shell (sh, ksh, bash, dash, zsh, etc.). The default.; • shell=:csh: a Unix C shell (csh, tcsh).; • shell=:wincmd: Microsoft Windows cmd.exe. • dir: specifies the working directory on the workers. Defaults to the host's current directory (as found by pwd()). • enable_threaded_blas: if true then BLAS will run on multiple threads in added processes. Default is false. • exename: name of the julia executable. Defaults to ""$(Sys.BINDIR)/julia"" or ""$(Sys.BINDIR)/julia-debug"" as the case may be. It is; recommended that a common Julia version is used on all remote machines because serialization and code distribution might fail; otherwise. • exeflags: additional flags passed to the worker processes. • topology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1470,Deployability,Configurat,Configuration,1470,"nvironment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the form (machine_spec, count), where; count is the number of workers to be launched on the specified host. Passing :auto as the worker count will launch as many workers as the number; of CPU threads on the remote host. Examples:. addprocs([; ""remote1"", # one worker on 'remote1' logging in with the current username; ""user@remote2"", # one worker on 'remote2' logging in with the 'user' username; ""user@remote3:2222"", # specifying SSH port to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1006,Integrability,message,messages,1006,"ocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4065,Integrability,message,message,4065,"ies the maximum number of workers connected to in parallel at a host. Defaults to 10. • shell: specifies the type of shell to which ssh connects on the workers.; • shell=:posix: a POSIX-compatible Unix/Linux shell (sh, ksh, bash, dash, zsh, etc.). The default.; • shell=:csh: a Unix C shell (csh, tcsh).; • shell=:wincmd: Microsoft Windows cmd.exe. • dir: specifies the working directory on the workers. Defaults to the host's current directory (as found by pwd()). • enable_threaded_blas: if true then BLAS will run on multiple threads in added processes. Default is false. • exename: name of the julia executable. Defaults to ""$(Sys.BINDIR)/julia"" or ""$(Sys.BINDIR)/julia-debug"" as the case may be. It is; recommended that a common Julia version is used on all remote machines because serialization and code distribution might fail; otherwise. • exeflags: additional flags passed to the worker processes. • topology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:442,Modifiability,variab,variable,442,"```; julia> using Distributed. help?> addprocs; search: addprocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1470,Modifiability,Config,Configuration,1470,"nvironment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the form (machine_spec, count), where; count is the number of workers to be launched on the specified host. Passing :auto as the worker count will launch as many workers as the number; of CPU threads on the remote host. Examples:. addprocs([; ""remote1"", # one worker on 'remote1' logging in with the current username; ""user@remote2"", # one worker on 'remote2' logging in with the 'user' username; ""user@remote3:2222"", # specifying SSH port to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4899,Modifiability,variab,variables,4899,"es because serialization and code distribution might fail; otherwise. • exeflags: additional flags passed to the worker processes. • topology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for conne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4973,Modifiability,variab,variable,4973,": Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5483,Modifiability,variab,variables,5483,"g. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5705,Modifiability,variab,variable,5705,"e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:6210,Modifiability,inherit,inherit,6210,"""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha! I was testing locally with v1.9 but the docs use v1.8.5; Seems like from v1.9 onwards the package environment is inherited so we don't need to instantiate multiple times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:6596,Modifiability,inherit,inheriting,6596,"""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha! I was testing locally with v1.9 but the docs use v1.8.5; Seems like from v1.9 onwards the package environment is inherited so we don't need to instantiate multiple times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:6811,Modifiability,inherit,inherited,6811,"""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha! I was testing locally with v1.9 but the docs use v1.8.5; Seems like from v1.9 onwards the package environment is inherited so we don't need to instantiate multiple times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:919,Performance,perform,perform,919,"```; julia> using Distributed. help?> addprocs; search: addprocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5663,Safety,timeout,timeout,5663,"e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5097,Security,authenticat,authentication,5097,"an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of proces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5166,Security,secur,secure,5166,"id 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:2335,Testability,log,logging,2335,"Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the form (machine_spec, count), where; count is the number of workers to be launched on the specified host. Passing :auto as the worker count will launch as many workers as the number; of CPU threads on the remote host. Examples:. addprocs([; ""remote1"", # one worker on 'remote1' logging in with the current username; ""user@remote2"", # one worker on 'remote2' logging in with the 'user' username; ""user@remote3:2222"", # specifying SSH port to '2222' for 'remote3'; (""user@remote4"", 4), # launch 4 workers on 'remote4'; (""user@remote5"", :auto), # launch as many workers as CPU threads on 'remote5'; ]). Keyword arguments:. • tunnel: if true then SSH tunneling will be used to connect to the worker from the master process. Default is false. • multiplex: if true then SSH multiplexing is used for SSH tunneling. Default is false. • ssh: the name or path of the SSH client executable used to start the workers. Default is ""ssh"". • sshflags: specifies additional ssh options, e.g. sshflags=`-i /home/foo/bar.pem`. • max_parallel: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10. • shell: specifies the type of shell to which ssh connects on the workers.; • shell=:posix: a POSIX-compatible Unix/Linux shell (sh, ksh, bash, dash, zsh, etc.). The default.; • shell=:csh: a Unix C shell (csh, tcsh).; • shell=:wincmd: Microsoft Windows cmd.exe. • dir: specifies the working direct",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:2415,Testability,log,logging,2415,"Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the form (machine_spec, count), where; count is the number of workers to be launched on the specified host. Passing :auto as the worker count will launch as many workers as the number; of CPU threads on the remote host. Examples:. addprocs([; ""remote1"", # one worker on 'remote1' logging in with the current username; ""user@remote2"", # one worker on 'remote2' logging in with the 'user' username; ""user@remote3:2222"", # specifying SSH port to '2222' for 'remote3'; (""user@remote4"", 4), # launch 4 workers on 'remote4'; (""user@remote5"", :auto), # launch as many workers as CPU threads on 'remote5'; ]). Keyword arguments:. • tunnel: if true then SSH tunneling will be used to connect to the worker from the master process. Default is false. • multiplex: if true then SSH multiplexing is used for SSH tunneling. Default is false. • ssh: the name or path of the SSH client executable used to start the workers. Default is ""ssh"". • sshflags: specifies additional ssh options, e.g. sshflags=`-i /home/foo/bar.pem`. • max_parallel: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10. • shell: specifies the type of shell to which ssh connects on the workers.; • shell=:posix: a POSIX-compatible Unix/Linux shell (sh, ksh, bash, dash, zsh, etc.). The default.; • shell=:csh: a Unix C shell (csh, tcsh).; • shell=:wincmd: Microsoft Windows cmd.exe. • dir: specifies the working direct",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:6704,Testability,test,testing,6704,"""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha! I was testing locally with v1.9 but the docs use v1.8.5; Seems like from v1.9 onwards the package environment is inherited so we don't need to instantiate multiple times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1582797406:145,Availability,down,down,145,"That makes a lot of sense. For documentation the BCI example was taking 1.6 hours to run. I changed resolution, run time, and plotting to get it down to about 10-15 minutes (I think). It's still the most expensive example by far. I would use 2 workers: one for the BCI example (and perhaps a second expensive one), and one for all the rest. If we can control threads-per-worker, we should put most of the threads on the heavy examples. Maybe that will speed things up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1582797406
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799:26,Testability,log,log,26,"don't use workers: 1h48, [log](https://buildkite.com/clima/oceananigans/builds/11732#0188b342-279d-4a32-a4fd-74b7954b87bb); `Distributed.addprocs(1)`: 1h41, [log](https://buildkite.com/clima/oceananigans/builds/11733#0188b423-8248-477c-8203-8f596f8836b9); `Distributed.addprocs(2)`: 1h33m, [log](https://buildkite.com/clima/oceananigans/builds/11735#0188b4b0-cdc5-4cb6-a224-785ad7268b20); `Distributed.addprocs(3)`: 1h15m, [log](https://buildkite.com/clima/oceananigans/builds/11740#0188b6be-995d-40cf-9408-df7fb78eb5d9); `Distributed.addprocs(4)`: 1h0m, [log](https://buildkite.com/clima/oceananigans/builds/11742#0188b82c-6142-4f90-acf8-dd29f0d2b543); `Distributed.addprocs(6)`: 1h [log](https://buildkite.com/clima/oceananigans/builds/11743#0188b8be-45bf-4124-a6dc-659fe891bc81)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799:158,Testability,log,log,158,"don't use workers: 1h48, [log](https://buildkite.com/clima/oceananigans/builds/11732#0188b342-279d-4a32-a4fd-74b7954b87bb); `Distributed.addprocs(1)`: 1h41, [log](https://buildkite.com/clima/oceananigans/builds/11733#0188b423-8248-477c-8203-8f596f8836b9); `Distributed.addprocs(2)`: 1h33m, [log](https://buildkite.com/clima/oceananigans/builds/11735#0188b4b0-cdc5-4cb6-a224-785ad7268b20); `Distributed.addprocs(3)`: 1h15m, [log](https://buildkite.com/clima/oceananigans/builds/11740#0188b6be-995d-40cf-9408-df7fb78eb5d9); `Distributed.addprocs(4)`: 1h0m, [log](https://buildkite.com/clima/oceananigans/builds/11742#0188b82c-6142-4f90-acf8-dd29f0d2b543); `Distributed.addprocs(6)`: 1h [log](https://buildkite.com/clima/oceananigans/builds/11743#0188b8be-45bf-4124-a6dc-659fe891bc81)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799:291,Testability,log,log,291,"don't use workers: 1h48, [log](https://buildkite.com/clima/oceananigans/builds/11732#0188b342-279d-4a32-a4fd-74b7954b87bb); `Distributed.addprocs(1)`: 1h41, [log](https://buildkite.com/clima/oceananigans/builds/11733#0188b423-8248-477c-8203-8f596f8836b9); `Distributed.addprocs(2)`: 1h33m, [log](https://buildkite.com/clima/oceananigans/builds/11735#0188b4b0-cdc5-4cb6-a224-785ad7268b20); `Distributed.addprocs(3)`: 1h15m, [log](https://buildkite.com/clima/oceananigans/builds/11740#0188b6be-995d-40cf-9408-df7fb78eb5d9); `Distributed.addprocs(4)`: 1h0m, [log](https://buildkite.com/clima/oceananigans/builds/11742#0188b82c-6142-4f90-acf8-dd29f0d2b543); `Distributed.addprocs(6)`: 1h [log](https://buildkite.com/clima/oceananigans/builds/11743#0188b8be-45bf-4124-a6dc-659fe891bc81)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799:424,Testability,log,log,424,"don't use workers: 1h48, [log](https://buildkite.com/clima/oceananigans/builds/11732#0188b342-279d-4a32-a4fd-74b7954b87bb); `Distributed.addprocs(1)`: 1h41, [log](https://buildkite.com/clima/oceananigans/builds/11733#0188b423-8248-477c-8203-8f596f8836b9); `Distributed.addprocs(2)`: 1h33m, [log](https://buildkite.com/clima/oceananigans/builds/11735#0188b4b0-cdc5-4cb6-a224-785ad7268b20); `Distributed.addprocs(3)`: 1h15m, [log](https://buildkite.com/clima/oceananigans/builds/11740#0188b6be-995d-40cf-9408-df7fb78eb5d9); `Distributed.addprocs(4)`: 1h0m, [log](https://buildkite.com/clima/oceananigans/builds/11742#0188b82c-6142-4f90-acf8-dd29f0d2b543); `Distributed.addprocs(6)`: 1h [log](https://buildkite.com/clima/oceananigans/builds/11743#0188b8be-45bf-4124-a6dc-659fe891bc81)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799:556,Testability,log,log,556,"don't use workers: 1h48, [log](https://buildkite.com/clima/oceananigans/builds/11732#0188b342-279d-4a32-a4fd-74b7954b87bb); `Distributed.addprocs(1)`: 1h41, [log](https://buildkite.com/clima/oceananigans/builds/11733#0188b423-8248-477c-8203-8f596f8836b9); `Distributed.addprocs(2)`: 1h33m, [log](https://buildkite.com/clima/oceananigans/builds/11735#0188b4b0-cdc5-4cb6-a224-785ad7268b20); `Distributed.addprocs(3)`: 1h15m, [log](https://buildkite.com/clima/oceananigans/builds/11740#0188b6be-995d-40cf-9408-df7fb78eb5d9); `Distributed.addprocs(4)`: 1h0m, [log](https://buildkite.com/clima/oceananigans/builds/11742#0188b82c-6142-4f90-acf8-dd29f0d2b543); `Distributed.addprocs(6)`: 1h [log](https://buildkite.com/clima/oceananigans/builds/11743#0188b8be-45bf-4124-a6dc-659fe891bc81)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799:685,Testability,log,log,685,"don't use workers: 1h48, [log](https://buildkite.com/clima/oceananigans/builds/11732#0188b342-279d-4a32-a4fd-74b7954b87bb); `Distributed.addprocs(1)`: 1h41, [log](https://buildkite.com/clima/oceananigans/builds/11733#0188b423-8248-477c-8203-8f596f8836b9); `Distributed.addprocs(2)`: 1h33m, [log](https://buildkite.com/clima/oceananigans/builds/11735#0188b4b0-cdc5-4cb6-a224-785ad7268b20); `Distributed.addprocs(3)`: 1h15m, [log](https://buildkite.com/clima/oceananigans/builds/11740#0188b6be-995d-40cf-9408-df7fb78eb5d9); `Distributed.addprocs(4)`: 1h0m, [log](https://buildkite.com/clima/oceananigans/builds/11742#0188b82c-6142-4f90-acf8-dd29f0d2b543); `Distributed.addprocs(6)`: 1h [log](https://buildkite.com/clima/oceananigans/builds/11743#0188b8be-45bf-4124-a6dc-659fe891bc81)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592121216:19,Testability,benchmark,benchmarks,19,"OK, in view of the benchmarks at https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1589191799 seems that the additional workers do something but not that much? With 4 workers we can bring the docs from 1h45 -> 1h. Shall we do that for now @glwagner?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592121216
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592133562:36,Testability,test,testing,36,"I suggest putting back the complete testing suite and seeing if reducing documentation build time from 1.45 to 1hr decreases overall test time and how much. If it does not give a substantial decrease in test time, I would not bother not to overload Tartarus (already a 1.75 speedup with 4 cores is probably not worth so much)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592133562
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592133562:133,Testability,test,test,133,"I suggest putting back the complete testing suite and seeing if reducing documentation build time from 1.45 to 1hr decreases overall test time and how much. If it does not give a substantial decrease in test time, I would not bother not to overload Tartarus (already a 1.75 speedup with 4 cores is probably not worth so much)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592133562
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592133562:203,Testability,test,test,203,"I suggest putting back the complete testing suite and seeing if reducing documentation build time from 1.45 to 1hr decreases overall test time and how much. If it does not give a substantial decrease in test time, I would not bother not to overload Tartarus (already a 1.75 speedup with 4 cores is probably not worth so much)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592133562
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592136209:60,Testability,test,testing,60,4 workers increase the pressure on Tartarus a lot if we are testing multiple branches at the same time,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592136209
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592190514:62,Testability,test,testing,62,> 4 workers increase the pressure on Tartarus a lot if we are testing multiple branches at the same time. what's wrong with that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592190514
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1595621060:53,Testability,test,tests,53,I'm happy with this PR. I think we should merge when tests pass. How about others?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1595621060
https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1595916251:55,Testability,test,tests,55,> I'm happy with this PR. I think we should merge when tests pass. How about others?. Agreed! Great PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1595916251
https://github.com/CliMA/Oceananigans.jl/issues/3137#issuecomment-1579112857:42,Testability,test,test,42,Thanks @simone-silvestri! Should we add a test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3137#issuecomment-1579112857
https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591:29,Testability,benchmark,benchmark,29,> What's the point?. Only to benchmark against the examples before you simplified them to see how faster the docs built. The other pr also includes a simpler bci example now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591
https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591:71,Usability,simpl,simplified,71,> What's the point?. Only to benchmark against the examples before you simplified them to see how faster the docs built. The other pr also includes a simpler bci example now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591
https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591:150,Usability,simpl,simpler,150,> What's the point?. Only to benchmark against the examples before you simplified them to see how faster the docs built. The other pr also includes a simpler bci example now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591
https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583213980:18,Testability,test,test,18,I think we should test the difference between using pmap or not on the other PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583213980
https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583214793:46,Energy Efficiency,reduce,reduced,46,"OK. But as a point of reference, this PR only reduced docs built from 3h to 2h30 --> https://buildkite.com/clima/oceananigans/builds/11644#018897e6-4547-44d2-9644-d8eeed5d1957",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583214793
https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583216547:76,Integrability,depend,depend,76,"Ok, good to know. But I think the strategy we use to distribute work should depend specifically on how much each example costs. So the optimal strategy for this code might be different than on the other PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583216547
https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581675497:217,Usability,simpl,simpler,217,"You are passing too many parameters in the `compute!` kernel, unfortunately. GPUs have a limit on the size of the parameters you can pass (4352 bytes, and you are using 4592 bytes). Try to split your computation into simpler abstract trees:; ```; @inline function vector_projection_aaa(i, j, k, grid, ϕˣ, ϕᶻ, params); return @inbounds ϕˣ[i,j,k]*params.xdirection + ϕᶻ[i,j,k]*params.zdirection; end. using Oceananigans.AbstractOperations: ∂x, ∂y, ∂z; u, v, w = model.velocities; dudx_tilt = compute!(Field(∂x(u) + 1e-7)); dudz_tilt = compute!(Field(∂z(u)). using Oceananigans.Grids: Center, Face; dudz_op = KernelFunctionOperation{Center, Center, Face}(vector_projection_aaa, model.grid,; dudx_tilt, dudz_tilt,; (xdirection=0.9,; zdirection=0.1)); dudz = Field(Average(dudz_op, dims=(1,2))); compute!(dudz). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581675497
https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581740522:591,Availability,error,error,591,"> You are passing too many parameters in the `compute!` kernel, unfortunately. GPUs have a limit on the size of the parameters you can pass (4352 bytes, and you are using 4592 bytes). Ah I see. So basically this is just a GPU limitation and there's nothing to be done in the Oceananigans/user side (apart ofc from splitting the computations)?. Also, is there a way to know at compile time whether the max parameter size is being reached? That way I can define things without ""nesting"" `Field` calls when possible (which saves memory), and use `Field` calls only when necessary to avoid this error. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581740522
https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581740522:580,Safety,avoid,avoid,580,"> You are passing too many parameters in the `compute!` kernel, unfortunately. GPUs have a limit on the size of the parameters you can pass (4352 bytes, and you are using 4592 bytes). Ah I see. So basically this is just a GPU limitation and there's nothing to be done in the Oceananigans/user side (apart ofc from splitting the computations)?. Also, is there a way to know at compile time whether the max parameter size is being reached? That way I can define things without ""nesting"" `Field` calls when possible (which saves memory), and use `Field` calls only when necessary to avoid this error. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581740522
https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1582850631:159,Energy Efficiency,reduce,reduced,159,We don't know of a way to know at compile time. This might be a question for GPUCompiler.jl or CUDA.jl. I have also found that it's rather limited what can be reduced on-the-fly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1582850631
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582815705:272,Usability,clear,clear,272,"Ok, I agree that is a bug if that's how it is implemented. I was responding to this:. > The current implementation of ImmersedBondaryCondition has opposite conventions as FieldBoundaryConditions. which is also true. But I guess there's a miscommunication because it's not clear what ""conventions"" means.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582815705
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582837617:21,Security,validat,validation,21,"Note that there is a validation test for couette flow here:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/immersed_couette_flow.jl. So apparently this is only a problem with the API for specifying fluxes on individual boundary facets. Ie this works:. ```julia; u_immersed_bc = ValueBoundaryCondition(-1); u_top_bc = ValueBoundaryCondition(1); u_bcs = FieldBoundaryConditions(immersed=u_immersed_bc, top=u_top_bc); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582837617
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582837617:112,Security,validat,validation,112,"Note that there is a validation test for couette flow here:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/immersed_couette_flow.jl. So apparently this is only a problem with the API for specifying fluxes on individual boundary facets. Ie this works:. ```julia; u_immersed_bc = ValueBoundaryCondition(-1); u_top_bc = ValueBoundaryCondition(1); u_bcs = FieldBoundaryConditions(immersed=u_immersed_bc, top=u_top_bc); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582837617
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582837617:32,Testability,test,test,32,"Note that there is a validation test for couette flow here:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/immersed_couette_flow.jl. So apparently this is only a problem with the API for specifying fluxes on individual boundary facets. Ie this works:. ```julia; u_immersed_bc = ValueBoundaryCondition(-1); u_top_bc = ValueBoundaryCondition(1); u_bcs = FieldBoundaryConditions(immersed=u_immersed_bc, top=u_top_bc); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582837617
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782:20,Integrability,interface,interface,20,"I mean the new user interface for `ImmersedBoundaryCondtion`. Previously, I tried to do a simulation with heating distributed on an irregular bottom, and I found that I had to use `ImmersedBoundaryCondition(top = the_bottom_heating)` instead of `ImmersedBoundaryCondition(bottom = the_bottom_heating)` after some testing. I felt this strange and reported this behavior to Simone. Then he opened this issue, because it affects his simulations as well. I am sorry for confusing you, since you did not know Simone and I had some discussion on issue before.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782:313,Testability,test,testing,313,"I mean the new user interface for `ImmersedBoundaryCondtion`. Previously, I tried to do a simulation with heating distributed on an irregular bottom, and I found that I had to use `ImmersedBoundaryCondition(top = the_bottom_heating)` instead of `ImmersedBoundaryCondition(bottom = the_bottom_heating)` after some testing. I felt this strange and reported this behavior to Simone. Then he opened this issue, because it affects his simulations as well. I am sorry for confusing you, since you did not know Simone and I had some discussion on issue before.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583458579:35,Integrability,interface,interface,35,"@Yixiao-Zhang what is the new user interface? Are you referring to the changes on #3142 ?. Either way, I recommend that you set up your simulation without using `ImmersedBoundaryCondition` at all. `ImmersedBoundaryCondition` is not appropriate for most physical modeling (I am considering whether we should say this more explicitly in the docstring). I suggest trying. ```julia; FieldBoundaryConditions(immersed=the_bottom_heating); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583458579
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587520861:157,Energy Efficiency,reduce,reduces-heat-transport-for-small-roughness-heights-in-turbulent-rayleighbenard-convection,157,It could be fun to reproduce the results of this paper: https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/how-surface-roughness-reduces-heat-transport-for-small-roughness-heights-in-turbulent-rayleighbenard-convection/B7B4E4F392EDC249A3B5FD75790F88FC,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587520861
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510:1048,Deployability,patch,patches,1048,"ell, ok. I see how using `ImmersedBoundaryCondition` is _convenient_. I disagree that this is a ""better"" model, however. It is an approximate model that leverages (what is hopefully) the thin aspect ratio of your simulation. Note, I don't think these issues are intrinsic to lego topography. In fact, I think this approach could completely fail if we had cut cells, which represents another caveat. The problem is that, when the cell facets are no longer oriented along one of x, y, z, we need to define what a flux across the bottom _means_. Is it a flux normal to the boundary, or is it a flux projected along one of the orthogonal directions? I'm not sure interpreting `ImmersedBoundaryCondition(bottom=flux)` as representing _only_ the vertical component of the bottom flux is sensible, especially when we consider the small scale limit or large eddy simulation or direct numerical simulation. We'll have to discuss that. To elaborate on the details, the geological constraint we have from observations is on the heat flux averaged over large patches of the ocean basin:. $$ Q_\text{obs} \approx \frac{1}{A} \int \boldsymbol{q} \cdot \boldsymbol{n} d A $$. where $A$ is the surface area of the ocean bottom (not the horizontal area). As you have noted, we can reproduce this constraint by applying the flux $Q$ across all upward facing facets. Then the total flux in our model is. $$ Q_\text{model} = \frac{1}{A_h} \int Q_\text{obs} d A_h $$. where $A_h$ is the horizontal area of the ocean basin and $d A_h$ is the horizontal projection of the surface area of the bottom. Clearly we obtain $Q_\text{model} = Q_\text{obs}$ and our goal is achieved. At small scales, this approximate model becomes questionable (but of course, it is also questionable to use a constant heat flux at small scales). Basically, I think that using this convenience actually obscures the true physics. So while it produces the right answer, it leads to confusion about what the observed geological heat flux actually re",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510:2246,Security,expose,expose,2246,"pproach could completely fail if we had cut cells, which represents another caveat. The problem is that, when the cell facets are no longer oriented along one of x, y, z, we need to define what a flux across the bottom _means_. Is it a flux normal to the boundary, or is it a flux projected along one of the orthogonal directions? I'm not sure interpreting `ImmersedBoundaryCondition(bottom=flux)` as representing _only_ the vertical component of the bottom flux is sensible, especially when we consider the small scale limit or large eddy simulation or direct numerical simulation. We'll have to discuss that. To elaborate on the details, the geological constraint we have from observations is on the heat flux averaged over large patches of the ocean basin:. $$ Q_\text{obs} \approx \frac{1}{A} \int \boldsymbol{q} \cdot \boldsymbol{n} d A $$. where $A$ is the surface area of the ocean bottom (not the horizontal area). As you have noted, we can reproduce this constraint by applying the flux $Q$ across all upward facing facets. Then the total flux in our model is. $$ Q_\text{model} = \frac{1}{A_h} \int Q_\text{obs} d A_h $$. where $A_h$ is the horizontal area of the ocean basin and $d A_h$ is the horizontal projection of the surface area of the bottom. Clearly we obtain $Q_\text{model} = Q_\text{obs}$ and our goal is achieved. At small scales, this approximate model becomes questionable (but of course, it is also questionable to use a constant heat flux at small scales). Basically, I think that using this convenience actually obscures the true physics. So while it produces the right answer, it leads to confusion about what the observed geological heat flux actually represents, and the detailed physics of heat flux across irregular boundaries... That said, I take the very important point that the convenience greatly simplifies applying this kind of model at large scales. So I am more convinced that we should expose `ImmersedBoundaryCondition` to users --- despite the dangers...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510:1578,Usability,Clear,Clearly,1578,"pproach could completely fail if we had cut cells, which represents another caveat. The problem is that, when the cell facets are no longer oriented along one of x, y, z, we need to define what a flux across the bottom _means_. Is it a flux normal to the boundary, or is it a flux projected along one of the orthogonal directions? I'm not sure interpreting `ImmersedBoundaryCondition(bottom=flux)` as representing _only_ the vertical component of the bottom flux is sensible, especially when we consider the small scale limit or large eddy simulation or direct numerical simulation. We'll have to discuss that. To elaborate on the details, the geological constraint we have from observations is on the heat flux averaged over large patches of the ocean basin:. $$ Q_\text{obs} \approx \frac{1}{A} \int \boldsymbol{q} \cdot \boldsymbol{n} d A $$. where $A$ is the surface area of the ocean bottom (not the horizontal area). As you have noted, we can reproduce this constraint by applying the flux $Q$ across all upward facing facets. Then the total flux in our model is. $$ Q_\text{model} = \frac{1}{A_h} \int Q_\text{obs} d A_h $$. where $A_h$ is the horizontal area of the ocean basin and $d A_h$ is the horizontal projection of the surface area of the bottom. Clearly we obtain $Q_\text{model} = Q_\text{obs}$ and our goal is achieved. At small scales, this approximate model becomes questionable (but of course, it is also questionable to use a constant heat flux at small scales). Basically, I think that using this convenience actually obscures the true physics. So while it produces the right answer, it leads to confusion about what the observed geological heat flux actually represents, and the detailed physics of heat flux across irregular boundaries... That said, I take the very important point that the convenience greatly simplifies applying this kind of model at large scales. So I am more convinced that we should expose `ImmersedBoundaryCondition` to users --- despite the dangers...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510:2152,Usability,simpl,simplifies,2152,"pproach could completely fail if we had cut cells, which represents another caveat. The problem is that, when the cell facets are no longer oriented along one of x, y, z, we need to define what a flux across the bottom _means_. Is it a flux normal to the boundary, or is it a flux projected along one of the orthogonal directions? I'm not sure interpreting `ImmersedBoundaryCondition(bottom=flux)` as representing _only_ the vertical component of the bottom flux is sensible, especially when we consider the small scale limit or large eddy simulation or direct numerical simulation. We'll have to discuss that. To elaborate on the details, the geological constraint we have from observations is on the heat flux averaged over large patches of the ocean basin:. $$ Q_\text{obs} \approx \frac{1}{A} \int \boldsymbol{q} \cdot \boldsymbol{n} d A $$. where $A$ is the surface area of the ocean bottom (not the horizontal area). As you have noted, we can reproduce this constraint by applying the flux $Q$ across all upward facing facets. Then the total flux in our model is. $$ Q_\text{model} = \frac{1}{A_h} \int Q_\text{obs} d A_h $$. where $A_h$ is the horizontal area of the ocean basin and $d A_h$ is the horizontal projection of the surface area of the bottom. Clearly we obtain $Q_\text{model} = Q_\text{obs}$ and our goal is achieved. At small scales, this approximate model becomes questionable (but of course, it is also questionable to use a constant heat flux at small scales). Basically, I think that using this convenience actually obscures the true physics. So while it produces the right answer, it leads to confusion about what the observed geological heat flux actually represents, and the detailed physics of heat flux across irregular boundaries... That said, I take the very important point that the convenience greatly simplifies applying this kind of model at large scales. So I am more convinced that we should expose `ImmersedBoundaryCondition` to users --- despite the dangers...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1588059918:845,Availability,down,downside,845,"I agree and I think that's also an issue with the ""fix"" in #3142. Eg previously the kwargs referred to immersed cells, ie `bottom=flux` means the `flux` is applied at the bottom of an immersed cell. But apparently, this was confused with the ""bottom"" of the domain... `upward` could be a good alternative. I'm worried about deciding on these conventions before we have cut cells though, which would probably become the preferred default. Whatever API we have should make sense for cut cells. . All of this is one reason why I feel it might better to remove documentation for `ImmersedBoundaryCondition` altogether and recommend using ordinary boundary conditions on immersed boundaries. I think it's straightforward to apply ordinary boundary conditions on either full cells, partial cells, or cut cells. While we do lose some convenience, that downside is balanced against requiring users to have a more detailed understanding of the problem they are trying to model, which is arguably a good thing... Confusing behavior for immersed boundaries seems to arise only when users try to exert more granular control over the boundary condition through `ImmersedBoundaryCondition`. I regret now exposing the API to ImmersedBoundaryCondition 🥲",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1588059918
https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1589814346:107,Security,expose,expose,107,"It would probably make sense to have a structure called `ImmersedBoundaryFlux`. If so, we will not have to expose `ImmersedBoundaryCondition`. What matters to me is that the integral of the flux over the ocean bottom (or any surface) should be easy to calculate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1589814346
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588245720:43,Deployability,update,updated,43,@simone-silvestri @tomchor @Yixiao-Zhang I updated the docs on `ImmersedBoundaryGrid`. See what you think.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588245720
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588250343:30,Testability,test,test,30,Probably makes sense to add a test to make sure this doesn't get reverted in the future too,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588250343
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588431703:242,Integrability,depend,depend,242,"> I think it is good to use it in hydrostatic simulations where the aspect ratio is very high (for example drag on the sides should not be equal to drag on the bottom). Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588431703
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1591106939:75,Integrability,depend,depend,75,"> Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions. That's an interesting example. This wouldn't generalize to cut cells, right? Perhaps we need an abstraction that represents the distances to the boundary, for use within boundary conditions. That way we can ensure the distance to the boundary is computed correctly regardless of how the boundary is represented. As an aside, hasn't it been shown that MOST is not valid in complex terrain? (That wouldn't prevent it from still somehow improving model fidelity, at least in principle.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1591106939
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1595915982:77,Integrability,depend,depend,77,"> > Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions.; > ; > That's an interesting example. This wouldn't generalize to cut cells, right? Perhaps we need an abstraction that represents the distances to the boundary, for use within boundary conditions. That way we can ensure the distance to the boundary is computed correctly regardless of how the boundary is represented. Agreed. Although I think that's for another PR, right?. > As an aside, hasn't it been shown that MOST is not valid in complex terrain? (That wouldn't prevent it from still somehow improving model fidelity, at least in principle.). Yes, although the discrepancy is less severe for neutral stability, which I suspect encompasses most of the simulations people have been using Oceananigans for. Interestingly, there's been a very recent attempt at generalization that [looks pretty promising](https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.130.124001)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1595915982
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1599998597:145,Safety,safe,safely,145,"> Agreed. Although I think that's for another PR, right?. For sure but if that case actually requires another abstraction that would mean we can safely recommend not using `ImmersedBoundaryCondition`, then we shouldn't put too much effort into it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1599998597
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1611771342:23,Deployability,patch,patch,23,@simone-silvestri bump patch version and merge?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1611771342
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1611801879:55,Deployability,release,release,55,"Actually now that I think about it, this is a breaking release. Idk how many people use this feature, but I wonder if we should do something similar to https://github.com/CliMA/Oceananigans.jl/pull/2990 and throw a warning whenever `ImmersedBoundaryCondition` is used so that previously working user scripts don't break silently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1611801879
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1613499377:126,Security,validat,validation,126,"I'd be in favor of always emitting a warning for `ImmersedBoundaryCondition` that it's experimental (no published papers, few validation tests)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1613499377
https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1613499377:137,Testability,test,tests,137,"I'd be in favor of always emitting a warning for `ImmersedBoundaryCondition` that it's experimental (no published papers, few validation tests)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1613499377
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1590176837:26,Testability,test,tests,26,"Note: I couldn't find any tests for this, so it'd probably be a good idea to add some here before merging.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1590176837
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:22,Availability,error,error,22,"hm... so we get this [error](https://buildkite.com/clima/oceananigans/builds/11766#0188bd84-7a4a-4062-8e5d-a6ca143ab861/19-335) although we added a method. . Is it because we defined, e.g., `xspacing` inside `Oceananigans.Grids` and then added a new method in `Oceananigans.ImmersedBoundaries` but in the unit tests we only called: `using Oceananigans.Grids: xspacing`?. ```Julia; Grid initialization: Error During Test at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203; Test threw exception; Expression: minimum_xspacing(grid) ≈ FT(π / 3); MethodError: xspacing(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::Center, ::Center, ::Center) is ambiguous. Candidates:; xspacing(i, j, k, grid::ImmersedBoundaryGrid, args...) in Oceananigans.ImmersedBoundaries at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/ImmersedBoundaries/immersed_grid_metrics.jl:40; xspacing(i, j, k, grid, ::Center, ::Center, ::Center) in Oceananigans.Operators at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Operators/spacings_and_areas_and_volumes.jl:264; Possible fix, define; xspacing(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Center, ::Center, ::Center); Stacktrace:; [1] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/kernel_function_operation.jl:73 [inlined]; [2] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/conditional_operations.jl:120 [inlined]; [3] getindex; @ ./subarray.jl:282 [inlined]; [4] _getindex; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:402,Availability,Error,Error,402,"hm... so we get this [error](https://buildkite.com/clima/oceananigans/builds/11766#0188bd84-7a4a-4062-8e5d-a6ca143ab861/19-335) although we added a method. . Is it because we defined, e.g., `xspacing` inside `Oceananigans.Grids` and then added a new method in `Oceananigans.ImmersedBoundaries` but in the unit tests we only called: `using Oceananigans.Grids: xspacing`?. ```Julia; Grid initialization: Error During Test at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203; Test threw exception; Expression: minimum_xspacing(grid) ≈ FT(π / 3); MethodError: xspacing(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::Center, ::Center, ::Center) is ambiguous. Candidates:; xspacing(i, j, k, grid::ImmersedBoundaryGrid, args...) in Oceananigans.ImmersedBoundaries at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/ImmersedBoundaries/immersed_grid_metrics.jl:40; xspacing(i, j, k, grid, ::Center, ::Center, ::Center) in Oceananigans.Operators at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Operators/spacings_and_areas_and_volumes.jl:264; Possible fix, define; xspacing(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Center, ::Center, ::Center); Stacktrace:; [1] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/kernel_function_operation.jl:73 [inlined]; [2] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/conditional_operations.jl:120 [inlined]; [3] getindex; @ ./subarray.jl:282 [inlined]; [4] _getindex; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:7948,Availability,mask,mask,7948,"oat32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float32}); @ Oceananigans.Fields ~/builds/tartarus-7/clima/oceananigans/src/Fields/field.jl:556; [9] minimum(f::Function, c::KernelFunctionOperation{Center, Center, Center, ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float32, typeof(xspacing), Tuple{Center, Center, Center}}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/builds/tartarus-7/clima/oceananigans/src/Fields/field.jl:647; [10] minimum; @ ~/builds/tartarus-7/clima/oceananigans/src/Fields/field.jl:637 [inlined]; [11] #minimum#45; @ ~/builds/tartarus-7/clima/oceananigans/src/Fields/field.jl:657 [inlined]; [12] minimum(c::KernelFunctionOperation{Center, Center, Center, ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float32, typeof(xspacing), Tuple{Center, Center, Center}}); @ Oceananigans.Fields ~/builds/tartarus-7/clima/o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:5047,Energy Efficiency,reduce,reducedim,5047," Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float32, typeof(xspacing), Tuple{Center, Center, Center}}, typeof(identity), ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float32}); @ Base ./reducedim.jl:274; [8] initialize_reduced_field!(#unused#::typeof(minimum!), f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float32, 3, Array{Float32, 3}}, Float32, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, c::ConditionalOperation{Center, Center, Center, KernelFunctionOperation{Center, Center, Center, Imme",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:310,Testability,test,tests,310,"hm... so we get this [error](https://buildkite.com/clima/oceananigans/builds/11766#0188bd84-7a4a-4062-8e5d-a6ca143ab861/19-335) although we added a method. . Is it because we defined, e.g., `xspacing` inside `Oceananigans.Grids` and then added a new method in `Oceananigans.ImmersedBoundaries` but in the unit tests we only called: `using Oceananigans.Grids: xspacing`?. ```Julia; Grid initialization: Error During Test at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203; Test threw exception; Expression: minimum_xspacing(grid) ≈ FT(π / 3); MethodError: xspacing(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::Center, ::Center, ::Center) is ambiguous. Candidates:; xspacing(i, j, k, grid::ImmersedBoundaryGrid, args...) in Oceananigans.ImmersedBoundaries at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/ImmersedBoundaries/immersed_grid_metrics.jl:40; xspacing(i, j, k, grid, ::Center, ::Center, ::Center) in Oceananigans.Operators at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Operators/spacings_and_areas_and_volumes.jl:264; Possible fix, define; xspacing(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Center, ::Center, ::Center); Stacktrace:; [1] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/kernel_function_operation.jl:73 [inlined]; [2] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/conditional_operations.jl:120 [inlined]; [3] getindex; @ ./subarray.jl:282 [inlined]; [4] _getindex; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:415,Testability,Test,Test,415,"hm... so we get this [error](https://buildkite.com/clima/oceananigans/builds/11766#0188bd84-7a4a-4062-8e5d-a6ca143ab861/19-335) although we added a method. . Is it because we defined, e.g., `xspacing` inside `Oceananigans.Grids` and then added a new method in `Oceananigans.ImmersedBoundaries` but in the unit tests we only called: `using Oceananigans.Grids: xspacing`?. ```Julia; Grid initialization: Error During Test at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203; Test threw exception; Expression: minimum_xspacing(grid) ≈ FT(π / 3); MethodError: xspacing(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::Center, ::Center, ::Center) is ambiguous. Candidates:; xspacing(i, j, k, grid::ImmersedBoundaryGrid, args...) in Oceananigans.ImmersedBoundaries at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/ImmersedBoundaries/immersed_grid_metrics.jl:40; xspacing(i, j, k, grid, ::Center, ::Center, ::Center) in Oceananigans.Operators at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Operators/spacings_and_areas_and_volumes.jl:264; Possible fix, define; xspacing(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Center, ::Center, ::Center); Stacktrace:; [1] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/kernel_function_operation.jl:73 [inlined]; [2] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/conditional_operations.jl:120 [inlined]; [3] getindex; @ ./subarray.jl:282 [inlined]; [4] _getindex; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:485,Testability,test,test,485,"hm... so we get this [error](https://buildkite.com/clima/oceananigans/builds/11766#0188bd84-7a4a-4062-8e5d-a6ca143ab861/19-335) although we added a method. . Is it because we defined, e.g., `xspacing` inside `Oceananigans.Grids` and then added a new method in `Oceananigans.ImmersedBoundaries` but in the unit tests we only called: `using Oceananigans.Grids: xspacing`?. ```Julia; Grid initialization: Error During Test at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203; Test threw exception; Expression: minimum_xspacing(grid) ≈ FT(π / 3); MethodError: xspacing(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::Center, ::Center, ::Center) is ambiguous. Candidates:; xspacing(i, j, k, grid::ImmersedBoundaryGrid, args...) in Oceananigans.ImmersedBoundaries at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/ImmersedBoundaries/immersed_grid_metrics.jl:40; xspacing(i, j, k, grid, ::Center, ::Center, ::Center) in Oceananigans.Operators at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Operators/spacings_and_areas_and_volumes.jl:264; Possible fix, define; xspacing(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Center, ::Center, ::Center); Stacktrace:; [1] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/kernel_function_operation.jl:73 [inlined]; [2] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/conditional_operations.jl:120 [inlined]; [3] getindex; @ ./subarray.jl:282 [inlined]; [4] _getindex; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:509,Testability,Test,Test,509,"hm... so we get this [error](https://buildkite.com/clima/oceananigans/builds/11766#0188bd84-7a4a-4062-8e5d-a6ca143ab861/19-335) although we added a method. . Is it because we defined, e.g., `xspacing` inside `Oceananigans.Grids` and then added a new method in `Oceananigans.ImmersedBoundaries` but in the unit tests we only called: `using Oceananigans.Grids: xspacing`?. ```Julia; Grid initialization: Error During Test at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203; Test threw exception; Expression: minimum_xspacing(grid) ≈ FT(π / 3); MethodError: xspacing(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::Center, ::Center, ::Center) is ambiguous. Candidates:; xspacing(i, j, k, grid::ImmersedBoundaryGrid, args...) in Oceananigans.ImmersedBoundaries at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/ImmersedBoundaries/immersed_grid_metrics.jl:40; xspacing(i, j, k, grid, ::Center, ::Center, ::Center) in Oceananigans.Operators at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Operators/spacings_and_areas_and_volumes.jl:264; Possible fix, define; xspacing(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Center, ::Center, ::Center); Stacktrace:; [1] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/kernel_function_operation.jl:73 [inlined]; [2] getindex; @ ~/builds/tartarus-7/clima/oceananigans/src/AbstractOperations/conditional_operations.jl:120 [inlined]; [3] getindex; @ ./subarray.jl:282 [inlined]; [4] _getindex; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:10297,Testability,Test,Test,10297," @ Oceananigans.Fields ~/builds/tartarus-7/clima/oceananigans/src/Fields/field.jl:657; [13] minimum_spacing(dir::Symbol, grid::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ℓx::Center, ℓy::Center, ℓz::Center); @ Oceananigans.Grids ~/builds/tartarus-7/clima/oceananigans/src/Grids/grid_utils.jl:408; [14] minimum_xspacing(grid::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}); @ Oceananigans.Grids ~/builds/tartarus-7/clima/oceananigans/src/Grids/grid_utils.jl:429; [15] macro expansion; @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [16] test_regular_rectilinear_xnode_ynode_znode_and_spacings(arch::CPU, FT::Type{Float32}); @ Main ~/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203. <br class=""Apple-interchange-newline"" style=""caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration: none;"">; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:10306,Testability,Test,Test,10306," @ Oceananigans.Fields ~/builds/tartarus-7/clima/oceananigans/src/Fields/field.jl:657; [13] minimum_spacing(dir::Symbol, grid::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ℓx::Center, ℓy::Center, ℓz::Center); @ Oceananigans.Grids ~/builds/tartarus-7/clima/oceananigans/src/Grids/grid_utils.jl:408; [14] minimum_xspacing(grid::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}); @ Oceananigans.Grids ~/builds/tartarus-7/clima/oceananigans/src/Grids/grid_utils.jl:429; [15] macro expansion; @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [16] test_regular_rectilinear_xnode_ynode_znode_and_spacings(arch::CPU, FT::Type{Float32}); @ Main ~/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203. <br class=""Apple-interchange-newline"" style=""caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration: none;"">; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:10467,Testability,test,test,10467," @ Oceananigans.Fields ~/builds/tartarus-7/clima/oceananigans/src/Fields/field.jl:657; [13] minimum_spacing(dir::Symbol, grid::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ℓx::Center, ℓy::Center, ℓz::Center); @ Oceananigans.Grids ~/builds/tartarus-7/clima/oceananigans/src/Grids/grid_utils.jl:408; [14] minimum_xspacing(grid::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}); @ Oceananigans.Grids ~/builds/tartarus-7/clima/oceananigans/src/Grids/grid_utils.jl:429; [15] macro expansion; @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [16] test_regular_rectilinear_xnode_ynode_znode_and_spacings(arch::CPU, FT::Type{Float32}); @ Main ~/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203. <br class=""Apple-interchange-newline"" style=""caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration: none;"">; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:1142,Availability,error,error,1142,"in` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to red",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:1052,Integrability,wrap,wrapped,1052,"in` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to red",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:2409,Integrability,interface,interface,2409," same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in the general case a call to `zspacings(::ImmersedBoundaryGrid)` _must_ return a 3D array (or `Field`, or `AbstractOp`...)).; - if we wanna keep the user-interface consistent (i.e. always return the same type of object) then we lose on simplicity (e.g. a call to `zspacings(::RectilinearGrid)` would always return _something_ 3D, even if the grid is regular). @navidcy @glwagner is this a fair assessment of the situation? Feel free to edit the text above if not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:2732,Integrability,interface,interface,2732," same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in the general case a call to `zspacings(::ImmersedBoundaryGrid)` _must_ return a 3D array (or `Field`, or `AbstractOp`...)).; - if we wanna keep the user-interface consistent (i.e. always return the same type of object) then we lose on simplicity (e.g. a call to `zspacings(::RectilinearGrid)` would always return _something_ 3D, even if the grid is regular). @navidcy @glwagner is this a fair assessment of the situation? Feel free to edit the text above if not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:507,Security,access,accesses,507,"I'm going to try and put some some into this, but I'm a bit unsure of what to do. First, to summarize what the current state on `main` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:788,Security,access,accesses,788,"I'm going to try and put some some into this, but I'm a bit unsure of what to do. First, to summarize what the current state on `main` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:1608,Usability,simpl,simply,1608,"ugh some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:2101,Usability,simpl,simple,2101," same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in the general case a call to `zspacings(::ImmersedBoundaryGrid)` _must_ return a 3D array (or `Field`, or `AbstractOp`...)).; - if we wanna keep the user-interface consistent (i.e. always return the same type of object) then we lose on simplicity (e.g. a call to `zspacings(::RectilinearGrid)` would always return _something_ 3D, even if the grid is regular). @navidcy @glwagner is this a fair assessment of the situation? Feel free to edit the text above if not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:2419,Usability,simpl,simple,2419," same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in the general case a call to `zspacings(::ImmersedBoundaryGrid)` _must_ return a 3D array (or `Field`, or `AbstractOp`...)).; - if we wanna keep the user-interface consistent (i.e. always return the same type of object) then we lose on simplicity (e.g. a call to `zspacings(::RectilinearGrid)` would always return _something_ 3D, even if the grid is regular). @navidcy @glwagner is this a fair assessment of the situation? Feel free to edit the text above if not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:2814,Usability,simpl,simplicity,2814," same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in the general case a call to `zspacings(::ImmersedBoundaryGrid)` _must_ return a 3D array (or `Field`, or `AbstractOp`...)).; - if we wanna keep the user-interface consistent (i.e. always return the same type of object) then we lose on simplicity (e.g. a call to `zspacings(::RectilinearGrid)` would always return _something_ 3D, even if the grid is regular). @navidcy @glwagner is this a fair assessment of the situation? Feel free to edit the text above if not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636853738:844,Usability,clear,clear,844,"My take is that I don't think there's a way around the choices I just mentioned in the previous post. To make it ever harder, based on @glwagner's comment I think we also need to discuss what exactly (regardless of format) `zspacings` should return to the user. Taking `PartialGridBottom` as an example, if we're to mimic the internals of the code, then it `zspacings(ibm_grid::IBG)` should return. 1. `zspacings(ibm_grid.underlying_grid)` if `z` is above the immersed boundary; 2. `zspacing(ibm_grid)` if the grid is at the immersed boundary (i.e. if the cell is partially wet, partially immersed); 3. `zspacings(ibm_grid.underlying_grid)` if `z` is fully below/inside the immersed boundary/solid. afaik this is exactly how the code internals work. However, since `zspacings` (and I guess also `zspacing`?) is a user-facing function, it's not clear if this is the best approach. For example, as a user, I wonder why we don't include the space occupied by the solid object when the cell is in the immersed _boundary_, but we do include it fully when the cell is completely inside/below the immersed boundary? In other words, why don't we do:. 1. `zspacings(ibm_grid.underlying_grid)` if `z` is above the immersed boundary; 2. `zspacing(ibm_grid)` if the grid is at the immersed boundary (i.e. if the cell is partially wet, partially immersed); 3. zero. ?. I think this latter option is more consistent (i.e. a solid _never_ counts as ""wet space"") and it makes stuff like offline integrals easier (since `sum(quantity * Δz) / sum(Δz)` will return the correct integral (ignoring x and y)). This is also more in line with the `xgcm` (also SGRID I think) conventions that I'm trying to implement in https://github.com/CliMA/Oceananigans.jl/pull/2652. I'm proposing the name `active_zspacing()` there:. https://github.com/CliMA/Oceananigans.jl/blob/b8b80598fb7250495f0d1925bfb406e15b3305b2/src/Grids/grid_utils.jl#L482-L496. (The main difference there is that the space _outside_ the domain (i.e. halos) al",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636853738
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1637681533:269,Energy Efficiency,efficient,efficient,269,"I think the right way forward is to implement something that works for all grids. Then we can implement the grid-specific versions --- which should be viewed as conveniences or optimizations rather than necessities --- as time allows. I think this is a better and more efficient approach then implementing convenience versions first, and figuring out the general version later. You might find that the convenience versions aren't really necessary because things are convenient enough...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1637681533
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1637681533:177,Performance,optimiz,optimizations,177,"I think the right way forward is to implement something that works for all grids. Then we can implement the grid-specific versions --- which should be viewed as conveniences or optimizations rather than necessities --- as time allows. I think this is a better and more efficient approach then implementing convenience versions first, and figuring out the general version later. You might find that the convenience versions aren't really necessary because things are convenient enough...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1637681533
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638223596:596,Energy Efficiency,efficient,efficient,596,"My suggestion of opening a separate issue comes from the fact that I don't have much time to work on this PR (as you guys could probably see by the month-delay in answering the last comments). And in the meantime there's a bug in the code that could be fixed rn with one extra commit. But fair enough. Let's solve this here. > I think the right way forward is to implement something that works for all grids. Then we can implement the grid-specific versions --- which should be viewed as conveniences or optimizations rather than necessities --- as time allows. I think this is a better and more efficient approach then implementing convenience versions first, and figuring out the general version later. You might find that the convenience versions aren't really necessary because things are convenient enough... If I understand what you're proposing, the way forward would be to implement something that always returns the 3D field/array, since that's the only way that works for all grids no matter what. Correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638223596
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638223596:504,Performance,optimiz,optimizations,504,"My suggestion of opening a separate issue comes from the fact that I don't have much time to work on this PR (as you guys could probably see by the month-delay in answering the last comments). And in the meantime there's a bug in the code that could be fixed rn with one extra commit. But fair enough. Let's solve this here. > I think the right way forward is to implement something that works for all grids. Then we can implement the grid-specific versions --- which should be viewed as conveniences or optimizations rather than necessities --- as time allows. I think this is a better and more efficient approach then implementing convenience versions first, and figuring out the general version later. You might find that the convenience versions aren't really necessary because things are convenient enough... If I understand what you're proposing, the way forward would be to implement something that always returns the 3D field/array, since that's the only way that works for all grids no matter what. Correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638223596
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638272192:260,Integrability,interface,interface,260,"> But it's possible to write code that works for all grids by referencing the kernel functions directly (rather than trying to extract the spacings from the grid properties). That's how we get spacings inside the code, so if we use the same method in the user interface then all is good. @glwagner, what do you mean here by ""kernel functions""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638272192
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1641138360:262,Integrability,interface,interface,262,"> > But it's possible to write code that works for all grids by referencing the kernel functions directly (rather than trying to extract the spacings from the grid properties). That's how we get spacings inside the code, so if we use the same method in the user interface then all is good.; > ; > @glwagner, what do you mean here by ""kernel functions""?. By ""kernel function"" I mean ""a function meant to be used inside a kernel"". In our convention these functions have the first four arguments `i, j, k, grid`. An example is `Δxᶠᶜᶜ(i, j, k, grid)`, which gets the x-spacing at face, center, center. Annoyingly they are all defined via metaprogramming, eg:. https://github.com/CliMA/Oceananigans.jl/blob/f4d7a94faeaa00cc48d0f92a26027a90d917ec62/src/Operators/spacings_and_areas_and_volumes.jl#L93. the 2D spacings though are defined . https://github.com/CliMA/Oceananigans.jl/blob/f4d7a94faeaa00cc48d0f92a26027a90d917ec62/src/Operators/spacings_and_areas_and_volumes.jl#L138",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1641138360
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2397250915:100,Testability,test,tests,100,"Trying to revive and merge this PR as part of tackling #2248. I think I mangled the merge commit so tests will fail, but I'll fix them. Sounds like we just want to have the spacings functions return the correct spacings whether on a `GridFittedBottom` or `PartialCellBottom`? And the best way to achieve this is with `KernelFunctionOperation`s.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2397250915
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2449864662:507,Energy Efficiency,reduce,reduced,507,"Just thinking about this PR a bit more and building off of @tomchor's summaries:. Am I correct in thinking that we want `xspacing`, `yspacing`, `zspacing`, etc. (+ λ, φ, ξ, η, r) to all be functions of `(i, j, k, lx, ly, lz, grid)` and return a number? This might already be true, although some may be missing. Then we want `xspacings`, `yspacings`, `zspacings`, etc. to return an array of spacings (perhaps with a `with_halos` flag)? Should it be an array or a `Field`?. Should the returned array/field be reduced when possible? So calling `zspacings` on an immersed partial-cell grid returns a 3D array/field, calling `xspacings` on a lat-lon grid returns a 2D array/field, and calling `xspacings` on a regular rectilinear grid returns a 1D array/field?. If so, then we can have a generic `KernelFunctionOperation` that returns a 3D array of spacings, and specialize via dispatch wherever possible to return 2D and 1D arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2449864662
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822:733,Energy Efficiency,allocate,allocate,733,"> Am I correct in thinking that we want xspacing, yspacing, zspacing, etc. (+ λ, φ, ξ, η, r) to all be functions of (i, j, k, lx, ly, lz, grid) and return a number?. yes. > Then we want xspacings, yspacings, zspacings, etc. to return an array of spacings (perhaps with a with_halos flag)? Should it be an array or a Field?. The cleanest implementation is to return a `KernelFunctionOperation` that calls `xspacing`, `yspacing`, etc, under the hood. I don't really like `with_halos`, I think that's a plotting issue not a spacing issue. We can solve that via the Makie extension. Or one can write `Field(xspacings(grid, lx, ly, lz), indices=(1:Nx, 1:Ny, 1:Nz))`. `Field` works too as a return type but I don't think we need to always allocate memory for the spacings. One barrier to this was plotting, but this issue is beginning to be solved with the new extension:. https://github.com/CliMA/Oceananigans.jl/blob/f2a8fb32251135f9cd9b230e0873f7bc1936f762/ext/OceananigansMakieExt.jl#L41-L45. > Should the returned array/field be reduced when possible?. The `KernelFunctionOperation` should have `Nothing` locations if the spacings / metrics do not depend on that direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822:1028,Energy Efficiency,reduce,reduced,1028,"> Am I correct in thinking that we want xspacing, yspacing, zspacing, etc. (+ λ, φ, ξ, η, r) to all be functions of (i, j, k, lx, ly, lz, grid) and return a number?. yes. > Then we want xspacings, yspacings, zspacings, etc. to return an array of spacings (perhaps with a with_halos flag)? Should it be an array or a Field?. The cleanest implementation is to return a `KernelFunctionOperation` that calls `xspacing`, `yspacing`, etc, under the hood. I don't really like `with_halos`, I think that's a plotting issue not a spacing issue. We can solve that via the Makie extension. Or one can write `Field(xspacings(grid, lx, ly, lz), indices=(1:Nx, 1:Ny, 1:Nz))`. `Field` works too as a return type but I don't think we need to always allocate memory for the spacings. One barrier to this was plotting, but this issue is beginning to be solved with the new extension:. https://github.com/CliMA/Oceananigans.jl/blob/f2a8fb32251135f9cd9b230e0873f7bc1936f762/ext/OceananigansMakieExt.jl#L41-L45. > Should the returned array/field be reduced when possible?. The `KernelFunctionOperation` should have `Nothing` locations if the spacings / metrics do not depend on that direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822:1147,Integrability,depend,depend,1147,"> Am I correct in thinking that we want xspacing, yspacing, zspacing, etc. (+ λ, φ, ξ, η, r) to all be functions of (i, j, k, lx, ly, lz, grid) and return a number?. yes. > Then we want xspacings, yspacings, zspacings, etc. to return an array of spacings (perhaps with a with_halos flag)? Should it be an array or a Field?. The cleanest implementation is to return a `KernelFunctionOperation` that calls `xspacing`, `yspacing`, etc, under the hood. I don't really like `with_halos`, I think that's a plotting issue not a spacing issue. We can solve that via the Makie extension. Or one can write `Field(xspacings(grid, lx, ly, lz), indices=(1:Nx, 1:Ny, 1:Nz))`. `Field` works too as a return type but I don't think we need to always allocate memory for the spacings. One barrier to this was plotting, but this issue is beginning to be solved with the new extension:. https://github.com/CliMA/Oceananigans.jl/blob/f2a8fb32251135f9cd9b230e0873f7bc1936f762/ext/OceananigansMakieExt.jl#L41-L45. > Should the returned array/field be reduced when possible?. The `KernelFunctionOperation` should have `Nothing` locations if the spacings / metrics do not depend on that direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450514567:507,Usability,intuit,intuitive,507,"> If so, then we can have a generic KernelFunctionOperation that returns a 3D array of spacings, and specialize via dispatch wherever possible to return 2D and 1D arrays. Again I think this is a plotting issue and not a spacing issues. The strategy that our plotting extension takes is to drop singleton dimensions:. https://github.com/CliMA/Oceananigans.jl/blob/f2a8fb32251135f9cd9b230e0873f7bc1936f762/ext/OceananigansMakieExt.jl#L69-L83. maybe other approaches will be needed but this seems to be fairly intuitive so far",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450514567
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450646793:65,Usability,feedback,feedback,65,"@tomchor Yes! Thanks for catching that. @glwagner Thanks for the feedback! I think I know where to start. Although I may be approaching this from a NetCDF output perspective rather than a plotting perspective, I think the one solution we're discussing should satisfy both needs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450646793
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450863860:131,Modifiability,config,configured,131,"I also find `with_halos` a bit messy, but in this case it might be neccessary to output grid metrics to disk if JLD2 or NetCDF are configured to output the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450863860
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450926823:133,Modifiability,config,configured,133,"> I also find `with_halos` a bit messy, but in this case it might be neccessary to output grid metrics to disk if JLD2 or NetCDF are configured to output the halos. On the contrary with this approach you should be able to use the existing `construct_output`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/OutputWriters/output_construction.jl#L44-L46. which is designed for `Field` / `AbstractOperation` already. So I think again with this approach the kwarg `with_halo` is irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450926823
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2451107164:112,Testability,test,tests,112,"I took a stab at it, and it seems to work (see below). If this is what you guys had in mind then I can add some tests and docstrings. I wasn't too sure where to place these `*spacings` functions. They can't go into the `Grids` or `Operators` modules since we need `KernelFunctionOperation`. So I added them to the `AbstractOperations/grid_metrics.jl`. I think these clash with the existing definitions in `Grids/nodes_and_spacings.jl` so I commented out the old ones. Do we want to deprecate/get rid of them? I guess it'll be a breaking change (for the greater good of course!). ---. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(size=(4, 5, 6), extent=(1, 1, 1)); bottom(x, y) = -1 + (x + y) / 2; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(bottom)); model = NonhydrostaticModel(; grid). zspacings(model.velocities.u) |> interior; ```. ```; 4×5×6 view(::Array{Float64, 3}, 4:7, 4:8, 4:9) with eltype Float64:; [:, :, 1] =; 0.0541667 0.166667 0.166667 0.166667 0.166667; 0.0541667 0.166667 0.166667 0.166667 0.166667; 0.166667 0.166667 0.166667 0.166667 0.166667; 0.166667 0.166667 0.166667 0.166667 0.166667. [:, :, 2] =; 0.166667 0.120833 0.166667 0.166667 0.166667; 0.0958333 0.120833 0.166667 0.166667 0.166667; 0.0958333 0.166667 0.166667 0.166667 0.166667; 0.166667 0.166667 0.166667 0.166667 0.166667. [:, :, 3] =; 0.166667 0.166667 0.166667 0.0875 0.166667; 0.166667 0.1625 0.0625 0.0875 0.166667; 0.1375 0.0375 0.0625 0.166667 0.166667; 0.1375 0.0375 0.166667 0.166667 0.166667. [:, :, 4] =; 0.166667 0.0791667 0.166667 0.166667 0.154167; 0.166667 0.166667 0.166667 0.129167 0.154167; 0.166667 0.166667 0.104167 0.129167 0.166667; 0.166667 0.0791667 0.104167 0.166667 0.166667. [:, :, 5] =; 0.166667 0.166667 0.145833 0.0458333 0.166667; 0.166667 0.166667 0.166667 0.166667 0.166667; 0.166667 0.166667 0.166667 0.166667 0.0708333; 0.166667 0.166667 0.145833 0.0458333 0.0708333. [:, :, 6] =; 0.166",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2451107164
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:504,Integrability,interface,interface,504,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:12,Modifiability,refactor,refactoring,12,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:35,Testability,test,tests,35,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:122,Testability,test,tests,122,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:586,Testability,test,tests,586,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221
https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459922652:68,Modifiability,refactor,refactor,68,Also apologies if this is PR feature scope but I found it easier to refactor if I de-cluttered the `ImmersedBoundaries.jl` module file. This ended up creating three new files:. * `immersed_boundary_grid.jl`; * `immersed_boundary_interface.jl`; * `immersed_boundary_nodes.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459922652
https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151:567,Integrability,interface,interface,567,"I know it's documented in the code but also: https://github.com/CliMA/Oceananigans.jl/blob/bf04295910ef02ca3d4105bee801070deef99175/src/OutputReaders/field_time_series_reductions.jl#L17. Would something simple like this work?. ```julia; function reduce_4d(spatial_reduction::Function, temporal_reduction::Function, f::Function, fts::FTS4D; dims, kw...); reduced_snapshots = [; spatial_reduction(f, fts[n]; dims=filter(d -> d != 4, dims), kw...); for n in 1:length(fts.times); ]; return temporal_reduction(reduced_snapshots); end; ```. I guess we might want a similar interface to the 3D reductions but this should work for all the reductions in `field_time_series.jl`: `(:sum, :maximum, :minimum, :all, :any, :prod)`. It wouldn't work for things like `median` or `quantile` which need to act on the entire 4D array at once, but maybe these aren't _actually_ reductions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151
https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151:203,Usability,simpl,simple,203,"I know it's documented in the code but also: https://github.com/CliMA/Oceananigans.jl/blob/bf04295910ef02ca3d4105bee801070deef99175/src/OutputReaders/field_time_series_reductions.jl#L17. Would something simple like this work?. ```julia; function reduce_4d(spatial_reduction::Function, temporal_reduction::Function, f::Function, fts::FTS4D; dims, kw...); reduced_snapshots = [; spatial_reduction(f, fts[n]; dims=filter(d -> d != 4, dims), kw...); for n in 1:length(fts.times); ]; return temporal_reduction(reduced_snapshots); end; ```. I guess we might want a similar interface to the 3D reductions but this should work for all the reductions in `field_time_series.jl`: `(:sum, :maximum, :minimum, :all, :any, :prod)`. It wouldn't work for things like `median` or `quantile` which need to act on the entire 4D array at once, but maybe these aren't _actually_ reductions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151
https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322240720:42,Usability,simpl,simple,42,Perhaps I should know this but is there a simple summary of why supporting reductions across the 4th dimension are hard?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322240720
https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097:931,Availability,mask,mask,931,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097
https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097:979,Availability,mask,mask,979,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097
https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097:207,Energy Efficiency,reduce,reduced,207,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097
https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097:367,Usability,simpl,simply,367,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595189695:234,Availability,down,down,234,"I agree. Perhaps we could link releases that introduce breaking changes to a specific PR that's dedicated to updating the version and detailing the API breaking change. This might be tedious work (for us) because it involves tracking down all API changes in past PRs, but it might be very beneficial for users",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595189695
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595189695:31,Deployability,release,releases,31,"I agree. Perhaps we could link releases that introduce breaking changes to a specific PR that's dedicated to updating the version and detailing the API breaking change. This might be tedious work (for us) because it involves tracking down all API changes in past PRs, but it might be very beneficial for users",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595189695
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:1849,Availability,error,errors,1849,"vant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). I'm not sure this is feasible. To use `git blame` to find the PR, navigate to `Project.toml` and toggle the `Blame` key at the top left of the file:. <img width=""784"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/2a5bbaa9-d6d2-4cda-8020-82ed2dbef46a"">. In this case the breaking change is supposedly on #2912. I started a discussion here: https://github.com/CliMA/Oceananigans.jl/commit/4ff41ab95c1313715e91863a9b3bc2dc8ab1d458",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:2152,Availability,error,error-by-error,2152,"vant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). I'm not sure this is feasible. To use `git blame` to find the PR, navigate to `Project.toml` and toggle the `Blame` key at the top left of the file:. <img width=""784"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/2a5bbaa9-d6d2-4cda-8020-82ed2dbef46a"">. In this case the breaking change is supposedly on #2912. I started a discussion here: https://github.com/CliMA/Oceananigans.jl/commit/4ff41ab95c1313715e91863a9b3bc2dc8ab1d458",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:122,Deployability,update,update,122,"I agree with this --- though this something similar is already our policy. PRs that have breaking changes are supposed to update the minor version, and also describe the PR in words in the top comment, which certainly includes describing a breaking change. It's true that we don't achieve this, however. We could be stricter in PR reviews?. To make it easier to find the specific PRs that has the change which updates the minor version within release notes, we could have a policy to put the new version in the name of the PR, ie preface the PR with. ```; (0.83.0) Title of the PR; ```. That way one can easily find the relevant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:410,Deployability,update,updates,410,"I agree with this --- though this something similar is already our policy. PRs that have breaking changes are supposed to update the minor version, and also describe the PR in words in the top comment, which certainly includes describing a breaking change. It's true that we don't achieve this, however. We could be stricter in PR reviews?. To make it easier to find the specific PRs that has the change which updates the minor version within release notes, we could have a policy to put the new version in the name of the PR, ie preface the PR with. ```; (0.83.0) Title of the PR; ```. That way one can easily find the relevant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:443,Deployability,release,release,443,"I agree with this --- though this something similar is already our policy. PRs that have breaking changes are supposed to update the minor version, and also describe the PR in words in the top comment, which certainly includes describing a breaking change. It's true that we don't achieve this, however. We could be stricter in PR reviews?. To make it easier to find the specific PRs that has the change which updates the minor version within release notes, we could have a policy to put the new version in the name of the PR, ie preface the PR with. ```; (0.83.0) Title of the PR; ```. That way one can easily find the relevant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:683,Deployability,release,release,683,"I agree with this --- though this something similar is already our policy. PRs that have breaking changes are supposed to update the minor version, and also describe the PR in words in the top comment, which certainly includes describing a breaking change. It's true that we don't achieve this, however. We could be stricter in PR reviews?. To make it easier to find the specific PRs that has the change which updates the minor version within release notes, we could have a policy to put the new version in the name of the PR, ie preface the PR with. ```; (0.83.0) Title of the PR; ```. That way one can easily find the relevant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:1171,Deployability,release,release,1171," describe the PR in words in the top comment, which certainly includes describing a breaking change. It's true that we don't achieve this, however. We could be stricter in PR reviews?. To make it easier to find the specific PRs that has the change which updates the minor version within release notes, we could have a policy to put the new version in the name of the PR, ie preface the PR with. ```; (0.83.0) Title of the PR; ```. That way one can easily find the relevant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:1276,Deployability,release,release,1276," describe the PR in words in the top comment, which certainly includes describing a breaking change. It's true that we don't achieve this, however. We could be stricter in PR reviews?. To make it easier to find the specific PRs that has the change which updates the minor version within release notes, we could have a policy to put the new version in the name of the PR, ie preface the PR with. ```; (0.83.0) Title of the PR; ```. That way one can easily find the relevant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:1666,Deployability,update,update,1666,"vant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). I'm not sure this is feasible. To use `git blame` to find the PR, navigate to `Project.toml` and toggle the `Blame` key at the top left of the file:. <img width=""784"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/2a5bbaa9-d6d2-4cda-8020-82ed2dbef46a"">. In this case the breaking change is supposedly on #2912. I started a discussion here: https://github.com/CliMA/Oceananigans.jl/commit/4ff41ab95c1313715e91863a9b3bc2dc8ab1d458",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:1726,Deployability,update,update,1726,"vant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). I'm not sure this is feasible. To use `git blame` to find the PR, navigate to `Project.toml` and toggle the `Blame` key at the top left of the file:. <img width=""784"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/2a5bbaa9-d6d2-4cda-8020-82ed2dbef46a"">. In this case the breaking change is supposedly on #2912. I started a discussion here: https://github.com/CliMA/Oceananigans.jl/commit/4ff41ab95c1313715e91863a9b3bc2dc8ab1d458",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:1875,Deployability,update,update,1875,"vant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). I'm not sure this is feasible. To use `git blame` to find the PR, navigate to `Project.toml` and toggle the `Blame` key at the top left of the file:. <img width=""784"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/2a5bbaa9-d6d2-4cda-8020-82ed2dbef46a"">. In this case the breaking change is supposedly on #2912. I started a discussion here: https://github.com/CliMA/Oceananigans.jl/commit/4ff41ab95c1313715e91863a9b3bc2dc8ab1d458",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:1982,Deployability,update,update,1982,"vant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). I'm not sure this is feasible. To use `git blame` to find the PR, navigate to `Project.toml` and toggle the `Blame` key at the top left of the file:. <img width=""784"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/2a5bbaa9-d6d2-4cda-8020-82ed2dbef46a"">. In this case the breaking change is supposedly on #2912. I started a discussion here: https://github.com/CliMA/Oceananigans.jl/commit/4ff41ab95c1313715e91863a9b3bc2dc8ab1d458",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:2266,Deployability,toggle,toggle,2266,"vant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). I'm not sure this is feasible. To use `git blame` to find the PR, navigate to `Project.toml` and toggle the `Blame` key at the top left of the file:. <img width=""784"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/2a5bbaa9-d6d2-4cda-8020-82ed2dbef46a"">. In this case the breaking change is supposedly on #2912. I started a discussion here: https://github.com/CliMA/Oceananigans.jl/commit/4ff41ab95c1313715e91863a9b3bc2dc8ab1d458",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085:1919,Testability,test,test,1919,"vant PR if there is a long list of PRs within a particular release, only one of which is important. (Note this information can also be obtained via `git blame` on `Project.toml`.). One concern I have is that we struggle to enforce conventions already, like style conventions in source code, branch naming conventions, etc. For example, issues should be labeled --- this issue itself needs a label!. What do we think about working on making PR titles more descriptive and helpful, rather than copying information that I think should be in PRs into release notes? It's nice to encourage people to look at PRs too; we can have conversations there (unlike release notes). As far as breaking changes go, by definition they should be encapsulated in a single PR so I think this will succeed. Another policy change that could help is to require two approving reviews (rather than just one), and to also informally try to be more strict about approving PRs. > Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.). Isn't trying an update and running some code / some kind of test the fastest and most effective way to deciding whether to update some package? . > If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). I'm not sure this is feasible. To use `git blame` to find the PR, navigate to `Project.toml` and toggle the `Blame` key at the top left of the file:. <img width=""784"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/2a5bbaa9-d6d2-4cda-8020-82ed2dbef46a"">. In this case the breaking change is supposedly on #2912. I started a discussion here: https://github.com/CliMA/Oceananigans.jl/commit/4ff41ab95c1313715e91863a9b3bc2dc8ab1d458",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:992,Availability,avail,available,992,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:65,Deployability,release,release,65,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:133,Deployability,release,releases,133,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:287,Deployability,release,release,287,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:239,Modifiability,extend,extended,239,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:1266,Usability,simpl,simple,1266,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:1688,Usability,undo,undo,1688,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1622137852:64,Deployability,release,release,64,"The PR titles should contain all information, so ""modifying the release notes"" should really just be copy/paste only. If you find yourself modifying notes with more than copy/paste, the problem is that the PR was not correctly titled.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1622137852
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599991092:23,Usability,simpl,simply,23,"I agree, it seems best simply to add drag to the internal tide example for the time being.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599991092
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028:461,Security,validat,validation,461,"The main rationale for not having an immersed boundary conditions example was because we regarded it as an experimental feature, and didn't want to trip new users up (which is the opposite of the motivation #3). We could change our philosophy though. @tomchor you may not realize it, but you probably have the most experience with immersed boundary conditions. I think it's reasonable that nobody has added an example for these yet. I don't think there are any validation tests at all, or papers that use them, in constrast to much of the rest of the code. The fact that a major bug like the one found in #3142 still exists is a testament to the fact that these are unvalidated, and I think also validates our justification for not having an example yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028:696,Security,validat,validates,696,"The main rationale for not having an immersed boundary conditions example was because we regarded it as an experimental feature, and didn't want to trip new users up (which is the opposite of the motivation #3). We could change our philosophy though. @tomchor you may not realize it, but you probably have the most experience with immersed boundary conditions. I think it's reasonable that nobody has added an example for these yet. I don't think there are any validation tests at all, or papers that use them, in constrast to much of the rest of the code. The fact that a major bug like the one found in #3142 still exists is a testament to the fact that these are unvalidated, and I think also validates our justification for not having an example yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028:472,Testability,test,tests,472,"The main rationale for not having an immersed boundary conditions example was because we regarded it as an experimental feature, and didn't want to trip new users up (which is the opposite of the motivation #3). We could change our philosophy though. @tomchor you may not realize it, but you probably have the most experience with immersed boundary conditions. I think it's reasonable that nobody has added an example for these yet. I don't think there are any validation tests at all, or papers that use them, in constrast to much of the rest of the code. The fact that a major bug like the one found in #3142 still exists is a testament to the fact that these are unvalidated, and I think also validates our justification for not having an example yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028:629,Testability,test,testament,629,"The main rationale for not having an immersed boundary conditions example was because we regarded it as an experimental feature, and didn't want to trip new users up (which is the opposite of the motivation #3). We could change our philosophy though. @tomchor you may not realize it, but you probably have the most experience with immersed boundary conditions. I think it's reasonable that nobody has added an example for these yet. I don't think there are any validation tests at all, or papers that use them, in constrast to much of the rest of the code. The fact that a major bug like the one found in #3142 still exists is a testament to the fact that these are unvalidated, and I think also validates our justification for not having an example yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1600893042:128,Deployability,release,release,128,"I guess imo it's a bit of a chicken and egg problem, since bugs are found when people start use the feature. And we don't wanna release the feature until bugs are found. So my thinking in suggesting an example is an attempt to break the cycle. But it's a good point that the first users of a feature that's still unvalidated should probably more ""experienced"" ones. Since now there's an example in the works with immersed boundaries, does that mean that that feature is not considered experimental anymore?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1600893042
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1030,Energy Efficiency,adapt,adapted,1030,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:412,Integrability,interface,interface,412,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:490,Integrability,interface,interfaces,490,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1030,Modifiability,adapt,adapted,1030,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:199,Security,validat,validation,199,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:322,Security,validat,validation,322,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:678,Security,validat,validation,678,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:882,Security,validat,validation,882,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1041,Security,validat,validate,1041,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1306,Security,validat,validation,1306,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1425,Security,validat,validated,1425,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1493,Security,validat,validate,1493,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:49,Testability,Test,Testing,49,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:210,Testability,test,test,210,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:689,Testability,test,tests,689,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1317,Testability,test,test,1317,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980:110,Integrability,interface,interface,110,"> I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. That's where the chicken and egg problem comes from IMO. It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. But that's only my personal opinion and that's obviously up for debate. I'll close this issue we apparently aren't ready for what I proposed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980:188,Integrability,interface,interfaces,188,"> I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. That's where the chicken and egg problem comes from IMO. It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. But that's only my personal opinion and that's obviously up for debate. I'll close this issue we apparently aren't ready for what I proposed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980:368,Integrability,interface,interface,368,"> I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. That's where the chicken and egg problem comes from IMO. It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. But that's only my personal opinion and that's obviously up for debate. I'll close this issue we apparently aren't ready for what I proposed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980:20,Security,validat,validation,20,"> I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. That's where the chicken and egg problem comes from IMO. It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. But that's only my personal opinion and that's obviously up for debate. I'll close this issue we apparently aren't ready for what I proposed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:46,Integrability,interface,interface,46,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:193,Integrability,interface,interface,193,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:262,Integrability,interface,interface,262,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:147,Security,validat,validation,147,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:229,Security,validat,validation,229,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:252,Security,expose,expose,252,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:158,Testability,test,test,158,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:240,Testability,test,test,240,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606158789:325,Integrability,interface,interface,325,"> True.; > ; > @tomchor would you be keen to add drag in the internal tide example? If you just add the code I can deal w the rest. I can, but I don't really see drag there adding value to the example. @navidcy, do you think it would be relevant to the physics? Or do we just want drag to be there as an example of using the interface?. Also, I'm not very familiar with these larger-scale, hydrostatic simulations. What's the physically-preferred way to add drag there? Does something like. ```math; \vec\tau = -C^D \vec u \sqrt{u^2+v^2}; ```; (applied to `bottom`, `west` and `east`, with $C^D \approx$ 1e-3) look reasonable?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606158789
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606264607:100,Integrability,interface,interface,100,"Indeed, I don't think drag is so relevant physically for this problem but it should demonstrate the interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606264607
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370:71,Integrability,depend,dependence,71,"And right, for thin aspect ratios (H/L << 1), we typically neglect the dependence on `w` for two reasons: (1) `w` is small (eg `w ~ u * H/L`), and (2) `w` is non-zero only on side-walls, which make a negligible contribution to the overall flux, because side-wall areas are O(H/L) smaller than vertical-normal areas. For this example, we can either use a hydrostatic-specific drag, or we can use a more general formulation and comment on how it could be simplified using an assumption of thin-aspect ratio (which is also the basis for the hydrostatic approximation). In the context of Oceananigans, it turns out to be _simpler_ to specify a 3D drag. So the ""simplification"" for thin-aspect ratio isn't as important as it is, for example, for analytical / theoretical calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370:453,Usability,simpl,simplified,453,"And right, for thin aspect ratios (H/L << 1), we typically neglect the dependence on `w` for two reasons: (1) `w` is small (eg `w ~ u * H/L`), and (2) `w` is non-zero only on side-walls, which make a negligible contribution to the overall flux, because side-wall areas are O(H/L) smaller than vertical-normal areas. For this example, we can either use a hydrostatic-specific drag, or we can use a more general formulation and comment on how it could be simplified using an assumption of thin-aspect ratio (which is also the basis for the hydrostatic approximation). In the context of Oceananigans, it turns out to be _simpler_ to specify a 3D drag. So the ""simplification"" for thin-aspect ratio isn't as important as it is, for example, for analytical / theoretical calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370
https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370:657,Usability,simpl,simplification,657,"And right, for thin aspect ratios (H/L << 1), we typically neglect the dependence on `w` for two reasons: (1) `w` is small (eg `w ~ u * H/L`), and (2) `w` is non-zero only on side-walls, which make a negligible contribution to the overall flux, because side-wall areas are O(H/L) smaller than vertical-normal areas. For this example, we can either use a hydrostatic-specific drag, or we can use a more general formulation and comment on how it could be simplified using an assumption of thin-aspect ratio (which is also the basis for the hydrostatic approximation). In the context of Oceananigans, it turns out to be _simpler_ to specify a 3D drag. So the ""simplification"" for thin-aspect ratio isn't as important as it is, for example, for analytical / theoretical calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370
https://github.com/CliMA/Oceananigans.jl/pull/3149#issuecomment-1605256793:60,Testability,test,tests,60,(It's not that important for Oceananigans since most of our tests run with buildkite rather than with GitHub Actions. But it's a good thing to have anyway.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3149#issuecomment-1605256793
https://github.com/CliMA/Oceananigans.jl/pull/3149#issuecomment-1605866380:29,Testability,test,tests,29,It would be nice to run unit tests on github actions before launching buildkite jobs. Someday...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3149#issuecomment-1605866380
https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163:78,Integrability,depend,depending,78,before it was 52 or 56min... so perhaps it helped slightly but also sometimes depending on how many thing tartarus is doing at the moment you can have some variability in times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163
https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163:156,Modifiability,variab,variability,156,before it was 52 or 56min... so perhaps it helped slightly but also sometimes depending on how many thing tartarus is doing at the moment you can have some variability in times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163
https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1613995023:213,Performance,optimiz,optimize,213,I just noticed:. https://buildkite.com/clima/oceananigans/builds/11955#018909c3-4c60-4b9c-b4e2-c6260d8b2189/40-2662. ```; [ Info: shallow_water_Bickley_jet.jl example took 28.452 minutes to build.; ```. We should optimize that or make it run first!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1613995023
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1605866597:106,Testability,test,test,106,Should we also use `deflatelevel` for the name of the `NetCDFOutputWriter` kwarg?. It'd be nice to have a test for this I think.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1605866597
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608564895:67,Availability,error,error,67,"BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword \(See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)\). That means that older versions of `Oceananigans.jl` \(\< 0.84\) will not work with newer versions of `NCDatasets.jl` \(\>0.12.17\).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608564895
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608564895:17,Deployability,release,release,17,"BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword \(See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)\). That means that older versions of `Oceananigans.jl` \(\< 0.84\) will not work with newer versions of `NCDatasets.jl` \(\>0.12.17\).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608564895
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608576153:69,Availability,error,error,69,"> BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword (See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)).; > ; > That means that older versions of `Oceananigans.jl` (< 0.84) will not work with newer versions of `NCDatasets.jl` (>0.12.17). Sounds that NCDatasets is gonna have a breaking change but _not_ a minor release?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608576153
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608576153:19,Deployability,release,release,19,"> BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword (See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)).; > ; > That means that older versions of `Oceananigans.jl` (< 0.84) will not work with newer versions of `NCDatasets.jl` (>0.12.17). Sounds that NCDatasets is gonna have a breaking change but _not_ a minor release?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608576153
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608576153:399,Deployability,release,release,399,"> BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword (See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)).; > ; > That means that older versions of `Oceananigans.jl` (< 0.84) will not work with newer versions of `NCDatasets.jl` (>0.12.17). Sounds that NCDatasets is gonna have a breaking change but _not_ a minor release?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608576153
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825:70,Availability,down,down,70,"I do not mean that. I think it should be a major change. When I wrote down that sentence, I did not realize that `compat` in `Project.toml` can prevent using newer versions of dependencies with breaking changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825:176,Integrability,depend,dependencies,176,"I do not mean that. I think it should be a major change. When I wrote down that sentence, I did not realize that `compat` in `Project.toml` can prevent using newer versions of dependencies with breaking changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608761156:69,Availability,error,error,69,"> BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword (See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)).; > ; > That means that older versions of `Oceananigans.jl` (< 0.84) will not work with newer versions of `NCDatasets.jl` (>0.12.17). That's good to know, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608761156
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608761156:19,Deployability,release,release,19,"> BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword (See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)).; > ; > That means that older versions of `Oceananigans.jl` (< 0.84) will not work with newer versions of `NCDatasets.jl` (>0.12.17). That's good to know, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608761156
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608761817:179,Deployability,release,release,179,"> As per the discussion in the PR, let's change the kwarg from `compression` to `deflatelevel`.; > ; > This is a breaking API change so @Yixiao-Zhang can you also bump up a minor release? That is, change the version number here: https://github.com/Yixiao-Zhang/Oceananigans.jl/blob/36961523d3b35bfb08e9af779504b99beb60d585/Project.toml#L4 to 0.84.0 ?. Also the title of the PR should be prepended with the new version ie `(0.84.0) Fix NetCDF...`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608761817
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1613664526:169,Deployability,release,releases,169,I thought that it wouldn’t make sense to register v0.84 and 20min later v0.85…. I added a description of the breaking change in https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0 and one can see in the PRs below the release description for more details.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1613664526
https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1613664526:227,Deployability,release,release,227,I thought that it wouldn’t make sense to register v0.84 and 20min later v0.85…. I added a description of the breaking change in https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0 and one can see in the PRs below the release description for more details.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1613664526
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605301393:553,Safety,safe,safe,553,"Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). I think my gut feeling would be against implementing such a feature, mostly because of the _test and maintain_ part you mentioned. Also because I can see sort-of-easy ways around it. Perhaps I'm missing something? E.g. I don't really quite understand what do you mean by ""safe to pick-up"" and ""due to the way pick-ups work"" in. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605301393
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605301393:682,Safety,safe,safe,682,"Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). I think my gut feeling would be against implementing such a feature, mostly because of the _test and maintain_ part you mentioned. Also because I can see sort-of-easy ways around it. Perhaps I'm missing something? E.g. I don't really quite understand what do you mean by ""safe to pick-up"" and ""due to the way pick-ups work"" in. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605301393
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680:1525,Availability,down,downside,1525,"rpretable and readable. I'm not sure we would achieve the same if we hide such a feature inside the source code. Does @navidcy's suggestion work for you @tomchor ?. I also think it is preferred to use separate files for a situation like this (though it may not be necessary to save intermediate times in the spin-up at all --- so a second file might not be necessary). If the spin up is recorded, I think it's better to use a separate file for its data. If the spin up is expensive, the following performance optimization could be used (we can leverage the `velocities` kwarg to save a bit of allocation):. ```julia; # Spin up with no tracers; model = NonhydrostaticModel(; tracers=nothing, kwargs...); simulation = Simulation(model, ...) # etc; run!(simulation). # Run for real, re-using the old `velocities` fields but overwriting the old `model`; model = NonhydrostaticModel(; tracers=:c, velocities=model.velocities, kwargs...); simulation = Simulation(model, ...) # etc; ```. There is some additional memory allocation for tendencies in this case, however, so it may not work for simulations that push GPU memory. > (I'm not aware of any way to ""remove"" the old Simulation from the GPU memory, but if there is, then this downside can be negated.). This occurs automatically with garbage collection, provided that there's no reference to the old simulation in the name space. CUDA may have a way to manually call the garbage collector, after doing something like `model=nothing; simulation=nothing`. If you figure that out, it'd be nice to know. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work. I don't follow, but if there's something to improve about picking simulations up we should pursue that. PS @milankl may be interested in this discussion, because it illustrates the importance of being able to modify tracer fields mid-run rather than requiring that they are initialized when the model is built.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680:796,Performance,perform,performance,796,"I agree with @navidcy's points. Of course, it doesn't even matter whether the tracer is initialized or not (referring to the comment in @navidcy's script). The main point is that you can ""re-initialize"" a state whenever you like. I'd also like to make the extra point that @navidcy's pattern is interpretable and readable. I'm not sure we would achieve the same if we hide such a feature inside the source code. Does @navidcy's suggestion work for you @tomchor ?. I also think it is preferred to use separate files for a situation like this (though it may not be necessary to save intermediate times in the spin-up at all --- so a second file might not be necessary). If the spin up is recorded, I think it's better to use a separate file for its data. If the spin up is expensive, the following performance optimization could be used (we can leverage the `velocities` kwarg to save a bit of allocation):. ```julia; # Spin up with no tracers; model = NonhydrostaticModel(; tracers=nothing, kwargs...); simulation = Simulation(model, ...) # etc; run!(simulation). # Run for real, re-using the old `velocities` fields but overwriting the old `model`; model = NonhydrostaticModel(; tracers=:c, velocities=model.velocities, kwargs...); simulation = Simulation(model, ...) # etc; ```. There is some additional memory allocation for tendencies in this case, however, so it may not work for simulations that push GPU memory. > (I'm not aware of any way to ""remove"" the old Simulation from the GPU memory, but if there is, then this downside can be negated.). This occurs automatically with garbage collection, provided that there's no reference to the old simulation in the name space. CUDA may have a way to manually call the garbage collector, after doing something like `model=nothing; simulation=nothing`. If you figure that out, it'd be nice to know. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work. I don't foll",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680:808,Performance,optimiz,optimization,808,"I agree with @navidcy's points. Of course, it doesn't even matter whether the tracer is initialized or not (referring to the comment in @navidcy's script). The main point is that you can ""re-initialize"" a state whenever you like. I'd also like to make the extra point that @navidcy's pattern is interpretable and readable. I'm not sure we would achieve the same if we hide such a feature inside the source code. Does @navidcy's suggestion work for you @tomchor ?. I also think it is preferred to use separate files for a situation like this (though it may not be necessary to save intermediate times in the spin-up at all --- so a second file might not be necessary). If the spin up is recorded, I think it's better to use a separate file for its data. If the spin up is expensive, the following performance optimization could be used (we can leverage the `velocities` kwarg to save a bit of allocation):. ```julia; # Spin up with no tracers; model = NonhydrostaticModel(; tracers=nothing, kwargs...); simulation = Simulation(model, ...) # etc; run!(simulation). # Run for real, re-using the old `velocities` fields but overwriting the old `model`; model = NonhydrostaticModel(; tracers=:c, velocities=model.velocities, kwargs...); simulation = Simulation(model, ...) # etc; ```. There is some additional memory allocation for tendencies in this case, however, so it may not work for simulations that push GPU memory. > (I'm not aware of any way to ""remove"" the old Simulation from the GPU memory, but if there is, then this downside can be negated.). This occurs automatically with garbage collection, provided that there's no reference to the old simulation in the name space. CUDA may have a way to manually call the garbage collector, after doing something like `model=nothing; simulation=nothing`. If you figure that out, it'd be nice to know. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work. I don't foll",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680:1922,Safety,safe,safe,1922,"rpretable and readable. I'm not sure we would achieve the same if we hide such a feature inside the source code. Does @navidcy's suggestion work for you @tomchor ?. I also think it is preferred to use separate files for a situation like this (though it may not be necessary to save intermediate times in the spin-up at all --- so a second file might not be necessary). If the spin up is recorded, I think it's better to use a separate file for its data. If the spin up is expensive, the following performance optimization could be used (we can leverage the `velocities` kwarg to save a bit of allocation):. ```julia; # Spin up with no tracers; model = NonhydrostaticModel(; tracers=nothing, kwargs...); simulation = Simulation(model, ...) # etc; run!(simulation). # Run for real, re-using the old `velocities` fields but overwriting the old `model`; model = NonhydrostaticModel(; tracers=:c, velocities=model.velocities, kwargs...); simulation = Simulation(model, ...) # etc; ```. There is some additional memory allocation for tendencies in this case, however, so it may not work for simulations that push GPU memory. > (I'm not aware of any way to ""remove"" the old Simulation from the GPU memory, but if there is, then this downside can be negated.). This occurs automatically with garbage collection, provided that there's no reference to the old simulation in the name space. CUDA may have a way to manually call the garbage collector, after doing something like `model=nothing; simulation=nothing`. If you figure that out, it'd be nice to know. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work. I don't follow, but if there's something to improve about picking simulations up we should pursue that. PS @milankl may be interested in this discussion, because it illustrates the importance of being able to modify tracer fields mid-run rather than requiring that they are initialized when the model is built.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386:550,Security,access,access,550,"Thanks, everyone. I agree with the major points here. To answer some specific comments:. > Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). This is mostly because the majority of my exploratory runs are run in the GPU, and since I have limited GPU time I try to not leave interactive GPU sessions open. If I unlimited access to a GPU (or in the cases where I can explore on the CPU), then I agree with your point. > I agree with Navid, it is better to have a more complicated script for cases this specific than a complicated source code. Again, agree. I posted this more because, if this was something a lot of other people were doing, it might be worth to maintain the infrastructure. But since it sounds like that's not the case, then I agree it's best to have complex user scripts and keep the source code simple. > Does @navidcy's suggestion work for you @tomchor ?. Yes, thanks for the suggestion @navidcy. I think this is the next best thing. The one disadvantage for me is that is ""wastes"" computation advecting tracers in the spin-up, but it has the huge advantage of keeping the source code simple, with also a readable user script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386:1042,Usability,simpl,simple,1042,"Thanks, everyone. I agree with the major points here. To answer some specific comments:. > Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). This is mostly because the majority of my exploratory runs are run in the GPU, and since I have limited GPU time I try to not leave interactive GPU sessions open. If I unlimited access to a GPU (or in the cases where I can explore on the CPU), then I agree with your point. > I agree with Navid, it is better to have a more complicated script for cases this specific than a complicated source code. Again, agree. I posted this more because, if this was something a lot of other people were doing, it might be worth to maintain the infrastructure. But since it sounds like that's not the case, then I agree it's best to have complex user scripts and keep the source code simple. > Does @navidcy's suggestion work for you @tomchor ?. Yes, thanks for the suggestion @navidcy. I think this is the next best thing. The one disadvantage for me is that is ""wastes"" computation advecting tracers in the spin-up, but it has the huge advantage of keeping the source code simple, with also a readable user script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386:1333,Usability,simpl,simple,1333,"Thanks, everyone. I agree with the major points here. To answer some specific comments:. > Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). This is mostly because the majority of my exploratory runs are run in the GPU, and since I have limited GPU time I try to not leave interactive GPU sessions open. If I unlimited access to a GPU (or in the cases where I can explore on the CPU), then I agree with your point. > I agree with Navid, it is better to have a more complicated script for cases this specific than a complicated source code. Again, agree. I posted this more because, if this was something a lot of other people were doing, it might be worth to maintain the infrastructure. But since it sounds like that's not the case, then I agree it's best to have complex user scripts and keep the source code simple. > Does @navidcy's suggestion work for you @tomchor ?. Yes, thanks for the suggestion @navidcy. I think this is the next best thing. The one disadvantage for me is that is ""wastes"" computation advecting tracers in the spin-up, but it has the huge advantage of keeping the source code simple, with also a readable user script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613470449:190,Availability,down,downside,190,"Huh, why is that easier? This judgement might be specific to your use case, so I wouldn't recommend taking that approach in general (for future readers of this issue). There is an important downside: the script is harder to read and interpret. So I'd regard that as less-than-best practice unless there's some specific reason to do it. (One reason could be: many similar simulations are being created using a function.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613470449
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613481559:41,Performance,perform,performance,41,"I thought of another way to achieve this performance optimization without any source-code-specific feature. For a simulation without buoyancy, for example, this might work:. ```julia; # Construct the full model with all desired tracers; model = NonHydrostaticModel(; grid, tracers, ...). model_properties = []; for name in propertynames(model); if name == :tracers; push!(model_properties, nothing); else; push!(model_properties, getproperty(model, name)); end; end. # Build a ""spin-up"" model using the inner constructor for NonhydrostaticModel, with tracers=nothing; spin_up_model = NonhydrostaticModel(model_properties...); ```. I believe that `spin_up_model` will run without evolving tracers. If you require _some_ tracers (ie active tracers like buoyancy) then things are slightly more complicated. You have to replace `tracers=nothing` with the appropriate `NamedTuple`. Also, I think you need to ensure that the active tracers are ""first"" in the list of tracers when the full model is built. Something like. ```julia; # Construct the full model with all desired tracers; model = NonHydrostaticModel(; grid, tracers=(T, S, c1, c2, c3, c4), ...). active_tracers = (T = model.tracers.T, S = model.tracers.S); model_properties = []; for name in propertynames(model); if name == :tracers; push!(model_properties, active_tracers); else; push!(model_properties, getproperty(model, name)); end; end. # Build a ""spin-up"" model using the inner constructor for NonhydrostaticModel, with tracers=(; T, S); spin_up_model = NonhydrostaticModel(model_properties...); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613481559
https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613481559:53,Performance,optimiz,optimization,53,"I thought of another way to achieve this performance optimization without any source-code-specific feature. For a simulation without buoyancy, for example, this might work:. ```julia; # Construct the full model with all desired tracers; model = NonHydrostaticModel(; grid, tracers, ...). model_properties = []; for name in propertynames(model); if name == :tracers; push!(model_properties, nothing); else; push!(model_properties, getproperty(model, name)); end; end. # Build a ""spin-up"" model using the inner constructor for NonhydrostaticModel, with tracers=nothing; spin_up_model = NonhydrostaticModel(model_properties...); ```. I believe that `spin_up_model` will run without evolving tracers. If you require _some_ tracers (ie active tracers like buoyancy) then things are slightly more complicated. You have to replace `tracers=nothing` with the appropriate `NamedTuple`. Also, I think you need to ensure that the active tracers are ""first"" in the list of tracers when the full model is built. Something like. ```julia; # Construct the full model with all desired tracers; model = NonHydrostaticModel(; grid, tracers=(T, S, c1, c2, c3, c4), ...). active_tracers = (T = model.tracers.T, S = model.tracers.S); model_properties = []; for name in propertynames(model); if name == :tracers; push!(model_properties, active_tracers); else; push!(model_properties, getproperty(model, name)); end; end. # Build a ""spin-up"" model using the inner constructor for NonhydrostaticModel, with tracers=(; T, S); spin_up_model = NonhydrostaticModel(model_properties...); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613481559
https://github.com/CliMA/Oceananigans.jl/issues/3158#issuecomment-1610955565:45,Modifiability,parameteriz,parameterizations,45,"Another application is for regularization in parameterizations, for example:; ```julia; Ri = ℑxyᶜᶜᵃ(i, j, k, grid, ℑxyᶠᶠᵃ, diffusivities.Ri) # Not boundary-aware . Ri = ℑxyᶜᶜᶜ(i, j, k, grid, ℑxyᶠᶠᶜ, diffusivities.Ri) # Boundary-aware ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3158#issuecomment-1610955565
https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1622122607:203,Deployability,update,update,203,Note that this could be considered bad practice (ie we ran into similar issues with julia 1.7 + MPI on apple silicon). Really we should fix the jll's. I'm ok with it as a bandaid though. We will have to update the jll in the future.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1622122607
https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1622336058:73,Deployability,update,updated,73,I know. But we need to plot! I think the issue goes away w Julia v1.9. I updated all deps no restrictions and don’t think there was an issue w Makie.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1622336058
https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623532631:16,Deployability,patch,patch,16,Could we have a patch release soon so that this fix gets out?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623532631
https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623532631:22,Deployability,release,release,22,Could we have a patch release soon so that this fix gets out?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623532631
https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623537319:46,Availability,down,downgrade,46,do you get the same issue? you can forcefully downgrade the above `jll` files.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623537319
https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623538067:56,Deployability,release,release,56,I don't know If this is an issue with the latest tagged release. is it?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623538067
https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623565698:107,Availability,down,downgrade,107,"Yeah, I get this issue too with the latest tag and 0.83.0. > do you get the same issue? you can forcefully downgrade the above `jll` files. How do I do this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161#issuecomment-1623565698
https://github.com/CliMA/Oceananigans.jl/issues/3163#issuecomment-1622119946:150,Energy Efficiency,schedul,schedules,150,"Because the string in constructed by iterating over. https://github.com/CliMA/Oceananigans.jl/blob/d7d146bc59f966d65eb66a875c16679bef365130/src/Utils/schedules.jl#L176. which includes the separators `"", ""`. So, we want to remove the separator from the very end of the string.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3163#issuecomment-1622119946
https://github.com/CliMA/Oceananigans.jl/issues/3163#issuecomment-1624208860:122,Energy Efficiency,schedul,schedules,122,It's used in `summary`:. https://github.com/CliMA/Oceananigans.jl/blob/d7d146bc59f966d65eb66a875c16679bef365130/src/Utils/schedules.jl#L262. which in turn is used to display output writers info in `Simulation`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3163#issuecomment-1624208860
https://github.com/CliMA/Oceananigans.jl/pull/3165#issuecomment-1619948370:38,Testability,test,tests,38,"Are these methods covered/used by the tests, do you know?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3165#issuecomment-1619948370
https://github.com/CliMA/Oceananigans.jl/issues/3166#issuecomment-1622058411:240,Testability,benchmark,benchmarks,240,I think this should be an issue since resolving it requires changing the repo. Agree that using a buildkite workflow is a good idea. It might also make sense to use a cluster resource rather than tartarus so it's easier to be sure that the benchmarks are clean.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3166#issuecomment-1622058411
https://github.com/CliMA/Oceananigans.jl/pull/3168#issuecomment-1616796587:39,Performance,optimiz,optimized,39,Yes. It is! And this example should be optimized. But until then I’m merging this so the developers have a slightly easier life ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3168#issuecomment-1616796587
https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630300785:86,Energy Efficiency,reduce,reduce,86,"I think, for now, since all docs built in 1h then let's not bother. But if we want to reduce it we'd know we have to start from the SWE example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630300785
https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630755758:652,Modifiability,variab,variable,652,"Running the example to t = 100 rather than t=150 would yield a quick 2/3. I think we can also decrease the resolution and increase the time-step. The resolution also is not isotropic, which essentially wastes grid points. The x dimension is 2pi but y is width 20. So if we use Ny = 128 then we might as well use something like Nx = 64 or 48. Further decreasing the resolution would also help a lot, because the time steps could be increased. And I think the movie doesn't need to plot so many frames. I think the writing and notation can also be improved. It's confusing to use `L_z` to refer to the reference depth. The `ShallowWaterModel` calls this variable `h`, and it's easy to confuse with the vertical extent of a 3D grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630755758
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799:997,Availability,avail,available,997,"thank you for replying, here is the output from the environment that I run the code in:. ```; julia> Pkg.status(); Status `~/.julia/environments/oc/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [336ed68f] CSV v0.10.11; ⌅ [052768ef] CUDA v4.3.2; [13f3f980] CairoMakie v0.10.6; [8f4d0f93] Conda v1.9.0; [f68482b8] Cthulhu v2.9.1; [d58978e5] Dagger v0.17.0; [a93c6f00] DataFrames v1.5.0; ⌃ [2b5f629d] DiffEqBase v6.125.1; [0c46a032] DifferentialEquations v7.8.0; ⌃ [31c24e10] Distributions v0.25.96; [587475ba] Flux v0.13.17; ⌃ [cd3eb016] HTTP v1.9.6; [0f8b85d8] JSON3 v1.13.1; [63c18a36] KernelAbstractions v0.9.6; [da04e1cc] MPI v0.20.11; [eff96d63] Measurements v2.9.0; [9e8cae18] Oceananigans v0.84.0 `~/Oceananigans.jl`; [1dea7af3] OrdinaryDiffEq v6.53.2; [98572fba] Parquet2 v0.2.17; [91a5bcdd] Plots v1.38.16; ⌃ [438e738f] PyCall v1.95.2; [3646fa90] ScikitLearn v0.7.0; ⌃ [9e226e20] SpeedyWeather v0.2.1; [90137ffa] StaticArrays v1.5.26; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated`. ```. I'm able to set breakpoints and debug the code for all of the other Julia code that I run - I'm also able to run the quick start example when I run the julia script. I only get the error I shared above while setting breakpoints for the quick start example. I have installed Oceananigans in editable/dev mode - the debugger does refer to the installed package - I get the same error even when I install Oceananigans via `Pkg.add()`. thank you for helping me!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799:1307,Availability,error,error,1307,"thank you for replying, here is the output from the environment that I run the code in:. ```; julia> Pkg.status(); Status `~/.julia/environments/oc/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [336ed68f] CSV v0.10.11; ⌅ [052768ef] CUDA v4.3.2; [13f3f980] CairoMakie v0.10.6; [8f4d0f93] Conda v1.9.0; [f68482b8] Cthulhu v2.9.1; [d58978e5] Dagger v0.17.0; [a93c6f00] DataFrames v1.5.0; ⌃ [2b5f629d] DiffEqBase v6.125.1; [0c46a032] DifferentialEquations v7.8.0; ⌃ [31c24e10] Distributions v0.25.96; [587475ba] Flux v0.13.17; ⌃ [cd3eb016] HTTP v1.9.6; [0f8b85d8] JSON3 v1.13.1; [63c18a36] KernelAbstractions v0.9.6; [da04e1cc] MPI v0.20.11; [eff96d63] Measurements v2.9.0; [9e8cae18] Oceananigans v0.84.0 `~/Oceananigans.jl`; [1dea7af3] OrdinaryDiffEq v6.53.2; [98572fba] Parquet2 v0.2.17; [91a5bcdd] Plots v1.38.16; ⌃ [438e738f] PyCall v1.95.2; [3646fa90] ScikitLearn v0.7.0; ⌃ [9e226e20] SpeedyWeather v0.2.1; [90137ffa] StaticArrays v1.5.26; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated`. ```. I'm able to set breakpoints and debug the code for all of the other Julia code that I run - I'm also able to run the quick start example when I run the julia script. I only get the error I shared above while setting breakpoints for the quick start example. I have installed Oceananigans in editable/dev mode - the debugger does refer to the installed package - I get the same error even when I install Oceananigans via `Pkg.add()`. thank you for helping me!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799:1502,Availability,error,error,1502,"thank you for replying, here is the output from the environment that I run the code in:. ```; julia> Pkg.status(); Status `~/.julia/environments/oc/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [336ed68f] CSV v0.10.11; ⌅ [052768ef] CUDA v4.3.2; [13f3f980] CairoMakie v0.10.6; [8f4d0f93] Conda v1.9.0; [f68482b8] Cthulhu v2.9.1; [d58978e5] Dagger v0.17.0; [a93c6f00] DataFrames v1.5.0; ⌃ [2b5f629d] DiffEqBase v6.125.1; [0c46a032] DifferentialEquations v7.8.0; ⌃ [31c24e10] Distributions v0.25.96; [587475ba] Flux v0.13.17; ⌃ [cd3eb016] HTTP v1.9.6; [0f8b85d8] JSON3 v1.13.1; [63c18a36] KernelAbstractions v0.9.6; [da04e1cc] MPI v0.20.11; [eff96d63] Measurements v2.9.0; [9e8cae18] Oceananigans v0.84.0 `~/Oceananigans.jl`; [1dea7af3] OrdinaryDiffEq v6.53.2; [98572fba] Parquet2 v0.2.17; [91a5bcdd] Plots v1.38.16; ⌃ [438e738f] PyCall v1.95.2; [3646fa90] ScikitLearn v0.7.0; ⌃ [9e226e20] SpeedyWeather v0.2.1; [90137ffa] StaticArrays v1.5.26; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated`. ```. I'm able to set breakpoints and debug the code for all of the other Julia code that I run - I'm also able to run the quick start example when I run the julia script. I only get the error I shared above while setting breakpoints for the quick start example. I have installed Oceananigans in editable/dev mode - the debugger does refer to the installed package - I get the same error even when I install Oceananigans via `Pkg.add()`. thank you for helping me!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799:1390,Deployability,install,installed,1390,"thank you for replying, here is the output from the environment that I run the code in:. ```; julia> Pkg.status(); Status `~/.julia/environments/oc/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [336ed68f] CSV v0.10.11; ⌅ [052768ef] CUDA v4.3.2; [13f3f980] CairoMakie v0.10.6; [8f4d0f93] Conda v1.9.0; [f68482b8] Cthulhu v2.9.1; [d58978e5] Dagger v0.17.0; [a93c6f00] DataFrames v1.5.0; ⌃ [2b5f629d] DiffEqBase v6.125.1; [0c46a032] DifferentialEquations v7.8.0; ⌃ [31c24e10] Distributions v0.25.96; [587475ba] Flux v0.13.17; ⌃ [cd3eb016] HTTP v1.9.6; [0f8b85d8] JSON3 v1.13.1; [63c18a36] KernelAbstractions v0.9.6; [da04e1cc] MPI v0.20.11; [eff96d63] Measurements v2.9.0; [9e8cae18] Oceananigans v0.84.0 `~/Oceananigans.jl`; [1dea7af3] OrdinaryDiffEq v6.53.2; [98572fba] Parquet2 v0.2.17; [91a5bcdd] Plots v1.38.16; ⌃ [438e738f] PyCall v1.95.2; [3646fa90] ScikitLearn v0.7.0; ⌃ [9e226e20] SpeedyWeather v0.2.1; [90137ffa] StaticArrays v1.5.26; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated`. ```. I'm able to set breakpoints and debug the code for all of the other Julia code that I run - I'm also able to run the quick start example when I run the julia script. I only get the error I shared above while setting breakpoints for the quick start example. I have installed Oceananigans in editable/dev mode - the debugger does refer to the installed package - I get the same error even when I install Oceananigans via `Pkg.add()`. thank you for helping me!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799:1467,Deployability,install,installed,1467,"thank you for replying, here is the output from the environment that I run the code in:. ```; julia> Pkg.status(); Status `~/.julia/environments/oc/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [336ed68f] CSV v0.10.11; ⌅ [052768ef] CUDA v4.3.2; [13f3f980] CairoMakie v0.10.6; [8f4d0f93] Conda v1.9.0; [f68482b8] Cthulhu v2.9.1; [d58978e5] Dagger v0.17.0; [a93c6f00] DataFrames v1.5.0; ⌃ [2b5f629d] DiffEqBase v6.125.1; [0c46a032] DifferentialEquations v7.8.0; ⌃ [31c24e10] Distributions v0.25.96; [587475ba] Flux v0.13.17; ⌃ [cd3eb016] HTTP v1.9.6; [0f8b85d8] JSON3 v1.13.1; [63c18a36] KernelAbstractions v0.9.6; [da04e1cc] MPI v0.20.11; [eff96d63] Measurements v2.9.0; [9e8cae18] Oceananigans v0.84.0 `~/Oceananigans.jl`; [1dea7af3] OrdinaryDiffEq v6.53.2; [98572fba] Parquet2 v0.2.17; [91a5bcdd] Plots v1.38.16; ⌃ [438e738f] PyCall v1.95.2; [3646fa90] ScikitLearn v0.7.0; ⌃ [9e226e20] SpeedyWeather v0.2.1; [90137ffa] StaticArrays v1.5.26; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated`. ```. I'm able to set breakpoints and debug the code for all of the other Julia code that I run - I'm also able to run the quick start example when I run the julia script. I only get the error I shared above while setting breakpoints for the quick start example. I have installed Oceananigans in editable/dev mode - the debugger does refer to the installed package - I get the same error even when I install Oceananigans via `Pkg.add()`. thank you for helping me!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799:1520,Deployability,install,install,1520,"thank you for replying, here is the output from the environment that I run the code in:. ```; julia> Pkg.status(); Status `~/.julia/environments/oc/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [336ed68f] CSV v0.10.11; ⌅ [052768ef] CUDA v4.3.2; [13f3f980] CairoMakie v0.10.6; [8f4d0f93] Conda v1.9.0; [f68482b8] Cthulhu v2.9.1; [d58978e5] Dagger v0.17.0; [a93c6f00] DataFrames v1.5.0; ⌃ [2b5f629d] DiffEqBase v6.125.1; [0c46a032] DifferentialEquations v7.8.0; ⌃ [31c24e10] Distributions v0.25.96; [587475ba] Flux v0.13.17; ⌃ [cd3eb016] HTTP v1.9.6; [0f8b85d8] JSON3 v1.13.1; [63c18a36] KernelAbstractions v0.9.6; [da04e1cc] MPI v0.20.11; [eff96d63] Measurements v2.9.0; [9e8cae18] Oceananigans v0.84.0 `~/Oceananigans.jl`; [1dea7af3] OrdinaryDiffEq v6.53.2; [98572fba] Parquet2 v0.2.17; [91a5bcdd] Plots v1.38.16; ⌃ [438e738f] PyCall v1.95.2; [3646fa90] ScikitLearn v0.7.0; ⌃ [9e226e20] SpeedyWeather v0.2.1; [90137ffa] StaticArrays v1.5.26; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated`. ```. I'm able to set breakpoints and debug the code for all of the other Julia code that I run - I'm also able to run the quick start example when I run the julia script. I only get the error I shared above while setting breakpoints for the quick start example. I have installed Oceananigans in editable/dev mode - the debugger does refer to the installed package - I get the same error even when I install Oceananigans via `Pkg.add()`. thank you for helping me!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799:174,Testability,Benchmark,BenchmarkTools,174,"thank you for replying, here is the output from the environment that I run the code in:. ```; julia> Pkg.status(); Status `~/.julia/environments/oc/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [336ed68f] CSV v0.10.11; ⌅ [052768ef] CUDA v4.3.2; [13f3f980] CairoMakie v0.10.6; [8f4d0f93] Conda v1.9.0; [f68482b8] Cthulhu v2.9.1; [d58978e5] Dagger v0.17.0; [a93c6f00] DataFrames v1.5.0; ⌃ [2b5f629d] DiffEqBase v6.125.1; [0c46a032] DifferentialEquations v7.8.0; ⌃ [31c24e10] Distributions v0.25.96; [587475ba] Flux v0.13.17; ⌃ [cd3eb016] HTTP v1.9.6; [0f8b85d8] JSON3 v1.13.1; [63c18a36] KernelAbstractions v0.9.6; [da04e1cc] MPI v0.20.11; [eff96d63] Measurements v2.9.0; [9e8cae18] Oceananigans v0.84.0 `~/Oceananigans.jl`; [1dea7af3] OrdinaryDiffEq v6.53.2; [98572fba] Parquet2 v0.2.17; [91a5bcdd] Plots v1.38.16; ⌃ [438e738f] PyCall v1.95.2; [3646fa90] ScikitLearn v0.7.0; ⌃ [9e226e20] SpeedyWeather v0.2.1; [90137ffa] StaticArrays v1.5.26; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated`. ```. I'm able to set breakpoints and debug the code for all of the other Julia code that I run - I'm also able to run the quick start example when I run the julia script. I only get the error I shared above while setting breakpoints for the quick start example. I have installed Oceananigans in editable/dev mode - the debugger does refer to the installed package - I get the same error even when I install Oceananigans via `Pkg.add()`. thank you for helping me!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616804799
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616809238:423,Availability,error,error,423,"it runs as expected even when I run the script in VSCode, the output is:. ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (96.214 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.980 seconds).; [ Info: Simulation is stopping after running for 6.189 seconds.; [ Info: Model iteration 100 equals or exceeds stop iteration 100. ```. I only get the error when I insert breakpoints in the quick start example and try to step through the code:. ```; using Oceananigans. grid = RectilinearGrid(size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()). ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). simulation = Simulation(model; Δt=0.01, stop_iteration=100); run!(simulation); ```. I've shared the exact line that throws the error in my original question. greatly appreciate your help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616809238
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616809238:873,Availability,error,error,873,"it runs as expected even when I run the script in VSCode, the output is:. ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (96.214 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.980 seconds).; [ Info: Simulation is stopping after running for 6.189 seconds.; [ Info: Model iteration 100 equals or exceeds stop iteration 100. ```. I only get the error when I insert breakpoints in the quick start example and try to step through the code:. ```; using Oceananigans. grid = RectilinearGrid(size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()). ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). simulation = Simulation(model; Δt=0.01, stop_iteration=100); run!(simulation); ```. I've shared the exact line that throws the error in my original question. greatly appreciate your help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616809238
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616859061:172,Availability,error,error,172,"that's exactly right - 2 is ok, 3 is not. also, 3 is ok for any non-Oceananigans Julia code. using the debugger with VScode on the quick start example should reproduce the error. thank you again!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616859061
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616903289:186,Deployability,install,installed,186,"hm... OK, I see. Let me try playing around then. Where can I find some info about the VS Code's debugging mode?. But also I wanted to point out that you have a lot of unrelated packages installed in the same environment like Oceananigans (eg, conda, dagger, ScikitLearn, DifferentialEquations,...) Just to ensure that this is not any sort of incompatibility between various deps versions, can you create an empty environment, just have Oceananigans there and try to do 3. and confirm that you get the same issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616903289
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616927702:40,Availability,error,error,40,"I can confirm that I'm getting the same error in a new environment with just Oceananigans installed. looks like this error occurs on the lines of code where a mutable function is called that returns `nothing`. such as `foreach(mask_immersed_field!, model.tracers)` , . `fill_halo_regions!(merge(model.velocities, model.tracers), model.clock, fields(model))`. here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616927702
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616927702:117,Availability,error,error,117,"I can confirm that I'm getting the same error in a new environment with just Oceananigans installed. looks like this error occurs on the lines of code where a mutable function is called that returns `nothing`. such as `foreach(mask_immersed_field!, model.tracers)` , . `fill_halo_regions!(merge(model.velocities, model.tracers), model.clock, fields(model))`. here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616927702
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616927702:90,Deployability,install,installed,90,"I can confirm that I'm getting the same error in a new environment with just Oceananigans installed. looks like this error occurs on the lines of code where a mutable function is called that returns `nothing`. such as `foreach(mask_immersed_field!, model.tracers)` , . `fill_halo_regions!(merge(model.velocities, model.tracers), model.clock, fields(model))`. here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616927702
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963:117,Availability,down,down,117,"By ""mutable"" function you mean one that modifies its args? But don't they all return nothing?. Seems you are getting down to the bottom it yourself... Perhaps try writing a simple code of your own then and running the debugger there? E.g. ```julia; function my_own_function!(a); a = 2a; return nothing; end. a = 17. my_own_function!(a). b = 10a; ```. or something like that and see if you get the same error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963:402,Availability,error,error,402,"By ""mutable"" function you mean one that modifies its args? But don't they all return nothing?. Seems you are getting down to the bottom it yourself... Perhaps try writing a simple code of your own then and running the debugger there? E.g. ```julia; function my_own_function!(a); a = 2a; return nothing; end. a = 17. my_own_function!(a). b = 10a; ```. or something like that and see if you get the same error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963:173,Usability,simpl,simple,173,"By ""mutable"" function you mean one that modifies its args? But don't they all return nothing?. Seems you are getting down to the bottom it yourself... Perhaps try writing a simple code of your own then and running the debugger there? E.g. ```julia; function my_own_function!(a); a = 2a; return nothing; end. a = 17. my_own_function!(a). b = 10a; ```. or something like that and see if you get the same error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616944254:203,Availability,error,error,203,the debugger works fine on the code snippet you shared - it also works fine on all other Julia libraries where I step through the code by inserting breakpoints - today is the first time I've gotten this error while trying to step through the Oceananigans codebase by using the quick start example,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616944254
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622044750:205,Availability,error,error,205,"> the debugger works fine on the code snippet you shared - it also works fine on all other Julia libraries where I step through the code by inserting breakpoints - today is the first time I've gotten this error while trying to step through the Oceananigans codebase by using the quick start example. Just a wild guess, but could it have to do with KernelAbstractions? Have you tried the debugger on other packages that use KernelAbstractions?. This smells like a problem with the debugger rather than an Oceananigans-specific issue. But maybe there is something we can change in the source code to help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622044750
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622057678:250,Usability,feedback,feedback,250,thank you for replying - I've never tried the debugger on any package that uses KernelAbstractions. I've opened an issue on the julia-vscode extension github repo (linked above) - I'll open an issue on the KernelAbstractions github repo to get their feedback. thank you for helping me - I'll spend some more time on this,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622057678
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622227332:113,Availability,error,error,113,"thank you so much for sharing that @glwagner . after making the change you suggested, I'm getting the exact same error. please let me know if there's any other change I could test - thank you again",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622227332
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622227332:175,Testability,test,test,175,"thank you so much for sharing that @glwagner . after making the change you suggested, I'm getting the exact same error. please let me know if there's any other change I could test - thank you again",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622227332
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622235678:161,Availability,error,error,161,"I ran through the code step by step after changing the grid as per your suggestion, this time, it is this line of code that threw the boundary_condition_nothing error:. https://github.com/CliMA/Oceananigans.jl/blob/92791a962c9096746301cdb888a3050e32c4a58b/src/Fields/field_tuples.jl#L73. leads to this line:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Utils/kernel_launching.jl#L97. which then throws the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622235678
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622235678:417,Availability,error,error,417,"I ran through the code step by step after changing the grid as per your suggestion, this time, it is this line of code that threw the boundary_condition_nothing error:. https://github.com/CliMA/Oceananigans.jl/blob/92791a962c9096746301cdb888a3050e32c4a58b/src/Fields/field_tuples.jl#L73. leads to this line:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Utils/kernel_launching.jl#L97. which then throws the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622235678
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622396101:266,Availability,error,error,266,"True! You could also try calling `fill_halo_regions!(model.velocities)` on it's own. Or you can create a tuple yourself and try:. ```julia; c1 = CenterField(grid); c2 = CenterField(grid); tracers = (; c1, c2); fill_halo_regions!(tracers); ```. and see if you get an error. PS if you use the permalinks then the code will be displayed inline in the github issue (like in my comment above --- I changed one of yours to illustrate)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622396101
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622441316:62,Availability,error,error,62,thank you for sharing the code snippet - I get the exact same error even when I run just the snippet you shared. please let me know if there is anything else I can try - thank you again,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622441316
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622497165:349,Availability,error,error,349,"I'm not sure if this is helpful, but I manually executed this line:. https://github.com/CliMA/Oceananigans.jl/blob/92791a962c9096746301cdb888a3050e32c4a58b/src/Utils/kernel_launching.jl#L97. and then this line:. https://github.com/CliMA/Oceananigans.jl/blob/92791a962c9096746301cdb888a3050e32c4a58b/src/Simulations/run.jl#L122. throws the following error, related to `KernelAbstractions` , but not related to the value of boundary_conditions:. ![oc_err_2](https://github.com/CliMA/Oceananigans.jl/assets/16384103/bd8fdedf-edcf-4ab0-ae2b-16a0ec3916c0). looks like the value `nothing` with functions that use `KernelAbstractions` seems to trip up the debugger",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622497165
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624165878:26,Availability,error,error,26,"Ok, can you reproduce the error by trying to loop over a simple kernel that returns `nothing` using `KernelAbstractions`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624165878
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624165878:57,Usability,simpl,simple,57,"Ok, can you reproduce the error by trying to loop over a simple kernel that returns `nothing` using `KernelAbstractions`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624165878
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600:31,Availability,error,error,31,"sure - I was able to repro the error by using the basic example on the `KernelAbstractions` quick start page:. https://juliagpu.github.io/KernelAbstractions.jl/dev/quickstart/. ```. using KernelAbstractions. @kernel function mul2_kernel(A); I = @index(Global); A[I] = 2 * A[I]; end. dev = CPU(); A = ones(1024, 1024); ev = mul2_kernel(dev, 64)(A, ndrange=size(A)); synchronize(dev); all(A .== 2.0). ```. this is the error. ![ka_err](https://github.com/CliMA/Oceananigans.jl/assets/16384103/4fe91c2a-e7c9-4fb5-b328-353d921d6a6b). the author of the `KernelAbstractions` library has responded to this issue here and thinks it's the fault of the debugger:. https://github.com/JuliaGPU/KernelAbstractions.jl/issues/405. I'm not sure if that's helpful, but I have only experienced this issue with the `KernelAbstractions` library and not any other library. I've also opened an issue on the julia-vscode extension repo, but have not received a response yet:. https://github.com/julia-vscode/julia-vscode/issues/3349. please let me know if there's anything else I can try - thank you again for helping me with this issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600:416,Availability,error,error,416,"sure - I was able to repro the error by using the basic example on the `KernelAbstractions` quick start page:. https://juliagpu.github.io/KernelAbstractions.jl/dev/quickstart/. ```. using KernelAbstractions. @kernel function mul2_kernel(A); I = @index(Global); A[I] = 2 * A[I]; end. dev = CPU(); A = ones(1024, 1024); ev = mul2_kernel(dev, 64)(A, ndrange=size(A)); synchronize(dev); all(A .== 2.0). ```. this is the error. ![ka_err](https://github.com/CliMA/Oceananigans.jl/assets/16384103/4fe91c2a-e7c9-4fb5-b328-353d921d6a6b). the author of the `KernelAbstractions` library has responded to this issue here and thinks it's the fault of the debugger:. https://github.com/JuliaGPU/KernelAbstractions.jl/issues/405. I'm not sure if that's helpful, but I have only experienced this issue with the `KernelAbstractions` library and not any other library. I've also opened an issue on the julia-vscode extension repo, but have not received a response yet:. https://github.com/julia-vscode/julia-vscode/issues/3349. please let me know if there's anything else I can try - thank you again for helping me with this issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600:629,Availability,fault,fault,629,"sure - I was able to repro the error by using the basic example on the `KernelAbstractions` quick start page:. https://juliagpu.github.io/KernelAbstractions.jl/dev/quickstart/. ```. using KernelAbstractions. @kernel function mul2_kernel(A); I = @index(Global); A[I] = 2 * A[I]; end. dev = CPU(); A = ones(1024, 1024); ev = mul2_kernel(dev, 64)(A, ndrange=size(A)); synchronize(dev); all(A .== 2.0). ```. this is the error. ![ka_err](https://github.com/CliMA/Oceananigans.jl/assets/16384103/4fe91c2a-e7c9-4fb5-b328-353d921d6a6b). the author of the `KernelAbstractions` library has responded to this issue here and thinks it's the fault of the debugger:. https://github.com/JuliaGPU/KernelAbstractions.jl/issues/405. I'm not sure if that's helpful, but I have only experienced this issue with the `KernelAbstractions` library and not any other library. I've also opened an issue on the julia-vscode extension repo, but have not received a response yet:. https://github.com/julia-vscode/julia-vscode/issues/3349. please let me know if there's anything else I can try - thank you again for helping me with this issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600:365,Integrability,synchroniz,synchronize,365,"sure - I was able to repro the error by using the basic example on the `KernelAbstractions` quick start page:. https://juliagpu.github.io/KernelAbstractions.jl/dev/quickstart/. ```. using KernelAbstractions. @kernel function mul2_kernel(A); I = @index(Global); A[I] = 2 * A[I]; end. dev = CPU(); A = ones(1024, 1024); ev = mul2_kernel(dev, 64)(A, ndrange=size(A)); synchronize(dev); all(A .== 2.0). ```. this is the error. ![ka_err](https://github.com/CliMA/Oceananigans.jl/assets/16384103/4fe91c2a-e7c9-4fb5-b328-353d921d6a6b). the author of the `KernelAbstractions` library has responded to this issue here and thinks it's the fault of the debugger:. https://github.com/JuliaGPU/KernelAbstractions.jl/issues/405. I'm not sure if that's helpful, but I have only experienced this issue with the `KernelAbstractions` library and not any other library. I've also opened an issue on the julia-vscode extension repo, but have not received a response yet:. https://github.com/julia-vscode/julia-vscode/issues/3349. please let me know if there's anything else I can try - thank you again for helping me with this issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624350568:486,Energy Efficiency,power,powerful,486,"Yes, it seems there is some bad interaction between KernelAbstractions and the debugger. It seems likely that fixing it will requiring some development of the debugger (but possibly also KernelAbstractions). Once that's resolved, I think it's likely the debugger will work with Oceananigans. Hopefully you can still have a productive development workflow in the meantime! Let us know if there is any way we can help. I think the bright side of this situation is that Julia has a lot of powerful built-in features for code introspection and interactive usage, a lot of which overlap with the features provided by a traditional debugger (as I understand it). Are you planning to contribute to Oceananigans development or just to interact with Oceananigans as a user?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624350568
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697286595:248,Deployability,update,update,248,"Hi @navidcy - it is still outstanding, but there's been some progress lately:. https://github.com/JuliaDebug/JuliaInterpreter.jl/issues/574#issuecomment-1674729615. https://github.com/julia-vscode/julia-vscode/issues/3349#event-10200480814. I will update this thread as soon as it's resolved - hope that sounds good - thank you",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697286595
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697433147:68,Deployability,release,release,68,"Hi @navidcy - you have great timing - it looks like the most recent release of the julia-vscode extension fixed the issue - I have tested it on a basic Oceananigans script and the debugger seems to be working now. the core issue here was with JuliaInterpreter.jl which was fixed and updated in the julia-vscode extension, which then fixed the issue. thank you so much for your help and patience!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697433147
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697433147:283,Deployability,update,updated,283,"Hi @navidcy - you have great timing - it looks like the most recent release of the julia-vscode extension fixed the issue - I have tested it on a basic Oceananigans script and the debugger seems to be working now. the core issue here was with JuliaInterpreter.jl which was fixed and updated in the julia-vscode extension, which then fixed the issue. thank you so much for your help and patience!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697433147
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697433147:131,Testability,test,tested,131,"Hi @navidcy - you have great timing - it looks like the most recent release of the julia-vscode extension fixed the issue - I have tested it on a basic Oceananigans script and the debugger seems to be working now. the core issue here was with JuliaInterpreter.jl which was fixed and updated in the julia-vscode extension, which then fixed the issue. thank you so much for your help and patience!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697433147
https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697492907:199,Deployability,release,release,199,I'm closing this issue with this note in case it helps anyone:. using the julia-vscode debugger is pretty slow - I'm not sure how if this can be resolved in the near term. someone was kind enough to release this repo to debug Pluto notebooks with vscode in case it helps:. https://github.com/disberd/PlutoVSCodeDebugger.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1697492907
https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624201105:133,Deployability,patch,patch,133,1) did we merge this before the tests passed?. 2) how OceanBioME.jl was working without this?. 3) I think this definitely deserves a patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624201105
https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624201105:139,Deployability,release,release,139,1) did we merge this before the tests passed?. 2) how OceanBioME.jl was working without this?. 3) I think this definitely deserves a patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624201105
https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624201105:32,Testability,test,tests,32,1) did we merge this before the tests passed?. 2) how OceanBioME.jl was working without this?. 3) I think this definitely deserves a patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624201105
https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624206162:266,Testability,test,test,266,Had they not passed!? I'm on my phone and thought if it let me merge they must have passed!. It's only the single column hydrostatic free surface models that this effects and I guess no one had used OceanBioMe with them before I tried earlier. I also think unless a test (e.g. in OceanBioME) was specifically looking for something like light attenuation to have been calculated it wouldn't be noticed just give weird results.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624206162
https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624207098:43,Testability,test,test,43,@jagoosw perhaps best practice is to add a test to make sure this doesn't break in the future,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624207098
https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624259955:51,Testability,test,testing,51,"Yeah that's a good idea, do you think I should add testing on lat/lon grids too?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624259955
https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624210397:2,Deployability,update,updated,2,I updated the patch,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624210397
https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624210397:14,Deployability,patch,patch,14,I updated the patch,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624210397
https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624211353:48,Deployability,patch,patch,48,Oh are we doing the `(0.84.1) PR Name` also for patch releases? Nice!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624211353
https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624211353:54,Deployability,release,releases,54,Oh are we doing the `(0.84.1) PR Name` also for patch releases? Nice!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624211353
https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624223869:163,Deployability,release,releases,163,"it's not a bad idea, but it's one more thing to the list... I'm happy either way... For breaking changes is crucial! I even tried to do it for the past view minor releases the other day. It help when you wanna figure out what changed when.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3174#issuecomment-1624223869
https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-1629233865:276,Integrability,depend,dependency,276,"Hmm yes we might need extensions to provide that functionality. Another possibility is to use plot recipes: https://docs.makie.org/stable/documentation/recipes/. That page says. > If you're a package developer, it's possible to add recipes without adding all of Makie.jl as a dependency. Instead, you can use the MakieCore package, which is a lightweight package which provides all the necessary elements to create a recipe, such as the @recipe macro, convert_arguments and convert_attribute functions, and even some basic plot type definitions. I'm not sure the stuff on `Imaginocean.jl` can be implemented with plot recipes, but if it can then perhaps that is a better approach?. Otherwise I agree that we should investigate extensions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-1629233865
https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:61,Availability,mainten,maintenance,61,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:98,Integrability,depend,depend,98,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:632,Safety,detect,detected,632,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:288,Testability,test,test,288,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:260,Usability,simpl,simply,260,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2272112363:197,Usability,simpl,simple,197,"My understanding is that you can write `convert_arguments` methods and then all the different plot types just work, for example (obviously not what you'd want in a finished extension but just as a simple example):; ```julia; using CairoMakie . import MakieCore: convert_arguments. convert_arguments(P::Type{<:AbstractPlot}, f::Field) = convert_arguments(P, xnodes(f), ynodes(f), interior(f, :, :, 1)). fig = Figure(); ax = Axis(fig[1, 1]); heatmap!(ax, c); ```; correctly plots the bottom level of a field `c` and puts the `x` and `y` axes in. I think you can pass other arguments too like:; ```julia; convert_arguments(P::Type{<:AbstractPlot}, f::Field, indices = (:, :, 1)) = convert_arguments(P, xnodes(f)[indices[1]], ynodes(f)[indices[2]], interior(f, indices...)); heatmap!(ax, c, (1:10, :, 1)); ```. so you could deal with slicing up 3D fields that way?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2272112363
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1629476318:35,Testability,test,test,35,I'm not sure why this fails as the test runs fine locally,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1629476318
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1629651601:37,Testability,test,test,37,"> I'm not sure why this fails as the test runs fine locally. You may need to run with `--check-bounds=yes` (the tests run with this option, but it's not default)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1629651601
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1629651601:112,Testability,test,tests,112,"> I'm not sure why this fails as the test runs fine locally. You may need to run with `--check-bounds=yes` (the tests run with this option, but it's not default)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1629651601
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630141560:295,Deployability,pipeline,pipeline,295,"> > I'm not sure why this fails as the test runs fine locally; > ; > You may need to run with `--check-bounds=yes` (the tests run with this option, but it's not default). I don't think so. Right?. https://github.com/CliMA/Oceananigans.jl/blob/84bc3c3c5438cda2e8f188a0e1a839ae7800b994/.buildkite/pipeline.yml#L257",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630141560
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630141560:39,Testability,test,test,39,"> > I'm not sure why this fails as the test runs fine locally; > ; > You may need to run with `--check-bounds=yes` (the tests run with this option, but it's not default). I don't think so. Right?. https://github.com/CliMA/Oceananigans.jl/blob/84bc3c3c5438cda2e8f188a0e1a839ae7800b994/.buildkite/pipeline.yml#L257",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630141560
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630141560:120,Testability,test,tests,120,"> > I'm not sure why this fails as the test runs fine locally; > ; > You may need to run with `--check-bounds=yes` (the tests run with this option, but it's not default). I don't think so. Right?. https://github.com/CliMA/Oceananigans.jl/blob/84bc3c3c5438cda2e8f188a0e1a839ae7800b994/.buildkite/pipeline.yml#L257",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630141560
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630161708:164,Testability,test,tests,164,"Are we sure that `VectorInvariant` works with `Flat` horizontal dimensions? @simone-silvestri?. Still, regardless of that, I also agree w @jagoosw that locally the tests pass for me as well so I don't understand why they fail on CPU on tartarus! Mystery!. On tartarus, seems like the issue comes from. https://github.com/CliMA/Oceananigans.jl/blob/84bc3c3c5438cda2e8f188a0e1a839ae7800b994/src/Operators/spacings_and_areas_and_volumes.jl#L206. which fails when both x and y dimensions are Flat on a LatLonGrid. What's even the point of defining a column grid on lat-lon grid??",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630161708
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630226850:242,Availability,error,error,242,"The test environment assumes `--check-bounds=yes` even when not explicitly specified. https://github.com/JuliaLang/Pkg.jl/blob/3ca88658d2bc23d877cc5829cdab2aa4dfdae564/src/Pkg.jl#L240-L278. Vector invariant should work with `Flat`, also, the error seems to stem from `div_𝐯u`, which is the flux form advection. I can take a look. You are right that maybe horizontally `Flat` does not work in general with lat-long",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630226850
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630226850:4,Testability,test,test,4,"The test environment assumes `--check-bounds=yes` even when not explicitly specified. https://github.com/JuliaLang/Pkg.jl/blob/3ca88658d2bc23d877cc5829cdab2aa4dfdae564/src/Pkg.jl#L240-L278. Vector invariant should work with `Flat`, also, the error seems to stem from `div_𝐯u`, which is the flux form advection. I can take a look. You are right that maybe horizontally `Flat` does not work in general with lat-long",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630226850
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630234724:21,Availability,error,error,21,But locally I get no error! That's strange.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630234724
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073:209,Availability,error,error,209,> You are right that maybe horizontally `Flat` does not work in general with lat-long. I change the test to have lat-lon grids with only one. of the horizontal directions flat. I think we should add a warning/error message when someone tries to create a lat-lon grid with both lat and lon being Flat. (but not in this PR).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073:215,Integrability,message,message,215,> You are right that maybe horizontally `Flat` does not work in general with lat-long. I change the test to have lat-lon grids with only one. of the horizontal directions flat. I think we should add a warning/error message when someone tries to create a lat-lon grid with both lat and lon being Flat. (but not in this PR).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073:100,Testability,test,test,100,> You are right that maybe horizontally `Flat` does not work in general with lat-long. I change the test to have lat-lon grids with only one. of the horizontal directions flat. I think we should add a warning/error message when someone tries to create a lat-lon grid with both lat and lon being Flat. (but not in this PR).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630430276:762,Availability,error,error,762,"The problem seems to be in . https://github.com/CliMA/Oceananigans.jl/blob/84bc3c3c5438cda2e8f188a0e1a839ae7800b994/src/Operators/spacings_and_areas_and_volumes.jl#L202-L209. When φ is flat then . ```; julia> grid = LatitudeLongitudeGrid(arch; topology = (Periodic, Flat, Bounded), size = (5, 5), longitude = (-30, 50), z = (-2, 0)); 5×1×5 LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo and without precomputed metrics; ├── longitude: Periodic λ ∈ [-30.0, 50.0) regularly spaced with Δλ=16.0; ├── latitude: Flat φ; └── z: Bounded z ∈ [-2.0, 0.0] regularly spaced with Δz=0.4. julia> grid.φᵃᶜᵃ; StepRangeLen(1.0, 0.0, 1); ```. and thus `φᵃᶜᵃ` only has _one_ element. So `j+1` or `j-1` is doomed to fail. I managed to reproduce the error locally if I enforce. ```; julia --project --check-bounds=yes; ```. What does that mean? Somehow there is an `@inbounds` that silently bypasses the problem when `--check-bounds=auto`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630430276
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630455445:4,Testability,test,test,4,"The test environment always runs with `--check-bounds=yes` so if you want to reproduce test results locally, you have to explicitly set `--check-bounds=yes`.; If the check bounds are not set, the `@inbounds` will bypass the problem. Anyways, those lines should not be called unless we specifically set `precompute_metrics=false` in the `LatitudeLongitudeGrid` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630455445
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630455445:87,Testability,test,test,87,"The test environment always runs with `--check-bounds=yes` so if you want to reproduce test results locally, you have to explicitly set `--check-bounds=yes`.; If the check bounds are not set, the `@inbounds` will bypass the problem. Anyways, those lines should not be called unless we specifically set `precompute_metrics=false` in the `LatitudeLongitudeGrid` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630455445
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:46,Availability,Error,Error,46,"the stacktrace is. ```Julia; Biogeochemistry: Error During Test at /Users/navid/Research/OC5.jl/test/test_biogeochemistry.jl:126; Got exception outside of a @test; BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ./range.jl:940 [inlined]; [4] Azᶜᶜᵃ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:209 [inlined]; [5] Azᶜᶜᶠ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:192 [inlined]; [6] macro expansion; @ ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl:135 [inlined]; [7] cpu__compute_coefficients!; @ ~/.julia/packages/KernelAbstractions/lhhMo/src/macros.jl:276 [inlined]; [8] cpu__compute_coefficients!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(5, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{2}, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(5, 1)}, Nothing, Nothing}}, diag::Array{Float64, 3}, Ax::Array{Float64, 3}, Ay::Array{Float64, 3}, ∫Ax::Field{Face, Center, Nothing, Nothing, LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:23202,Availability,Error,Error,23202,"}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [34] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [35] invokelatest; @ ./essentials.jl:813 [inlined]; [36] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [37] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [38] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Biogeochemistry | 9 1 10 1m32.9s; ERROR: LoadError: Some tests did not pass: 9 passed, 0 failed, 1 errored, 0 broken.; in expression start; ```. so it seems like those lines are called by the matrix implicit solver somehow?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:23254,Availability,ERROR,ERROR,23254,"}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [34] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [35] invokelatest; @ ./essentials.jl:813 [inlined]; [36] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [37] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [38] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Biogeochemistry | 9 1 10 1m32.9s; ERROR: LoadError: Some tests did not pass: 9 passed, 0 failed, 1 errored, 0 broken.; in expression start; ```. so it seems like those lines are called by the matrix implicit solver somehow?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:23319,Availability,error,errored,23319,"}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [34] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [35] invokelatest; @ ./essentials.jl:813 [inlined]; [36] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [37] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [38] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Biogeochemistry | 9 1 10 1m32.9s; ERROR: LoadError: Some tests did not pass: 9 passed, 0 failed, 1 errored, 0 broken.; in expression start; ```. so it seems like those lines are called by the matrix implicit solver somehow?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:23261,Performance,Load,LoadError,23261,"}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [34] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [35] invokelatest; @ ./essentials.jl:813 [inlined]; [36] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [37] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [38] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Biogeochemistry | 9 1 10 1m32.9s; ERROR: LoadError: Some tests did not pass: 9 passed, 0 failed, 1 errored, 0 broken.; in expression start; ```. so it seems like those lines are called by the matrix implicit solver somehow?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:188,Security,access,access,188,"the stacktrace is. ```Julia; Biogeochemistry: Error During Test at /Users/navid/Research/OC5.jl/test/test_biogeochemistry.jl:126; Got exception outside of a @test; BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ./range.jl:940 [inlined]; [4] Azᶜᶜᵃ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:209 [inlined]; [5] Azᶜᶜᶠ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:192 [inlined]; [6] macro expansion; @ ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl:135 [inlined]; [7] cpu__compute_coefficients!; @ ~/.julia/packages/KernelAbstractions/lhhMo/src/macros.jl:276 [inlined]; [8] cpu__compute_coefficients!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(5, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{2}, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(5, 1)}, Nothing, Nothing}}, diag::Array{Float64, 3}, Ax::Array{Float64, 3}, Ay::Array{Float64, 3}, ∫Ax::Field{Face, Center, Nothing, Nothing, LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:59,Testability,Test,Test,59,"the stacktrace is. ```Julia; Biogeochemistry: Error During Test at /Users/navid/Research/OC5.jl/test/test_biogeochemistry.jl:126; Got exception outside of a @test; BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ./range.jl:940 [inlined]; [4] Azᶜᶜᵃ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:209 [inlined]; [5] Azᶜᶜᶠ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:192 [inlined]; [6] macro expansion; @ ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl:135 [inlined]; [7] cpu__compute_coefficients!; @ ~/.julia/packages/KernelAbstractions/lhhMo/src/macros.jl:276 [inlined]; [8] cpu__compute_coefficients!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(5, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{2}, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(5, 1)}, Nothing, Nothing}}, diag::Array{Float64, 3}, Ax::Array{Float64, 3}, Ay::Array{Float64, 3}, ∫Ax::Field{Face, Center, Nothing, Nothing, LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:96,Testability,test,test,96,"the stacktrace is. ```Julia; Biogeochemistry: Error During Test at /Users/navid/Research/OC5.jl/test/test_biogeochemistry.jl:126; Got exception outside of a @test; BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ./range.jl:940 [inlined]; [4] Azᶜᶜᵃ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:209 [inlined]; [5] Azᶜᶜᶠ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:192 [inlined]; [6] macro expansion; @ ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl:135 [inlined]; [7] cpu__compute_coefficients!; @ ~/.julia/packages/KernelAbstractions/lhhMo/src/macros.jl:276 [inlined]; [8] cpu__compute_coefficients!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(5, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{2}, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(5, 1)}, Nothing, Nothing}}, diag::Array{Float64, 3}, Ax::Array{Float64, 3}, Ay::Array{Float64, 3}, ∫Ax::Field{Face, Center, Nothing, Nothing, LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:158,Testability,test,test,158,"the stacktrace is. ```Julia; Biogeochemistry: Error During Test at /Users/navid/Research/OC5.jl/test/test_biogeochemistry.jl:126; Got exception outside of a @test; BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ./range.jl:940 [inlined]; [4] Azᶜᶜᵃ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:209 [inlined]; [5] Azᶜᶜᶠ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:192 [inlined]; [6] macro expansion; @ ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl:135 [inlined]; [7] cpu__compute_coefficients!; @ ~/.julia/packages/KernelAbstractions/lhhMo/src/macros.jl:276 [inlined]; [8] cpu__compute_coefficients!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(5, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{2}, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(5, 1)}, Nothing, Nothing}}, diag::Array{Float64, 3}, Ax::Array{Float64, 3}, Ay::Array{Float64, 3}, ∫Ax::Field{Face, Center, Nothing, Nothing, LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:21591,Testability,test,test,21591,", Nothing, Nothing, Nothing}}, NamedTuple{(:u, :v, :w), Tuple{ZeroField{Int64, 3}, ZeroField{Int64, 3}, ConstantField{Float64, 3}}}}, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:175; [21] test_biogeochemistry!(grid::LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdli",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:21667,Testability,test,test,21667,"4, 3}, ZeroField{Int64, 3}, ConstantField{Float64, 3}}}}, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:175; [21] test_biogeochemistry!(grid::LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:21775,Testability,Test,Test,21775,"sivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:175; [21] test_biogeochemistry!(grid::LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#10",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:21784,Testability,Test,Test,21784,"sivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:175; [21] test_biogeochemistry!(grid::LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#10",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:21850,Testability,test,test,21850,"ns.Models.HydrostaticFreeSurfaceModels ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:175; [21] test_biogeochemistry!(grid::LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [34] #invokelatest#",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:23181,Testability,Test,Test,23181,"}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [34] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [35] invokelatest; @ ./essentials.jl:813 [inlined]; [36] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [37] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [38] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Biogeochemistry | 9 1 10 1m32.9s; ERROR: LoadError: Some tests did not pass: 9 passed, 0 failed, 1 errored, 0 broken.; in expression start; ```. so it seems like those lines are called by the matrix implicit solver somehow?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:23277,Testability,test,tests,23277,"}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [34] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [35] invokelatest; @ ./essentials.jl:813 [inlined]; [36] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [37] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [38] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Biogeochemistry | 9 1 10 1m32.9s; ERROR: LoadError: Some tests did not pass: 9 passed, 0 failed, 1 errored, 0 broken.; in expression start; ```. so it seems like those lines are called by the matrix implicit solver somehow?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630559577:30,Testability,test,test,30,I added the flat lat/lon grid test because it has its own functions [here](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl) which failed when I was testing something. But if this isn't tested elsewhere we might as well remove it? I also don't really see why it would exist since a lat/lon grid with flat dimensions is the same as a rectilinear grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630559577
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630559577:219,Testability,test,testing,219,I added the flat lat/lon grid test because it has its own functions [here](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl) which failed when I was testing something. But if this isn't tested elsewhere we might as well remove it? I also don't really see why it would exist since a lat/lon grid with flat dimensions is the same as a rectilinear grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630559577
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630559577:256,Testability,test,tested,256,I added the flat lat/lon grid test because it has its own functions [here](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl) which failed when I was testing something. But if this isn't tested elsewhere we might as well remove it? I also don't really see why it would exist since a lat/lon grid with flat dimensions is the same as a rectilinear grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630559577
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630594751:50,Testability,test,tests,50,But now I removed that and I replaced it with two tests with 2D lat-lon grids (one that has Flat lon and one that has Flat lat). But there is an issue still!. @simone-silvestri these grids _now_ are not SingleColumnGrids ... Can the MatrixImplicitSolver work with 2D lat-depth or lon-depth slices?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630594751
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630671744:348,Availability,error,error,348,"> ok I see, then it means there must be something wrong with this line which is bypassed; > ; > https://github.com/CliMA/Oceananigans.jl/blob/a1f4f4e75e51a83cf9dec9e671866cff67de1211/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl#L28. So this line is being used when the grid has **both** lat and lon flat. But then it hits an error in the advective flux as you first guessed @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630671744
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630792224:21,Safety,avoid,avoid,21,@jagoosw I would say avoid the flat `LatitudeLongitudeGrid` in the testing (use periodic directions instead) in this PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630792224
https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630792224:67,Testability,test,testing,67,@jagoosw I would say avoid the flat `LatitudeLongitudeGrid` in the testing (use periodic directions instead) in this PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630792224
https://github.com/CliMA/Oceananigans.jl/pull/3180#issuecomment-1631462344:37,Energy Efficiency,reduce,reduce,37,Note: It seems that it didn't really reduce the docs built overall time. I guess we've reached to the point where examples aren't the bottleneck anymore but rather doctests and compilation times are. :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3180#issuecomment-1631462344
https://github.com/CliMA/Oceananigans.jl/pull/3180#issuecomment-1631462344:134,Performance,bottleneck,bottleneck,134,Note: It seems that it didn't really reduce the docs built overall time. I guess we've reached to the point where examples aren't the bottleneck anymore but rather doctests and compilation times are. :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3180#issuecomment-1631462344
https://github.com/CliMA/Oceananigans.jl/pull/3182#issuecomment-1637677967:76,Integrability,message,message,76,closing this as we are moving fwd with a compat entry that will render this message useless.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182#issuecomment-1637677967
https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893:155,Integrability,depend,depends,155,"This is an ok idea but the warning really needs to be better. It isn't clear who is ""recommending"" what; also it doesn't really make sense because the CFL depends on the time stepping method and in principle, someone can use `TimeStepWizard` with any time stepper (for example there are models external to Oceananigans that use the `Simulation`). Presumably 0.8 is some rule of thumb for RK3. Note that we envision moving `Simulation` to an external package eventually, where it could be used by other models (eg atmospheric models). Since ClimaAtmos supports all sorts of time-steppers, I'm not sure this ""recommendation"" would continue to make sense. So I'm a little skeptical about how this is put together. You could write something like ""When using 3rd order Runge-Kutta time-stepping, a time-step that produces a CFL number `cfl > sqrt(3) ≈ 1.7` is unconditionally unstable. As a rule of thumb, we recommend using time-steps that lie well within the realm of stability: for a 3rd order Runge-Kutta scheme, for example, we recommend `cfl < 0.8`. For an Adams-Bashforth scheme, which requires `cfl < XX` for stability, we recommend `cfl < 0.2`. Other time-stepping methods have different stability constraints. For more information see [a reference].""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893
https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893:71,Usability,clear,clear,71,"This is an ok idea but the warning really needs to be better. It isn't clear who is ""recommending"" what; also it doesn't really make sense because the CFL depends on the time stepping method and in principle, someone can use `TimeStepWizard` with any time stepper (for example there are models external to Oceananigans that use the `Simulation`). Presumably 0.8 is some rule of thumb for RK3. Note that we envision moving `Simulation` to an external package eventually, where it could be used by other models (eg atmospheric models). Since ClimaAtmos supports all sorts of time-steppers, I'm not sure this ""recommendation"" would continue to make sense. So I'm a little skeptical about how this is put together. You could write something like ""When using 3rd order Runge-Kutta time-stepping, a time-step that produces a CFL number `cfl > sqrt(3) ≈ 1.7` is unconditionally unstable. As a rule of thumb, we recommend using time-steps that lie well within the realm of stability: for a 3rd order Runge-Kutta scheme, for example, we recommend `cfl < 0.8`. For an Adams-Bashforth scheme, which requires `cfl < XX` for stability, we recommend `cfl < 0.2`. Other time-stepping methods have different stability constraints. For more information see [a reference].""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893
https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:626,Availability,error,error,626,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276
https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:24,Integrability,interface,interface,24,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276
https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:196,Modifiability,extend,extendable,196,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276
https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:717,Security,validat,validate,717,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276
https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697334830:330,Integrability,depend,depending,330,"Ok better idea. The _first_ time that time-step wizard is called as a callback, it can call into a function like `validate_CFL(model, cfl)`. . Then model developers can implement that function if they would like to warn users. Since it's called at iteration 0, the warning is prominent. Moreover, the warning can be made specific depending on the type of model and time-stepper being used, so we can be more sure that we are giving accurate and relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697334830
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636223845:298,Safety,safe,safer,298,"As discussed in https://github.com/CliMA/Oceananigans.jl/discussions/3177#discussioncomment-6448740 I see two solutions: either drop support for v1.8 or prior with a v1.9 compat entry, or add something like; ```Julia; if VERSION < v""1.8""; ...; else; ...; end; ```. Adding the compat requirement is safer since tests only run on v1.9. . On the other hand, in this case, allowing backwards compatibility might be just a few lines like above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636223845
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636223845:310,Testability,test,tests,310,"As discussed in https://github.com/CliMA/Oceananigans.jl/discussions/3177#discussioncomment-6448740 I see two solutions: either drop support for v1.8 or prior with a v1.9 compat entry, or add something like; ```Julia; if VERSION < v""1.8""; ...; else; ...; end; ```. Adding the compat requirement is safer since tests only run on v1.9. . On the other hand, in this case, allowing backwards compatibility might be just a few lines like above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636223845
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:261,Availability,error,error,261,"Btw, the problem is not related with bathymetry directly. It's related with the Heptadiagonal Matrix-based free surface solver. When there is an immersed boundary the default free-surface solver is the Heptadiagonal Matrix-based solver so that's why we get the error above. But an immersed boundary grid is not really required. ```julia; test_Oceananigans/ $ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.5 (2023-01-08); _/ |\__'_|_|_|\__'_| |; |__/ |. (@v1.8) pkg> activate .; Activating new project at `~/Research/test_OC`. (test_Oceananigans) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Updating `~/Research/test_OC/Project.toml`; [9e8cae18] + Oceananigans v0.84.1; Updating `~/Research/test_OC/Manifest.toml`; [621f4979] + AbstractFFTs v1.4.0; [79e6a3ab] + Adapt v3.6.2; [4fba245c] + ArrayInterface v7.4.11; [a9b6321e] + Atomix v0.1.0; [ab4f0b2a] + BFloat16s v0.4.2; [fa961155] + CEnum v0.4.2; [179af706] + CFTime v0.1.2; [052768ef] + CUDA v4.4.0; [1af6417a] + CUDA_Runtime_Discovery v0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:4610,Availability,Down,Downloads,4610,3bb67fe8] + TranscodingStreams v0.9.13; [9d95972d] + TupleTools v1.3.0; [013be700] + UnsafeAtomics v0.2.1; [d80eeb9a] + UnsafeAtomicsLLVM v0.1.3; [81def892] + VersionParsing v1.3.0; [6e34b625] + Bzip2_jll v1.0.8+0; [4ee394cb] + CUDA_Driver_jll v0.5.0+1; [76a88914] + CUDA_Runtime_jll v0.6.0+0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.14.0+0; [1d5cc7b8] + IntelOpenMP_jll v2023.1.0+0; [dad2f222] + LLVMExtra_jll v0.0.23+0; [1d63c593] + LLVMOpenMP_jll v15.0.4+0; [94ce4f54] + Libiconv_jll v1.16.1+2; [856f044c] + MKL_jll v2023.1.0+0; [7cb0a576] + MPICH_jll v4.1.2+0; [f1f71cc9] + MPItrampoline_jll v5.3.1+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+4; [7243133f] + NetCDF_jll v400.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatching; [b77e0a4c] + InteractiveUtils; [4af54fe1] + LazyArtifacts; [b27032c2] + LibCURL v0.6.3; [76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions v1.2.0; [44cfe95a] + Pkg v1.8.0; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA v0.7.0; [9e88b42a] + Serialization; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [4607b0f0] + SuiteSparse; [fa267f1f] + TOML v1.0.0; [a4e569a6] + Tar v1.10.1; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0; [deac9b47] + LibCURL_jll v7.84.0+0; [29816b5a] + LibSSH2_jll v1.10.2+0; [c8ffd9c3] + MbedTLS_jll v2.28.0+0; [14a3606d] + MozillaCACerts_jll v2022.2.1; [4536629a] + OpenBLAS_jll v0.3.20+0; [05823500] + OpenLibm_jll v0.8.1+0; [83775a58] + Zlib_jll ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:5735,Availability,avail,available,5735,"76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions v1.2.0; [44cfe95a] + Pkg v1.8.0; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA v0.7.0; [9e88b42a] + Serialization; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [4607b0f0] + SuiteSparse; [fa267f1f] + TOML v1.0.0; [a4e569a6] + Tar v1.10.1; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0; [deac9b47] + LibCURL_jll v7.84.0+0; [29816b5a] + LibSSH2_jll v1.10.2+0; [c8ffd9c3] + MbedTLS_jll v2.28.0+0; [14a3606d] + MozillaCACerts_jll v2022.2.1; [4536629a] + OpenBLAS_jll v0.3.20+0; [05823500] + OpenLibm_jll v0.8.1+0; [83775a58] + Zlib_jll v1.2.12+3; [8e850b90] + libblastrampoline_jll v5.1.1+0; [8e850ede] + nghttp2_jll v1.48.0+0; [3f19e933] + p7zip_jll v17.4.0+0; Info Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`. julia> using Oceananigans. julia> grid = RectilinearGrid(size=(5, 4, 3), extent=(1, 2, 3));. julia> model = HydrostaticFreeSurfaceModel(; grid); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 5×4×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (T, S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with ĝ = NegativeZDirection(); ├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; └── coriolis: Nothing. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface = ImplicitFreeSurface(; solver_method=:HeptadiagonalIterativeSolver)); ERROR: MethodError: no method matching",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:6706,Availability,ERROR,ERROR,6706,"p7zip_jll v17.4.0+0; Info Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`. julia> using Oceananigans. julia> grid = RectilinearGrid(size=(5, 4, 3), extent=(1, 2, 3));. julia> model = HydrostaticFreeSurfaceModel(; grid); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 5×4×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (T, S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with ĝ = NegativeZDirection(); ├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; └── coriolis: Nothing. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface = ImplicitFreeSurface(; solver_method=:HeptadiagonalIterativeSolver)); ERROR: MethodError: no method matching fkeep!(::Oceananigans.Solvers.var""#60#61"", ::SparseArrays.SparseMatrixCSC{Float64, Int64}); Closest candidates are:; fkeep!(::SparseArrays.AbstractSparseMatrixCSC, ::Any) at ~/julia-1.8/usr/share/julia/stdlib/v1.8/SparseArrays/src/sparsematrix.jl:1491; fkeep!(::SparseArrays.AbstractSparseMatrixCSC, ::Any, ::Bool) at ~/julia-1.8/usr/share/julia/stdlib/v1.8/SparseArrays/src/sparsematrix.jl:1491; fkeep!(::SparseArrays.SparseVector, ::Any) at ~/julia-1.8/usr/share/julia/stdlib/v1.8/SparseArrays/src/sparsevector.jl:2005; Stacktrace:; [1] ensure_diagonal_elements_are_present!; @ ~/.julia/packages/Oceananigans/uvw2D/src/Solvers/matrix_solver_utils.jl:96 [inlined]; [2] matrix_from_coefficients(arch::CPU, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Offse",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:8728,Availability,toler,tolerance,8728,"}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, coeffs::NTuple{5, Array{Float64, 3}}, reduced_dim::Tuple{Bool, Bool, Bool}); @ Oceananigans.Solvers ~/.julia/packages/Oceananigans/uvw2D/src/Solvers/heptadiagonal_iterative_solver.jl:196; [3] Oceananigans.Solvers.HeptadiagonalIterativeSolver(coeffs::NTuple{5, Array{Float64, 3}}; grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, iterative_solver::Function, maximum_iterations::Int64, tolerance::Float64, reduced_dim::Tuple{Bool, Bool, Bool}, placeholder_timestep::Float64, preconditioner_method::Symbol, preconditioner_settings::Nothing, template::Vector{Float64}, verbose::Bool); @ Oceananigans.Solvers ~/.julia/packages/Oceananigans/uvw2D/src/Solvers/heptadiagonal_iterative_solver.jl:98; [4] Oceananigans.Models.HydrostaticFreeSurfaceModels.MatrixImplicitFreeSurfaceSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, settings::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, gravitational_acceleration::Float64); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/uvw",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:991,Energy Efficiency,Adapt,Adapt,991,"Btw, the problem is not related with bathymetry directly. It's related with the Heptadiagonal Matrix-based free surface solver. When there is an immersed boundary the default free-surface solver is the Heptadiagonal Matrix-based solver so that's why we get the error above. But an immersed boundary grid is not really required. ```julia; test_Oceananigans/ $ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.5 (2023-01-08); _/ |\__'_|_|_|\__'_| |; |__/ |. (@v1.8) pkg> activate .; Activating new project at `~/Research/test_OC`. (test_Oceananigans) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Updating `~/Research/test_OC/Project.toml`; [9e8cae18] + Oceananigans v0.84.1; Updating `~/Research/test_OC/Manifest.toml`; [621f4979] + AbstractFFTs v1.4.0; [79e6a3ab] + Adapt v3.6.2; [4fba245c] + ArrayInterface v7.4.11; [a9b6321e] + Atomix v0.1.0; [ab4f0b2a] + BFloat16s v0.4.2; [fa961155] + CEnum v0.4.2; [179af706] + CFTime v0.1.2; [052768ef] + CUDA v4.4.0; [1af6417a] + CUDA_Runtime_Discovery v0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:991,Modifiability,Adapt,Adapt,991,"Btw, the problem is not related with bathymetry directly. It's related with the Heptadiagonal Matrix-based free surface solver. When there is an immersed boundary the default free-surface solver is the Heptadiagonal Matrix-based solver so that's why we get the error above. But an immersed boundary grid is not really required. ```julia; test_Oceananigans/ $ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.5 (2023-01-08); _/ |\__'_|_|_|\__'_| |; |__/ |. (@v1.8) pkg> activate .; Activating new project at `~/Research/test_OC`. (test_Oceananigans) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Updating `~/Research/test_OC/Project.toml`; [9e8cae18] + Oceananigans v0.84.1; Updating `~/Research/test_OC/Manifest.toml`; [621f4979] + AbstractFFTs v1.4.0; [79e6a3ab] + Adapt v3.6.2; [4fba245c] + ArrayInterface v7.4.11; [a9b6321e] + Atomix v0.1.0; [ab4f0b2a] + BFloat16s v0.4.2; [fa961155] + CEnum v0.4.2; [179af706] + CFTime v0.1.2; [052768ef] + CUDA v4.4.0; [1af6417a] + CUDA_Runtime_Discovery v0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:3648,Safety,Unsafe,UnsafeAtomics,3648,.2; [21216c6a] + Preferences v1.4.0; [49802e3a] + ProgressBars v1.5.0; [94ee1d12] + Quaternions v0.7.4; [74087812] + Random123 v1.6.1; [e6cf234a] + RandomNumbers v1.5.3; [c1ae055f] + RealDot v0.1.0; [3cdcf5f2] + RecipesBase v1.3.4; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.3.0; [6038ab10] + Rotations v1.5.1; [6c6a2e73] + Scratch v1.2.0; [d496a93d] + SeawaterPolynomials v0.3.2; [66db9d55] + SnoopPrecompile v1.0.3; [276daf66] + SpecialFunctions v2.3.0; [aedffcd0] + Static v0.8.7; [0d7ed370] + StaticArrayInterface v1.4.0; [90137ffa] + StaticArrays v1.6.1; [1e83bf80] + StaticArraysCore v1.4.1; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v2.0.1; [4db3bf67] + StridedViews v0.1.2; [09ab397b] + StructArrays v0.6.15; [856f2bd8] + StructTypes v1.10.0; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.10.1; [6aa5eb33] + TaylorSeries v0.15.2; [a759f4b9] + TimerOutputs v0.5.23; [3bb67fe8] + TranscodingStreams v0.9.13; [9d95972d] + TupleTools v1.3.0; [013be700] + UnsafeAtomics v0.2.1; [d80eeb9a] + UnsafeAtomicsLLVM v0.1.3; [81def892] + VersionParsing v1.3.0; [6e34b625] + Bzip2_jll v1.0.8+0; [4ee394cb] + CUDA_Driver_jll v0.5.0+1; [76a88914] + CUDA_Runtime_jll v0.6.0+0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.14.0+0; [1d5cc7b8] + IntelOpenMP_jll v2023.1.0+0; [dad2f222] + LLVMExtra_jll v0.0.23+0; [1d63c593] + LLVMOpenMP_jll v15.0.4+0; [94ce4f54] + Libiconv_jll v1.16.1+2; [856f044c] + MKL_jll v2023.1.0+0; [7cb0a576] + MPICH_jll v4.1.2+0; [f1f71cc9] + MPItrampoline_jll v5.3.1+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+4; [7243133f] + NetCDF_jll v400.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatc,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:3683,Safety,Unsafe,UnsafeAtomicsLLVM,3683,[49802e3a] + ProgressBars v1.5.0; [94ee1d12] + Quaternions v0.7.4; [74087812] + Random123 v1.6.1; [e6cf234a] + RandomNumbers v1.5.3; [c1ae055f] + RealDot v0.1.0; [3cdcf5f2] + RecipesBase v1.3.4; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.3.0; [6038ab10] + Rotations v1.5.1; [6c6a2e73] + Scratch v1.2.0; [d496a93d] + SeawaterPolynomials v0.3.2; [66db9d55] + SnoopPrecompile v1.0.3; [276daf66] + SpecialFunctions v2.3.0; [aedffcd0] + Static v0.8.7; [0d7ed370] + StaticArrayInterface v1.4.0; [90137ffa] + StaticArrays v1.6.1; [1e83bf80] + StaticArraysCore v1.4.1; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v2.0.1; [4db3bf67] + StridedViews v0.1.2; [09ab397b] + StructArrays v0.6.15; [856f2bd8] + StructTypes v1.10.0; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.10.1; [6aa5eb33] + TaylorSeries v0.15.2; [a759f4b9] + TimerOutputs v0.5.23; [3bb67fe8] + TranscodingStreams v0.9.13; [9d95972d] + TupleTools v1.3.0; [013be700] + UnsafeAtomics v0.2.1; [d80eeb9a] + UnsafeAtomicsLLVM v0.1.3; [81def892] + VersionParsing v1.3.0; [6e34b625] + Bzip2_jll v1.0.8+0; [4ee394cb] + CUDA_Driver_jll v0.5.0+1; [76a88914] + CUDA_Runtime_jll v0.6.0+0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.14.0+0; [1d5cc7b8] + IntelOpenMP_jll v2023.1.0+0; [dad2f222] + LLVMExtra_jll v0.0.23+0; [1d63c593] + LLVMOpenMP_jll v15.0.4+0; [94ce4f54] + Libiconv_jll v1.16.1+2; [856f044c] + MKL_jll v2023.1.0+0; [7cb0a576] + MPICH_jll v4.1.2+0; [f1f71cc9] + MPItrampoline_jll v5.3.1+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+4; [7243133f] + NetCDF_jll v400.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatching; [b77e0a4c] + InteractiveUtils; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:2218,Testability,Log,LogExpFunctions,2218,0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.32; [692b3bcd] + JLLWrappers v1.4.1; [0f8b85d8] + JSON3 v1.13.1; [63c18a36] + KernelAbstractions v0.9.7; [929cbde3] + LLVM v6.1.0; [2ab3a3ac] + LogExpFunctions v0.3.24; [da04e1cc] + MPI v0.20.12; [3da0fdf6] + MPIPreferences v0.1.8; [1914dd2f] + MacroTools v0.5.10; [85f8d34a] + NCDatasets v0.12.17; [9e8cae18] + Oceananigans v0.84.1; [6fe1bfb0] + OffsetArrays v1.12.10; [bac558e1] + OrderedCollections v1.6.0; [69de0a69] + Parsers v2.7.1; ⌅ [0e08944d] + PencilArrays v0.18.0; [4a48f351] + PencilFFTs v0.15.0; [eebad327] + PkgVersion v0.3.2; [aea7be01] + PrecompileTools v1.1.2; [21216c6a] + Preferences v1.4.0; [49802e3a] + ProgressBars v1.5.0; [94ee1d12] + Quaternions v0.7.4; [74087812] + Random123 v1.6.1; [e6cf234a] + RandomNumbers v1.5.3; [c1ae055f] + RealDot v0.1.0; [3cdcf5f2] + RecipesBase v1.3.4; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.3.0; [6038ab10] + Rotations v1.5.1; [6c6a2e73] + Scratch v1.2.0; [d496a93d] + SeawaterPolynomials v0.3.2; [66db9d55] + SnoopPrecompile v1.0.3; [276daf66] + SpecialFunctions v2.3.0; [aedffcd0] + Static v0.8.7; [0d7ed370] + StaticArrayInterface v1.4.0; [90137ffa] + StaticArrays v1.6.1; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:4826,Testability,Log,Logging,4826,14] + CUDA_Runtime_jll v0.6.0+0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.14.0+0; [1d5cc7b8] + IntelOpenMP_jll v2023.1.0+0; [dad2f222] + LLVMExtra_jll v0.0.23+0; [1d63c593] + LLVMOpenMP_jll v15.0.4+0; [94ce4f54] + Libiconv_jll v1.16.1+2; [856f044c] + MKL_jll v2023.1.0+0; [7cb0a576] + MPICH_jll v4.1.2+0; [f1f71cc9] + MPItrampoline_jll v5.3.1+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+4; [7243133f] + NetCDF_jll v400.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatching; [b77e0a4c] + InteractiveUtils; [4af54fe1] + LazyArtifacts; [b27032c2] + LibCURL v0.6.3; [76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions v1.2.0; [44cfe95a] + Pkg v1.8.0; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA v0.7.0; [9e88b42a] + Serialization; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [4607b0f0] + SuiteSparse; [fa267f1f] + TOML v1.0.0; [a4e569a6] + Tar v1.10.1; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0; [deac9b47] + LibCURL_jll v7.84.0+0; [29816b5a] + LibSSH2_jll v1.10.2+0; [c8ffd9c3] + MbedTLS_jll v2.28.0+0; [14a3606d] + MozillaCACerts_jll v2022.2.1; [4536629a] + OpenBLAS_jll v0.3.20+0; [05823500] + OpenLibm_jll v0.8.1+0; [83775a58] + Zlib_jll v1.2.12+3; [8e850b90] + libblastrampoline_jll v5.1.1+0; [8e850ede] + nghttp2_jll v1.48.0+0; [3f19e933] + p7zip_jll v17.4.0+0; Info Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `sta,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:5217,Testability,Test,Test,5217,"0.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatching; [b77e0a4c] + InteractiveUtils; [4af54fe1] + LazyArtifacts; [b27032c2] + LibCURL v0.6.3; [76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions v1.2.0; [44cfe95a] + Pkg v1.8.0; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA v0.7.0; [9e88b42a] + Serialization; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [4607b0f0] + SuiteSparse; [fa267f1f] + TOML v1.0.0; [a4e569a6] + Tar v1.10.1; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0; [deac9b47] + LibCURL_jll v7.84.0+0; [29816b5a] + LibSSH2_jll v1.10.2+0; [c8ffd9c3] + MbedTLS_jll v2.28.0+0; [14a3606d] + MozillaCACerts_jll v2022.2.1; [4536629a] + OpenBLAS_jll v0.3.20+0; [05823500] + OpenLibm_jll v0.8.1+0; [83775a58] + Zlib_jll v1.2.12+3; [8e850b90] + libblastrampoline_jll v5.1.1+0; [8e850ede] + nghttp2_jll v1.48.0+0; [3f19e933] + p7zip_jll v17.4.0+0; Info Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`. julia> using Oceananigans. julia> grid = RectilinearGrid(size=(5, 4, 3), extent=(1, 2, 3));. julia> model = HydrostaticFreeSurfaceModel(; grid); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 5×4×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (T, S); ├── closure: Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1637026804:255,Availability,error,error,255,"Although it seems an easy fix, I'm leaning more towards to dropping support for v1.8 since we don't test there any more. Even if this bug can be alleviated, who knows whether something else is broken (or even silently broken, without even spitting out an error).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1637026804
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1637026804:100,Testability,test,test,100,"Although it seems an easy fix, I'm leaning more towards to dropping support for v1.8 since we don't test there any more. Even if this bug can be alleviated, who knows whether something else is broken (or even silently broken, without even spitting out an error).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1637026804
https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1638016603:90,Deployability,update,update,90,Julia's compat entry at Project.toml + remove the warning mentioned in #3182 whatsoever + update the docs/readme where we mention what version of Julia is needed. Probably that's it. Start with that and we can work together on the PR?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1638016603
https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377469350:851,Usability,simpl,simple,851,"> @xkykai I propose the following to move forward, let me know what you think:; > ; > 1. Change the names a bit because technically, ImmersedPoissonSolver can be used as a general Poisson solver that works even on a lat lon grid. I think just `ConjugateGradientPoissonSolver` is good.; > ; > 2. Make it default to an FFT-based preconditioner when possible, and otherwise to the ""diagonally dominant preconditioner""; > ; > 3. Since I feel we don't want to drop this just yet, let's not make it the default yet. However, I will put a note in the warning that currently accompanies NonhydrostaticModel on ImmersedBoundaryGrid about the possibility of using it. I agree with all 3 points. One thing that I think would be useful is to come up with one example to put in the docs about the choices of preconditioners and how to use it. We can perhaps use a simple example of a staircase convection to illustrate the point, advertising the FFT-preconditioned solver at the same time as well. Currently there's no section about solver choices, and I suspect some users (me included) might not have been aware that different solver choices could be made. I'd be happy to put together the example case. > It keeps tripping me up that NonhydrostaticModel calls it a ""pressure solver"" but everywhere else we use the term ""Poisson solver"". Should we call it `NonhydrostaticModel.poisson_solver`?. Of course! It doesn't only solve the pressure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377469350
https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377809861:168,Usability,simpl,simple,168,"> One thing that I think would be useful is to come up with one example to put in the docs about the choices of preconditioners and how to use it. We can perhaps use a simple example of a staircase convection to illustrate the point, advertising the FFT-preconditioned solver at the same time as well. I like this idea though I am not sure it should be an example. There are no other examples like that. We are sort of in the process of revamping the docs to add more ""tutorials"". For example, this is a tutorial on grids: https://clima.github.io/OceananigansDocumentation/stable/grids/. I think what you're proposing is a ""tutorial"" on pressure solvers. What do you think?. I think we probably should wait though. It'd be nice to publish a paper about the solver first, and then put what we learned from the paper into the tutorial.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377809861
https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377809861:792,Usability,learn,learned,792,"> One thing that I think would be useful is to come up with one example to put in the docs about the choices of preconditioners and how to use it. We can perhaps use a simple example of a staircase convection to illustrate the point, advertising the FFT-preconditioned solver at the same time as well. I like this idea though I am not sure it should be an example. There are no other examples like that. We are sort of in the process of revamping the docs to add more ""tutorials"". For example, this is a tutorial on grids: https://clima.github.io/OceananigansDocumentation/stable/grids/. I think what you're proposing is a ""tutorial"" on pressure solvers. What do you think?. I think we probably should wait though. It'd be nice to publish a paper about the solver first, and then put what we learned from the paper into the tutorial.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377809861
https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377862921:199,Usability,learn,learnt,199,"> I think what you're proposing is a ""tutorial"" on pressure solvers. What do you think?. Yes I think a tutorial is what I meant. We can do this after the paper is done so we encapsulate what we have learnt.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377862921
https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234:813,Modifiability,config,configure,813,"> Personally, I don't think it's confusing. I also don't feel strongly either way though. Ah yes, totally agree that it isn't confusing. I wasn't arguing that it was confusing though. . In terms of _reading_ these code statements I much prefer seeing `pressure_solver = poisson_solver`. Its even pedagogical because it teaches you that we solve the Poisson equation for pressure. I love that and that is exactly why we chose this design. Please bear with me to understand the reason I am proposing this change. In practical usage / when coding new experiments it is easy to mix up ""pressure"" with ""poisson"". I've been working testing lots of different solvers these past few days, and keep accidentally typing `pressure_solver = ConjugateGradientPressureSolver(grid)` which is wrong. If it becomes more common to configure the pressure / poisson solver in the future (because we have better support for different solvers for irregular geometries) then I would like to also help others that may run into this issue. It's nice to have syntax that ""rolls of the tongue"", ie, is what you would type if you were typing without concentrating very hard. It's not big deal either. I just tend to think that if one makes the same syntax mistake multiple times, it's important to make sure you step back and consider whether the problem is you, or the syntax.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234
https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234:626,Testability,test,testing,626,"> Personally, I don't think it's confusing. I also don't feel strongly either way though. Ah yes, totally agree that it isn't confusing. I wasn't arguing that it was confusing though. . In terms of _reading_ these code statements I much prefer seeing `pressure_solver = poisson_solver`. Its even pedagogical because it teaches you that we solve the Poisson equation for pressure. I love that and that is exactly why we chose this design. Please bear with me to understand the reason I am proposing this change. In practical usage / when coding new experiments it is easy to mix up ""pressure"" with ""poisson"". I've been working testing lots of different solvers these past few days, and keep accidentally typing `pressure_solver = ConjugateGradientPressureSolver(grid)` which is wrong. If it becomes more common to configure the pressure / poisson solver in the future (because we have better support for different solvers for irregular geometries) then I would like to also help others that may run into this issue. It's nice to have syntax that ""rolls of the tongue"", ie, is what you would type if you were typing without concentrating very hard. It's not big deal either. I just tend to think that if one makes the same syntax mistake multiple times, it's important to make sure you step back and consider whether the problem is you, or the syntax.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234
https://github.com/CliMA/Oceananigans.jl/issues/3189#issuecomment-1638382659:19,Availability,error,error,19,I've just got this error again on 0.84.1 so I don't think this is Oceananigans related so will close this issue for now,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189#issuecomment-1638382659
https://github.com/CliMA/Oceananigans.jl/issues/3189#issuecomment-1641975792:22,Deployability,upgrade,upgraded,22,Started on 1.9.1 then upgraded to 1.9.2,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189#issuecomment-1641975792
https://github.com/CliMA/Oceananigans.jl/pull/3190#issuecomment-1639504831:474,Testability,test,tests,474,"@iuryt, in the fields.jl you only needed to remove the branch of the conditional statement that was referring to pre-1.7 versions, not both. E.g., in the [ternary operators](https://docs.julialang.org/en/v1/manual/control-flow/#man-conditional-evaluation):. ```Julia; check_version_larger_than_7() = VERSION.minor > 7. initialize_a_field!(::SumReduction, f, r, c) = check_version_larger_than_7() ? do_this_if_minor > 7 : do_this_if_minor <= 7; ```. I fixed it. Let's see if tests pass now!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3190#issuecomment-1639504831
https://github.com/CliMA/Oceananigans.jl/pull/3190#issuecomment-1639635132:53,Deployability,release,release,53,"> this is a breaking change so let's bump up a minor release @iuryt, could you bump up the minor version number in the Project.toml?; > ; > https://github.com/iuryt/Oceananigans.jl/blob/ef5e0aa1a8130f26117d06b82d6b8eba420e384f/Project.toml#L4. Also, when this happens, rename the PR to add the new version in front; see [#3147](https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595628085).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3190#issuecomment-1639635132
https://github.com/CliMA/Oceananigans.jl/pull/3190#issuecomment-1642612901:46,Deployability,update,updated,46,"Hi, is that expected that the docs is not yet updated?. https://clima.github.io/OceananigansDocumentation. For me, it is still showing that you could use 1.6. ![image](https://github.com/CliMA/Oceananigans.jl/assets/5797727/fc26483d-0518-4bb0-b399-bae80d6e3345)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3190#issuecomment-1642612901
https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711356979:0,Deployability,Deploy,Deploy,0,Deploy of gh-pages at OceananigansDocumentation repo seems OK now. I think it was just a glitch...; https://github.com/CliMA/OceananigansDocumentation/actions/runs/6109843276. But the tags don't seem to push docs in the repo. I believe it has something to do with buildkite settings...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711356979
https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161:444,Integrability,message,message,444,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161
https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161:541,Integrability,message,messages,541,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161
https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161:596,Integrability,message,messages,596,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161
https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161:231,Usability,clear,clear,231,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1648148527:492,Testability,log,log-law,492,"Hello, ; Do you want to simulate a channel flow or a turbulent boundary layer? Because at the moment, you are just specifying the drag at the bottom (which I guess is a model for the no-slip boundary condition), while a channel requires no-slip at both the top and the bottom. Also, in case you want to simulate a turbulent boundary layer, take care that it is not a periodic case but spatially developing in the streamwise direction, so if you are looking for the self-similar solution (the log-law), you need to rescale somewhere at the beginning or the end of the domain. ; This is not a problem with a fully developed channel flow that is statistically homogeneous in the streamwise direction. Given that you probably need to specify the drag at the top and bottom (unless drag is only for roughness), also `cᴰᵇ` is wrong. This is because the closest grid center to the bottom is the first element in the `znodes` array, not the last:; ```julia; const z₁ = -1*znodes(Center,grid)[1] # Closest grid center to the bottom; ```; Let me know if that works",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1648148527
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1648882721:58,Usability,clear,clear,58,"Thank you for your reply! And apologies for have not been clear.; Firstly, we want to simulate a ""half-channel flow"", so we only use no-slip boundary condition at the bottom. Secondly, we have used periodic boundary condition in x (streamwise) and y (crosswise) direction.; Finally, in this case the z-axis is range from -15 to 0, so I can't use ``` const z₁ = -1*znodes(Center,grid)[1] ``` because if I do that, the value of z1 will change to 14.88. My code ``` const z₁ = -1*znodes(Center,grid)[grid.Nz] ``` will keep z1 equals to Closest grid center to the bottom (0.12).; Everything seems right, but the result seems strange!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1648882721
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834:1932,Safety,predict,predicted,1932," have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference? ![u_profile (2)](https://user-images.githubusercontent.com/117068415/255586911-14e2c865-ec3b-4065-a13a-213a99257d31.png) ![uw_flux (1)](https://user-images.githubusercontent.com/117068415/255630762-1cd16836-6f59-465b-8d02-0577052b52ba.png); > ; > ```julia; > const H=15 #/m; > grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); > const u★=0.01 #friction velocity; > Fx(x,y,z,t)=u★^2/H #forcing; > ; > const z₀ = H*1e-4 # m (roughness length); > const κ = 0.4 # von Karman constant; > const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; > const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient; > ; > @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); > @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v); > ; > drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > ; > u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); > v_bcs = FieldBoundaryConditions(bottom = drag_bc_v); > ; > model = NonhydrostaticModel(; grid, coriolis,; > advection = WENO(),; > timestepper = :RungeKutta3,; > tracers =(:T,:S),; > buoyancy = SeawaterBuoyancy(),; > closure = AnisotropicMinimumDissipation(),; > boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; > forcing=(u=Fx,)); > ```. I also have the same problem here. I am trying to simulate the neutral turbulent boundary layer here. However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. Any ideas? @glwagner @tomchor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834:112,Testability,log,log-low,112,"> Hi all, I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference? ![u_profile (2)](https://user-images.githubusercontent.com/117068415/255586911-14e2c865-ec3b-4065-a13a-213a99257d31.png) ![uw_flux (1)](https://user-images.githubusercontent.com/117068415/255630762-1cd16836-6f59-465b-8d02-0577052b52ba.png); > ; > ```julia; > const H=15 #/m; > grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); > const u★=0.01 #friction velocity; > Fx(x,y,z,t)=u★^2/H #forcing; > ; > const z₀ = H*1e-4 # m (roughness length); > const κ = 0.4 # von Karman constant; > const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; > const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient; > ; > @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); > @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v); > ; > drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > ; > u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); > v_bcs = FieldBoundaryConditions(bottom = drag_bc_v); > ; > model = NonhydrostaticModel(; grid, coriolis,; > advection = WENO(),; > timestepper = :RungeKutta3,; > tracers =(:T,:S),; > buoyancy = SeawaterBuoyancy(),; > closure = AnisotropicMinimumDissipation(),; > boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; > forcing=(u=Fx,)); > ```. I also have the same problem here. I am trying to simulate the neutral turbulent boundary layer here. However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. Any ideas? @glwagne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834:933,Testability,log,log,933,"> Hi all, I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference? ![u_profile (2)](https://user-images.githubusercontent.com/117068415/255586911-14e2c865-ec3b-4065-a13a-213a99257d31.png) ![uw_flux (1)](https://user-images.githubusercontent.com/117068415/255630762-1cd16836-6f59-465b-8d02-0577052b52ba.png); > ; > ```julia; > const H=15 #/m; > grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); > const u★=0.01 #friction velocity; > Fx(x,y,z,t)=u★^2/H #forcing; > ; > const z₀ = H*1e-4 # m (roughness length); > const κ = 0.4 # von Karman constant; > const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; > const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient; > ; > @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); > @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v); > ; > drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > ; > u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); > v_bcs = FieldBoundaryConditions(bottom = drag_bc_v); > ; > model = NonhydrostaticModel(; grid, coriolis,; > advection = WENO(),; > timestepper = :RungeKutta3,; > tracers =(:T,:S),; > buoyancy = SeawaterBuoyancy(),; > closure = AnisotropicMinimumDissipation(),; > boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; > forcing=(u=Fx,)); > ```. I also have the same problem here. I am trying to simulate the neutral turbulent boundary layer here. However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. Any ideas? @glwagne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834:46,Usability,simpl,simple,46,"> Hi all, I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference? ![u_profile (2)](https://user-images.githubusercontent.com/117068415/255586911-14e2c865-ec3b-4065-a13a-213a99257d31.png) ![uw_flux (1)](https://user-images.githubusercontent.com/117068415/255630762-1cd16836-6f59-465b-8d02-0577052b52ba.png); > ; > ```julia; > const H=15 #/m; > grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); > const u★=0.01 #friction velocity; > Fx(x,y,z,t)=u★^2/H #forcing; > ; > const z₀ = H*1e-4 # m (roughness length); > const κ = 0.4 # von Karman constant; > const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; > const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient; > ; > @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); > @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v); > ; > drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > ; > u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); > v_bcs = FieldBoundaryConditions(bottom = drag_bc_v); > ; > model = NonhydrostaticModel(; grid, coriolis,; > advection = WENO(),; > timestepper = :RungeKutta3,; > tracers =(:T,:S),; > buoyancy = SeawaterBuoyancy(),; > closure = AnisotropicMinimumDissipation(),; > boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; > forcing=(u=Fx,)); > ```. I also have the same problem here. I am trying to simulate the neutral turbulent boundary layer here. However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. Any ideas? @glwagne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:936,Availability,robust,robust,936,"Here are a couple of comments that come to mind when looking at your code. 1. You're using a call to `znodes(Center,grid)`, which indicates that you're using an out-of-date version of the code. I suggest you update the code to the latest version and then try again. It's good to always keep your code up-to-date (especially when posting here) because the code is always being improved upon (and in some instances some bugs get fixed which may be important to your example!). 2. That said, about this:. > Finally, in this case the z-axis is range from -15 to 0, so I can't use `const z₁ = -1*znodes(Center,grid)[1]` because if I do that, the value of z1 will change to 14.88. My code `const z₁ = -1*znodes(Center,grid)[grid.Nz]` will keep z1 equals to Closest grid center to the bottom (0.12). This isn't the best way to define $z_1$. The current statement will break if you, for example, decide to stretch the grid vertically. The more robust way to define $z_1$ is. ```julia; julia> grid = RectilinearGrid(CPU(), size=(64,64,64), extent=(π*H, π*H, H)); 64×64×64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:2202,Availability,error,errors,2202,"rGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth investigating.; - Have you tried using the `SmagorinskyLilly` closure? I've had some issues with AMD in the past (although not exactly the same as yours), and I remember @glwagner mentioning having an issue with AMD near boundaries that could explain the behavior you're seeing.; - Finally, I'd suggest starting with a very simple model first for debugging/investigating. Just the bare minimum to reproduce a log-law. (i.e., no tracers, buoyancy, Coriolis, forcing...). @Tinydog8 @chabbymark Hope this helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:2316,Availability,error,error,2316,"rGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth investigating.; - Have you tried using the `SmagorinskyLilly` closure? I've had some issues with AMD in the past (although not exactly the same as yours), and I remember @glwagner mentioning having an issue with AMD near boundaries that could explain the behavior you're seeing.; - Finally, I'd suggest starting with a very simple model first for debugging/investigating. Just the bare minimum to reproduce a log-law. (i.e., no tracers, buoyancy, Coriolis, forcing...). @Tinydog8 @chabbymark Hope this helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:208,Deployability,update,update,208,"Here are a couple of comments that come to mind when looking at your code. 1. You're using a call to `znodes(Center,grid)`, which indicates that you're using an out-of-date version of the code. I suggest you update the code to the latest version and then try again. It's good to always keep your code up-to-date (especially when posting here) because the code is always being improved upon (and in some instances some bugs get fixed which may be important to your example!). 2. That said, about this:. > Finally, in this case the z-axis is range from -15 to 0, so I can't use `const z₁ = -1*znodes(Center,grid)[1]` because if I do that, the value of z1 will change to 14.88. My code `const z₁ = -1*znodes(Center,grid)[grid.Nz]` will keep z1 equals to Closest grid center to the bottom (0.12). This isn't the best way to define $z_1$. The current statement will break if you, for example, decide to stretch the grid vertically. The more robust way to define $z_1$ is. ```julia; julia> grid = RectilinearGrid(CPU(), size=(64,64,64), extent=(π*H, π*H, H)); 64×64×64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:2373,Testability,test,test,2373,"rGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth investigating.; - Have you tried using the `SmagorinskyLilly` closure? I've had some issues with AMD in the past (although not exactly the same as yours), and I remember @glwagner mentioning having an issue with AMD near boundaries that could explain the behavior you're seeing.; - Finally, I'd suggest starting with a very simple model first for debugging/investigating. Just the bare minimum to reproduce a log-law. (i.e., no tracers, buoyancy, Coriolis, forcing...). @Tinydog8 @chabbymark Hope this helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:2535,Testability,log,log-law,2535,"rGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth investigating.; - Have you tried using the `SmagorinskyLilly` closure? I've had some issues with AMD in the past (although not exactly the same as yours), and I remember @glwagner mentioning having an issue with AMD near boundaries that could explain the behavior you're seeing.; - Finally, I'd suggest starting with a very simple model first for debugging/investigating. Just the bare minimum to reproduce a log-law. (i.e., no tracers, buoyancy, Coriolis, forcing...). @Tinydog8 @chabbymark Hope this helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:2974,Testability,log,log-law,2974,"rGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth investigating.; - Have you tried using the `SmagorinskyLilly` closure? I've had some issues with AMD in the past (although not exactly the same as yours), and I remember @glwagner mentioning having an issue with AMD near boundaries that could explain the behavior you're seeing.; - Finally, I'd suggest starting with a very simple model first for debugging/investigating. Just the bare minimum to reproduce a log-law. (i.e., no tracers, buoyancy, Coriolis, forcing...). @Tinydog8 @chabbymark Hope this helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:1528,Usability,clear,clearer,1528,"an't use `const z₁ = -1*znodes(Center,grid)[1]` because if I do that, the value of z1 will change to 14.88. My code `const z₁ = -1*znodes(Center,grid)[grid.Nz]` will keep z1 equals to Closest grid center to the bottom (0.12). This isn't the best way to define $z_1$. The current statement will break if you, for example, decide to stretch the grid vertically. The more robust way to define $z_1$ is. ```julia; julia> grid = RectilinearGrid(CPU(), size=(64,64,64), extent=(π*H, π*H, H)); 64×64×64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:2889,Usability,simpl,simple,2889,"rGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth investigating.; - Have you tried using the `SmagorinskyLilly` closure? I've had some issues with AMD in the past (although not exactly the same as yours), and I remember @glwagner mentioning having an issue with AMD near boundaries that could explain the behavior you're seeing.; - Finally, I'd suggest starting with a very simple model first for debugging/investigating. Just the bare minimum to reproduce a log-law. (i.e., no tracers, buoyancy, Coriolis, forcing...). @Tinydog8 @chabbymark Hope this helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:744,Availability,failure,failure,744,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:197,Modifiability,layers,layers,197,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:93,Safety,predict,predicted,93,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:451,Safety,predict,predictions,451,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:769,Testability,log,log-law,769,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:444,Integrability,depend,dependent,444,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:540,Integrability,depend,dependent-Lagrangian-dynamic-model-for,540,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:369,Modifiability,layers,layers,369,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:140,Performance,perform,performances,140,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:632,Performance,perform,performance,632,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:33,Testability,test,tested,33,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:998,Usability,learn,learning,998,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1653726059:1335,Deployability,update,update,1335,"Hmm ok. But just to make sure I understand --- you are saying that you _disagree_ with Yang, Park, and Moin (2017) paper, correct? In that paper, they apparently use the Lagrangian-scale-averaged (LSA) SGS model. <img width=""1040"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/b67188a4-a2e9-4705-955c-7ba42bdd4d3a"">. Of course, whether or not this LSA closure has an issue, there could _still_ be a problem with wall-modeled stresses when using `AnisotropicMinimumDissipation`. (In the above paper, they claim that the SGS model doesn't matter.). I'm curious what happens if you try. ```julia; advection = WENO(order=9); ```. You may also need to add something like `halo = (4, 4, 4)` or `halo = (5, 5, 5)` to the `RectilinearGrid` constructor. I'm also curious what happens if you use `advection = WENO(order=9)` with `closure = nothing`. > Now the problem is that if someone can implement this filtering in the code or not. Are you referring to the time-filtering described in equation 2?. <img width=""1047"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/f9bb4cf7-06bd-4aef-9965-f7ace6530a44"">. It is not necessary to change Oceananigans to implement this --- it can be implemented in your script. You need to introduce a new field to store the time-filtered wall velocity, and update this field in a `Simulation.callbacks`. It should be straightforward. By the way, I think this should be a Discussion (rather than an issue), because this does not (as far as I can tell) involve a bug of some kind in Oceananigans. It could motivate implementing a new SGS model, but that's a discussion for another day perhaps...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1653726059
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493:1281,Modifiability,variab,variables,1281,"@Tinydog8 let me know if you're ok to convert this to discussion. Here's a sketch of how to accumulate `u_wm`:. ```julia; u_wall_model = XFaceField(grid, indices=(:, :, 1)) # It's purely a niceity to specify `indices` properly here --- the only thing we really need is a 2D array. # Also define other velocity components as needed; # Define drag boundary condition in terms of u_wall_model, other velocity components, etc using the `discrete_form=true`. # This function is meant to be used in a callback; function compute_wall_model_velocity!(sim); u, v, w = sim.model.velocities. filtering_time_scale = 1.0 # seconds --- for example; ϵ = sim.Δt / filtering_time_scale. u_wm = interior(u_wall_model, :, :, 1) # extract a view to broadcast over; u_LES = interior(u, :, :, 1) # a view into the LES velocity within the first grid cell; @. u_wm = (1 - ϵ) * u_wm + ϵ * u_LES. # Compute other components as needed; return nothing; end. simulation.callbacks[:wall_model] = Callback(compute_wall_model_velocity!); ```. An even more slick approach would build new auxiliary fields for the wall model velocities. In that case (if I'm not mistaken), then the wall model velocities are accessible from the argument to the boundary condition function (and don't have to be referenced as global variables).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493:1174,Security,access,accessible,1174,"@Tinydog8 let me know if you're ok to convert this to discussion. Here's a sketch of how to accumulate `u_wm`:. ```julia; u_wall_model = XFaceField(grid, indices=(:, :, 1)) # It's purely a niceity to specify `indices` properly here --- the only thing we really need is a 2D array. # Also define other velocity components as needed; # Define drag boundary condition in terms of u_wall_model, other velocity components, etc using the `discrete_form=true`. # This function is meant to be used in a callback; function compute_wall_model_velocity!(sim); u, v, w = sim.model.velocities. filtering_time_scale = 1.0 # seconds --- for example; ϵ = sim.Δt / filtering_time_scale. u_wm = interior(u_wall_model, :, :, 1) # extract a view to broadcast over; u_LES = interior(u, :, :, 1) # a view into the LES velocity within the first grid cell; @. u_wm = (1 - ϵ) * u_wm + ϵ * u_LES. # Compute other components as needed; return nothing; end. simulation.callbacks[:wall_model] = Callback(compute_wall_model_velocity!); ```. An even more slick approach would build new auxiliary fields for the wall model velocities. In that case (if I'm not mistaken), then the wall model velocities are accessible from the argument to the boundary condition function (and don't have to be referenced as global variables).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654582701:76,Testability,log,log-law,76,@glwagner if this works (i.e. if AMD with this change indeed reproduces the log-law better) this would make a pretty cool example for the docs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654582701
https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1655986822:78,Testability,log,log-law,78,"> @glwagner if this works (i.e. if AMD with this change indeed reproduces the log-law better) this would make a pretty cool example for the docs. We can put it on the list though I'd be hesitant to move too quickly because our docs will probably be getting a lot heavier in the near future with sphere examples, and examples with more complex bathymetry. Perhaps you can make the tilted bottom boundary layer 3D and add it into that one, so we don't pay the price of a new independent example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1655986822
https://github.com/CliMA/Oceananigans.jl/issues/3199#issuecomment-2044094083:132,Safety,avoid,avoid,132,"> This was mostly dealt with #3488 but still the implementation in #3488 requires 1 region per panel. Maybe we close this issue (to avoid confusion), and later, create a new one to enable multiple regions per panel and an associated PR (to close it)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3199#issuecomment-2044094083
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718257374:81,Performance,optimiz,optimization,81,"Is this task required to complete the cubed sphere, or should we regard it as an optimization that's important for performance but not functionality?. @simone-silvestri @navidcy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718257374
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718257374:115,Performance,perform,performance,115,"Is this task required to complete the cubed sphere, or should we regard it as an optimization that's important for performance but not functionality?. @simone-silvestri @navidcy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718257374
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718731994:8,Performance,perform,performance,8,"It's a ""performance"" task really but I have the gut feeling that it might be impeding performance so much that we won't be able to consider the cubed sphere done if we don't deal with this. So probably good idea to leave it in the milestone of global simulation using cubed sphere as is now?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718731994
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718731994:86,Performance,perform,performance,86,"It's a ""performance"" task really but I have the gut feeling that it might be impeding performance so much that we won't be able to consider the cubed sphere done if we don't deal with this. So probably good idea to leave it in the milestone of global simulation using cubed sphere as is now?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718731994
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032:106,Performance,perform,performance,106,"""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032:196,Performance,optimiz,optimization,196,"""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032:383,Performance,perform,performant,383,"""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478:651,Energy Efficiency,reduce,reduced,651,"> ""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. . > Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU. Well at least some gut feeling comes from that am pretty sure that it can be reduced in half by getting done in a single pass. But you are on point, I don’t have a gut feeling regarding how much impact the two passes have on performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478:108,Performance,perform,performance,108,"> ""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. . > Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU. Well at least some gut feeling comes from that am pretty sure that it can be reduced in half by getting done in a single pass. But you are on point, I don’t have a gut feeling regarding how much impact the two passes have on performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478:198,Performance,optimiz,optimization,198,"> ""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. . > Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU. Well at least some gut feeling comes from that am pretty sure that it can be reduced in half by getting done in a single pass. But you are on point, I don’t have a gut feeling regarding how much impact the two passes have on performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478:269,Performance,perform,performance,269,"> ""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. . > Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU. Well at least some gut feeling comes from that am pretty sure that it can be reduced in half by getting done in a single pass. But you are on point, I don’t have a gut feeling regarding how much impact the two passes have on performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478:551,Performance,perform,performant,551,"> ""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. . > Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU. Well at least some gut feeling comes from that am pretty sure that it can be reduced in half by getting done in a single pass. But you are on point, I don’t have a gut feeling regarding how much impact the two passes have on performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478:799,Performance,perform,performance,799,"> ""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. . > Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU. Well at least some gut feeling comes from that am pretty sure that it can be reduced in half by getting done in a single pass. But you are on point, I don’t have a gut feeling regarding how much impact the two passes have on performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468:52,Performance,perform,performance,52,"> True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. We expect to be at lower performance. For that reason we have dedicated two independent milestones to the cubed sphere. The first milestone is rather susinct ""complete the cubed sphere implementation"". The second milestone pertain to performance: ""achieve 10 SYPD at 25 km resolution"". I think this is nice, because we want to separate tasks into ones that are _required_ for correct functionality, versus tasks that are oriented towards performance rather than correctness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468:189,Performance,perform,performance,189,"> True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. We expect to be at lower performance. For that reason we have dedicated two independent milestones to the cubed sphere. The first milestone is rather susinct ""complete the cubed sphere implementation"". The second milestone pertain to performance: ""achieve 10 SYPD at 25 km resolution"". I think this is nice, because we want to separate tasks into ones that are _required_ for correct functionality, versus tasks that are oriented towards performance rather than correctness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468:398,Performance,perform,performance,398,"> True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. We expect to be at lower performance. For that reason we have dedicated two independent milestones to the cubed sphere. The first milestone is rather susinct ""complete the cubed sphere implementation"". The second milestone pertain to performance: ""achieve 10 SYPD at 25 km resolution"". I think this is nice, because we want to separate tasks into ones that are _required_ for correct functionality, versus tasks that are oriented towards performance rather than correctness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468:602,Performance,perform,performance,602,"> True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. We expect to be at lower performance. For that reason we have dedicated two independent milestones to the cubed sphere. The first milestone is rather susinct ""complete the cubed sphere implementation"". The second milestone pertain to performance: ""achieve 10 SYPD at 25 km resolution"". I think this is nice, because we want to separate tasks into ones that are _required_ for correct functionality, versus tasks that are oriented towards performance rather than correctness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:365,Availability,Recover,Recovering,365,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:13,Performance,perform,performance,13,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:225,Performance,perform,performance,225,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:381,Performance,perform,performance,381,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187
https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:365,Safety,Recover,Recovering,365,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187
https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1717770543:3301,Integrability,message,message,3301,"4+1, Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₁ = φnode(3Nx÷4+1, Ny÷4+1, getregion(grid, panel), Center(), Center()). panel = 4; λ₂ = λnode(Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₂ = φnode(Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()). panel = 3; λ₃ = λnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₃ = φnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()). panel = 6; λ₄ = λnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₄ = φnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()). δR = 2; θ₀ = 1. θᵢ(λ, φ, z) = θ₀ * exp(-((λ - λ₁)^2 + (φ - φ₁)^2) / 2δR^2) +; θ₀ * exp(-((λ - λ₂)^2 + (φ - φ₂)^2) / 2δR^2) +; θ₀ * exp(-((λ - λ₃)^2 + (φ - φ₃)^2) / 2δR^2) + ; θ₀ * exp(-((λ - λ₄)^2 + (φ - φ₄)^2) / 2δR^2). set!(model, θ = θᵢ). θ = model.tracers.θ; fill_halo_regions!(θ). Δt = 0.0015; stop_iteration = 8000. simulation = Simulation(model; Δt, stop_iteration). # Print a progress message; using Printf. progress_message(sim) = @printf(""Iteration: %04d, time: %s, Δt: %s, wall time: %s\n"",; iteration(sim), prettytime(sim), prettytime(sim.Δt),; prettytime(sim.run_wall_time)). simulation.callbacks[:progress] = Callback(progress_message, IterationInterval(100)). tracer_fields = Field[]. function save_tracer(sim); push!(tracer_fields, deepcopy(sim.model.tracers.θ)); end. simulation.callbacks[:save_tracer] = Callback(save_tracer, IterationInterval(20)). run!(simulation). @info ""Making an animation from the saved data..."". n = Observable(1). Θₙ = []; for region in 1:6; push!(Θₙ, @lift parent(getregion(tracer_fields[$n], region)[:, :, grid.Nz])); end. function where_to_plot(region); region == 1 && return (3, 1); region == 2 && return (3, 2); region == 3 && return (2, 2); region == 4 && return (2, 3); region == 5 && return (1, 3); region == 6 && return (1, 4); end. function heatlatlon!(ax::Axis, field, k=1; kwargs...). LX, LY, LZ = location(field). grid = field.grid; _, (λ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1717770543
https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432:75,Modifiability,Extend,Extending,75,"It's very exciting! I was just remarking about ""we have to comment X out"". Extending a method that doesn't work on the cubed sphere is practically the same amount of work (in this case), and illustrates the proper workflow when developing a new feature (often methods will have to be extended, since they may make assumptions that are no longer valid). So I wanted to point that out in case people run into this in the future and use it as a template for their own development. Also if you are working with others, being clear about the development that's needed can help coordinate efforts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432
https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432:284,Modifiability,extend,extended,284,"It's very exciting! I was just remarking about ""we have to comment X out"". Extending a method that doesn't work on the cubed sphere is practically the same amount of work (in this case), and illustrates the proper workflow when developing a new feature (often methods will have to be extended, since they may make assumptions that are no longer valid). So I wanted to point that out in case people run into this in the future and use it as a template for their own development. Also if you are working with others, being clear about the development that's needed can help coordinate efforts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432
https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432:521,Usability,clear,clear,521,"It's very exciting! I was just remarking about ""we have to comment X out"". Extending a method that doesn't work on the cubed sphere is practically the same amount of work (in this case), and illustrates the proper workflow when developing a new feature (often methods will have to be extended, since they may make assumptions that are no longer valid). So I wanted to point that out in case people run into this in the future and use it as a template for their own development. Also if you are working with others, being clear about the development that's needed can help coordinate efforts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432
https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659126401:282,Availability,Checkpoint,Checkpointer,282,"Possibly you want to invent a new function (or keyword argument) for this? Something like. ```julia; set!(model, checkpoint_file; with_halos=false); ```. Hopefully this can be done simply. I was going to suggest using `FieldTimeSeries`. But then I realized that can't be done with `Checkpointer`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659126401
https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659126401:181,Usability,simpl,simply,181,"Possibly you want to invent a new function (or keyword argument) for this? Something like. ```julia; set!(model, checkpoint_file; with_halos=false); ```. Hopefully this can be done simply. I was going to suggest using `FieldTimeSeries`. But then I realized that can't be done with `Checkpointer`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659126401
https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376:11,Availability,Checkpoint,Checkpointer,11,"Note, the `Checkpointer` currently does not save field location --- it only serializes the field data:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L170. For a clean implementation of this feature, you'll need to extend the `Checkpointer` to also serialize the field location (and indices). Then you can use something like. ```julia; parent_data = file[""$name/data""]; loc = file[""$name/location""]; indices = file[""$name/indices""]; data = offset_data(parent_data, grid, loc, indices); model_field = model_fields[name]. if with_halos; copyto!(parent(model_field), parent_data); else; set!(model_field, data); end; ```. which extends these lines. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L215-L217",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376
https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376:209,Availability,checkpoint,checkpointer,209,"Note, the `Checkpointer` currently does not save field location --- it only serializes the field data:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L170. For a clean implementation of this feature, you'll need to extend the `Checkpointer` to also serialize the field location (and indices). Then you can use something like. ```julia; parent_data = file[""$name/data""]; loc = file[""$name/location""]; indices = file[""$name/indices""]; data = offset_data(parent_data, grid, loc, indices); model_field = model_fields[name]. if with_halos; copyto!(parent(model_field), parent_data); else; set!(model_field, data); end; ```. which extends these lines. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L215-L217",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376
https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376:302,Availability,Checkpoint,Checkpointer,302,"Note, the `Checkpointer` currently does not save field location --- it only serializes the field data:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L170. For a clean implementation of this feature, you'll need to extend the `Checkpointer` to also serialize the field location (and indices). Then you can use something like. ```julia; parent_data = file[""$name/data""]; loc = file[""$name/location""]; indices = file[""$name/indices""]; data = offset_data(parent_data, grid, loc, indices); model_field = model_fields[name]. if with_halos; copyto!(parent(model_field), parent_data); else; set!(model_field, data); end; ```. which extends these lines. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L215-L217",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376
https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376:826,Availability,checkpoint,checkpointer,826,"Note, the `Checkpointer` currently does not save field location --- it only serializes the field data:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L170. For a clean implementation of this feature, you'll need to extend the `Checkpointer` to also serialize the field location (and indices). Then you can use something like. ```julia; parent_data = file[""$name/data""]; loc = file[""$name/location""]; indices = file[""$name/indices""]; data = offset_data(parent_data, grid, loc, indices); model_field = model_fields[name]. if with_halos; copyto!(parent(model_field), parent_data); else; set!(model_field, data); end; ```. which extends these lines. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L215-L217",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376
https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376:290,Modifiability,extend,extend,290,"Note, the `Checkpointer` currently does not save field location --- it only serializes the field data:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L170. For a clean implementation of this feature, you'll need to extend the `Checkpointer` to also serialize the field location (and indices). Then you can use something like. ```julia; parent_data = file[""$name/data""]; loc = file[""$name/location""]; indices = file[""$name/indices""]; data = offset_data(parent_data, grid, loc, indices); model_field = model_fields[name]. if with_halos; copyto!(parent(model_field), parent_data); else; set!(model_field, data); end; ```. which extends these lines. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L215-L217",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376
https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376:700,Modifiability,extend,extends,700,"Note, the `Checkpointer` currently does not save field location --- it only serializes the field data:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L170. For a clean implementation of this feature, you'll need to extend the `Checkpointer` to also serialize the field location (and indices). Then you can use something like. ```julia; parent_data = file[""$name/data""]; loc = file[""$name/location""]; indices = file[""$name/indices""]; data = offset_data(parent_data, grid, loc, indices); model_field = model_fields[name]. if with_halos; copyto!(parent(model_field), parent_data); else; set!(model_field, data); end; ```. which extends these lines. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L215-L217",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376
https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1659297199:269,Deployability,release,releases,269,"@glwagner, it looks like something happened in between early stages of this PR (https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100709220), when the BC were working as intended, and the main branch of [v.086.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.86.0).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1659297199
https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317:927,Deployability,integrat,integration,927,"I get the same problem, and it looks like the boundary condition is added correctly:. ```julia; julia> model.velocities.u; 1×1×32 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×32 ImmersedBoundaryGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Value, immersed: ImmersedBoundaryCondition; └── data: 1×1×38 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:35) with eltype Float64 with indices 1:1×1:1×-2:35; └── max=-0.0857023, min=-0.972122, mean=-0.393485; ```. I think `FluxBoundaryCondition` is tested here:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/test/test_boundary_conditions_integration.jl#L231-L241. (though only for `NonhydrostaticModel`)... Might make sense to build up those boundary condition integration tests for `HydrostaticFreeSurfaceModel` and also for `ValueBoundaryCondition` and `GradientBoundaryCondition`. @simone-silvestri is this broken because we are now using ""boundary-aware"" derivatives?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317
https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317:927,Integrability,integrat,integration,927,"I get the same problem, and it looks like the boundary condition is added correctly:. ```julia; julia> model.velocities.u; 1×1×32 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×32 ImmersedBoundaryGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Value, immersed: ImmersedBoundaryCondition; └── data: 1×1×38 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:35) with eltype Float64 with indices 1:1×1:1×-2:35; └── max=-0.0857023, min=-0.972122, mean=-0.393485; ```. I think `FluxBoundaryCondition` is tested here:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/test/test_boundary_conditions_integration.jl#L231-L241. (though only for `NonhydrostaticModel`)... Might make sense to build up those boundary condition integration tests for `HydrostaticFreeSurfaceModel` and also for `ValueBoundaryCondition` and `GradientBoundaryCondition`. @simone-silvestri is this broken because we are now using ""boundary-aware"" derivatives?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317
https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317:673,Testability,test,tested,673,"I get the same problem, and it looks like the boundary condition is added correctly:. ```julia; julia> model.velocities.u; 1×1×32 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×32 ImmersedBoundaryGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Value, immersed: ImmersedBoundaryCondition; └── data: 1×1×38 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:35) with eltype Float64 with indices 1:1×1:1×-2:35; └── max=-0.0857023, min=-0.972122, mean=-0.393485; ```. I think `FluxBoundaryCondition` is tested here:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/test/test_boundary_conditions_integration.jl#L231-L241. (though only for `NonhydrostaticModel`)... Might make sense to build up those boundary condition integration tests for `HydrostaticFreeSurfaceModel` and also for `ValueBoundaryCondition` and `GradientBoundaryCondition`. @simone-silvestri is this broken because we are now using ""boundary-aware"" derivatives?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317
https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317:774,Testability,test,test,774,"I get the same problem, and it looks like the boundary condition is added correctly:. ```julia; julia> model.velocities.u; 1×1×32 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×32 ImmersedBoundaryGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Value, immersed: ImmersedBoundaryCondition; └── data: 1×1×38 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:35) with eltype Float64 with indices 1:1×1:1×-2:35; └── max=-0.0857023, min=-0.972122, mean=-0.393485; ```. I think `FluxBoundaryCondition` is tested here:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/test/test_boundary_conditions_integration.jl#L231-L241. (though only for `NonhydrostaticModel`)... Might make sense to build up those boundary condition integration tests for `HydrostaticFreeSurfaceModel` and also for `ValueBoundaryCondition` and `GradientBoundaryCondition`. @simone-silvestri is this broken because we are now using ""boundary-aware"" derivatives?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317
https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317:939,Testability,test,tests,939,"I get the same problem, and it looks like the boundary condition is added correctly:. ```julia; julia> model.velocities.u; 1×1×32 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×32 ImmersedBoundaryGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Value, immersed: ImmersedBoundaryCondition; └── data: 1×1×38 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:35) with eltype Float64 with indices 1:1×1:1×-2:35; └── max=-0.0857023, min=-0.972122, mean=-0.393485; ```. I think `FluxBoundaryCondition` is tested here:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/test/test_boundary_conditions_integration.jl#L231-L241. (though only for `NonhydrostaticModel`)... Might make sense to build up those boundary condition integration tests for `HydrostaticFreeSurfaceModel` and also for `ValueBoundaryCondition` and `GradientBoundaryCondition`. @simone-silvestri is this broken because we are now using ""boundary-aware"" derivatives?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317
https://github.com/CliMA/Oceananigans.jl/pull/3209#issuecomment-1662919220:375,Availability,down,downsides,375,"> I think this bug allows the option to restructure the code differently and implement the `ValueBoundaryCondition` like the immersed boundary. In that way, we can get rid of the fill halo regions for value, gradient, and flux boundary conditions.; > I know this might be a bit more tedious, but I think it might pay off later. I agree that's interesting. However, there are downsides for diagnostics since you can no longer evaluate gradients on the boundary. This means, for example, that we couldn't calculate the viscous momentum flux on a no-slip boundary in a straightforward manner (though it's still possible to figure it out).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3209#issuecomment-1662919220
https://github.com/CliMA/Oceananigans.jl/pull/3209#issuecomment-1665678824:477,Availability,down,downsides,477,"> I think this bug allows the option to restructure the code differently and implement the `ValueBoundaryCondition` like the immersed boundary. In that way, we can get rid of the fill halo regions for value, gradient, and flux boundary conditions.; > I know this might be a bit more tedious, but I think it might pay off later. @simone-silvestri how about merging this now and restructuring the code in a future PR? I think we also have to decide whether we want to accept the downsides of the restructuring, so we may not be ready to implement it yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3209#issuecomment-1665678824
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168:279,Deployability,integrat,integrated,279,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168:293,Energy Efficiency,energy,energy,293,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168:279,Integrability,integrat,integrated,279,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168:81,Usability,simpl,simple,81,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672138501:53,Availability,error,error,53,"For a given time step at z=50 (surface) the rounding error in mantissa bits in the tendency addition. If red approaches 23 mantissa bits then there would be a stagnation due to rounding errors, but as long as this doesn't happen systematically it should be fine. ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/eee6d63d-c76c-4362-816d-cb931ecdb827)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672138501
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672138501:186,Availability,error,errors,186,"For a given time step at z=50 (surface) the rounding error in mantissa bits in the tendency addition. If red approaches 23 mantissa bits then there would be a stagnation due to rounding errors, but as long as this doesn't happen systematically it should be fine. ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/eee6d63d-c76c-4362-816d-cb931ecdb827)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672138501
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256:379,Energy Efficiency,power,power,379,Calculation via $$\log_2(\vert \frac{progn}{tend} \vert)$$. with $progn$ being the prognostic variable (zonal velocity above) and $tend$ being the tendency taken as two consecutive time steps from the output. It's not exactly that obv because the AB2 time stepper works a bit differently but it's probably good enough! So this quantity is essentially the orders of magnitude (as power of 2) that the prognostic variables are larger than the tendencies. This is equivalent to the mantissa bits of precision lost in the addition of the two.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256:94,Modifiability,variab,variable,94,Calculation via $$\log_2(\vert \frac{progn}{tend} \vert)$$. with $progn$ being the prognostic variable (zonal velocity above) and $tend$ being the tendency taken as two consecutive time steps from the output. It's not exactly that obv because the AB2 time stepper works a bit differently but it's probably good enough! So this quantity is essentially the orders of magnitude (as power of 2) that the prognostic variables are larger than the tendencies. This is equivalent to the mantissa bits of precision lost in the addition of the two.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256:411,Modifiability,variab,variables,411,Calculation via $$\log_2(\vert \frac{progn}{tend} \vert)$$. with $progn$ being the prognostic variable (zonal velocity above) and $tend$ being the tendency taken as two consecutive time steps from the output. It's not exactly that obv because the AB2 time stepper works a bit differently but it's probably good enough! So this quantity is essentially the orders of magnitude (as power of 2) that the prognostic variables are larger than the tendencies. This is equivalent to the mantissa bits of precision lost in the addition of the two.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672187417:47,Availability,avail,available,47,"Now also with resting potential energy RPE and available potential energy APE. ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/616360e4-b61b-48c2-80ca-684311f73802). Float32 is more jaggedy, I reckon it's gravity waves that affect buoyancy? But note that there's no obvious bias otherwise. Which may explain why APE decreases less fast as with Float32 too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672187417
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672187417:32,Energy Efficiency,energy,energy,32,"Now also with resting potential energy RPE and available potential energy APE. ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/616360e4-b61b-48c2-80ca-684311f73802). Float32 is more jaggedy, I reckon it's gravity waves that affect buoyancy? But note that there's no obvious bias otherwise. Which may explain why APE decreases less fast as with Float32 too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672187417
https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672187417:67,Energy Efficiency,energy,energy,67,"Now also with resting potential energy RPE and available potential energy APE. ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/616360e4-b61b-48c2-80ca-684311f73802). Float32 is more jaggedy, I reckon it's gravity waves that affect buoyancy? But note that there's no obvious bias otherwise. Which may explain why APE decreases less fast as with Float32 too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672187417
https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894:773,Performance,optimiz,optimization,773,"> `2)` is because I cannot think of a situation where you would want to output something different than Array? But please correct me if I'm wrong. I haven't found another example in this repository. We chose `array_type` to permit the flexibility of other array types. I don't know enough to say that we would _never_ want another array type. Better to be defensive than aggressively constraining user action?. `Float32` used to be the default. However, this produced a lot of pain in some testing situations where we wanted to show bitwise reproducability / accuracy in saving. I can't remember all the details, but after a few user issues (in addition to our own pain), we decided to switch to Float64. I agree that Float32 is better, but could be regarded as ""premature optimization"" in this case. Definitely open to discuss though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894
https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894:490,Testability,test,testing,490,"> `2)` is because I cannot think of a situation where you would want to output something different than Array? But please correct me if I'm wrong. I haven't found another example in this repository. We chose `array_type` to permit the flexibility of other array types. I don't know enough to say that we would _never_ want another array type. Better to be defensive than aggressively constraining user action?. `Float32` used to be the default. However, this produced a lot of pain in some testing situations where we wanted to show bitwise reproducability / accuracy in saving. I can't remember all the details, but after a few user issues (in addition to our own pain), we decided to switch to Float64. I agree that Float32 is better, but could be regarded as ""premature optimization"" in this case. Definitely open to discuss though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894
https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679437354:558,Testability,test,test,558,"> I would need to know the details, but technically bitwise reproducibility is _easier_ with Float32 if you compute in Float64 because you throw away 29 bits that could be different. In practice, however, I don't see a difference between Float32/64 regarding this or accuracy. Both are way too precise for what we're doing anyway?. It's not actually a question of easy vs hard, its a question of whether you need output in `Float64` for `a == b` to return `true`. If you forget that the default is `Float32` then `a` won't exactly equal `b` for this sort of test. But you might think there's a bug in the output writers or your own code before you realize that it's just because you need `Float64` for this particular kind of check. I think one example was computing an average on the fly, versus computing it in post-processing by averaging the output?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679437354
https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679450417:112,Testability,test,test,112,"Might've been this one:. https://github.com/CliMA/Oceananigans.jl/blob/fa5e280115f619d01a460f012328bd7e6d253b38/test/test_netcdf_output_writer.jl#L552. But there were also some user issues which lead us to believe it wasn't just about making sure the tests were good, as a recall. We can still take an opinionated stance that this is an important enough issue that it's worth some temporary user confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679450417
https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679450417:251,Testability,test,tests,251,"Might've been this one:. https://github.com/CliMA/Oceananigans.jl/blob/fa5e280115f619d01a460f012328bd7e6d253b38/test/test_netcdf_output_writer.jl#L552. But there were also some user issues which lead us to believe it wasn't just about making sure the tests were good, as a recall. We can still take an opinionated stance that this is an important enough issue that it's worth some temporary user confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679450417
https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1809461325:15,Availability,ping,ping,15,Thanks for the ping. I want to tackle this week after I submitted the JOSS paper!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1809461325
https://github.com/CliMA/Oceananigans.jl/pull/3215#issuecomment-1688662028:70,Deployability,release,release,70,I guess this breaks the advective forcing API so does it need a minor release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3215#issuecomment-1688662028
https://github.com/CliMA/Oceananigans.jl/pull/3215#issuecomment-1690031565:11,Testability,test,tests,11,Merge when tests pass?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3215#issuecomment-1690031565
https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856:1168,Availability,down,down,1168,"1bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) you pointed out the tracer-`CenterField` had its values filled via `set!` with an anonymous function:. https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L152. The above does not fill any values in the halo regions! On the other hand, you were filling values for the `XFaceField` using a `for`-loop that was looping in the halo regions as well... https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L193-L198. So this might be one reason for why the plots look different? I am not quite sure because the plots also don't include color bars so I'm not sure if the disagreement is a plotting issue or a combination of plotting + a bug. But let's strip down the script to the bare minimum showcasing the problem -- at the moment the script has a lot of if statements and seems to be used for many things, not just to showcase the issue discussed here. For example, running this ; ```julia; using Oceananigans; using Oceananigans.MultiRegion: getregion. grid = ConformalCubedSphereGrid(panel_size=(4 ,4, 1), z=(-1, 0), radius=1). u = XFaceField(grid); v = YFaceField(grid); c = CenterField(grid). set!(c, (λ, φ, z) -> φ); set!(u, (λ, φ, z) -> φ); set!(v, (λ, φ, z) -> φ). @info ""u values""; display(rotl90(view(getregion(u, 1).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, 1).data, :, :, 1))). @info ""c values""; display(rotl90(view(getregion(c, 1).data, :, :, 1))); ```. gives. ```Julia; [ Info: u values; 6×6 OffsetArray(::Matrix{Float64}, 0:5, 0:5) with eltype Float64 with indices 0:5×0:5:; 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 29.5018 32.0568 34.1162 32.0568 0.0; 0.0 10.7341 11.1836 11.6116 11.1836 0.0; 0.0 -10.7341 -11.1836 -11.6116 -11.1836 0.0; 0.0 -29.5018 -32.0568 -34.1162 -32.0568 0.0; 0.0 0.0 0.0 0.0 0.0 0.0; [ Info:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856
https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856:287,Security,validat,validation,287,"@siddharthabishnu can you post perhaps a shorter MWE-type code snippet that showcases this issue, e.g., for a `CenterField` and `XFaceField`?. After some investigation, I noticed that in the [script](https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) you pointed out the tracer-`CenterField` had its values filled via `set!` with an anonymous function:. https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L152. The above does not fill any values in the halo regions! On the other hand, you were filling values for the `XFaceField` using a `for`-loop that was looping in the halo regions as well... https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L193-L198. So this might be one reason for why the plots look different? I am not quite sure because the plots also don't include color bars so I'm not sure if the disagreement is a plotting issue or a combination of plotting + a bug. But let's strip down the script to the bare minimum showcasing the problem -- at the moment the script has a lot of if statements and seems to be used for many things, not just to showcase the issue discussed here. For example, running this ; ```julia; using Oceananigans; using Oceananigans.MultiRegion: getregion. grid = ConformalCubedSphereGrid(panel_size=(4 ,4, 1), z=(-1, 0), radius=1). u = XFaceField(grid); v = YFaceField(grid); c = CenterField(grid). set!(c, (λ, φ, z) -> φ); set!(u, (λ, φ, z) -> φ); set!(v, (λ, φ, z) -> φ). @info ""u values""; display(rotl90(view(getregion(u, 1).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, 1).data, :, :, 1))). @info ""c values""; display(rotl90(view(getregion(c, 1).data, :, :, 1))); ```. gives. ```Julia; [ Info: u values; 6×6 OffsetArray(::Matrix{Float64}, 0:5, 0:5) with eltype Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856
https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856:531,Security,validat,validation,531,"@siddharthabishnu can you post perhaps a shorter MWE-type code snippet that showcases this issue, e.g., for a `CenterField` and `XFaceField`?. After some investigation, I noticed that in the [script](https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) you pointed out the tracer-`CenterField` had its values filled via `set!` with an anonymous function:. https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L152. The above does not fill any values in the halo regions! On the other hand, you were filling values for the `XFaceField` using a `for`-loop that was looping in the halo regions as well... https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L193-L198. So this might be one reason for why the plots look different? I am not quite sure because the plots also don't include color bars so I'm not sure if the disagreement is a plotting issue or a combination of plotting + a bug. But let's strip down the script to the bare minimum showcasing the problem -- at the moment the script has a lot of if statements and seems to be used for many things, not just to showcase the issue discussed here. For example, running this ; ```julia; using Oceananigans; using Oceananigans.MultiRegion: getregion. grid = ConformalCubedSphereGrid(panel_size=(4 ,4, 1), z=(-1, 0), radius=1). u = XFaceField(grid); v = YFaceField(grid); c = CenterField(grid). set!(c, (λ, φ, z) -> φ); set!(u, (λ, φ, z) -> φ); set!(v, (λ, φ, z) -> φ). @info ""u values""; display(rotl90(view(getregion(u, 1).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, 1).data, :, :, 1))). @info ""c values""; display(rotl90(view(getregion(c, 1).data, :, :, 1))); ```. gives. ```Julia; [ Info: u values; 6×6 OffsetArray(::Matrix{Float64}, 0:5, 0:5) with eltype Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856
https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856:864,Security,validat,validation,864,"@siddharthabishnu can you post perhaps a shorter MWE-type code snippet that showcases this issue, e.g., for a `CenterField` and `XFaceField`?. After some investigation, I noticed that in the [script](https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) you pointed out the tracer-`CenterField` had its values filled via `set!` with an anonymous function:. https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L152. The above does not fill any values in the halo regions! On the other hand, you were filling values for the `XFaceField` using a `for`-loop that was looping in the halo regions as well... https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L193-L198. So this might be one reason for why the plots look different? I am not quite sure because the plots also don't include color bars so I'm not sure if the disagreement is a plotting issue or a combination of plotting + a bug. But let's strip down the script to the bare minimum showcasing the problem -- at the moment the script has a lot of if statements and seems to be used for many things, not just to showcase the issue discussed here. For example, running this ; ```julia; using Oceananigans; using Oceananigans.MultiRegion: getregion. grid = ConformalCubedSphereGrid(panel_size=(4 ,4, 1), z=(-1, 0), radius=1). u = XFaceField(grid); v = YFaceField(grid); c = CenterField(grid). set!(c, (λ, φ, z) -> φ); set!(u, (λ, φ, z) -> φ); set!(v, (λ, φ, z) -> φ). @info ""u values""; display(rotl90(view(getregion(u, 1).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, 1).data, :, :, 1))). @info ""c values""; display(rotl90(view(getregion(c, 1).data, :, :, 1))); ```. gives. ```Julia; [ Info: u values; 6×6 OffsetArray(::Matrix{Float64}, 0:5, 0:5) with eltype Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856
https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689366850:1982,Security,validat,validation,1982,"(rotl90(view(getregion(u, region).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, region).data, :, :, 1))). # Plotting longitude values using λnodes. Hx, Hy, Hz = grid.Hx, grid.Hy, grid.Hz. for region in 1:6; ; for i in 1-Hx:Nx+Hx, j in 1-Hy:Ny+Hy; getregion(c, region).data[i, j, 1] = λnodes(getregion(grid, region), Center(), Center(), Center(); ; with_halos=true)[i, j, 1]; getregion(u, region).data[i, j, 1] = λnodes(getregion(grid, region), Face(), Center(), Center(); ; with_halos=true)[i, j, 1]; getregion(v, region).data[i, j, 1] = λnodes(getregion(grid, region), Center(), Face(), Center(); ; with_halos=true)[i, j, 1]; end. end. @info ""Plotting longitude values using λnodes"". @info ""c values""; display(rotl90(view(getregion(c, region).data, :, :, 1))). @info ""u values""; display(rotl90(view(getregion(u, region).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, region).data, :, :, 1))); ```. Here's the output:. ```Julia; julia> include(""validation/multi_region/multi_region_longitude.jl""); [ Info: Plotting longitude values using the set function; [ Info: c values; 7×7 OffsetArray(::Matrix{Float64}, 0:6, 0:6) with eltype Float64 with indices 0:6×0:6:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 -38.0887 -20.9234 -9.30769e-16 20.9234 38.0887 0.0; 0.0 -36.589 -18.9205 -2.33529e-15 18.9205 36.589 0.0; 0.0 -36.3047 -18.488 -3.50835e-15 18.488 36.3047 0.0; 0.0 -36.589 -18.9205 -4.68142e-15 18.9205 36.589 0.0; 0.0 -38.0887 -20.9234 -6.08594e-15 20.9234 38.0887 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; [ Info: u values; 7×7 OffsetArray(::Matrix{Float64}, 0:6, 0:6) with eltype Float64 with indices 0:6×0:6:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 -45.0 -30.1124 -10.7432 10.7432 30.1124 0.0; 0.0 -45.0 -27.9373 -9.56157 9.56157 27.9373 0.0; 0.0 -45.0 -27.4907 -9.3003 9.3003 27.4907 0.0; 0.0 -45.0 -27.9373 -9.56157 9.56157 27.9373 0.0; 0.0 -45.0 -30.1124 -10.7432 10.7432 30.1124 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; [ Info: v values; 7×7 OffsetArray(::Matrix{Float64}, 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689366850
https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689722400:241,Security,validat,validation,241,"Here are some plots of longitudes at locations cca, fca and cfa with colorbars. They can be generated by running the script [multiregion_cubed_sphere.jl](https://github.com/CliMA/Oceananigans.jl/blob/623b6f5d4c230441871ac61ba55e27d379898ead/validation/multi_region/multi_region_cubed_sphere.jl) of the commit [623b6f5](https://github.com/CliMA/Oceananigans.jl/commit/623b6f5d4c230441871ac61ba55e27d379898ead) of the Oceananigans branch [sb-ncc-ss/cubed-sphere-tracer-advection](https://github.com/CliMA/Oceananigans.jl/tree/sb-ncc-ss/cubed-sphere-tracer-advection) with the specification test_multi_region_cubed_sphere_plots = true. Since these plots look fine to me, I guess the unusual nature of the previous plots can be attributed to a plotting artifact. So, I may be back to square one. . Using set! at location cca; ![longitude_panel_wise_visualization_c_set](https://github.com/CliMA/Oceananigans.jl/assets/12926768/3733da53-dde3-4ce2-9960-c0530d322ba3); Using λnodes at location cca; ![longitude_panel_wise_visualization_u_nodes](https://github.com/CliMA/Oceananigans.jl/assets/12926768/dbd1c4e3-506c-4a2e-b0af-b6a626205784). Using set! at location fca; ![longitude_panel_wise_visualization_u_set](https://github.com/CliMA/Oceananigans.jl/assets/12926768/66c57a6a-81e7-44af-a662-f0c4cc986783); Using λnodes at location fca; ![longitude_panel_wise_visualization_v_nodes](https://github.com/CliMA/Oceananigans.jl/assets/12926768/c6066339-af84-4ca7-a547-e98de9627ffc). Using set! at location cfa; ![longitude_panel_wise_visualization_v_set](https://github.com/CliMA/Oceananigans.jl/assets/12926768/e86ec39d-799a-4891-ad65-b436037e0c4c); Using λnodes at location cfa; ![longitude_panel_wise_visualization_c_nodes](https://github.com/CliMA/Oceananigans.jl/assets/12926768/7920da3c-96b9-41fc-bbab-14daa5665d90)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689722400
https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1723710908:285,Usability,undo,undo,285,@siddharthabishnu this PR changes 73 files at the moment. Are you sure this is intentional?. A lot of commits seem to have happened between _this post_ and my previous post. But they are mostly things already merged in main? But this PR seems to re-introduce the changes and sometimes undo them?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1723710908
https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1724393955:50,Safety,safe,safe,50,"@glwagner, there isn't much code in it. So, it is safe to close this PR and delete the associated branch. I will proceed with that. @navid, after some digging, I discovered that my default git pull command was set to git rebase instead of git merge following git fetch. This altered the commit history to linearize it, causing confusion in both my previous tracer advection branch and the one associated with this PR. I have now reset the default setting. My apologies for the oversight.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1724393955
https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1724412295:293,Usability,undo,undo,293,> @siddharthabishnu this PR changes 73 files at the moment. Are you sure this is intentional?; > ; > A lot of commits seem to have happened between _this post_ and my previous post. But they are mostly things already merged in main? But this PR seems to re-introduce the changes and sometimes undo them?. Please see my response above.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1724412295
https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1724858256:196,Deployability,update,update,196,"> The longitude plots look better, and once I gain confidence in their accuracy, I will proceed to close issue #3217. You mean with the latest `#main` they look better? Better or perfect? Can you update the issue #3217?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1724858256
https://github.com/CliMA/Oceananigans.jl/pull/3223#issuecomment-1688509460:17,Testability,test,tests,17,We'll merge once tests pass,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3223#issuecomment-1688509460
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689059208:672,Usability,Usab,Usability,672,"Hmm yes, the halo regions are essentially never filled by default. During time-stepping they are filled at the conclusion of a time-step within `update_state!`. But offline, you'll generally have to manually call `fill_halo_regions!`... For offline diagnostics, a better approach for the horizontal convection example is to save halo regions using `with_halos=true` when building the output writer, I think. We've discussed making `with_halos = true` the default. The problem is that having halo regions is inconvenient for people who do not use `FieldTimeSeries`. So this is a trade-off; we can favor the users who prefer `FieldTimeSeries` by making `with_halos = true`. Usability suggestions like places where we should fill halo regions by default are also welcome! We have debated adding that to `set!` for example, but @simone-silvestri has pointed out that for very large, distributed problems, one needs to be cautious about calling `fill_halo_regions!` as it triggers communication. But for applications which are guaranteed to only involve post-processing, I don't think this is an issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689059208
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689073910:644,Usability,intuit,intuitive,644,"> a better approach for the horizontal convection example is to save halo regions using `with_halos=true` when building the output writer. Maybe I am misunderstanding you, but isn't that already what is done in the horizontal convection example?; https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/examples/horizontal_convection.jl#L153-L157. It seems like this is indeed saving grids with halos, but erroneously filling them with zeros rather than the correct values? Is the intended behavior that output writers automatically call `fill_halo_region!` before saving when `with_halos=true`? That would be an intuitive enough API, even if the default was still `with_halos=false`, but I think separate from this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689073910
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689838510:1333,Performance,load,loaded,1333,">Maybe I am misunderstanding you, but isn't that already what is done in the horizontal convection example?. No, you are understanding me! I think you're on to something. > Is the intended behavior that output writers automatically call fill_halo_region! before saving when with_halos=true?. Ah no this is not default. However, for prognostic fields, the halos are filled within `update_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl#L24C1-L24C1. However, halos are not filled for diagnostic fields. We probably don't want to make filling halos default, since filling halo regions is expensive and useful only for a subset of experiments. However, we could add a keyword argument to `JLD2OutputWriter`, something like `fill_halos = true`. (Thinking about this with a little more coffee, it probably doesn't make sense to add something like this, because generally speaking the halo values for diagnostic fields are not useful except for periodic boundary conditions; only prognostic fields can have specified / meaningful boundary conditions.). I wonder if this is a bug in `FieldTimeSeries`. Are you using `FieldTimeSeries` to compute the diagnostics offline? Perhaps the halo data is saved correctly, but is not loaded correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689838510
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689894462:672,Energy Efficiency,schedul,schedule,672,"This illustrates the bug (slightly overpowered, because I was trying to figure out what's going wrong):. ```julia; using Oceananigans; using GLMakie. grid = RectilinearGrid(size=3, halo=3, z=(0, 1), topology=(Flat, Flat, Bounded)). c_bottom_bc = ValueBoundaryCondition(1); c_bcs = FieldBoundaryConditions(bottom=c_bottom_bc); closure = ScalarDiffusivity(κ=1). model = HydrostaticFreeSurfaceModel(; grid, closure,; tracers = :c,; buoyancy = nothing,; boundary_conditions=(; c=c_bcs)). simulation = Simulation(model, Δt=1e-2, stop_iteration=100). filename = ""simple_tracer_output_test.jld2""; simulation.output_writers[:c] = JLD2OutputWriter(model, model.tracers; filename,; schedule = IterationInterval(1),; overwrite_existing = true,; with_halos = true). # Evaluate c on boundary; using Oceananigans.Operators: ℑzᵃᵃᶠ. function show_boundary_c(sim); c = sim.model.tracers.c; cb = ℑzᵃᵃᶠ(1, 1, 1, grid, c); @info string(""Iter: "", iteration(sim), "", c(z=0): "", cb); return nothing; end. simulation.callbacks[:show] = Callback(show_boundary_c). run!(simulation). ct = FieldTimeSeries(filename, ""c""). t = ct.times; grid = ct.grid; Nt = length(t); cb = zeros(Nt); for n = 1:Nt; cn = ct[n]; cb[n] = ℑzᵃᵃᶠ(1, 1, 1, grid, cn); end. fig = Figure(); ax = Axis(fig[1, 1], xlabel=""Iteration"", ylabel=""c""); lines!(ax, ct[1, 1, 0, :], label=""c[0]""); lines!(ax, cb, label=""c(z=0)""); lines!(ax, ct[1, 1, 1, :], label=""c[1]""); axislegend(ax); display(fig); ```. giving. <img width=""396"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/f9d97246-0cc1-4185-a346-590a0f7357f1"">. yellow is `c` interpolated to the boundary --- which should be 1 always (as the `show_boundary_c` illustrates is true online). the blue is the halo value, which should not be 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689894462
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689901112:430,Performance,perform,performance,430,"As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689901112
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689906410:701,Availability,down,down,701,"Inspecting the file manually shows that the data is indeed correct in there, so the problem appears to be with `FieldTimeSeries`:. ```julia; julia> using JLD2. julia> file = jldopen(filename); JLDFile /Users/gregorywagner/Desktop/simple_tracer_output_test.jld2 (read-only); ├─📂 grid; │ ├─🔢 Nx; │ ├─🔢 Ny; │ ├─🔢 Nz; │ ├─🔢 Hx; │ ├─🔢 Hy; │ ├─🔢 Hz; │ ├─🔢 Lx; │ └─ ⋯ (14 more entries); └─ ⋯ (3 more entries). julia> c_data = file[""timeseries/c/0""][:]; 9-element Vector{Float64}:; 0.0; 0.0; 2.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0. julia> c_data = file[""timeseries/c/1""][:]; 9-element Vector{Float64}:; 0.0; 0.0; 1.82; 0.18; 0.0; 0.0; 0.0; 0.0; 0.0; ```. The halo value across the bottom boundary is the third one down from the top. At iteration 0, it's value is 2 (so that interpolating between 0 and 2 returns 1). At iteration 1 it's value is 1.82, showing that it is changing correctly in time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689906410
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675:8,Performance,load,loaded,8,Data is loaded into `FieldTimeSeries` by. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L146. which calls. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L200-L205. The data seems to be loaded into the intermediate `Field`:. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L237. so the problem may be. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L205. Voila... https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/Fields/set!.jl#L43-L55,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675:345,Performance,load,loaded,345,Data is loaded into `FieldTimeSeries` by. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L146. which calls. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L200-L205. The data seems to be loaded into the intermediate `Field`:. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L237. so the problem may be. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L205. Voila... https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/Fields/set!.jl#L43-L55,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113:598,Availability,down,down,598,"> As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models). I agree, but this patch-up will not work for immersed boundaries anyway. I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113:497,Deployability,patch,patch-up,497,"> As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models). I agree, but this patch-up will not work for immersed boundaries anyway. I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113:432,Performance,perform,performance,432,"> As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models). I agree, but this patch-up will not work for immersed boundaries anyway. I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689980077:94,Usability,clear,clear,94,"> I am actually not even sure that it would be possible to do easily in this case. Just to be clear, this is just for offline diagnostics, right? Online diagnostic operations on prognostic fields still correctly feel the boundary conditions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689980077
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:643,Availability,down,down,643,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:506,Deployability,patch,patch-up,506,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:584,Deployability,patch,patch-up,584,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:935,Modifiability,refactor,refactor,935,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:434,Performance,perform,performance,434,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690236897:845,Integrability,interface,interface,845,"I think to support inserting `Value` or `Gradient` directly into abstract operations would essentially entail an independent implementation from the current `AbstractOperation`, because while this is certainly feasible on the CPU, I suspect we will run into limitations on the GPU fairly quickly. I think if people are interested in direct numerical simulation in complex domains that would benefit from that kind of thing then this is a worthwhile endeavor and could even be prototyped in an independent repository (magic of Julia). Supporting correct boundary evaluation for non-immersed boundaries is straightforward via rules for filling halo regions. Thus despite the trade-offs, it makes sense to provide such a ""bonus"" feature: it's enabling for quite a few applications without a great cost (at least _yet_, because we don't have a user interface or great support for distributed computations). Support for operations across immersed boundaries is a more complex endeavor. Thus because I do not think we should regard Value / Gradient boundary conditions as a ""core"" feature (this package is oriented towards ocean modeling from large eddy simulation up to global scales --- direct numerical simulation is not our core application) the trade-off points towards not supporting this. Especially due to finite resources for software development, many of our decisions are compromises. We don't aim to be perfect, we aim to be good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690236897
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690256956:915,Modifiability,refactor,refactor,915,"> Thus because I do not think we should regard Value / Gradient boundary conditions as a ""core"" feature (this package is oriented towards ocean modeling from large eddy simulation up to global scales --- direct numerical simulation is not our core application) the trade-off points towards not supporting this. Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on **non-immersed** boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. I can't really conceive of any reasons why one would want Value / Gradient BCs on the immersed boundary though, and agree it is not alone worth a major refactor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690256956
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:882,Integrability,mediat,mediated,882,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:948,Modifiability,parameteriz,parameterization,948,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:1209,Modifiability,parameteriz,parameterization-derived,1209,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:596,Performance,perform,performance,596,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452
https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:1288,Safety,predict,predict,1288,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452
https://github.com/CliMA/Oceananigans.jl/pull/3225#issuecomment-1689951611:13,Testability,test,test,13,PS there's a test now,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3225#issuecomment-1689951611
https://github.com/CliMA/Oceananigans.jl/pull/3225#issuecomment-1689958017:92,Availability,robust,robust,92,"Note: we probably need more tests for `FieldTimeSeries` specifically as well to ensure more robust behavior. These are a little more annoying to design though, I will leave for the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3225#issuecomment-1689958017
https://github.com/CliMA/Oceananigans.jl/pull/3225#issuecomment-1689958017:28,Testability,test,tests,28,"Note: we probably need more tests for `FieldTimeSeries` specifically as well to ensure more robust behavior. These are a little more annoying to design though, I will leave for the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3225#issuecomment-1689958017
https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:80,Integrability,interface,interface,80,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122
https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:131,Modifiability,extend,extend,131,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122
https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:124,Usability,simpl,simply,124,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122
https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690271165:1,Testability,log,loganpknudsen,1,@loganpknudsen can you see if https://github.com/CliMA/Oceananigans.jl/pull/3228 gives you what you need?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690271165
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:45,Availability,error,error,45,"@simone-silvestri is this what's causing the error seem in the Oceanostics CI?: https://github.com/tomchor/Oceanostics.jl/pull/151. The error is. ```; ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/RnhUQ/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 10 times); @ ./tuple.jl:414 [inlined]; [4] _findfirst_rec(f::typeof(Oceananigans.Utils.isregional), i::Int64, t::Tuple{Tuple{DataType, DataType, DataType}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:136,Availability,error,error,136,"@simone-silvestri is this what's causing the error seem in the Oceanostics CI?: https://github.com/tomchor/Oceanostics.jl/pull/151. The error is. ```; ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/RnhUQ/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 10 times); @ ./tuple.jl:414 [inlined]; [4] _findfirst_rec(f::typeof(Oceananigans.Utils.isregional), i::Int64, t::Tuple{Tuple{DataType, DataType, DataType}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31098,Availability,Error,Error,31098,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31147,Availability,ERROR,ERROR,31147,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31213,Availability,error,errored,31213,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31329,Availability,ERROR,ERROR,31329,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31367,Availability,error,errored,31367,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31154,Performance,Load,LoadError,31154,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31336,Performance,Load,LoadError,31336,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:30419,Testability,test,test,30419,"ananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we re",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:30502,Testability,test,test,30502,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:30619,Testability,Test,Test,30619,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:30628,Testability,Test,Test,30628,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:30713,Testability,test,test,30713,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31077,Testability,Test,Test,31077,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31170,Testability,test,tests,31170,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31307,Testability,test,test,31307,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31382,Testability,test,testing,31382,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1738363833:1,Testability,log,loganpknudsen,1,"@loganpknudsen, does this address your issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1738363833
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:155,Availability,error,error,155,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:578,Availability,ERROR,ERROR,578,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:603,Availability,error,error,603,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:636,Availability,error,error,636,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:718,Availability,error,errorhandling,718,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:30922,Energy Efficiency,schedul,schedule,30922,"itions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.identity3), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; [6] top-level scope; @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:585,Performance,Load,LoadError,585,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:85,Testability,test,tested,85,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:308,Testability,log,loganknudsen,308,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:336,Testability,log,loganknudsen,336,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:31439,Testability,log,loganknudsen,31439,"itions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.identity3), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; [6] top-level scope; @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:157,Availability,error,error,157,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:594,Availability,ERROR,ERROR,594,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:619,Availability,error,error,619,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:652,Availability,error,error,652,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:740,Availability,error,errorhandling,740,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:31572,Availability,error,error,31572,", Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); > @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; > [6] top-level scope; > @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > ```. Huh, that error seems unrelated but I'm not sure. In particular, it looks like you cannot create a netcdf file in the first place (this takes place before any code is executed that has to do specifically with this PR). Does your code work on `main`? You could also try using `JLD2OutputWriter` to see if you still get an error. It also could help to see what code you're running. PS I changed you single ticks ""`"" to block ticks ""```"" to make your message more readable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:31883,Availability,error,error,31883,", Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); > @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; > [6] top-level scope; > @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > ```. Huh, that error seems unrelated but I'm not sure. In particular, it looks like you cannot create a netcdf file in the first place (this takes place before any code is executed that has to do specifically with this PR). Does your code work on `main`? You could also try using `JLD2OutputWriter` to see if you still get an error. It also could help to see what code you're running. PS I changed you single ticks ""`"" to block ticks ""```"" to make your message more readable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:30958,Energy Efficiency,schedul,schedule,30958,", Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); > @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; > [6] top-level scope; > @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > ```. Huh, that error seems unrelated but I'm not sure. In particular, it looks like you cannot create a netcdf file in the first place (this takes place before any code is executed that has to do specifically with this PR). Does your code work on `main`? You could also try using `JLD2OutputWriter` to see if you still get an error. It also could help to see what code you're running. PS I changed you single ticks ""`"" to block ticks ""```"" to make your message more readable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:32010,Integrability,message,message,32010,", Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); > @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; > [6] top-level scope; > @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > ```. Huh, that error seems unrelated but I'm not sure. In particular, it looks like you cannot create a netcdf file in the first place (this takes place before any code is executed that has to do specifically with this PR). Does your code work on `main`? You could also try using `JLD2OutputWriter` to see if you still get an error. It also could help to see what code you're running. PS I changed you single ticks ""`"" to block ticks ""```"" to make your message more readable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:601,Performance,Load,LoadError,601,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:87,Testability,test,tested,87,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:318,Testability,log,loganknudsen,318,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:346,Testability,log,loganknudsen,346,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:31483,Testability,log,loganknudsen,31483,", Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); > @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; > [6] top-level scope; > @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > ```. Huh, that error seems unrelated but I'm not sure. In particular, it looks like you cannot create a netcdf file in the first place (this takes place before any code is executed that has to do specifically with this PR). Does your code work on `main`? You could also try using `JLD2OutputWriter` to see if you still get an error. It also could help to see what code you're running. PS I changed you single ticks ""`"" to block ticks ""```"" to make your message more readable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347:21,Availability,error,error,21,"It's common for this error to pop up when there's a file handle already open (maybe if there was an error the previous time you ran the code). @loganpknudsen if you haven't done so yet, you could close and reopen the repl before running the code again. Or/and you can delete the previously created netcdf file. Regardless, this error is likely not related to this branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347:100,Availability,error,error,100,"It's common for this error to pop up when there's a file handle already open (maybe if there was an error the previous time you ran the code). @loganpknudsen if you haven't done so yet, you could close and reopen the repl before running the code again. Or/and you can delete the previously created netcdf file. Regardless, this error is likely not related to this branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347:328,Availability,error,error,328,"It's common for this error to pop up when there's a file handle already open (maybe if there was an error the previous time you ran the code). @loganpknudsen if you haven't done so yet, you could close and reopen the repl before running the code again. Or/and you can delete the previously created netcdf file. Regardless, this error is likely not related to this branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347:144,Testability,log,loganpknudsen,144,"It's common for this error to pop up when there's a file handle already open (maybe if there was an error the previous time you ran the code). @loganpknudsen if you haven't done so yet, you could close and reopen the repl before running the code again. Or/and you can delete the previously created netcdf file. Regardless, this error is likely not related to this branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1748967572:359,Testability,log,loganpknudsen,359,"> Good news, I closed the REPL and reran the code with the following output line; > ; > ```; > output = (;u,v,w,model.tracers.b,U=model.background_fields.velocities.u,V=model.background_fields.velocities.v,B=model.background_fields.tracers.b); > ```; > ; > and it worked! Apologies again it took this long to resolve, and thank you for your help. No problem @loganpknudsen, thanks for helping out, it's greatly appreciated! And remember to use triple backticks to format code blocks!! :-D",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1748967572
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1974919655:12,Testability,test,tests,12,"I fixed the tests and also started testing that `BackgroundField`s get written correctly. @glwagner If you're okay with it, I'm gonna merge this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1974919655
https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1974919655:35,Testability,test,testing,35,"I fixed the tests and also started testing that `BackgroundField`s get written correctly. @glwagner If you're okay with it, I'm gonna merge this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1974919655
https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1703878093:353,Performance,optimiz,optimization,353,> @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed. Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1703878093
https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1708642106:362,Performance,optimiz,optimization,362,> > @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed.; > ; > Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization. @navidcy can you answer @TZTsai's question?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1708642106
https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1711066770:362,Performance,optimiz,optimization,362,> > @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed.; > ; > Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization. Sorry I missed the question!. I think in principle it could be used for the construction of the Heptadiagonal solver matrix (cc @simone-silvestri) but even for that the matrix is actually hardcoded for the particular free-surface problem. Right @simone-silvestri?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1711066770
https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519:287,Integrability,interface,interface,287,Oh no problem. I think there could even be more than one PR. First we just want to show that we can build a latitude longitude grid using OSSG. next we can test dynamics on OSSG and make sure its identical (that's a better test than just visualizing a splash). Then we can design a user interface that makes it easy to build latitdue longitude grid or any other grid on OSSG. Then we can deprecate latitude longitude grid. So there's a lot of ways to break it up. I just thought if OSSG works it'd be nice to demonstrate by running a case on lat lon grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519
https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519:156,Testability,test,test,156,Oh no problem. I think there could even be more than one PR. First we just want to show that we can build a latitude longitude grid using OSSG. next we can test dynamics on OSSG and make sure its identical (that's a better test than just visualizing a splash). Then we can design a user interface that makes it easy to build latitdue longitude grid or any other grid on OSSG. Then we can deprecate latitude longitude grid. So there's a lot of ways to break it up. I just thought if OSSG works it'd be nice to demonstrate by running a case on lat lon grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519
https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519:223,Testability,test,test,223,Oh no problem. I think there could even be more than one PR. First we just want to show that we can build a latitude longitude grid using OSSG. next we can test dynamics on OSSG and make sure its identical (that's a better test than just visualizing a splash). Then we can design a user interface that makes it easy to build latitdue longitude grid or any other grid on OSSG. Then we can deprecate latitude longitude grid. So there's a lot of ways to break it up. I just thought if OSSG works it'd be nice to demonstrate by running a case on lat lon grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519
https://github.com/CliMA/Oceananigans.jl/issues/3232#issuecomment-1692646162:32,Testability,test,test,32,"@tomchor seems we are missing a test, maybe we can identify what test we should add",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232#issuecomment-1692646162
https://github.com/CliMA/Oceananigans.jl/issues/3232#issuecomment-1692646162:65,Testability,test,test,65,"@tomchor seems we are missing a test, maybe we can identify what test we should add",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232#issuecomment-1692646162
https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533:574,Availability,ERROR,ERROR,574,"at the moment for chunked arrays the user can change with `set!`. For the above example of `fts3` which has a chunk size of 4:. ```; julia> fts3[1]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.0, min=2.0, mean=2.0. julia> fts3[7]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, 7]. julia> set!(fts3, 7:10). julia> fts3[7]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=14.0, min=14.0, mean=14.0. julia> fts3[1]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, -5]; Stacktrace:; ```. So at the moment the chunked field does not ""auto-load"". I am not sure whether it is better to autoload or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533
https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533:1142,Availability,ERROR,ERROR,1142,"at the moment for chunked arrays the user can change with `set!`. For the above example of `fts3` which has a chunk size of 4:. ```; julia> fts3[1]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.0, min=2.0, mean=2.0. julia> fts3[7]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, 7]. julia> set!(fts3, 7:10). julia> fts3[7]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=14.0, min=14.0, mean=14.0. julia> fts3[1]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, -5]; Stacktrace:; ```. So at the moment the chunked field does not ""auto-load"". I am not sure whether it is better to autoload or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533
https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533:1310,Performance,load,load,1310,"at the moment for chunked arrays the user can change with `set!`. For the above example of `fts3` which has a chunk size of 4:. ```; julia> fts3[1]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.0, min=2.0, mean=2.0. julia> fts3[7]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, 7]. julia> set!(fts3, 7:10). julia> fts3[7]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=14.0, min=14.0, mean=14.0. julia> fts3[1]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, -5]; Stacktrace:; ```. So at the moment the chunked field does not ""auto-load"". I am not sure whether it is better to autoload or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533
https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533:605,Security,access,access,605,"at the moment for chunked arrays the user can change with `set!`. For the above example of `fts3` which has a chunk size of 4:. ```; julia> fts3[1]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.0, min=2.0, mean=2.0. julia> fts3[7]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, 7]. julia> set!(fts3, 7:10). julia> fts3[7]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=14.0, min=14.0, mean=14.0. julia> fts3[1]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, -5]; Stacktrace:; ```. So at the moment the chunked field does not ""auto-load"". I am not sure whether it is better to autoload or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533
https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533:1173,Security,access,access,1173,"at the moment for chunked arrays the user can change with `set!`. For the above example of `fts3` which has a chunk size of 4:. ```; julia> fts3[1]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.0, min=2.0, mean=2.0. julia> fts3[7]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, 7]. julia> set!(fts3, 7:10). julia> fts3[7]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=14.0, min=14.0, mean=14.0. julia> fts3[1]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, -5]; Stacktrace:; ```. So at the moment the chunked field does not ""auto-load"". I am not sure whether it is better to autoload or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533
https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1753490292:35,Testability,test,tests,35,Should be ready. Maybe a couple of tests,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1753490292
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694023822:28,Testability,test,test,28,"Few TODO:. 1. Add a minimal test (probably only need one or two to start, we can build the tests up gradually if this gets adopted); 2. Brainstorm how to use this with output writers (eg `JLD2OutputWriter(model, outputs; fuse_computations=true)`) or something like that. @simone-silvestri curious what you think",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694023822
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694023822:91,Testability,test,tests,91,"Few TODO:. 1. Add a minimal test (probably only need one or two to start, we can build the tests up gradually if this gets adopted); 2. Brainstorm how to use this with output writers (eg `JLD2OutputWriter(model, outputs; fuse_computations=true)`) or something like that. @simone-silvestri curious what you think",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694023822
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694026789:46,Performance,perform,perform,46,"Oh, it looks good, it would be interesting to perform some complex operation and see if we get a speedup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694026789
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688:170,Energy Efficiency,Reduce,Reduced,170,"I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. ; We have an implementation like that for `fill_halo_regions!` here; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78. What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields. On the other hand, if defining a new type is useful for OutputWriters I am ok with it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688:538,Modifiability,extend,extend,538,"I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. ; We have an implementation like that for `fill_halo_regions!` here; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78. What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields. On the other hand, if defining a new type is useful for OutputWriters I am ok with it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036:1015,Availability,error,error,1015,"> I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. We have an implementation like that for `fill_halo_regions!` here; > ; > https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78; > ; > What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields.; > ; > On the other hand, if defining a new type is useful for OutputWriters I am ok with it. The new commit follows the suggestion of overloading the `compute!` method to apply it on a tuple of `ComputedField`. I also added a check to make sure that all these fields are `FullField`. However, I wonder whether we should throw an error when any of these fields is not a ""full field"" or we should follow the implementation of `fill_halo_regions!` to fill these regions using different methods?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036:172,Energy Efficiency,Reduce,Reduced,172,"> I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. We have an implementation like that for `fill_halo_regions!` here; > ; > https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78; > ; > What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields.; > ; > On the other hand, if defining a new type is useful for OutputWriters I am ok with it. The new commit follows the suggestion of overloading the `compute!` method to apply it on a tuple of `ComputedField`. I also added a check to make sure that all these fields are `FullField`. However, I wonder whether we should throw an error when any of these fields is not a ""full field"" or we should follow the implementation of `fill_halo_regions!` to fill these regions using different methods?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036:550,Modifiability,extend,extend,550,"> I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. We have an implementation like that for `fill_halo_regions!` here; > ; > https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78; > ; > What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields.; > ; > On the other hand, if defining a new type is useful for OutputWriters I am ok with it. The new commit follows the suggestion of overloading the `compute!` method to apply it on a tuple of `ComputedField`. I also added a check to make sure that all these fields are `FullField`. However, I wonder whether we should throw an error when any of these fields is not a ""full field"" or we should follow the implementation of `fill_halo_regions!` to fill these regions using different methods?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967:195,Performance,perform,performance,195,> The new commit follows the suggestion of overloading the compute! method to apply it on a tuple of ComputedField. Good point that we may not need an independent type (except for the very minor performance optimization of precomputing the compatibility between fields -- which probably doesn't matter),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967
https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967:207,Performance,optimiz,optimization,207,> The new commit follows the suggestion of overloading the compute! method to apply it on a tuple of ComputedField. Good point that we may not need an independent type (except for the very minor performance optimization of precomputing the compatibility between fields -- which probably doesn't matter),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967
https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1694521592:47,Testability,test,test,47,This indeed seems to fix the issue. Is there a test we can include to prevent this in the future?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1694521592
https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709330310:32,Testability,test,test,32,I am fine with having that as a test. Do you want to add it and merge?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709330310
https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709331729:34,Testability,test,test,34,> I am fine with having that as a test. Do you want to add it and merge?. Sure!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709331729
https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709338556:15,Deployability,patch,patch,15,Can I bump the patch version and release a new version?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709338556
https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709338556:33,Deployability,release,release,33,Can I bump the patch version and release a new version?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709338556
https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709385664:16,Deployability,update,update,16,Don't forget to update the title of the PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3235#issuecomment-1709385664
https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1695852941:202,Modifiability,extend,extend,202,"Well, fractional indices work, just not `DateTimes` indices. I am not super familiar with what date-times supports in terms of operations, if it supports summation and division it is straightforward to extend indexing with to `DateTimes`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1695852941
https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139:30,Integrability,interface,interface,30,"Are we ok with this as a user interface? it's a little implicit. We could alternatively use a function-based API to make things a little more obvious, something like. ```julia; fts[1, 2, 3, 4] # get 4th time-index; ```. ```julia; at_time(4, fts, 1, 2, 3) # linearly interpolate to t=4; ```. mainly i'd be worried about issues like. ```julia; fts[1, 2, 3, 4] \ne fts[1, 2, 3, 4.0]; ```. which is rather easy to confuse?. We also might be able to use syntax like. ```julia; fts[1, 2, 3, time=4]; ```. if that is performant. Or. ```julia; fts[1, 2, 3, Time(4)]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139
https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139:510,Performance,perform,performant,510,"Are we ok with this as a user interface? it's a little implicit. We could alternatively use a function-based API to make things a little more obvious, something like. ```julia; fts[1, 2, 3, 4] # get 4th time-index; ```. ```julia; at_time(4, fts, 1, 2, 3) # linearly interpolate to t=4; ```. mainly i'd be worried about issues like. ```julia; fts[1, 2, 3, 4] \ne fts[1, 2, 3, 4.0]; ```. which is rather easy to confuse?. We also might be able to use syntax like. ```julia; fts[1, 2, 3, time=4]; ```. if that is performant. Or. ```julia; fts[1, 2, 3, Time(4)]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139
https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696113759:183,Integrability,depend,depends,183,"> Out of curiosity @simone-silvestri could you check; > ; > ```julia; > fts2[1, 2, 3, 4] == fts2[1, 2, 3, 4.0]; > ```; > ; > in your example with the `.jld2` file above?. the outcome depends on whether `fts.times = [1, 2, 3, 4]` or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696113759
https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696116590:186,Availability,avail,available,186,Another way would be to pass Oceananigans' `Clock` as an index. . This might be convenient because we usually pass the `clock` to functions (such as forcing and bc) so we always have it available,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696116590
https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696124980:25,Availability,avail,available,25,We wouldn't have `Clock` available in post-processing.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696124980
https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696126523:108,Availability,avail,available,108,So I would propose a clock implementation for easy internal manipulation which calls the `at_time` function available for postprocessing,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696126523
https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696133206:472,Integrability,interface,interface,472,"> I am thinking about the ease of use in bc, for example; > ; > ```julia; > @inline time_interpolated_bc(i, j, grid, clock, fields, p) = p.time_array[i, j, 1, clock]; > ```; > ; > vs; > ; > ```julia; > @inline function time_interpolated_bc(i, j, grid, clock, fields, p) ; > time = Time(clock); > return p.time_array[i, j, 1, time]; > end; > ```; > ; > I find the first implementation a bit more straightforward, but we can also have both. I propose we prioritize the user interface rather than the source code implementation, which basically has to be written once then left alone",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696133206
https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696136206:280,Energy Efficiency,power,powerful,280,"also worth checking out . https://github.com/rafaqz/DimensionalData.jl. the `Time` object is a ""selector"" in their terminology. IF we have something similar here, we could eventually consider sub typing `AbstractDimArray` (which has been proposed before), which gives us a lot of powerful functionality. Someone passionate about that stuff has to take that on for a full implementation but at least we are consistent with it, which helps",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696136206
https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1694660034:31,Testability,test,test,31,Not sure why the matrix solver test failed,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1694660034
https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1695671775:73,Testability,test,test,73,I'm ok with removing `Function` here by the way. I don't think we need a test for it --- those tests are in Julia Base (ie we don't need to test that callable objects are possible). Why is `<:Function` there anyways?. The only thing I can think of is that users have to subtype `<:Function` for this to work and maybe that makes code more legible. But it's a restriction of `StructForcing` also has to subtype something else. So I would actually be in favor of removing the `<:Forcing` restriction. Note there are many places in the code we allow this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1695671775
https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1695671775:95,Testability,test,tests,95,I'm ok with removing `Function` here by the way. I don't think we need a test for it --- those tests are in Julia Base (ie we don't need to test that callable objects are possible). Why is `<:Function` there anyways?. The only thing I can think of is that users have to subtype `<:Function` for this to work and maybe that makes code more legible. But it's a restriction of `StructForcing` also has to subtype something else. So I would actually be in favor of removing the `<:Forcing` restriction. Note there are many places in the code we allow this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1695671775
https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1695671775:140,Testability,test,test,140,I'm ok with removing `Function` here by the way. I don't think we need a test for it --- those tests are in Julia Base (ie we don't need to test that callable objects are possible). Why is `<:Function` there anyways?. The only thing I can think of is that users have to subtype `<:Function` for this to work and maybe that makes code more legible. But it's a restriction of `StructForcing` also has to subtype something else. So I would actually be in favor of removing the `<:Forcing` restriction. Note there are many places in the code we allow this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1695671775
https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1697389186:75,Testability,test,test,75,> I'm ok with removing `Function` here by the way. I don't think we need a test for it --- those tests are in Julia Base (ie we don't need to test that callable objects are possible).; > ; > Why is `<:Function` there anyways?; > ; > The only thing I can think of is that users have to subtype `<:Function` for this to work and maybe that makes code more legible.; > ; > But it's a restriction of `StructForcing` also has to subtype something else. So I would actually be in favor of removing the `<:Forcing` restriction. Note there are many places in the code we allow this. Should I reopen this and remove the test then?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1697389186
https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1697389186:97,Testability,test,tests,97,> I'm ok with removing `Function` here by the way. I don't think we need a test for it --- those tests are in Julia Base (ie we don't need to test that callable objects are possible).; > ; > Why is `<:Function` there anyways?; > ; > The only thing I can think of is that users have to subtype `<:Function` for this to work and maybe that makes code more legible.; > ; > But it's a restriction of `StructForcing` also has to subtype something else. So I would actually be in favor of removing the `<:Forcing` restriction. Note there are many places in the code we allow this. Should I reopen this and remove the test then?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1697389186
https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1697389186:142,Testability,test,test,142,> I'm ok with removing `Function` here by the way. I don't think we need a test for it --- those tests are in Julia Base (ie we don't need to test that callable objects are possible).; > ; > Why is `<:Function` there anyways?; > ; > The only thing I can think of is that users have to subtype `<:Function` for this to work and maybe that makes code more legible.; > ; > But it's a restriction of `StructForcing` also has to subtype something else. So I would actually be in favor of removing the `<:Forcing` restriction. Note there are many places in the code we allow this. Should I reopen this and remove the test then?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1697389186
https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1697389186:611,Testability,test,test,611,> I'm ok with removing `Function` here by the way. I don't think we need a test for it --- those tests are in Julia Base (ie we don't need to test that callable objects are possible).; > ; > Why is `<:Function` there anyways?; > ; > The only thing I can think of is that users have to subtype `<:Function` for this to work and maybe that makes code more legible.; > ; > But it's a restriction of `StructForcing` also has to subtype something else. So I would actually be in favor of removing the `<:Forcing` restriction. Note there are many places in the code we allow this. Should I reopen this and remove the test then?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237#issuecomment-1697389186
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:860,Energy Efficiency,allocate,allocate,860,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:12,Integrability,interface,interface,12,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:58,Modifiability,refactor,refactor,58,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:441,Modifiability,variab,variable,441,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:563,Usability,feedback,feedback,563,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695628026:43,Modifiability,refactor,refactor,43,"(@simone-silvestri, until we implement the refactor and/or changes, what's the best way forward using v0.87.1?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695628026
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:38,Energy Efficiency,adapt,adaptive,38,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:350,Energy Efficiency,adapt,adapt,350,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:38,Modifiability,adapt,adaptive,38,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:229,Modifiability,refactor,refactor,229,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450
https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:350,Modifiability,adapt,adapt,350,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450
https://github.com/CliMA/Oceananigans.jl/pull/3239#issuecomment-1711319187:575,Energy Efficiency,green,green,575,"@simone-silvestri I plot here how the metric look for a series of overlapping conformal cubed sphere panels constructed with this PR. ```Julia; using Oceananigans; using Oceananigans.Grids; using Oceananigans.MultiRegion: getregion; using GLMakie. Nx, Ny = 8, 8; H = 4. range_with_offset(N, H, offset::Int) = (-H + 1 + offset*N):(N + H + offset*N). function plot_series_ossg(grid, filename); j_index = 2. fig = Figure(resolution=(2200, 600), fontsize=30); ax = Axis(fig[1, 1]); lines!(ax, range_with_offset(Nx, H, 0), parent(grid.Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:green, 0.9), label=""an ossg""); lines!(ax, range_with_offset(Nx, H, 1), parent(grid.Δxᶜᶜᵃ)[:, j_index+H], linewidth=8, color = (:red, 0.5), label=""another ossg""); lines!(ax, range_with_offset(Nx, H, 2), parent(grid.Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:blue, 0.5), label=""another ossg""); vlines!(ax, [1, Nx+1, 2Nx+1, 3Nx+1], linewidth=8, color=(:black, 0.3)); fig[1, 2] = Legend(fig, ax, framevisible = false); save(filename, fig). return fig; end. grid = conformal_cubed_sphere_panel(size=(Nx, Ny, 1), z=(-1, 0), halo=(H, H, 1)); plot_series_ossg(grid, ""metric_test_ossg_bounded.png""). grid = conformal_cubed_sphere_panel(size=(Nx, Ny, 1), z=(-1, 0), halo=(H, H, 1), topology=(Periodic, Periodic, Bounded)); plot_series_ossg(grid, ""metric_test_ossg_periodic.png""); ```. For `Bounded` topology:. ![metric_test_ossg_bounded](https://github.com/CliMA/Oceananigans.jl/assets/7112768/39ae83dd-48af-4d95-851f-840b114fac29). For `Periodic` topology:. ![metric_test_ossg_periodic](https://github.com/CliMA/Oceananigans.jl/assets/7112768/9c096c35-da0d-46cd-b9f4-fabc12eb3532). Isn't this what you were trying to imply they should look like?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3239#issuecomment-1711319187
https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697336901:40,Testability,test,test,40,"> Nice!; > ; > Should we implement this test for OrthogonalSphericalShellGrid instead, considering we are going to deprecate LatitutdeLongitudeGrid?. That's already implemented for OSSG + other similar tests. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/test/test_grids.jl#L934-L955",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697336901
https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697336901:202,Testability,test,tests,202,"> Nice!; > ; > Should we implement this test for OrthogonalSphericalShellGrid instead, considering we are going to deprecate LatitutdeLongitudeGrid?. That's already implemented for OSSG + other similar tests. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/test/test_grids.jl#L934-L955",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697336901
https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697336901:296,Testability,test,test,296,"> Nice!; > ; > Should we implement this test for OrthogonalSphericalShellGrid instead, considering we are going to deprecate LatitutdeLongitudeGrid?. That's already implemented for OSSG + other similar tests. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/test/test_grids.jl#L934-L955",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697336901
https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697337369:20,Security,validat,validation,20,I also improved the validation according to the discussion in #3241.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697337369
https://github.com/CliMA/Oceananigans.jl/issues/3241#issuecomment-1697301358:27,Security,validat,validation,27,I think the latitude range validation should occur regardless of topology... right?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241#issuecomment-1697301358
https://github.com/CliMA/Oceananigans.jl/issues/3241#issuecomment-1697308462:68,Testability,assert,assert,68,"These lines:. ```julia; φ₁, φ₂ = get_domain_extent(latitude, Nφ) ; @assert -90 <= φ₁ <= φ₂ <= 90 ; ; (φ₁ == -90 || φ₂ == 90) && ; @warn ""Are you sure you want to use a latitude-longitude grid with a grid point at the pole?"" ; ```. should be outside the if statement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241#issuecomment-1697308462
https://github.com/CliMA/Oceananigans.jl/issues/3246#issuecomment-2069797007:0,Availability,ping,pinging,0,pinging @siddharthabishnu; wondering if we should mark this issue resolved.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3246#issuecomment-2069797007
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:97,Energy Efficiency,adapt,adapt,97,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:189,Energy Efficiency,adapt,adapt,189,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:233,Energy Efficiency,adapt,adaptation,233,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:313,Integrability,wrap,wrap,313,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:97,Modifiability,adapt,adapt,97,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:189,Modifiability,adapt,adapt,189,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:233,Modifiability,adapt,adaptation,233,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:411,Availability,error,error,411,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:105,Energy Efficiency,adapt,adapt,105,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:203,Energy Efficiency,adapt,adapt,203,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:247,Energy Efficiency,adapt,adaptation,247,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:327,Integrability,wrap,wrap,327,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:105,Modifiability,adapt,adapt,105,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:203,Modifiability,adapt,adapt,203,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:247,Modifiability,adapt,adaptation,247,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394:11,Availability,error,errors,11,One of the errors is for the Stratified Couette flow validation.; But `max_change = 1.1` in ; https://github.com/iuryt/Oceananigans.jl/blob/22e2e06b4f1451c18cfd4489a8862e28faab0759/validation/stratified_couette_flow/stratified_couette_flow.jl#L245. I suggest to add in the error output which value was given by the user.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394:273,Availability,error,error,273,One of the errors is for the Stratified Couette flow validation.; But `max_change = 1.1` in ; https://github.com/iuryt/Oceananigans.jl/blob/22e2e06b4f1451c18cfd4489a8862e28faab0759/validation/stratified_couette_flow/stratified_couette_flow.jl#L245. I suggest to add in the error output which value was given by the user.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394:53,Security,validat,validation,53,One of the errors is for the Stratified Couette flow validation.; But `max_change = 1.1` in ; https://github.com/iuryt/Oceananigans.jl/blob/22e2e06b4f1451c18cfd4489a8862e28faab0759/validation/stratified_couette_flow/stratified_couette_flow.jl#L245. I suggest to add in the error output which value was given by the user.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394:181,Security,validat,validation,181,One of the errors is for the Stratified Couette flow validation.; But `max_change = 1.1` in ; https://github.com/iuryt/Oceananigans.jl/blob/22e2e06b4f1451c18cfd4489a8862e28faab0759/validation/stratified_couette_flow/stratified_couette_flow.jl#L245. I suggest to add in the error output which value was given by the user.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705752129:140,Availability,error,error,140,"How does that work for Julia?; For Python, if the user gives both `max_change<1` and `min_change>1`, this is going to give the `max_change` error only. Is it the same for Julia? If so, should we keep like this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705752129
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705753655:144,Availability,error,error,144,"> How does that work for Julia?; > For Python, if the user gives both `max_change<1` and `min_change>1`, this is going to give the `max_change` error only. Is it the same for Julia? If so, should we keep like this?. Sorry that was my bad for the error. . This. ```; a==b && foo; ```. means that `foo` will be executed only if `a==b`. See:. https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation. But to answer your question: yes lets keep it like that. User will get another error next time :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705753655
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705753655:246,Availability,error,error,246,"> How does that work for Julia?; > For Python, if the user gives both `max_change<1` and `min_change>1`, this is going to give the `max_change` error only. Is it the same for Julia? If so, should we keep like this?. Sorry that was my bad for the error. . This. ```; a==b && foo; ```. means that `foo` will be executed only if `a==b`. See:. https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation. But to answer your question: yes lets keep it like that. User will get another error next time :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705753655
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705753655:499,Availability,error,error,499,"> How does that work for Julia?; > For Python, if the user gives both `max_change<1` and `min_change>1`, this is going to give the `max_change` error only. Is it the same for Julia? If so, should we keep like this?. Sorry that was my bad for the error. . This. ```; a==b && foo; ```. means that `foo` will be executed only if `a==b`. See:. https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation. But to answer your question: yes lets keep it like that. User will get another error next time :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705753655
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705755810:136,Availability,error,error,136,"Ok. I was thinking that if, for some reason, the user giver both `max_change < 1` and `min_change > 1`, this is going to give a partial error. But well, the user can just try with a different `max_change` and then get the error for `min_change` and solve for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705755810
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705755810:222,Availability,error,error,222,"Ok. I was thinking that if, for some reason, the user giver both `max_change < 1` and `min_change > 1`, this is going to give a partial error. But well, the user can just try with a different `max_change` and then get the error for `min_change` and solve for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705755810
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1706940582:138,Availability,error,error,138,"> Ok. I was thinking that if, for some reason, the user giver both `max_change < 1` and `min_change > 1`, this is going to give a partial error. But well, the user can just try with a different `max_change` and then get the error for `min_change` and solve for both. Note this is common. If your code has many bugs, you'll typically only be able to receive errors from one at a time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1706940582
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1706940582:224,Availability,error,error,224,"> Ok. I was thinking that if, for some reason, the user giver both `max_change < 1` and `min_change > 1`, this is going to give a partial error. But well, the user can just try with a different `max_change` and then get the error for `min_change` and solve for both. Note this is common. If your code has many bugs, you'll typically only be able to receive errors from one at a time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1706940582
https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1706940582:357,Availability,error,errors,357,"> Ok. I was thinking that if, for some reason, the user giver both `max_change < 1` and `min_change > 1`, this is going to give a partial error. But well, the user can just try with a different `max_change` and then get the error for `min_change` and solve for both. Note this is common. If your code has many bugs, you'll typically only be able to receive errors from one at a time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1706940582
https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1710017077:129,Safety,avoid,avoided,129,I like kwarg because it’s more verbose. ; Is there any other reason why it should be positional?; As you said `grid=grid` can be avoided although some people like it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1710017077
https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1716901107:248,Integrability,interface,interface,248,"> Is there any other reason why it should be positional?. I guess I'm just arguing that it's not consistent with most of the API, eg we write `CenterField(grid)`. I find the position representation of required arguments to be a natural and concise interface but perhaps I shouldn't die on that hill",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1716901107
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691:140,Modifiability,evolve,evolve,140,"One thing that might be easier to ask for help with his, I wanted to print out the norm of the perturbation buoyancy in both cases. When we evolve the perturbation this is easy, but when we evolve the total field, I couldn't figure out how to do it. Do you have a recommendation? . This would be helpful to determine how the norm changes with resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691:190,Modifiability,evolve,evolve,190,"One thing that might be easier to ask for help with his, I wanted to print out the norm of the perturbation buoyancy in both cases. When we evolve the perturbation this is easy, but when we evolve the total field, I couldn't figure out how to do it. Do you have a recommendation? . This would be helpful to determine how the norm changes with resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762:155,Availability,error,error,155,"@simone-silvestri , thanks to your help I am now able to print out the norms of the perturbation buoyancy in the case when we evolve the total fields. The error that arises in this case, but not when we evolve the perturbation fields, decreases quadratically with increasing resolution. I could pick a resolution where this is small but in the first hour the norm or buoyancy grows by three orders of magnitude, which looks like an instability. It is not noisy and very well resolved, it can't be a baroclinic instability and does not look anything like an inertial instability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762:126,Modifiability,evolve,evolve,126,"@simone-silvestri , thanks to your help I am now able to print out the norms of the perturbation buoyancy in the case when we evolve the total fields. The error that arises in this case, but not when we evolve the perturbation fields, decreases quadratically with increasing resolution. I could pick a resolution where this is small but in the first hour the norm or buoyancy grows by three orders of magnitude, which looks like an instability. It is not noisy and very well resolved, it can't be a baroclinic instability and does not look anything like an inertial instability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762:203,Modifiability,evolve,evolve,203,"@simone-silvestri , thanks to your help I am now able to print out the norms of the perturbation buoyancy in the case when we evolve the total fields. The error that arises in this case, but not when we evolve the perturbation fields, decreases quadratically with increasing resolution. I could pick a resolution where this is small but in the first hour the norm or buoyancy grows by three orders of magnitude, which looks like an instability. It is not noisy and very well resolved, it can't be a baroclinic instability and does not look anything like an inertial instability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708630040:77,Deployability,continuous,continuous,77,"Is it because your initial condition is only geostrophically balanced in the continuous limit? You may need to compute the velocity field that's in discrete geostrophic balance with your initial buoyancy field. You are using analytical formula for both `U` and `B`:. ```julia; U(x, y, z) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ```. but to satisfy the discrete geostrophic balance you would have to compute one of those fields from the other one, in a manner consistent with how Coriolis forces are implemented.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708630040
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708762171:127,Availability,error,error,127,"@glwagner : I was able to get your suggestion working very easily, thanks again. Unfortuantely it doesn't help is removing the error that is introduced in the centre or the fact that it grows exponentially (I am guessing). I have looked at the pressure and it looks smooth but I suppose looking at the pertrubation pressure might be more telling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708762171
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712152144:266,Availability,error,error,266,"Thank you for the great suggestions so far. I see no problem with converting this thread to a discussion. Although the problem is not solved yet, we have done some investigation around it:; 1) Increasing the precision of the output to Float64 eliminates the initial error seen at the first few frames of the animation. 2) Using a barotropic version of the jet ; ```; U(x, y, z) = Umax / cosh(y/Lⱼ)^2; B(x, y, z) = N² * z; ```; leads to no perturbation when evolving the total fields. 3) Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712152144
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712152144:598,Availability,error,error,598,"Thank you for the great suggestions so far. I see no problem with converting this thread to a discussion. Although the problem is not solved yet, we have done some investigation around it:; 1) Increasing the precision of the output to Float64 eliminates the initial error seen at the first few frames of the animation. 2) Using a barotropic version of the jet ; ```; U(x, y, z) = Umax / cosh(y/Lⱼ)^2; B(x, y, z) = N² * z; ```; leads to no perturbation when evolving the total fields. 3) Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712152144
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487:113,Availability,error,error,113,"> Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields. Why not? When evolving the total fields, the condition of geostrophic balance is computed during the prognostic evolution of the total variables. When evolving just the perturbation, the algorithm for mean-perturbaiton decomposition _assumes_ that the mean fields are balanced. There is no need to worry about the tiny difference between discrete and continuous balance in the case that you only evolve perturbations. But if you want to evolve the geostrophically balanced state, you must ensure that it is perfectly balanced to within machine precision, or you will have an adjustment. That's the basis for my suggestion. I'm not sure the computation I recommended achieves numerical balance (something might be missing) --- that should be checked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487:515,Deployability,continuous,continuous,515,"> Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields. Why not? When evolving the total fields, the condition of geostrophic balance is computed during the prognostic evolution of the total variables. When evolving just the perturbation, the algorithm for mean-perturbaiton decomposition _assumes_ that the mean fields are balanced. There is no need to worry about the tiny difference between discrete and continuous balance in the case that you only evolve perturbations. But if you want to evolve the geostrophically balanced state, you must ensure that it is perfectly balanced to within machine precision, or you will have an adjustment. That's the basis for my suggestion. I'm not sure the computation I recommended achieves numerical balance (something might be missing) --- that should be checked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487:299,Modifiability,variab,variables,299,"> Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields. Why not? When evolving the total fields, the condition of geostrophic balance is computed during the prognostic evolution of the total variables. When evolving just the perturbation, the algorithm for mean-perturbaiton decomposition _assumes_ that the mean fields are balanced. There is no need to worry about the tiny difference between discrete and continuous balance in the case that you only evolve perturbations. But if you want to evolve the geostrophically balanced state, you must ensure that it is perfectly balanced to within machine precision, or you will have an adjustment. That's the basis for my suggestion. I'm not sure the computation I recommended achieves numerical balance (something might be missing) --- that should be checked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487:560,Modifiability,evolve,evolve,560,"> Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields. Why not? When evolving the total fields, the condition of geostrophic balance is computed during the prognostic evolution of the total variables. When evolving just the perturbation, the algorithm for mean-perturbaiton decomposition _assumes_ that the mean fields are balanced. There is no need to worry about the tiny difference between discrete and continuous balance in the case that you only evolve perturbations. But if you want to evolve the geostrophically balanced state, you must ensure that it is perfectly balanced to within machine precision, or you will have an adjustment. That's the basis for my suggestion. I'm not sure the computation I recommended achieves numerical balance (something might be missing) --- that should be checked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487:601,Modifiability,evolve,evolve,601,"> Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields. Why not? When evolving the total fields, the condition of geostrophic balance is computed during the prognostic evolution of the total variables. When evolving just the perturbation, the algorithm for mean-perturbaiton decomposition _assumes_ that the mean fields are balanced. There is no need to worry about the tiny difference between discrete and continuous balance in the case that you only evolve perturbations. But if you want to evolve the geostrophically balanced state, you must ensure that it is perfectly balanced to within machine precision, or you will have an adjustment. That's the basis for my suggestion. I'm not sure the computation I recommended achieves numerical balance (something might be missing) --- that should be checked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712197575:75,Availability,error,error,75,> Increasing the precision of the output to Float64 eliminates the initial error seen at the first few frames of the animation. I'm not sure I understand. The error is only associated with post-processing and not with the actual simulation?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712197575
https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712197575:159,Availability,error,error,159,> Increasing the precision of the output to Float64 eliminates the initial error seen at the first few frames of the animation. I'm not sure I understand. The error is only associated with post-processing and not with the actual simulation?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712197575
https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1711700565:514,Energy Efficiency,green,green,514,"```Julia; using Oceananigans; using Oceananigans.MultiRegion: getregion; using GLMakie. Nx, Ny = 5, 5; H = 3. range_with_offset(N, H, offset::Int) = (-H + 1 + offset*N):(N + H + offset*N). grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, 1), z = (0, 1), horizontal_direction_halo = H). j_index = 2; i_index = Nx+1 - j_index. fig = Figure(resolution=(2200, 600), fontsize=30); ax = Axis(fig[1, 1]); lines!(ax, range_with_offset(Nx, H, 0), parent(getregion(grid, 1).Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:green, 0.9), label=""panel 1""); lines!(ax, range_with_offset(Nx, H, 1), parent(getregion(grid, 2).Δxᶜᶜᵃ)[:, j_index+H], linewidth=8, color = (:red, 0.5), label=""panel 2""); lines!(ax, range_with_offset(Ny, H, 2), parent(getregion(grid, 4).Δyᶜᶜᵃ)[i_index+H, :], linewidth=4, color = (:blue, 0.5), label=""panel 4""); vlines!(ax, [1, Nx+1, 2Nx+1, 3Nx+1], linewidth=8, color=(:black, 0.3)); fig[1, 2] = Legend(fig, ax, framevisible = false); fig; save(""metrictest.png"", fig); ```. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/c9e2f210-a407-4e06-b3c4-0996b5ea8759). while **BEFORE THIS PR**:. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/9ed5be14-05b9-4f83-81f5-2d92def37ff5)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1711700565
https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761:251,Modifiability,rewrite,rewrite,251,I wanted to add tests but the current test functionality is difficult to adjust to work for 2D arrays. . https://github.com/CliMA/Oceananigans.jl/blob/39e9b6f3e5c5f43845f21f8e10fdd629ced448fc/test/test_multi_region_cubed_sphere.jl#L9-L62. I'd like to rewrite those to use the connectivity property of the `ConformalCubedSphereGrid` rather than a series of if statements. Also address ##3242. But I wasn't planning to do this on this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761
https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761:16,Testability,test,tests,16,I wanted to add tests but the current test functionality is difficult to adjust to work for 2D arrays. . https://github.com/CliMA/Oceananigans.jl/blob/39e9b6f3e5c5f43845f21f8e10fdd629ced448fc/test/test_multi_region_cubed_sphere.jl#L9-L62. I'd like to rewrite those to use the connectivity property of the `ConformalCubedSphereGrid` rather than a series of if statements. Also address ##3242. But I wasn't planning to do this on this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761
https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761:38,Testability,test,test,38,I wanted to add tests but the current test functionality is difficult to adjust to work for 2D arrays. . https://github.com/CliMA/Oceananigans.jl/blob/39e9b6f3e5c5f43845f21f8e10fdd629ced448fc/test/test_multi_region_cubed_sphere.jl#L9-L62. I'd like to rewrite those to use the connectivity property of the `ConformalCubedSphereGrid` rather than a series of if statements. Also address ##3242. But I wasn't planning to do this on this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761
https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761:192,Testability,test,test,192,I wanted to add tests but the current test functionality is difficult to adjust to work for 2D arrays. . https://github.com/CliMA/Oceananigans.jl/blob/39e9b6f3e5c5f43845f21f8e10fdd629ced448fc/test/test_multi_region_cubed_sphere.jl#L9-L62. I'd like to rewrite those to use the connectivity property of the `ConformalCubedSphereGrid` rather than a series of if statements. Also address ##3242. But I wasn't planning to do this on this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1712408442:26,Testability,test,test,26,"Voting ""yes"" for adding a test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1712408442
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1714613575:23,Testability,test,tests,23,Are there any existing tests @simone-silvestri @jagoosw ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1714613575
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474:80,Availability,error,error,80,"Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error. Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474:173,Availability,error,error,173,"Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error. Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474:20,Testability,test,tested,20,"Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error. Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474:47,Testability,test,tests,47,"Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error. Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474:207,Testability,test,tests,207,"Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error. Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715564474
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:82,Availability,error,error,82,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:175,Availability,error,error,175,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:429,Modifiability,extend,extend,429,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:22,Testability,test,tested,22,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:49,Testability,test,tests,49,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:216,Testability,test,tests,216,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:449,Testability,test,test,449,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715929949:24,Testability,test,test,24,"Ok @jagoosw I added the test you asked for, let me know what you think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715929949
https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1716027943:61,Testability,test,test,61,"Thanks, this looks good and I can't think of cases where the test would erroneously pass now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1716027943
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819:131,Availability,error,error,131,"When using `with_halos = true` in the `JLD2OutputWriter` works well, however in `NetCDFOutputWriter` it crashes with the following error: . ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, wall time: 0 seconds; ERROR: LoadError: DimensionMismatch: new dimensions (156, 156, 22, 1) must be consistent with array size 24336; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDataset{Nothing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/CommonDataModel/pO4st/src/cfvariable.jl:419; [6] save_output!(ds::NCDataset{…}, output::Field{…}, model::HydrostaticFreeSurfaceModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:479; [7] write_output!(ow::NetCDFOutputWriter{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:518; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/Simulations/run.jl:212; [9] time_step!(sim::Simul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819:253,Availability,ERROR,ERROR,253,"When using `with_halos = true` in the `JLD2OutputWriter` works well, however in `NetCDFOutputWriter` it crashes with the following error: . ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, wall time: 0 seconds; ERROR: LoadError: DimensionMismatch: new dimensions (156, 156, 22, 1) must be consistent with array size 24336; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDataset{Nothing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/CommonDataModel/pO4st/src/cfvariable.jl:419; [6] save_output!(ds::NCDataset{…}, output::Field{…}, model::HydrostaticFreeSurfaceModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:479; [7] write_output!(ow::NetCDFOutputWriter{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:518; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/Simulations/run.jl:212; [9] time_step!(sim::Simul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819:601,Modifiability,Variab,Variable,601,"When using `with_halos = true` in the `JLD2OutputWriter` works well, however in `NetCDFOutputWriter` it crashes with the following error: . ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, wall time: 0 seconds; ERROR: LoadError: DimensionMismatch: new dimensions (156, 156, 22, 1) must be consistent with array size 24336; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDataset{Nothing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/CommonDataModel/pO4st/src/cfvariable.jl:419; [6] save_output!(ds::NCDataset{…}, output::Field{…}, model::HydrostaticFreeSurfaceModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:479; [7] write_output!(ow::NetCDFOutputWriter{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:518; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/Simulations/run.jl:212; [9] time_step!(sim::Simul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819:260,Performance,Load,LoadError,260,"When using `with_halos = true` in the `JLD2OutputWriter` works well, however in `NetCDFOutputWriter` it crashes with the following error: . ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, wall time: 0 seconds; ERROR: LoadError: DimensionMismatch: new dimensions (156, 156, 22, 1) must be consistent with array size 24336; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDataset{Nothing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/CommonDataModel/pO4st/src/cfvariable.jl:419; [6] save_output!(ds::NCDataset{…}, output::Field{…}, model::HydrostaticFreeSurfaceModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:479; [7] write_output!(ow::NetCDFOutputWriter{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:518; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/Simulations/run.jl:212; [9] time_step!(sim::Simul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2012871651:822,Security,access,access,822,"I'm a bit confused, I managed to solve the issue by changing manually the grid passed to `output_indices` at:; https://github.com/CliMA/Oceananigans.jl/blob/e243e5b44ea0c4570ae427bdce1d68dc29594f24/src/OutputWriters/output_construction.jl#L32-L42; For example, in the example provided by @navidcy:; ```; julia> size(grid); (5, 5, 4); ```; That is passed to the `output_indices` function that outputs the indices `(1:5, 1:5, 1:5)` or `(4:8, 4:8, 4:8)` once the halos are taken into account. ; The way I managed to save $\eta$ in a hacky way was by changing the `size(grid)` to (5, 5, -1), so it outputs the surface index in `z`, since the `size(eta)` is `(5, 5, 1)`; My two ideas on how to fixing this are:; - Rather than using the `size(grid)`, use `size(output)`, however using `size(eta)` still crashes, since it try to access the indexes `(4:8, 4:8, 4:5)` rather than `(4:8, 4:8, 1:0)`; - Check if there is a `Face` in the `z` direction of the `location(output)`, and then force the last index to be `-1`. . Before I do any of this changes, I don't understand how are the halos (applied in all directions) implemented in a surface such as $\eta$? I guess the same will apply to any flux at the surface right? . Do you have any other way to fix this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2012871651
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2013010886:872,Availability,error,error,872,"There is definitely a wrong assumption somewhere in this pipeline. Maybe we can focus on this:. > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2013010886
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2013010886:57,Deployability,pipeline,pipeline,57,"There is definitely a wrong assumption somewhere in this pipeline. Maybe we can focus on this:. > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2013010886
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2013010886:114,Security,access,access,114,"There is definitely a wrong assumption somewhere in this pipeline. Maybe we can focus on this:. > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2013010886
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:302,Availability,error,error,302,"> There is definitely a wrong assumption somewhere in this pipeline.; > ; > Maybe we can focus on this:; > ; > > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). I had a typo here, the indexes that it tries to access are `(4:8, 4:8, 4:8)` as if the field was 3D (See the error below). > ; > First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:2567,Availability,ERROR,ERROR,2567," fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole sta",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:3674,Availability,error,error,3674,"y.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?; Yes, here it is:; ```; ERROR: LoadError: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:3753,Availability,ERROR,ERROR,3753,"y.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?; Yes, here it is:; ```; ERROR: LoadError: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:59,Deployability,pipeline,pipeline,59,"> There is definitely a wrong assumption somewhere in this pipeline.; > ; > Maybe we can focus on this:; > ; > > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). I had a typo here, the indexes that it tries to access are `(4:8, 4:8, 4:8)` as if the field was 3D (See the error below). > ; > First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:5563,Energy Efficiency,schedul,schedule,5563,"ields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/output_construction.jl:50; [8] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [9] iterate; @ ./generator.jl:47 [inlined]; [10] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:364; [11] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:151; [12] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::TimeInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:190; [13] top-level scope; @ ~/github/Oceananigans.jl/test.jl:19; [14] include(fname::String); @ Base.MainInclude ./client.jl:489; [15] top-level scope; @ REPL[1]:1; in expression starting at /Users/jmtzmo/github/Oceananigans.jl/test.jl:19; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:3760,Performance,Load,LoadError,3760,"y.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?; Yes, here it is:; ```; ERROR: LoadError: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:129,Security,access,access,129,"> There is definitely a wrong assumption somewhere in this pipeline.; > ; > Maybe we can focus on this:; > ; > > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). I had a typo here, the indexes that it tries to access are `(4:8, 4:8, 4:8)` as if the field was 3D (See the error below). > ; > First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:241,Security,access,access,241,"> There is definitely a wrong assumption somewhere in this pipeline.; > ; > Maybe we can focus on this:; > ; > > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). I had a typo here, the indexes that it tries to access are `(4:8, 4:8, 4:8)` as if the field was 3D (See the error below). > ; > First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:571,Security,access,accessing,571,"> There is definitely a wrong assumption somewhere in this pipeline.; > ; > Maybe we can focus on this:; > ; > > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). I had a typo here, the indexes that it tries to access are `(4:8, 4:8, 4:8)` as if the field was 3D (See the error below). > ; > First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:1364,Security,access,accessing,1364,"t we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:1834,Security,access,access,1834," there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:2482,Security,access,access,2482,"However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:2598,Security,access,access,2598," fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole sta",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:3795,Security,access,access,3795,"y.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?; Yes, here it is:; ```; ERROR: LoadError: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:6007,Testability,test,test,6007,"ields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/output_construction.jl:50; [8] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [9] iterate; @ ./generator.jl:47 [inlined]; [10] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:364; [11] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:151; [12] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::TimeInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:190; [13] top-level scope; @ ~/github/Oceananigans.jl/test.jl:19; [14] include(fname::String); @ Base.MainInclude ./client.jl:489; [15] top-level scope; @ REPL[1]:1; in expression starting at /Users/jmtzmo/github/Oceananigans.jl/test.jl:19; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:6182,Testability,test,test,6182,"ields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/output_construction.jl:50; [8] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [9] iterate; @ ./generator.jl:47 [inlined]; [10] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:364; [11] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:151; [12] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::TimeInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:190; [13] top-level scope; @ ~/github/Oceananigans.jl/test.jl:19; [14] include(fname::String); @ Base.MainInclude ./client.jl:489; [15] top-level scope; @ REPL[1]:1; in expression starting at /Users/jmtzmo/github/Oceananigans.jl/test.jl:19; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014619281:130,Security,access,access,130,"As far as I can tell, I think this is related to the issue @jagoosw mentioned too, where the indices that the output is trying to access does not match the size of the sliced fields, similar to what we are seeing here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014619281
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259:223,Energy Efficiency,schedul,schedule,223,"A simple fix to manage to output $\eta$ will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; ```; simulation.output_writers[:surface] = JLD2OutputWriter(model, ; (η=eta,),; indices=(:,:,,1-grid.Hz),; schedule = TimeInterval(200),; filename = ""surface"",; with_halos = false,; overwrite_existing = true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259:2,Usability,simpl,simple,2,"A simple fix to manage to output $\eta$ will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; ```; simulation.output_writers[:surface] = JLD2OutputWriter(model, ; (η=eta,),; indices=(:,:,,1-grid.Hz),; schedule = TimeInterval(200),; filename = ""surface"",; with_halos = false,; overwrite_existing = true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018362902:150,Security,access,accessing,150,"> Nope, that is without the halo (with_halo=False), when using with_halo=true the indexes passed are (Colon(), Colon(), Colon()) so there is no issue accessing the indexes of the output. Sorry, I meant `with_halo=false`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018362902
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018365052:234,Energy Efficiency,schedul,schedule,234,"> A simple fix to manage to output η will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; > ; > ```; > simulation.output_writers[:surface] = JLD2OutputWriter(model, ; > (η=eta,),; > indices=(:,:,,1-grid.Hz),; > schedule = TimeInterval(200),; > filename = ""surface"",; > with_halos = false,; > overwrite_existing = true); > ```. Good to know but definitely we want to fix the underlying issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018365052
https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018365052:4,Usability,simpl,simple,4,"> A simple fix to manage to output η will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; > ; > ```; > simulation.output_writers[:surface] = JLD2OutputWriter(model, ; > (η=eta,),; > indices=(:,:,,1-grid.Hz),; > schedule = TimeInterval(200),; > filename = ""surface"",; > with_halos = false,; > overwrite_existing = true); > ```. Good to know but definitely we want to fix the underlying issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018365052
https://github.com/CliMA/Oceananigans.jl/pull/3261#issuecomment-1714613118:11,Testability,test,test,11,Still some test to fix,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3261#issuecomment-1714613118
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1714600321:481,Availability,down,downsides,481,"A few comments:. 1. Let's call this `materialize_biogeochemistry`. We would like to change the names of the functions to ""materialize"" as well.; 2. This should be avoided unless strictly necessary. Generally, this step introduces complexity and fragility to model setup. One source of insidious bugs is when the user-build `biogeochemistry` is different from `model.biogeochemistry`. Can you provide an example of when this is necessary to motivate this feature, given its serious downsides?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1714600321
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1714600321:163,Safety,avoid,avoided,163,"A few comments:. 1. Let's call this `materialize_biogeochemistry`. We would like to change the names of the functions to ""materialize"" as well.; 2. This should be avoided unless strictly necessary. Generally, this step introduces complexity and fragility to model setup. One source of insidious bugs is when the user-build `biogeochemistry` is different from `model.biogeochemistry`. Can you provide an example of when this is necessary to motivate this feature, given its serious downsides?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1714600321
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319:913,Availability,down,downsides,913,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319:1163,Availability,error,error,1163,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319:1169,Integrability,message,message,1169,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319:1303,Usability,usab,usability,1303,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715934843:875,Energy Efficiency,allocate,allocated,875,"> I suppose you could do it a different way if the user manually declared the tracers, but it would complicate the setup of the bgc models quite a lot because you'd have to make sure you had the full list of tracers before and e.g. would have to change the bgc setup if you change the buoyancy model. Why do you have to change the BGC setup if you change the buoyancy model? Can you give an example?. > Also in this specific case there shouldn't be a problem with the disparity between the user declared `biogeochemistry` and `model.biogeochemistry` because this should only have an effect when its used through a GPU kernel, and if `biogeochemistry` is given to a new model the same thing would happen to it right?. I'm not sure how you plan to use the ""materialize"" feature so I can't say. The main issue is if a biogeochemistry model contains fields which end up being re-allocated. This can make callbacks or forcing incorrect.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715934843
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716026302:1025,Availability,down,down,1025,"> Why do you have to change the BGC setup if you change the buoyancy model? Can you give an example?. In this case, if you've set up a model with the above then you would need to tell it the list of tracers that would be present in the model e.g. (:N, :P, :Z, :D, :b), so that when the BGC model is set up it can convert some to indices, then if you changed the buoyancy model and your new tracer list looked like (:T, :S, :N, :P, :Z, :D) then the scaling would have the wrong indices. I suppose in most cases people would retain the order so the indices would be correct, but there's no guarantee that would happen. > I'm not sure how you plan to use the ""materialize"" feature so I can't say. The main issue is if a biogeochemistry model contains fields which end up being re-allocated. This can make callbacks or forcing incorrect. I see what you mean and can see why that would be a problem. I think it would be useful for this to be possible but the documentation to discourage people from using it, and then it would be down to whoever is implementing the bgc model to make sure this didn't happen.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716026302
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716026302:777,Energy Efficiency,allocate,allocated,777,"> Why do you have to change the BGC setup if you change the buoyancy model? Can you give an example?. In this case, if you've set up a model with the above then you would need to tell it the list of tracers that would be present in the model e.g. (:N, :P, :Z, :D, :b), so that when the BGC model is set up it can convert some to indices, then if you changed the buoyancy model and your new tracer list looked like (:T, :S, :N, :P, :Z, :D) then the scaling would have the wrong indices. I suppose in most cases people would retain the order so the indices would be correct, but there's no guarantee that would happen. > I'm not sure how you plan to use the ""materialize"" feature so I can't say. The main issue is if a biogeochemistry model contains fields which end up being re-allocated. This can make callbacks or forcing incorrect. I see what you mean and can see why that would be a problem. I think it would be useful for this to be possible but the documentation to discourage people from using it, and then it would be down to whoever is implementing the bgc model to make sure this didn't happen.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716026302
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716346783:606,Integrability,depend,dependent,606,"> The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before. Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716346783
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716883676:615,Integrability,depend,dependent,615,"> > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them. Ok got it. What's the purpose of that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716883676
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717571221:627,Integrability,depend,dependent,627,"> > > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > > ; > > ; > > Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them.; > ; > Ok got it. What's the purpose of that?. Unless I've missed something I believe that structs with `Tuple{:Symbol}` properties can't be passed to GPU kernels when I manually change the element in bgc model I'm having problems with to a tuple of integers it works",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717571221
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609010:480,Availability,error,error,480,"I also don't feel we can motivate this feature unless we understand the specific thing we are going for and ensure that it can't be achieved otherwise. It has wider implications too, because if we can't move away from the `materialize_x` pattern, then we can commit to supporting it. We've discussed at various times trying to eliminate the `materialize_x` step, and ways to avoid having it. A similar example pertains to grids and halos. We've decided that it's best to throw an error when the grid halo is not adequate for the chosen advection scheme. Previously, we had the notion that we might ""automatically expand"" the grid within the model constructor if the halo was not correct. So, let's discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609010
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609010:375,Safety,avoid,avoid,375,"I also don't feel we can motivate this feature unless we understand the specific thing we are going for and ensure that it can't be achieved otherwise. It has wider implications too, because if we can't move away from the `materialize_x` pattern, then we can commit to supporting it. We've discussed at various times trying to eliminate the `materialize_x` step, and ways to avoid having it. A similar example pertains to grids and halos. We've decided that it's best to throw an error when the grid halo is not adequate for the chosen advection scheme. Previously, we had the notion that we might ""automatically expand"" the grid within the model constructor if the halo was not correct. So, let's discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609010
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609513:1002,Security,access,access,1002,"> That's true, such code has to be compiled away. However, the method that `forcing` uses is a little fragile and often fails to compile. We've just failed to come up with a better way for users to specify arbitrary forcings. But presumably you are doing something else, because otherwise your users could use `forcing`. That's why I'm asking: what outcome are you trying to achieve? Maybe we can come up with another design. Ah, I see. The problem is occurring where I've got this `update_state` for changing the negative tracers (as discussed in ). The code is currently:; https://github.com/OceanBioME/OceanBioME.jl/blob/ac8419a1ce5a06a82be31588583636b212c09598/src/Utils/negative_tracers.jl#L87-L118; But this doesn't work on GPU. The list of symbols is needed so that the group that the total is conserved in can be defined. An alternative I've thought of but not tested yet is to have functions like `conserved_tracers(bgc)` which can just return the list of symbols instead. . I currently can't access a GPU but will see if this works when I can. I'm sure I can find an alternative way todo this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609513
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609513:869,Testability,test,tested,869,"> That's true, such code has to be compiled away. However, the method that `forcing` uses is a little fragile and often fails to compile. We've just failed to come up with a better way for users to specify arbitrary forcings. But presumably you are doing something else, because otherwise your users could use `forcing`. That's why I'm asking: what outcome are you trying to achieve? Maybe we can come up with another design. Ah, I see. The problem is occurring where I've got this `update_state` for changing the negative tracers (as discussed in ). The code is currently:; https://github.com/OceanBioME/OceanBioME.jl/blob/ac8419a1ce5a06a82be31588583636b212c09598/src/Utils/negative_tracers.jl#L87-L118; But this doesn't work on GPU. The list of symbols is needed so that the group that the total is conserved in can be defined. An alternative I've thought of but not tested yet is to have functions like `conserved_tracers(bgc)` which can just return the list of symbols instead. . I currently can't access a GPU but will see if this works when I can. I'm sure I can find an alternative way todo this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609513
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1718747355:299,Usability,simpl,simpler,299,"Why not just extract the tracers to be scaled in advance of launching the kernel?. ```julia; tracers_to_scale = Tuple(fields[name] for name in keys(scale.tracers)); # launch kernel, indexing from 1:length(tracers_to_scale); ```. You can also launch one kernel per tracer which might be ok and a bit simpler which is nice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1718747355
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719178763:116,Integrability,depend,depends,116,"Yeah, I guess that would work too!. It does have to just be one kernel per point I think because the modified value depends on all of the other tracer values.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719178763
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719179326:57,Testability,test,test,57,I'll close this PR and let you know when I've managed to test this. Thanks!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719179326
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719382840:149,Safety,avoid,avoid,149,"Excellent!. To summarize:. 1. A `materialize_biogeochemistry` feature may still be needed sometime in the future; 2. Generally we think it's best to avoid this step if possible, for a few reasons:; - code that relies on this step may end up unnecessarily complicated or convoluted; - materializing objects leads to a distinction between user input and model properties that can produce hard-to-find bugs; - it can be complicated to maintain a `materialize_X` feature.; 3. For the specific problem considered here, we can probably find a solution that avoids `materialize_biogeochemistry`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719382840
https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719382840:551,Safety,avoid,avoids,551,"Excellent!. To summarize:. 1. A `materialize_biogeochemistry` feature may still be needed sometime in the future; 2. Generally we think it's best to avoid this step if possible, for a few reasons:; - code that relies on this step may end up unnecessarily complicated or convoluted; - materializing objects leads to a distinction between user input and model properties that can produce hard-to-find bugs; - it can be complicated to maintain a `materialize_X` feature.; 3. For the specific problem considered here, we can probably find a solution that avoids `materialize_biogeochemistry`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719382840
https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723445680:203,Deployability,update,update,203,I think we need stretched WENO with 2D coefficients. Now `WENO(grid)` assumes 1D coefficients which is okay for latitude-longitude and rectilinear but not for cubed sphere. It will be straightforward to update WENO once everything is in place,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723445680
https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723492480:212,Deployability,update,update,212,> I think we need stretched WENO with 2D coefficients. Now `WENO(grid)` assumes 1D coefficients which is okay for latitude-longitude and rectilinear but not for cubed sphere.; > ; > It will be straightforward to update WENO once everything is in place. Good point. So if I fall back to the default scheme for tracers then it should be OK?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723492480
https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723500085:115,Availability,error,errors,115,A centered second order advection should be okay but you have to pair it with some diffusion otherwise oscillatory errors will break your solution,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723500085
https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723549969:117,Availability,error,errors,117,"> A centered second order advection should be okay but you have to pair it with some diffusion otherwise oscillatory errors will break your solution. True! At least we know what's going on. Thanks @simone-silvestri!. Here it is without any diffusion:. https://github.com/CliMA/Oceananigans.jl/assets/7112768/626e976e-2a75-4b66-ba7d-8a8614ad4ef8. And here it is with `ScalarDiffusivity(; κ=1e-2)`:. https://github.com/CliMA/Oceananigans.jl/assets/7112768/8e3d924c-1165-49fa-a047-786d1d287479. You can still ""see"" the corner.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723549969
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:39,Availability,error,error,39,"When I exit the REPL I get a very long error message ending:; <summary>; <details>; ```; WARNING: Error while freeing DeviceBuffer(568 bytes at 0x0000000320000400):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemFreeAsync; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #free#2; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:97 [inlined]; [5] free; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:92 [inlined]; [6] #actual_free#976; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:77 [inlined]; [7] actual_free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:74 [inlined]; [8] #_free#998; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:492 [inlined]; [9] _free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:479 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:464 [inlined]; [11] macro expansion; @ ./timing.jl:393 [inlined]; [12] #free#997; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:463 [inlined]; [13] free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:452 [inlined]; [14] (::CUDA.var""#1004#1005""{CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, CUDA.CuStream})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:130; [15] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; WARNING: Error while freeing DeviceBuffer(560 bytes at 0x0000000320000000):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:98,Availability,Error,Error,98,"When I exit the REPL I get a very long error message ending:; <summary>; <details>; ```; WARNING: Error while freeing DeviceBuffer(568 bytes at 0x0000000320000400):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemFreeAsync; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #free#2; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:97 [inlined]; [5] free; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:92 [inlined]; [6] #actual_free#976; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:77 [inlined]; [7] actual_free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:74 [inlined]; [8] #_free#998; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:492 [inlined]; [9] _free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:479 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:464 [inlined]; [11] macro expansion; @ ./timing.jl:393 [inlined]; [12] #free#997; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:463 [inlined]; [13] free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:452 [inlined]; [14] (::CUDA.var""#1004#1005""{CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, CUDA.CuStream})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:130; [15] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; WARNING: Error while freeing DeviceBuffer(560 bytes at 0x0000000320000000):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:1852,Availability,Error,Error,1852,"ol.jl:492 [inlined]; [9] _free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:479 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:464 [inlined]; [11] macro expansion; @ ./timing.jl:393 [inlined]; [12] #free#997; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:463 [inlined]; [13] free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:452 [inlined]; [14] (::CUDA.var""#1004#1005""{CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, CUDA.CuStream})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:130; [15] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; WARNING: Error while freeing DeviceBuffer(560 bytes at 0x0000000320000000):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemFreeAsync; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #free#2; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:97 [inlined]; [5] free; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:92 [inlined]; [6] #actual_free#976; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:77 [inlined]; [7] actual_free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:74 [inlined]; [8] #_free#998; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:492 [inlined]; [9] _free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:479 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:464 [inlined]; [11] macro expansion; @ ./timing.jl:393 [inlined]; [12] #free#997; @ ~/.juli",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:3597,Availability,error,error,3597,"ackages/CUDA/35NC6/src/pool.jl:492 [inlined]; [9] _free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:479 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:464 [inlined]; [11] macro expansion; @ ./timing.jl:393 [inlined]; [12] #free#997; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:463 [inlined]; [13] free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:452 [inlined]; [14] (::CUDA.var""#1004#1005""{CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, CUDA.CuStream})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:130; [15] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/defaul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4435,Deployability,release,release-,4435,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4543,Deployability,release,release-,4543,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4637,Deployability,release,release-,4637,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4745,Deployability,release,release-,4745,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4839,Deployability,release,release-,4839,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4934,Deployability,release,release-,4934,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:5034,Deployability,release,release-,5034,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:45,Integrability,message,message,45,"When I exit the REPL I get a very long error message ending:; <summary>; <details>; ```; WARNING: Error while freeing DeviceBuffer(568 bytes at 0x0000000320000400):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemFreeAsync; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #free#2; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:97 [inlined]; [5] free; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:92 [inlined]; [6] #actual_free#976; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:77 [inlined]; [7] actual_free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:74 [inlined]; [8] #_free#998; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:492 [inlined]; [9] _free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:479 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:464 [inlined]; [11] macro expansion; @ ./timing.jl:393 [inlined]; [12] #free#997; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:463 [inlined]; [13] free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:452 [inlined]; [14] (::CUDA.var""#1004#1005""{CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, CUDA.CuStream})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:130; [15] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; WARNING: Error while freeing DeviceBuffer(560 bytes at 0x0000000320000000):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4390,Performance,cache,cache,4390,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4498,Performance,cache,cache,4498,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4592,Performance,cache,cache,4592,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4700,Performance,cache,cache,4700,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4794,Performance,cache,cache,4794,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4889,Performance,cache,cache,4889,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4989,Performance,cache,cache,4989,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721341345:44,Availability,error,error,44,Trying to make an MWE I can't reproduce the error without all of my code running so perhaps its not actually in the pressure solver even though that's where the error is being raised.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721341345
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721341345:161,Availability,error,error,161,Trying to make an MWE I can't reproduce the error without all of my code running so perhaps its not actually in the pressure solver even though that's where the error is being raised.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721341345
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:182,Availability,error,error,182,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:265,Availability,error,error,265,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:77,Integrability,synchroniz,synchronize,77,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:295,Integrability,synchroniz,synchronizing,295,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:326,Integrability,synchroniz,synchronize,326,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:22,Performance,load,load,22,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:207,Security,access,access,207,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1722074987:28,Integrability,synchroniz,synchronize,28,Do you know why the manual `synchronize` is needed?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1722074987
https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1751498431:112,Integrability,synchroniz,synchronize,112,"I found a similar problem \(see #3320\), but I am not sure whether it is related or not. I do not know whether `synchronize(device(architecture(model)))` will solve my problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1751498431
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775917629:293,Usability,clear,clear,293,"I was thinking about it. The problem is that they do in fact encode some physical statements, like, for example, impenetrability for U (XFaceFields) and V (YFaceFields) and no flux for center-fields (C). ; Periodic topologies act according to periodic BC.; We probably need a way to make this clear. I am afraid a compact notation would not convey this entirely, maybe we can be a bit more verbose like; ```julia; δyᵃᶜᵃ_nopenetration; δxᶠᵃᵃ_noflux; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775917629
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775922222:292,Usability,clear,clear,292,"> I was thinking about it. The problem is that they do in fact encode some physical statements, like, for example, impenetrability for U (XFaceFields) and V (YFaceFields) and no flux for center-fields (C). Periodic topologies act according to periodic BC. We probably need a way to make this clear. I am afraid a compact notation would not convey this entirely, maybe we can be a bit more verbose like; > ; > ```julia; > δyᵃᶜᵃ_nopenetration; > δxᶠᵃᵃ_noflux; > ```; > ; > ?. Two thoughts:; - ""penetration"" and ""flux"" are physical concepts. More precisely the operator returns zero when differenced across a `Bounded` direction.; - The operator names are ""mathematical"" rather than English, ie we use symbols like `δx`, rather than `x_difference`. I think we should try to strive to keep names in one category or another rather than blending them",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775922222
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2327849488:145,Modifiability,refactor,refactor,145,"Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2327849488
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236:147,Modifiability,refactor,refactor,147,"> Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions. Hopefully we don't have to pass boundary conditions 🥺 . Not all complexity is justified by the performance gains...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236:303,Performance,perform,performance,303,"> Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions. Hopefully we don't have to pass boundary conditions 🥺 . Not all complexity is justified by the performance gains...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617:288,Modifiability,refactor,refactor,288,"Is this PR looking for an adopter? Happy to try to complete it since it seems like the first step towards open BCs for hydrostatic models. > > Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.; > ; > Hopefully we don't have to pass boundary conditions 🥺; > ; > Not all complexity is justified by the performance gains... Ah I'm actually not sure where the performance gains would come from, but I thought that the operators need to be aware of the boundary condition in order to correctly implement open BCs (at least based on @simone-silvestri's comments in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617:456,Performance,perform,performance,456,"Is this PR looking for an adopter? Happy to try to complete it since it seems like the first step towards open BCs for hydrostatic models. > > Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.; > ; > Hopefully we don't have to pass boundary conditions 🥺; > ; > Not all complexity is justified by the performance gains... Ah I'm actually not sure where the performance gains would come from, but I thought that the operators need to be aware of the boundary condition in order to correctly implement open BCs (at least based on @simone-silvestri's comments in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617:512,Performance,perform,performance,512,"Is this PR looking for an adopter? Happy to try to complete it since it seems like the first step towards open BCs for hydrostatic models. > > Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.; > ; > Hopefully we don't have to pass boundary conditions 🥺; > ; > Not all complexity is justified by the performance gains... Ah I'm actually not sure where the performance gains would come from, but I thought that the operators need to be aware of the boundary condition in order to correctly implement open BCs (at least based on @simone-silvestri's comments in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298:402,Modifiability,variab,variables,402,"If you want to adopt this PR, that would be great. I would leave the boundary conditions outside the operator for the moment, then we can look at the influence of those in performance in another PR. To test the performance we should push PR #3596 that implements split explicit with fill halos at every substep. Using that implementation for split-explicit will make boundary conditions for barotropic variables quite trivial to implement, but probably extremely slow. However, we can use it as a benchmark",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298:172,Performance,perform,performance,172,"If you want to adopt this PR, that would be great. I would leave the boundary conditions outside the operator for the moment, then we can look at the influence of those in performance in another PR. To test the performance we should push PR #3596 that implements split explicit with fill halos at every substep. Using that implementation for split-explicit will make boundary conditions for barotropic variables quite trivial to implement, but probably extremely slow. However, we can use it as a benchmark",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298:211,Performance,perform,performance,211,"If you want to adopt this PR, that would be great. I would leave the boundary conditions outside the operator for the moment, then we can look at the influence of those in performance in another PR. To test the performance we should push PR #3596 that implements split explicit with fill halos at every substep. Using that implementation for split-explicit will make boundary conditions for barotropic variables quite trivial to implement, but probably extremely slow. However, we can use it as a benchmark",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298:202,Testability,test,test,202,"If you want to adopt this PR, that would be great. I would leave the boundary conditions outside the operator for the moment, then we can look at the influence of those in performance in another PR. To test the performance we should push PR #3596 that implements split explicit with fill halos at every substep. Using that implementation for split-explicit will make boundary conditions for barotropic variables quite trivial to implement, but probably extremely slow. However, we can use it as a benchmark",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298:497,Testability,benchmark,benchmark,497,"If you want to adopt this PR, that would be great. I would leave the boundary conditions outside the operator for the moment, then we can look at the influence of those in performance in another PR. To test the performance we should push PR #3596 that implements split explicit with fill halos at every substep. Using that implementation for split-explicit will make boundary conditions for barotropic variables quite trivial to implement, but probably extremely slow. However, we can use it as a benchmark",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686:136,Energy Efficiency,efficient,efficient,136,"I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686:97,Performance,perform,performance,97,"I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984:138,Energy Efficiency,efficient,efficient,138,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. At least that is what @siddharthabishnu told me, I am not sure about the timings, can you confirm @siddharthabishnu?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984:99,Performance,perform,performance,99,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. At least that is what @siddharthabishnu told me, I am not sure about the timings, can you confirm @siddharthabishnu?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:685,Deployability,update,update,685,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:138,Energy Efficiency,efficient,efficient,138,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:535,Integrability,depend,dependent,535,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:561,Modifiability,variab,variables,561,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:99,Performance,perform,performance,99,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627:53,Energy Efficiency,efficient,efficient,53,> the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. What does this have to do with putting boundary conditions in operators?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627:14,Performance,perform,performance,14,> the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. What does this have to do with putting boundary conditions in operators?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652:488,Availability,down,down,488,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652:441,Integrability,depend,depend,441,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652:269,Usability,user-friendly,user-friendly,269,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856:9,Modifiability,refactor,refactoring,9,Did some refactoring and CPU and GPU hydrostatic regression tests pass locally so I think this PR is ready for review!. @simone-silvestri Requesting a review from you on your own PR again lol but I won't approve unless you do.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856
https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856:60,Testability,test,tests,60,Did some refactoring and CPU and GPU hydrostatic regression tests pass locally so I think this PR is ready for review!. @simone-silvestri Requesting a review from you on your own PR again lol but I won't approve unless you do.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856
https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416:192,Safety,safe,safe,192,"There are a few more `0.0` in the code. Question:. If there is. ```Julia; fill!(var, 0.0); ```. where `var::Array` and if we don't have access to grid, then is . ```Julia; fill!(var, 0); ```; safe to do?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416
https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416:136,Security,access,access,136,"There are a few more `0.0` in the code. Question:. If there is. ```Julia; fill!(var, 0.0); ```. where `var::Array` and if we don't have access to grid, then is . ```Julia; fill!(var, 0); ```; safe to do?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416
https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988:260,Performance,perform,performance,260,"`0` is almost always safe. But neither case is really an issue. The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. ~`fill(var, 0)`~ `fill!(var, 0)` is cheap and unlikely to affect performance. That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988
https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988:21,Safety,safe,safe,21,"`0` is almost always safe. But neither case is really an issue. The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. ~`fill(var, 0)`~ `fill!(var, 0)` is cheap and unlikely to affect performance. That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988
https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023:180,Performance,perform,performance,180,"> The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. `fill(var, 0)` is cheap and unlikely to affect performance.; > ; > That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it. You were meant to write `fill!` not `fill` right? For `fill!(::AbstractArray,0)` this is what happens. ```julia; julia> a = Float32[1,2,3]; 3-element Vector{Float32}:; 1.0; 2.0; 3.0. julia> @code_llvm fill!(a,0); ; @ array.jl:346 within `fill!`; define nonnull {}* @""julia_fill!_127""({}* noundef nonnull align 16 dereferenceable(40) %0, i64 signext %1) #0 {; top:; ; @ array.jl:347 within `fill!`; ; ┌ @ number.jl:7 within `convert`; ; │┌ @ float.jl:159 within `Float32`; %2 = sitofp i64 %1 to float; ; └└; ```. So the very first thing is that if `eltype` of the array and type of second argument aren't the same then it's converted (the `%2 ...` line); Using `fill!(var, zero(eltype(var)))` then can skip this conversion (it's compiled away) but the result is the same. You can make and educated guess of the type of the zero, but honestly, I wouldn't even bother. It has probably zero impact on performance for any larger than a few elements and I find `fill!(A,0)` very clear to read too, so that's what I now always try to write.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023
https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023:1261,Performance,perform,performance,1261,"> The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. `fill(var, 0)` is cheap and unlikely to affect performance.; > ; > That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it. You were meant to write `fill!` not `fill` right? For `fill!(::AbstractArray,0)` this is what happens. ```julia; julia> a = Float32[1,2,3]; 3-element Vector{Float32}:; 1.0; 2.0; 3.0. julia> @code_llvm fill!(a,0); ; @ array.jl:346 within `fill!`; define nonnull {}* @""julia_fill!_127""({}* noundef nonnull align 16 dereferenceable(40) %0, i64 signext %1) #0 {; top:; ; @ array.jl:347 within `fill!`; ; ┌ @ number.jl:7 within `convert`; ; │┌ @ float.jl:159 within `Float32`; %2 = sitofp i64 %1 to float; ; └└; ```. So the very first thing is that if `eltype` of the array and type of second argument aren't the same then it's converted (the `%2 ...` line); Using `fill!(var, zero(eltype(var)))` then can skip this conversion (it's compiled away) but the result is the same. You can make and educated guess of the type of the zero, but honestly, I wouldn't even bother. It has probably zero impact on performance for any larger than a few elements and I find `fill!(A,0)` very clear to read too, so that's what I now always try to write.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023
https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023:1337,Usability,clear,clear,1337,"> The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. `fill(var, 0)` is cheap and unlikely to affect performance.; > ; > That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it. You were meant to write `fill!` not `fill` right? For `fill!(::AbstractArray,0)` this is what happens. ```julia; julia> a = Float32[1,2,3]; 3-element Vector{Float32}:; 1.0; 2.0; 3.0. julia> @code_llvm fill!(a,0); ; @ array.jl:346 within `fill!`; define nonnull {}* @""julia_fill!_127""({}* noundef nonnull align 16 dereferenceable(40) %0, i64 signext %1) #0 {; top:; ; @ array.jl:347 within `fill!`; ; ┌ @ number.jl:7 within `convert`; ; │┌ @ float.jl:159 within `Float32`; %2 = sitofp i64 %1 to float; ; └└; ```. So the very first thing is that if `eltype` of the array and type of second argument aren't the same then it's converted (the `%2 ...` line); Using `fill!(var, zero(eltype(var)))` then can skip this conversion (it's compiled away) but the result is the same. You can make and educated guess of the type of the zero, but honestly, I wouldn't even bother. It has probably zero impact on performance for any larger than a few elements and I find `fill!(A,0)` very clear to read too, so that's what I now always try to write.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023
https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725835152:431,Deployability,patch,patch,431,I think these minor changes allow / encourage the compiler to infer the output type of `offset_data` --- is that right? As far as I can tell it does not change the type that's outputted by `offset_data`. But I could be wrong. Once we confirm the intent we can merge (it could make sense also to add a comment to the code so that this doesn't get reverted for some reason in the future). @wsmoses let us know if you'd like to tag a patch release as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725835152
https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725835152:437,Deployability,release,release,437,I think these minor changes allow / encourage the compiler to infer the output type of `offset_data` --- is that right? As far as I can tell it does not change the type that's outputted by `offset_data`. But I could be wrong. Once we confirm the intent we can merge (it could make sense also to add a comment to the code so that this doesn't get reverted for some reason in the future). @wsmoses let us know if you'd like to tag a patch release as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725835152
https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725922794:20,Deployability,Patch,Patch,20,"Nice, let's merge ! Patch release or no? There will probably be a patch release before long anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725922794
https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725922794:26,Deployability,release,release,26,"Nice, let's merge ! Patch release or no? There will probably be a patch release before long anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725922794
https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725922794:66,Deployability,patch,patch,66,"Nice, let's merge ! Patch release or no? There will probably be a patch release before long anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725922794
https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725922794:72,Deployability,release,release,72,"Nice, let's merge ! Patch release or no? There will probably be a patch release before long anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725922794
https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725927258:20,Deployability,release,release,20,"~We'll have a minor release soon with #3125, right? So no need to bother here with patch?~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725927258
https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725927258:83,Deployability,patch,patch,83,"~We'll have a minor release soon with #3125, right? So no need to bother here with patch?~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3273#issuecomment-1725927258
https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401:215,Deployability,integrat,integrated,215,"@navidcy and @glwagner, I created this halo test branch from your tracer advection branch the day before yesterday, prior to its merger with the main. Given that the tracer advection, along with other branches, was integrated into the main branch yesterday, this branch started displaying numerous reverse changes. To address this, I merged the main branch into this one, resolved the conflicts manually by accepting the incoming changes. This process led to several commits. I will close this PR and create a fresh branch from the main. I will then push my commits. Please bear with me for a few minutes while I do this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401
https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401:215,Integrability,integrat,integrated,215,"@navidcy and @glwagner, I created this halo test branch from your tracer advection branch the day before yesterday, prior to its merger with the main. Given that the tracer advection, along with other branches, was integrated into the main branch yesterday, this branch started displaying numerous reverse changes. To address this, I merged the main branch into this one, resolved the conflicts manually by accepting the incoming changes. This process led to several commits. I will close this PR and create a fresh branch from the main. I will then push my commits. Please bear with me for a few minutes while I do this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401
https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401:44,Testability,test,test,44,"@navidcy and @glwagner, I created this halo test branch from your tracer advection branch the day before yesterday, prior to its merger with the main. Given that the tracer advection, along with other branches, was integrated into the main branch yesterday, this branch started displaying numerous reverse changes. To address this, I merged the main branch into this one, resolved the conflicts manually by accepting the incoming changes. This process led to several commits. I will close this PR and create a fresh branch from the main. I will then push my commits. Please bear with me for a few minutes while I do this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842:76,Performance,perform,performance,76,"Ok. That makes sense, since CPU is not our goal; we can accept some loss of performance on CPU in order to simplify the code. The other question is why we are not implementing this in PencilArrays / PencilFFTs. Having an independent implementation may not be the best practice (we want to be good open source community members), but could be justified, maybe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842:107,Usability,simpl,simplify,107,"Ok. That makes sense, since CPU is not our goal; we can accept some loss of performance on CPU in order to simplify the code. The other question is why we are not implementing this in PencilArrays / PencilFFTs. Having an independent implementation may not be the best practice (we want to be good open source community members), but could be justified, maybe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:420,Deployability,configurat,configuration,420,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:139,Energy Efficiency,efficient,efficient,139,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:420,Modifiability,config,configuration,420,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:47,Performance,perform,performant,47,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:412,Usability,simpl,simple,412,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:427,Deployability,configurat,configuration,427,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:141,Energy Efficiency,efficient,efficient,141,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:427,Modifiability,config,configuration,427,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:49,Performance,perform,performant,49,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:968,Testability,benchmark,benchmarking,968,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:419,Usability,simpl,simple,419,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132:308,Deployability,configurat,configuration,308,"At the moment, this PR allows slab decomposition in x and y, and pencil decomposition in x, y.; This PR implements these transposes:; ```julia; z -> y; y -> x; x -> y ; y -> z; ```; where the above letter stands for the ""free"" direction (the direction that is completely local). We always start from the `z` configuration because we do not want to support z-decompositions (because of possible vertical integrals and implicit vertical diffusion). ; The FFT based algorithm is ; ```julia; z_transform! ; z -> y; y_transform!; y -> x; x_transform!; division by λ; x_transform!; x -> y ; y_transform!; y -> z; z_transform!; ```; The whole procedure needs 4 transposes for pencil decomposition and 2 for slab decomposition.; I am still working on implementing the Fourier tridiagonal solver, which is very easily done naively by increasing the number of transposes:; ```julia; z -> y; y_transform!; y -> x; x_transform!; x -> y ; y -> z; tridiagonal_solve!; z -> y; y_transform!; y -> x; x_transform!; x -> y; y -> z; ```; This requires 8 transposes though, which would kill any possibility of scaling even if we completely fill the GPU memory.; I would like to ensure that we always do a maximum of 4 transposes (2 forward and 2 backward).; This means playing with memory in the background, I still have to do a little bit of thinking to ensure it, maybe I have to define other transposes like; ```julia; x -> z; z -> x; ```; which would remove two of them but it is slightly more complicated. This is because, in the previous transposes we switch partitioning between the in and out free direction while the third dimension remains untouched. On the other hand, z-configuration and x-configuration also have a differently partitioned y-direction which makes the transpose process between `x` and `z` non-trivial",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132:1662,Deployability,configurat,configuration,1662,"At the moment, this PR allows slab decomposition in x and y, and pencil decomposition in x, y.; This PR implements these transposes:; ```julia; z -> y; y -> x; x -> y ; y -> z; ```; where the above letter stands for the ""free"" direction (the direction that is completely local). We always start from the `z` configuration because we do not want to support z-decompositions (because of possible vertical integrals and implicit vertical diffusion). ; The FFT based algorithm is ; ```julia; z_transform! ; z -> y; y_transform!; y -> x; x_transform!; division by λ; x_transform!; x -> y ; y_transform!; y -> z; z_transform!; ```; The whole procedure needs 4 transposes for pencil decomposition and 2 for slab decomposition.; I am still working on implementing the Fourier tridiagonal solver, which is very easily done naively by increasing the number of transposes:; ```julia; z -> y; y_transform!; y -> x; x_transform!; x -> y ; y -> z; tridiagonal_solve!; z -> y; y_transform!; y -> x; x_transform!; x -> y; y -> z; ```; This requires 8 transposes though, which would kill any possibility of scaling even if we completely fill the GPU memory.; I would like to ensure that we always do a maximum of 4 transposes (2 forward and 2 backward).; This means playing with memory in the background, I still have to do a little bit of thinking to ensure it, maybe I have to define other transposes like; ```julia; x -> z; z -> x; ```; which would remove two of them but it is slightly more complicated. This is because, in the previous transposes we switch partitioning between the in and out free direction while the third dimension remains untouched. On the other hand, z-configuration and x-configuration also have a differently partitioned y-direction which makes the transpose process between `x` and `z` non-trivial",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132:1682,Deployability,configurat,configuration,1682,"At the moment, this PR allows slab decomposition in x and y, and pencil decomposition in x, y.; This PR implements these transposes:; ```julia; z -> y; y -> x; x -> y ; y -> z; ```; where the above letter stands for the ""free"" direction (the direction that is completely local). We always start from the `z` configuration because we do not want to support z-decompositions (because of possible vertical integrals and implicit vertical diffusion). ; The FFT based algorithm is ; ```julia; z_transform! ; z -> y; y_transform!; y -> x; x_transform!; division by λ; x_transform!; x -> y ; y_transform!; y -> z; z_transform!; ```; The whole procedure needs 4 transposes for pencil decomposition and 2 for slab decomposition.; I am still working on implementing the Fourier tridiagonal solver, which is very easily done naively by increasing the number of transposes:; ```julia; z -> y; y_transform!; y -> x; x_transform!; x -> y ; y -> z; tridiagonal_solve!; z -> y; y_transform!; y -> x; x_transform!; x -> y; y -> z; ```; This requires 8 transposes though, which would kill any possibility of scaling even if we completely fill the GPU memory.; I would like to ensure that we always do a maximum of 4 transposes (2 forward and 2 backward).; This means playing with memory in the background, I still have to do a little bit of thinking to ensure it, maybe I have to define other transposes like; ```julia; x -> z; z -> x; ```; which would remove two of them but it is slightly more complicated. This is because, in the previous transposes we switch partitioning between the in and out free direction while the third dimension remains untouched. On the other hand, z-configuration and x-configuration also have a differently partitioned y-direction which makes the transpose process between `x` and `z` non-trivial",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132:308,Modifiability,config,configuration,308,"At the moment, this PR allows slab decomposition in x and y, and pencil decomposition in x, y.; This PR implements these transposes:; ```julia; z -> y; y -> x; x -> y ; y -> z; ```; where the above letter stands for the ""free"" direction (the direction that is completely local). We always start from the `z` configuration because we do not want to support z-decompositions (because of possible vertical integrals and implicit vertical diffusion). ; The FFT based algorithm is ; ```julia; z_transform! ; z -> y; y_transform!; y -> x; x_transform!; division by λ; x_transform!; x -> y ; y_transform!; y -> z; z_transform!; ```; The whole procedure needs 4 transposes for pencil decomposition and 2 for slab decomposition.; I am still working on implementing the Fourier tridiagonal solver, which is very easily done naively by increasing the number of transposes:; ```julia; z -> y; y_transform!; y -> x; x_transform!; x -> y ; y -> z; tridiagonal_solve!; z -> y; y_transform!; y -> x; x_transform!; x -> y; y -> z; ```; This requires 8 transposes though, which would kill any possibility of scaling even if we completely fill the GPU memory.; I would like to ensure that we always do a maximum of 4 transposes (2 forward and 2 backward).; This means playing with memory in the background, I still have to do a little bit of thinking to ensure it, maybe I have to define other transposes like; ```julia; x -> z; z -> x; ```; which would remove two of them but it is slightly more complicated. This is because, in the previous transposes we switch partitioning between the in and out free direction while the third dimension remains untouched. On the other hand, z-configuration and x-configuration also have a differently partitioned y-direction which makes the transpose process between `x` and `z` non-trivial",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132:1662,Modifiability,config,configuration,1662,"At the moment, this PR allows slab decomposition in x and y, and pencil decomposition in x, y.; This PR implements these transposes:; ```julia; z -> y; y -> x; x -> y ; y -> z; ```; where the above letter stands for the ""free"" direction (the direction that is completely local). We always start from the `z` configuration because we do not want to support z-decompositions (because of possible vertical integrals and implicit vertical diffusion). ; The FFT based algorithm is ; ```julia; z_transform! ; z -> y; y_transform!; y -> x; x_transform!; division by λ; x_transform!; x -> y ; y_transform!; y -> z; z_transform!; ```; The whole procedure needs 4 transposes for pencil decomposition and 2 for slab decomposition.; I am still working on implementing the Fourier tridiagonal solver, which is very easily done naively by increasing the number of transposes:; ```julia; z -> y; y_transform!; y -> x; x_transform!; x -> y ; y -> z; tridiagonal_solve!; z -> y; y_transform!; y -> x; x_transform!; x -> y; y -> z; ```; This requires 8 transposes though, which would kill any possibility of scaling even if we completely fill the GPU memory.; I would like to ensure that we always do a maximum of 4 transposes (2 forward and 2 backward).; This means playing with memory in the background, I still have to do a little bit of thinking to ensure it, maybe I have to define other transposes like; ```julia; x -> z; z -> x; ```; which would remove two of them but it is slightly more complicated. This is because, in the previous transposes we switch partitioning between the in and out free direction while the third dimension remains untouched. On the other hand, z-configuration and x-configuration also have a differently partitioned y-direction which makes the transpose process between `x` and `z` non-trivial",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132:1682,Modifiability,config,configuration,1682,"At the moment, this PR allows slab decomposition in x and y, and pencil decomposition in x, y.; This PR implements these transposes:; ```julia; z -> y; y -> x; x -> y ; y -> z; ```; where the above letter stands for the ""free"" direction (the direction that is completely local). We always start from the `z` configuration because we do not want to support z-decompositions (because of possible vertical integrals and implicit vertical diffusion). ; The FFT based algorithm is ; ```julia; z_transform! ; z -> y; y_transform!; y -> x; x_transform!; division by λ; x_transform!; x -> y ; y_transform!; y -> z; z_transform!; ```; The whole procedure needs 4 transposes for pencil decomposition and 2 for slab decomposition.; I am still working on implementing the Fourier tridiagonal solver, which is very easily done naively by increasing the number of transposes:; ```julia; z -> y; y_transform!; y -> x; x_transform!; x -> y ; y -> z; tridiagonal_solve!; z -> y; y_transform!; y -> x; x_transform!; x -> y; y -> z; ```; This requires 8 transposes though, which would kill any possibility of scaling even if we completely fill the GPU memory.; I would like to ensure that we always do a maximum of 4 transposes (2 forward and 2 backward).; This means playing with memory in the background, I still have to do a little bit of thinking to ensure it, maybe I have to define other transposes like; ```julia; x -> z; z -> x; ```; which would remove two of them but it is slightly more complicated. This is because, in the previous transposes we switch partitioning between the in and out free direction while the third dimension remains untouched. On the other hand, z-configuration and x-configuration also have a differently partitioned y-direction which makes the transpose process between `x` and `z` non-trivial",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1854403078:31,Testability,benchmark,benchmarking,31,Should we put some preliminary benchmarking results here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1854403078
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986288526:135,Availability,error,errors,135,"If you want to give it a try it's cool, I just tried reviving this branch which was a bit stale so probably there are going to be some errors to fix. There are mainly four files that deal with the distributed Poisson solver.; The distributed FFT implementation is in ; `DistributedComputations/distributed_fft_based_poisson_solver.jl` where the plan setup is in `DistributedComputations/plan_distributed_transforms.jl`. The transpose is defined in `DistributedComputations/transpose_parallel_fields.jl` and its setup is in `DistributedComputations/parallel_fields.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986288526
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986306179:11,Performance,bottleneck,bottlenecks,11,The actual bottlenecks (as seen from the profile) are the transpose steps. The FFT steps are basically irrelevant.; This file shows how to setup and perform the transposes; https://github.com/CliMA/Oceananigans.jl/blob/ss/distributed-fft/test/test_distributed_transpose.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986306179
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986306179:149,Performance,perform,perform,149,The actual bottlenecks (as seen from the profile) are the transpose steps. The FFT steps are basically irrelevant.; This file shows how to setup and perform the transposes; https://github.com/CliMA/Oceananigans.jl/blob/ss/distributed-fft/test/test_distributed_transpose.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986306179
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986306179:238,Testability,test,test,238,The actual bottlenecks (as seen from the profile) are the transpose steps. The FFT steps are basically irrelevant.; This file shows how to setup and perform the transposes; https://github.com/CliMA/Oceananigans.jl/blob/ss/distributed-fft/test/test_distributed_transpose.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986306179
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178894494:369,Energy Efficiency,power,power,369,"Do you mean saving outputs in Fourier space?. The objective of this PR is only to enable multi-GPU support for the nonhydrostatic model through MPI. ; Saving in Fourier space is independent of the single/multiple GPU framework and could be worked on as an independent PR.; I am not very sure you would want such a feature though, maybe a feature to automatically build power spectra and cospectra would be nice",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178894494
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178922830:63,Performance,perform,perform,63,"Thanks for clarifying. Yes, I was thinking about being able to perform fit in any dimension you choose and save outputs like this. Putting the heavy load on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178922830
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178922830:149,Performance,load,load,149,"Thanks for clarifying. Yes, I was thinking about being able to perform fit in any dimension you choose and save outputs like this. Putting the heavy load on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178922830
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740:275,Deployability,pipeline,pipeline,275,"Ready to be reviewed. I could not make the oceanic les regression test work for the moment, but we still have to build a bit on this PR so this is a good starting point to not blow up this PR too much. Next steps should be; - include an example (to be ran on the distributed pipeline); - include a tridiagonal solve; - relax the constraints on the divisibility of the grid size by the ranks, this will require a bit of experimenting but it can be easily done by modifying the buffers in `TransposableField` to be of variable size",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740:516,Modifiability,variab,variable,516,"Ready to be reviewed. I could not make the oceanic les regression test work for the moment, but we still have to build a bit on this PR so this is a good starting point to not blow up this PR too much. Next steps should be; - include an example (to be ran on the distributed pipeline); - include a tridiagonal solve; - relax the constraints on the divisibility of the grid size by the ranks, this will require a bit of experimenting but it can be easily done by modifying the buffers in `TransposableField` to be of variable size",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740:66,Testability,test,test,66,"Ready to be reviewed. I could not make the oceanic les regression test work for the moment, but we still have to build a bit on this PR so this is a good starting point to not blow up this PR too much. Next steps should be; - include an example (to be ran on the distributed pipeline); - include a tridiagonal solve; - relax the constraints on the divisibility of the grid size by the ranks, this will require a bit of experimenting but it can be easily done by modifying the buffers in `TransposableField` to be of variable size",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:416,Deployability,configurat,configuration,416,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:451,Deployability,configurat,configuration,451,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:342,Integrability,rout,routine,342,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:416,Modifiability,config,configuration,416,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:451,Modifiability,config,configuration,451,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:303,Performance,perform,performed,303,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007:229,Energy Efficiency,adapt,adapted,229,Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007:229,Modifiability,adapt,adapted,229,Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003:231,Energy Efficiency,adapt,adapted,231,"> Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?. I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; ```julia; transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.forward.x!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ; # Perform the implicit vertical solve here on storage.zfield... transpose_z_to_y!(storage); solver.plan.backward.y!(parent(storage.yfield), buffer.y); transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.backward.y!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ```. This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003:231,Modifiability,adapt,adapted,231,"> Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?. I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; ```julia; transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.forward.x!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ; # Perform the implicit vertical solve here on storage.zfield... transpose_z_to_y!(storage); solver.plan.backward.y!(parent(storage.yfield), buffer.y); transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.backward.y!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ```. This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003:807,Performance,Perform,Perform,807,"> Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?. I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; ```julia; transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.forward.x!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ; # Perform the implicit vertical solve here on storage.zfield... transpose_z_to_y!(storage); solver.plan.backward.y!(parent(storage.yfield), buffer.y); transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.backward.y!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ```. This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925:233,Energy Efficiency,adapt,adapted,233,"> > Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?; > ; > I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; > ; > ```julia; > transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; > solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.forward.x!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ; > # Perform the implicit vertical solve here on storage.zfield...; > ; > transpose_z_to_y!(storage); > solver.plan.backward.y!(parent(storage.yfield), buffer.y); > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.backward.y!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ```; > ; > This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538. Can you just say, you are planning to implement the algorithm in #2538? The way you describe it, I can't figure out if you are coming up with something new or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925:233,Modifiability,adapt,adapted,233,"> > Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?; > ; > I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; > ; > ```julia; > transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; > solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.forward.x!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ; > # Perform the implicit vertical solve here on storage.zfield...; > ; > transpose_z_to_y!(storage); > solver.plan.backward.y!(parent(storage.yfield), buffer.y); > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.backward.y!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ```; > ; > This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538. Can you just say, you are planning to implement the algorithm in #2538? The way you describe it, I can't figure out if you are coming up with something new or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925:837,Performance,Perform,Perform,837,"> > Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?; > ; > I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; > ; > ```julia; > transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; > solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.forward.x!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ; > # Perform the implicit vertical solve here on storage.zfield...; > ; > transpose_z_to_y!(storage); > solver.plan.backward.y!(parent(storage.yfield), buffer.y); > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.backward.y!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ```; > ; > This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538. Can you just say, you are planning to implement the algorithm in #2538? The way you describe it, I can't figure out if you are coming up with something new or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2233468948:98,Usability,clear,clearer,98,I have added a bit of documentation for the `transpose` functions. Now everything should be a bit clearer,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2233468948
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2259262179:92,Availability,error,error,92,> No stretched mesh is supported at the moment (that will come in a later PR). Will an info/error been thrown in this case?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2259262179
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2259299531:100,Availability,error,error,100,> > No stretched mesh is supported at the moment (that will come in a later PR); > ; > Will an info/error been thrown in this case?. It does now!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2259299531
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2267582185:1081,Availability,error,error,1081,"> > > This is looking great!; > > > Also, I see you're using MPI. Does this mean that we're not limited by the CUDA multi-GPU requirements? (I don't remember details, but I believe you can use only CUDA software and run multi-GPU, but only up to 8 GPUs and all on the same node or something...?); > > ; > > ; > > Yes this uses MPI which means that it should scale up to whatever number of GPUs you can get your hands on. There is no restriction in terms of infra or intra-node computations. The only restriction is that you need to user a number of tasks per node which are smaller or equal than the number of GPUs per node because there is a one-to-one mapping between a MPI rank and a GPU in the node.; > ; > Should we include something in the docs about this functionality? Or is it still considered experimental?. This is a bit hidden in the docstring here; https://github.com/CliMA/Oceananigans.jl/blob/7eeb9a064f884402afb3bc697ba8c8c8c9c773ee/src/DistributedComputations/distributed_architectures.jl#L200; but anyways when bulding the architecture this step will spit out an error if you are trying to set a device which does not exist on the node; https://github.com/CliMA/Oceananigans.jl/blob/7eeb9a064f884402afb3bc697ba8c8c8c9c773ee/src/DistributedComputations/distributed_architectures.jl#L236-L241. The change of the docstring is being addressed here #3673",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2267582185
https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2269883534:148,Integrability,depend,dependencies,148,Well it adds a new feature. I could just bump to 0.91.6 instead but it seems quite a major feature to justify the bump in version.; Also it removes dependencies on quite some packages.; What do people think?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2269883534
https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511:73,Testability,test,test,73,"Let me summarize my findings in the commit 4841c96. I wrote a new script test/test_multi_region_cubed_sphere_scalar_halos.jl to verify the correct halo filling for scalar fields at locations cca, fca, cfa, and ffa. I manually filled out the halos of the parent (off-set) array and compared them against the halos of the array filled out with the fill_halo_regions! function. At the ffa locations, the tests fail for all halos. At the cca, fca, and cfa locations, the tests fail for (a) the north and west halos of the odd-numbered panels 1, 3, 5 (with non-trivial connectivities), and (b) the south and east halos of the even-numbered panels 2, 4, 6 (with non-trivial connectivities). The tests which fail are currently commented out in the script test/test_multi_region_cubed_sphere_scalar_halos.jl. After some digging, I found out that both the latitude and longitude values are not correctly defined on these halos. . To delve into the root of the issue, I first replace the line ; ```julia; Ψᵣ(λ, φ, z) = - U * R * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)); ```; with; ```julia; Ψᵣ(λ, φ, z) = λ ; ```; in test/test_multi_region_cubed_sphere_scalar_halos.jl, and run the script:; ```julia; julia> include(""test/test_multi_region_cubed_sphere_scalar_halos.jl""); ```; Then I type the following commands over the terminal and study the output:; ```julia; julia> Nx, Ny, Nz = 3, 3, 1; (3, 3, 1). julia> grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, Nz), z = (0, 1), radius = 1, horizontal_direction_halo = 3, z_halo = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> data_1 = create_c_test_data(grid); Cubed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511
https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511:401,Testability,test,tests,401,"Let me summarize my findings in the commit 4841c96. I wrote a new script test/test_multi_region_cubed_sphere_scalar_halos.jl to verify the correct halo filling for scalar fields at locations cca, fca, cfa, and ffa. I manually filled out the halos of the parent (off-set) array and compared them against the halos of the array filled out with the fill_halo_regions! function. At the ffa locations, the tests fail for all halos. At the cca, fca, and cfa locations, the tests fail for (a) the north and west halos of the odd-numbered panels 1, 3, 5 (with non-trivial connectivities), and (b) the south and east halos of the even-numbered panels 2, 4, 6 (with non-trivial connectivities). The tests which fail are currently commented out in the script test/test_multi_region_cubed_sphere_scalar_halos.jl. After some digging, I found out that both the latitude and longitude values are not correctly defined on these halos. . To delve into the root of the issue, I first replace the line ; ```julia; Ψᵣ(λ, φ, z) = - U * R * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)); ```; with; ```julia; Ψᵣ(λ, φ, z) = λ ; ```; in test/test_multi_region_cubed_sphere_scalar_halos.jl, and run the script:; ```julia; julia> include(""test/test_multi_region_cubed_sphere_scalar_halos.jl""); ```; Then I type the following commands over the terminal and study the output:; ```julia; julia> Nx, Ny, Nz = 3, 3, 1; (3, 3, 1). julia> grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, Nz), z = (0, 1), radius = 1, horizontal_direction_halo = 3, z_halo = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> data_1 = create_c_test_data(grid); Cubed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511
https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511:467,Testability,test,tests,467,"Let me summarize my findings in the commit 4841c96. I wrote a new script test/test_multi_region_cubed_sphere_scalar_halos.jl to verify the correct halo filling for scalar fields at locations cca, fca, cfa, and ffa. I manually filled out the halos of the parent (off-set) array and compared them against the halos of the array filled out with the fill_halo_regions! function. At the ffa locations, the tests fail for all halos. At the cca, fca, and cfa locations, the tests fail for (a) the north and west halos of the odd-numbered panels 1, 3, 5 (with non-trivial connectivities), and (b) the south and east halos of the even-numbered panels 2, 4, 6 (with non-trivial connectivities). The tests which fail are currently commented out in the script test/test_multi_region_cubed_sphere_scalar_halos.jl. After some digging, I found out that both the latitude and longitude values are not correctly defined on these halos. . To delve into the root of the issue, I first replace the line ; ```julia; Ψᵣ(λ, φ, z) = - U * R * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)); ```; with; ```julia; Ψᵣ(λ, φ, z) = λ ; ```; in test/test_multi_region_cubed_sphere_scalar_halos.jl, and run the script:; ```julia; julia> include(""test/test_multi_region_cubed_sphere_scalar_halos.jl""); ```; Then I type the following commands over the terminal and study the output:; ```julia; julia> Nx, Ny, Nz = 3, 3, 1; (3, 3, 1). julia> grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, Nz), z = (0, 1), radius = 1, horizontal_direction_halo = 3, z_halo = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> data_1 = create_c_test_data(grid); Cubed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511
https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511:689,Testability,test,tests,689,"Let me summarize my findings in the commit 4841c96. I wrote a new script test/test_multi_region_cubed_sphere_scalar_halos.jl to verify the correct halo filling for scalar fields at locations cca, fca, cfa, and ffa. I manually filled out the halos of the parent (off-set) array and compared them against the halos of the array filled out with the fill_halo_regions! function. At the ffa locations, the tests fail for all halos. At the cca, fca, and cfa locations, the tests fail for (a) the north and west halos of the odd-numbered panels 1, 3, 5 (with non-trivial connectivities), and (b) the south and east halos of the even-numbered panels 2, 4, 6 (with non-trivial connectivities). The tests which fail are currently commented out in the script test/test_multi_region_cubed_sphere_scalar_halos.jl. After some digging, I found out that both the latitude and longitude values are not correctly defined on these halos. . To delve into the root of the issue, I first replace the line ; ```julia; Ψᵣ(λ, φ, z) = - U * R * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)); ```; with; ```julia; Ψᵣ(λ, φ, z) = λ ; ```; in test/test_multi_region_cubed_sphere_scalar_halos.jl, and run the script:; ```julia; julia> include(""test/test_multi_region_cubed_sphere_scalar_halos.jl""); ```; Then I type the following commands over the terminal and study the output:; ```julia; julia> Nx, Ny, Nz = 3, 3, 1; (3, 3, 1). julia> grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, Nz), z = (0, 1), radius = 1, horizontal_direction_halo = 3, z_halo = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> data_1 = create_c_test_data(grid); Cubed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511
https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511:748,Testability,test,test,748,"Let me summarize my findings in the commit 4841c96. I wrote a new script test/test_multi_region_cubed_sphere_scalar_halos.jl to verify the correct halo filling for scalar fields at locations cca, fca, cfa, and ffa. I manually filled out the halos of the parent (off-set) array and compared them against the halos of the array filled out with the fill_halo_regions! function. At the ffa locations, the tests fail for all halos. At the cca, fca, and cfa locations, the tests fail for (a) the north and west halos of the odd-numbered panels 1, 3, 5 (with non-trivial connectivities), and (b) the south and east halos of the even-numbered panels 2, 4, 6 (with non-trivial connectivities). The tests which fail are currently commented out in the script test/test_multi_region_cubed_sphere_scalar_halos.jl. After some digging, I found out that both the latitude and longitude values are not correctly defined on these halos. . To delve into the root of the issue, I first replace the line ; ```julia; Ψᵣ(λ, φ, z) = - U * R * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)); ```; with; ```julia; Ψᵣ(λ, φ, z) = λ ; ```; in test/test_multi_region_cubed_sphere_scalar_halos.jl, and run the script:; ```julia; julia> include(""test/test_multi_region_cubed_sphere_scalar_halos.jl""); ```; Then I type the following commands over the terminal and study the output:; ```julia; julia> Nx, Ny, Nz = 3, 3, 1; (3, 3, 1). julia> grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, Nz), z = (0, 1), radius = 1, horizontal_direction_halo = 3, z_halo = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> data_1 = create_c_test_data(grid); Cubed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511
https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511:1117,Testability,test,test,1117,"4841c96. I wrote a new script test/test_multi_region_cubed_sphere_scalar_halos.jl to verify the correct halo filling for scalar fields at locations cca, fca, cfa, and ffa. I manually filled out the halos of the parent (off-set) array and compared them against the halos of the array filled out with the fill_halo_regions! function. At the ffa locations, the tests fail for all halos. At the cca, fca, and cfa locations, the tests fail for (a) the north and west halos of the odd-numbered panels 1, 3, 5 (with non-trivial connectivities), and (b) the south and east halos of the even-numbered panels 2, 4, 6 (with non-trivial connectivities). The tests which fail are currently commented out in the script test/test_multi_region_cubed_sphere_scalar_halos.jl. After some digging, I found out that both the latitude and longitude values are not correctly defined on these halos. . To delve into the root of the issue, I first replace the line ; ```julia; Ψᵣ(λ, φ, z) = - U * R * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)); ```; with; ```julia; Ψᵣ(λ, φ, z) = λ ; ```; in test/test_multi_region_cubed_sphere_scalar_halos.jl, and run the script:; ```julia; julia> include(""test/test_multi_region_cubed_sphere_scalar_halos.jl""); ```; Then I type the following commands over the terminal and study the output:; ```julia; julia> Nx, Ny, Nz = 3, 3, 1; (3, 3, 1). julia> grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, Nz), z = (0, 1), radius = 1, horizontal_direction_halo = 3, z_halo = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> data_1 = create_c_test_data(grid); CubedSphereField{Center, Center, Center}; ├── g",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511
https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511:1217,Testability,test,test,1217," manually filled out the halos of the parent (off-set) array and compared them against the halos of the array filled out with the fill_halo_regions! function. At the ffa locations, the tests fail for all halos. At the cca, fca, and cfa locations, the tests fail for (a) the north and west halos of the odd-numbered panels 1, 3, 5 (with non-trivial connectivities), and (b) the south and east halos of the even-numbered panels 2, 4, 6 (with non-trivial connectivities). The tests which fail are currently commented out in the script test/test_multi_region_cubed_sphere_scalar_halos.jl. After some digging, I found out that both the latitude and longitude values are not correctly defined on these halos. . To delve into the root of the issue, I first replace the line ; ```julia; Ψᵣ(λ, φ, z) = - U * R * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)); ```; with; ```julia; Ψᵣ(λ, φ, z) = λ ; ```; in test/test_multi_region_cubed_sphere_scalar_halos.jl, and run the script:; ```julia; julia> include(""test/test_multi_region_cubed_sphere_scalar_halos.jl""); ```; Then I type the following commands over the terminal and study the output:; ```julia; julia> Nx, Ny, Nz = 3, 3, 1; (3, 3, 1). julia> grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, Nz), z = (0, 1), radius = 1, horizontal_direction_halo = 3, z_halo = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> data_1 = create_c_test_data(grid); CubedSphereField{Center, Center, Center}; ├── grid: 3×3×1 ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo; ├── boundary conditions: FieldBoundaryConditions; └── data: Mul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511
https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1744976086:29,Testability,test,test,29,How did the tracer advection test pass then?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1744976086
https://github.com/CliMA/Oceananigans.jl/pull/3282#issuecomment-1740441822:27,Testability,test,tests,27,@glwagner some `simulation-tests` are failing. Could you address that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3282#issuecomment-1740441822
https://github.com/CliMA/Oceananigans.jl/pull/3282#issuecomment-1749389837:153,Integrability,interface,interface,153,@glwagner is this PR breaking only because of the deletion of `MEWSVerticalDiffusivity`?. Or is there something else that's breaking in the `Simulation` interface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3282#issuecomment-1749389837
https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:938,Availability,down,down,938,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:128,Integrability,depend,depend,128,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:923,Modifiability,extend,extend,923,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:1618,Modifiability,parameteriz,parameterization,1618,"underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L247-L248. If we introduce a new parameter, say `minimum_entrainment_buoyancy_frequency`, then we can modify this criteria to read. ```julia; convecting = N² < 0 # applies regardless of Qᵇ . N²_entrainment = minimum_entrainment_buoyancy_frequency; entraining = (N²_above < 0) & (N² > N²_entrainment) (Qᵇ > 0); ```. Now the user can determine `minimum_entrainment_buoyancy_frequency` to stabilize their model. Probably some default like `minimum_entrainment_buoyancy_frequency = 1e-7` would work for Earth-like situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:1277,Usability,simpl,simple,1277,"t into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L247-L248. If we introduce a new parameter, say `minimum_entrainment_buoyancy_frequency`, then we can modify this criteria to read. ```julia; convecting = N² < 0 # applies regardless of Qᵇ . N²_entrainment = minimum_entrainment_buoyancy_frequency; entraining = (N²_above < 0) & (N² > ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:1288,Usability,simpl,simply,1288,"t into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L247-L248. If we introduce a new parameter, say `minimum_entrainment_buoyancy_frequency`, then we can modify this criteria to read. ```julia; convecting = N² < 0 # applies regardless of Qᵇ . N²_entrainment = minimum_entrainment_buoyancy_frequency; entraining = (N²_above < 0) & (N² > ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680:37,Integrability,interface,interface,37,"Is this extra simplicity in the user interface worth the extra code to maintain?. I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I also think a user can easily infer that `z` in the signature can be ignored if they just defined a grid with a `Flat` z topology, so I think the added user-friendliness is minor. (Maybe even negative since the signatures now can change based on `topology(grid)`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680:14,Usability,simpl,simplicity,14,"Is this extra simplicity in the user interface worth the extra code to maintain?. I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I also think a user can easily infer that `z` in the signature can be ignored if they just defined a grid with a `Flat` z topology, so I think the added user-friendliness is minor. (Maybe even negative since the signatures now can change based on `topology(grid)`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1395,Energy Efficiency,meter,meter,1395,"eans that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this chan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:39,Integrability,interface,interface,39,"> Is this extra simplicity in the user interface worth the extra code to maintain?. Given the minor code changes required and the priority we place on user interface, I think so. > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:156,Integrability,interface,interface,156,"> Is this extra simplicity in the user interface worth the extra code to maintain?. Given the minor code changes required and the priority we place on user interface, I think so. > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1485,Integrability,depend,depend,1485,"rection to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1523,Integrability,depend,depend,1523,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1727,Integrability,depend,depend,1727,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1790,Integrability,depend,depend,1790,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:2187,Integrability,depend,depends,2187,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:2219,Integrability,depend,dependent,2219,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:2155,Modifiability,variab,variables,2155,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:2323,Modifiability,variab,variables,2323,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:16,Usability,simpl,simplicity,16,"> Is this extra simplicity in the user interface worth the extra code to maintain?. Given the minor code changes required and the priority we place on user interface, I think so. > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777364648:419,Availability,error,errors,419,"> > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code.; > ; > I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. I just noticed that a lot of errors from new users that I've helped come from having the wrong function signatures, either when imposing initial or boundary conditions or forcings. With standardized ""3D"" function calls it makes it easier to catch. My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. But I guess your hope is that this will decrease the number of mistakes in the first place since the signatures hopefully will become more intuitive?. > I think the scripts read better with this change. Agreed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777364648
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777364648:899,Usability,intuit,intuitive,899,"> > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code.; > ; > I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. I just noticed that a lot of errors from new users that I've helped come from having the wrong function signatures, either when imposing initial or boundary conditions or forcings. With standardized ""3D"" function calls it makes it easier to catch. My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. But I guess your hope is that this will decrease the number of mistakes in the first place since the signatures hopefully will become more intuitive?. > I think the scripts read better with this change. Agreed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777364648
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777710858:141,Usability,intuit,intuitive,141,"> But I guess your hope is that this will decrease the number of mistakes in the first place since the signatures hopefully will become more intuitive?. It will make the function signatures more specific to the problem at hand, which broadly speaking eliminates more bugs. For example, in a one dimensional problem there is only one function argument, completely eliminating the possibility of mix up between two coordinates. But I think the main advantage is making the scripts more readable. I don't think there's much of a change to how ""intuitive"" the API is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777710858
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777710858:541,Usability,intuit,intuitive,541,"> But I guess your hope is that this will decrease the number of mistakes in the first place since the signatures hopefully will become more intuitive?. It will make the function signatures more specific to the problem at hand, which broadly speaking eliminates more bugs. For example, in a one dimensional problem there is only one function argument, completely eliminating the possibility of mix up between two coordinates. But I think the main advantage is making the scripts more readable. I don't think there's much of a change to how ""intuitive"" the API is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777710858
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:560,Availability,error,error,560,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:623,Availability,error,errors,623,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:244,Modifiability,variab,variables,244,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:368,Modifiability,variab,variables,368,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:455,Modifiability,variab,variable,455,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:479,Modifiability,variab,variables,479,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631
https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777718505:58,Availability,error,errors,58,> We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`. I like this idea!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777718505
https://github.com/CliMA/Oceananigans.jl/issues/3286#issuecomment-1735856663:47,Usability,simpl,simply,47,It may be the answer to several conundrums. Or simply not many use fields for BCs?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3286#issuecomment-1735856663
https://github.com/CliMA/Oceananigans.jl/pull/3287#issuecomment-1735858145:17,Testability,test,test,17,Should we have a test? Or could you demonstrably that what you did had a positive impact in resolving the issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3287#issuecomment-1735858145
https://github.com/CliMA/Oceananigans.jl/pull/3287#issuecomment-1737807119:20,Testability,test,tests,20,"Right, there are no tests (or examples, or docs) on using `Field` (rather than `Array`) as a boundary condition... How about an issue to change the docs and add a test in a future PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3287#issuecomment-1737807119
https://github.com/CliMA/Oceananigans.jl/pull/3287#issuecomment-1737807119:163,Testability,test,test,163,"Right, there are no tests (or examples, or docs) on using `Field` (rather than `Array`) as a boundary condition... How about an issue to change the docs and add a test in a future PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3287#issuecomment-1737807119
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732432961:25,Availability,error,error,25,Great work. . What's the error with `TimeInterval`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732432961
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732647490:55,Availability,avail,available,55,"How will we test code for Metal GPU? Is there anything available through github actions, or will we have to hook something up via buildkite?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732647490
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732647490:12,Testability,test,test,12,"How will we test code for Metal GPU? Is there anything available through github actions, or will we have to hook something up via buildkite?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732647490
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465:18,Availability,error,error,18,"Copy-pasting this error from the #2618 :. ```julia; model = HydrostaticFreeSurfaceModel(; grid); ERROR: Metal does not support Float64 values, try using Float32 instead; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] check_eltype(T::Type); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:32; [3] Metal.MtlArray{Float64, 3, Metal.MTL.MTLResourceStorageModePrivate}(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:50; [4] (Metal.MtlArray{Float64, 3})(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:98; [5] MtlArray; @ ~/.julia/packages/Metal/lnkVP/src/array.jl:157 [inlined]; [6] Metal.MtlArray(A::Array{Float64, 3}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:173; [7] arch_array(#unused#::Oceananigans.Architectures.MetalBackend, a::Array{Float64, 3}); @ Oceananigans.Architectures ~/Documents/Projects/Oceananigans.jl/src/Architectures.jl:75; [8] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}, planner_flag::UInt32); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:61; [9] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:51; [10] Oceananigans.Models.Hydr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465:97,Availability,ERROR,ERROR,97,"Copy-pasting this error from the #2618 :. ```julia; model = HydrostaticFreeSurfaceModel(; grid); ERROR: Metal does not support Float64 values, try using Float32 instead; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] check_eltype(T::Type); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:32; [3] Metal.MtlArray{Float64, 3, Metal.MTL.MTLResourceStorageModePrivate}(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:50; [4] (Metal.MtlArray{Float64, 3})(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:98; [5] MtlArray; @ ~/.julia/packages/Metal/lnkVP/src/array.jl:157 [inlined]; [6] Metal.MtlArray(A::Array{Float64, 3}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:173; [7] arch_array(#unused#::Oceananigans.Architectures.MetalBackend, a::Array{Float64, 3}); @ Oceananigans.Architectures ~/Documents/Projects/Oceananigans.jl/src/Architectures.jl:75; [8] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}, planner_flag::UInt32); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:61; [9] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:51; [10] Oceananigans.Models.Hydr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465:187,Availability,error,error,187,"Copy-pasting this error from the #2618 :. ```julia; model = HydrostaticFreeSurfaceModel(; grid); ERROR: Metal does not support Float64 values, try using Float32 instead; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] check_eltype(T::Type); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:32; [3] Metal.MtlArray{Float64, 3, Metal.MTL.MTLResourceStorageModePrivate}(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:50; [4] (Metal.MtlArray{Float64, 3})(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:98; [5] MtlArray; @ ~/.julia/packages/Metal/lnkVP/src/array.jl:157 [inlined]; [6] Metal.MtlArray(A::Array{Float64, 3}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:173; [7] arch_array(#unused#::Oceananigans.Architectures.MetalBackend, a::Array{Float64, 3}); @ Oceananigans.Architectures ~/Documents/Projects/Oceananigans.jl/src/Architectures.jl:75; [8] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}, planner_flag::UInt32); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:61; [9] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:51; [10] Oceananigans.Models.Hydr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465:214,Availability,error,error,214,"Copy-pasting this error from the #2618 :. ```julia; model = HydrostaticFreeSurfaceModel(; grid); ERROR: Metal does not support Float64 values, try using Float32 instead; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] check_eltype(T::Type); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:32; [3] Metal.MtlArray{Float64, 3, Metal.MTL.MTLResourceStorageModePrivate}(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:50; [4] (Metal.MtlArray{Float64, 3})(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:98; [5] MtlArray; @ ~/.julia/packages/Metal/lnkVP/src/array.jl:157 [inlined]; [6] Metal.MtlArray(A::Array{Float64, 3}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:173; [7] arch_array(#unused#::Oceananigans.Architectures.MetalBackend, a::Array{Float64, 3}); @ Oceananigans.Architectures ~/Documents/Projects/Oceananigans.jl/src/Architectures.jl:75; [8] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}, planner_flag::UInt32); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:61; [9] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:51; [10] Oceananigans.Models.Hydr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465:8819,Availability,avail,available,8819,"loat32, Vector{Float32}}, OffsetArrays.OffsetVector{Float32, Vector{Float32}}, OffsetArrays.OffsetVector{Float32, Vector{Float32}}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:95; [14] HydrostaticFreeSurfaceModel(; grid::RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetArrays.OffsetVector{Float32, Vector{Float32}}, OffsetArrays.OffsetVector{Float32, Vector{Float32}}, OffsetArrays.OffsetVector{Float32, Vector{Float32}}, Oceananigans.Architectures.MetalBackend}, clock::Clock{Float32}, momentum_advection::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, tracer_advection::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, buoyancy::SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{Symbol, Symbol}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:169; [15] top-level scope; @ REPL[5]:1; [16] top-level scope; @ ~/.julia/packages/Metal/lnkVP/src/initialization.jl:57; ```. The `eltype` of the grid is not being propagated here:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/HydrostaticFreeSurfaceModels/fft_based_implicit_free_surface_solver.jl#L61-L64. So that needs to be fixed. However, are FFTs available on Metal? If not, then no FFT code can be ported there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732656326:322,Availability,avail,available,322,"Thanks, I'll go through all the comments tomorrow!. ~~As far as I can tell there are no Julia FFT libraries yet based on this discussion https://discourse.julialang.org/t/metal-jl-does-not-speed-up-fft/95528/3 so~~(see below) I think that is going to be the main barrier at the moment. I don't think any metal runners are available for GitHub actions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732656326
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732656499:13,Availability,error,error,13,"> What's the error with `TimeInterval`?. I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732656499
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734214155:175,Performance,perform,performant,175,"Perhaps we could convert to this: https://github.com/DTolm/VkFFT which supports hardware-accelerated FFT on CUDA, Metal and lots of others. It looks like that library is more performant than `cuFFT` as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734214155
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698:15,Availability,error,error,15,"> > What's the error with `TimeInterval`?; > ; > I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel. (copy-pasting from #2618). One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698:829,Integrability,interface,interface,829,"> > What's the error with `TimeInterval`?; > ; > I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel. (copy-pasting from #2618). One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698:940,Modifiability,variab,variables,940,"> > What's the error with `TimeInterval`?; > ; > I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel. (copy-pasting from #2618). One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734543134:177,Performance,perform,performant,177,"> Perhaps we could convert to this: https://github.com/DTolm/VkFFT which supports hardware-accelerated FFT on CUDA, Metal and lots of others. It looks like that library is more performant than `cuFFT` as well. Why do we have to convert? Can we use that only for Metal?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734543134
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735296417:233,Safety,risk,risk,233,> Yeah we could just do it for Metal. I was just thinking it might be just as much effort as using it for all. I think it would be more effort if we take into account the need to rebenchmark a lot of cases. I also think it adds some risk...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735296417
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298477:124,Safety,risk,risk,124,"> I think it would be more effort if we take into account the need to rebenchmark a lot of cases. I also think it adds some risk... Yeah true, they do claim it is more peformant so maybe something to consider in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298477
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298954:30,Integrability,wrap,wrap,30,I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C. . Does anyone working on Oceananigans have experience doing that sort of thing?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298954
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503:414,Deployability,install,install,414,"> I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C.; > ; > Does anyone working on Oceananigans have experience doing that sort of thing?. Could be worth asking on julia slack! You'll have to ship an independent wrapper package (eg `VkFFT.jl`) and figure out how to precompile the binaries, right (so we can install everything from the REPL)?. Could be good for this PR to focus on getting explicit free surface to work, then build up the rest of the features after that. Doing this for real will also require figuring testing out I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503:32,Integrability,wrap,wrap,32,"> I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C.; > ; > Does anyone working on Oceananigans have experience doing that sort of thing?. Could be worth asking on julia slack! You'll have to ship an independent wrapper package (eg `VkFFT.jl`) and figure out how to precompile the binaries, right (so we can install everything from the REPL)?. Could be good for this PR to focus on getting explicit free surface to work, then build up the rest of the features after that. Doing this for real will also require figuring testing out I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503:318,Integrability,wrap,wrapper,318,"> I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C.; > ; > Does anyone working on Oceananigans have experience doing that sort of thing?. Could be worth asking on julia slack! You'll have to ship an independent wrapper package (eg `VkFFT.jl`) and figure out how to precompile the binaries, right (so we can install everything from the REPL)?. Could be good for this PR to focus on getting explicit free surface to work, then build up the rest of the features after that. Doing this for real will also require figuring testing out I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503:625,Testability,test,testing,625,"> I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C.; > ; > Does anyone working on Oceananigans have experience doing that sort of thing?. Could be worth asking on julia slack! You'll have to ship an independent wrapper package (eg `VkFFT.jl`) and figure out how to precompile the binaries, right (so we can install everything from the REPL)?. Could be good for this PR to focus on getting explicit free surface to work, then build up the rest of the features after that. Doing this for real will also require figuring testing out I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1740676312:19,Testability,test,tests,19,"weird that all the tests fail, when I run e.g. `RectilinearGrid(CPU(), FT, size=(16, 16, 16), extent=(1, 1, 1))` locally it works fine",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1740676312
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191:304,Modifiability,refactor,refactor,304,"> Curious what's the status of this effort to add Metal support to Oceananigans. It's crazy how easy it is to add this support, but the major limitation is that Metal only supports Float32. There hasn't been much effort to validate anything for Float32, though this is a worthwhile goal... Also if we do refactor this PR, I think we should probably put the Metal functionality in an extension, much as #3468 does.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191
https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191:223,Security,validat,validate,223,"> Curious what's the status of this effort to add Metal support to Oceananigans. It's crazy how easy it is to add this support, but the major limitation is that Metal only supports Float32. There hasn't been much effort to validate anything for Float32, though this is a worthwhile goal... Also if we do refactor this PR, I think we should probably put the Metal functionality in an extension, much as #3468 does.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191
https://github.com/CliMA/Oceananigans.jl/issues/3289#issuecomment-1734789419:141,Performance,perform,performant,141,"We have to debate the best choice... fate cannot decide it for us. I think split-explicit is probably the best choice for a default --- it's performant in all contexts, and potentially also the least complicated? I believe it will also handle nonlinearity better than an implicit formulation (which we don't support now, but could support in the future). @simone-silvestri can probably best advise. Not sure how the docstring diverged from the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3289#issuecomment-1734789419
https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074:61,Deployability,integrat,integrated,61,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074
https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074:409,Deployability,integrat,integrated,409,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074
https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074:61,Integrability,integrat,integrated,61,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074
https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074:409,Integrability,integrat,integrated,409,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074
https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074:1016,Usability,simpl,simplest,1016,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074
https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734543228:393,Usability,clear,clear,393,"> The movies don't play for me. Weird, they're playing for me on two different browsers... not sure what to do about that. > The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). True, but just to be clear, these simulations don't use any stretched grid direction, so I believe they don't use the tridiagonal solver, correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734543228
https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734754117:778,Testability,test,test,778,"> > The movies don't play for me.; > ; > Weird, they're playing for me on two different browsers... not sure what to do about that. There's nothing for you to do, I was on plane internet! I can see it now. I was just letting you know... > > The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver).; > ; > True, but just to be clear, these simulations don't use any stretched grid direction, so I believe they don't use the tridiagonal solver, correct?. Correct --- I just wanted to issue that warning in case there was more interest in vertically-periodic simulations (we basically don't test that situation, but it wouldn't be unreasonable to work on that).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734754117
https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734754117:516,Usability,clear,clear,516,"> > The movies don't play for me.; > ; > Weird, they're playing for me on two different browsers... not sure what to do about that. There's nothing for you to do, I was on plane internet! I can see it now. I was just letting you know... > > The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver).; > ; > True, but just to be clear, these simulations don't use any stretched grid direction, so I believe they don't use the tridiagonal solver, correct?. Correct --- I just wanted to issue that warning in case there was more interest in vertically-periodic simulations (we basically don't test that situation, but it wouldn't be unreasonable to work on that).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734754117
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:82,Availability,error,error,82,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:402,Availability,ERROR,ERROR,402,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:4320,Availability,error,error,4320,"actions.NDIteration.StaticSize{(30, 1)}, Tuple{Int64, Int64}, Tuple{Int64, Int64}}}, c::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, south_bc::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, north_bc::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.North, Oceananigans.MultiRegion.West, Oceananigans.MultiRegion.↺}}, loc::Tuple{Center, Center, Face}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, args::Tuple{}); @ Oceananigans.BoundaryConditions ./none:0; ```. Upon inspection, the root of the problem appears to stem from the type specification of BoundaryCondition in the methods _fill_west_halo!, _fill_east_halo!, _fill_south_halo!, and _fill_north_halo!. I attempted to resolve the issue by adding MCBC to the union of type specifications in the pertinent methods. However, this did not rectify the error. It became evident that numerous other locations required modifications. Moreover, I realized we might be invoking the incorrect methods. Specifically, the methods fill_west_halo!, fill_east_halo!, fill_south_halo!, and fill_north_halo! defined in src/MultiRegion/multi_region_boundary_conditions.jl should be referenced. Instead, we are calling their underscore-prefixed counterparts from src/BoundaryConditions scripts. @navidcy, @glwagner and @simone-silvestri, what is the most effective strategy to address and resolve this issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:409,Performance,Load,LoadError,409,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:14,Security,validat,validation,14,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:138,Security,validat,validation,138,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742744955:142,Usability,simpl,simpler,142,"I'm trying to debug the situation and the code hangs long time at model construction. Is this happening for you @siddharthabishnu?. Even this simpler:. ```Julia; using Oceananigans. grid = ConformalCubedSphereGrid(; panel_size = (10, 10, 2),; z = (-1, 0),; horizontal_direction_halo = 3). model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); ```. took 10 min to run.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742744955
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742939924:150,Usability,simpl,simpler,150,"> I'm trying to debug the situation and the code hangs long time at model construction. Is this happening for you @siddharthabishnu?; > ; > Even this simpler:; > ; > ```julia; > using Oceananigans; > ; > grid = ConformalCubedSphereGrid(; panel_size = (10, 10, 2),; > z = (-1, 0),; > horizontal_direction_halo = 3); > ; > model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); > ```; > ; > took 10 min to run. Yes, it happened for me too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742939924
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743107148:172,Availability,error,error,172,@siddharthabishnu this remark is relevant:. https://github.com/CliMA/Oceananigans.jl/blob/7e411f63c4f763ef79cc1464dbaf66e34bde72f4/src/Fields/field.jl#L704-L720. since the error you came across comes from filling the halo region of the free surface which _is_ actually a field with non-trivial indices.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743107148
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743270262:42,Testability,test,testing,42,@navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743270262
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:204,Availability,error,error,204,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:1524,Availability,error,errors,1524,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:1668,Availability,ERROR,ERROR,1668,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:1808,Availability,error,error,1808,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:1833,Availability,ERROR,ERROR,1833,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:1675,Performance,Load,LoadError,1675,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:1840,Performance,Load,LoadError,1840,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:642,Security,validat,validation,642,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:44,Testability,test,testing,44,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:59,Availability,error,errors,59,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:211,Availability,ERROR,ERROR,211,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:359,Availability,error,error,359,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:392,Availability,ERROR,ERROR,392,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:218,Performance,Load,LoadError,218,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:399,Performance,Load,LoadError,399,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:61,Availability,error,errors,61,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:213,Availability,ERROR,ERROR,213,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:427,Availability,error,error,427,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:460,Availability,ERROR,ERROR,460,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:220,Performance,Load,LoadError,220,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:467,Performance,Load,LoadError,467,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924:181,Security,validat,validation,181,"@siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at . https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924:32,Usability,simpl,simpler,32,"@siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at . https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234:188,Security,validat,validation,188,"> @siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63. Thanks @navidcy. Switching to fully explicit free surface from the default implicit one resolved the boundary condition issue I mentioned in the beginning of this conversation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234
https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234:34,Usability,simpl,simpler,34,"> @siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63. Thanks @navidcy. Switching to fully explicit free surface from the default implicit one resolved the boundary condition issue I mentioned in the beginning of this conversation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747335909:132,Energy Efficiency,reduce,reduced,132,it blows up at some point... . https://github.com/CliMA/Oceananigans.jl/assets/7112768/b8396af4-810e-4584-85d6-18431deb4bc4. I even reduced the tilmestep but not sure if it's that or corner-related artifacts,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747335909
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747422980:84,Energy Efficiency,reduce,reduced,84,> it blows up at some point...; > ; > cubed_sphere_momentum_dynamics.mp4 ; > I even reduced the tilmestep but not sure if it's that or corner-related artifacts. Might help to plot vorticity. Are we using WENO or second order momentum advection?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747422980
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747517934:85,Energy Efficiency,reduce,reduced,85,> > it blows up at some point...; > > cubed_sphere_momentum_dynamics.mp4; > > I even reduced the tilmestep but not sure if it's that or corner-related artifacts; > ; > Might help to plot vorticity. Are we using WENO or second order momentum advection?. I didn't prescribe anything so probably 2nd order.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747517934
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747519294:91,Energy Efficiency,reduce,reduced,91,"> > > it blows up at some point...; > > > cubed_sphere_momentum_dynamics.mp4; > > > I even reduced the tilmestep but not sure if it's that or corner-related artifacts; > > ; > > ; > > Might help to plot vorticity. Are we using WENO or second order momentum advection?; > ; > I didn't prescribe anything so probably 2nd order. Could be the culprit if we don't have viscosity, how about with viscosity or WENO?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747519294
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1748724414:51,Security,validat,validation,51,"@siddharthabishnu, can you commit the steady-state validation script in this PR from #3302? We were trying to ensure that double halo passing occurs for velocities etc and these are probably also needed for #3302 so let's have both validation scripts in one place so we don't do double job?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1748724414
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1748724414:232,Security,validat,validation,232,"@siddharthabishnu, can you commit the steady-state validation script in this PR from #3302? We were trying to ensure that double halo passing occurs for velocities etc and these are probably also needed for #3302 so let's have both validation scripts in one place so we don't do double job?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1748724414
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1749381446:53,Security,validat,validation,53,"> @siddharthabishnu, can you commit the steady-state validation script in this PR from #3302? We were trying to ensure that double halo passing occurs for velocities etc and these are probably also needed for #3302 so let's have both validation scripts in one place so we don't do double job?. Done. 😊",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1749381446
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1749381446:234,Security,validat,validation,234,"> @siddharthabishnu, can you commit the steady-state validation script in this PR from #3302? We were trying to ensure that double halo passing occurs for velocities etc and these are probably also needed for #3302 so let's have both validation scripts in one place so we don't do double job?. Done. 😊",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1749381446
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341:718,Safety,redund,redundancy,718,"There is a script at https://github.com/CliMA/Oceananigans.jl/blob/ncc-glw/cubed-sphere-dynamics/validation/multi_region/cubed_sphere_vorticity.jl. ![vorticity](https://github.com/CliMA/Oceananigans.jl/assets/7112768/fcf66cf7-c257-4fd0-bc5a-39cb79a6bc92). So computing the vorticity there are 6 holes on the 2 corners that do not correspond to an interior point. These are the. `i = 1, j = Ny+1` points for odd panels and `i = Nx+1, j = 1` for even panels. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. One idea is to have each panel of the cubed sphere span until, e.g., `Nx+1` or `Ny+1`. We will have redundancy in the computations but will sort the other issue. Otherwise we just want to call the vorticity kernel on those 3 points; do we do it in a different kernel? Before calling the kernel we need to ensure that the horizontal velocities have their halo regions filled right as the circulation around those points involves some velocities in the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341:97,Security,validat,validation,97,"There is a script at https://github.com/CliMA/Oceananigans.jl/blob/ncc-glw/cubed-sphere-dynamics/validation/multi_region/cubed_sphere_vorticity.jl. ![vorticity](https://github.com/CliMA/Oceananigans.jl/assets/7112768/fcf66cf7-c257-4fd0-bc5a-39cb79a6bc92). So computing the vorticity there are 6 holes on the 2 corners that do not correspond to an interior point. These are the. `i = 1, j = Ny+1` points for odd panels and `i = Nx+1, j = 1` for even panels. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. One idea is to have each panel of the cubed sphere span until, e.g., `Nx+1` or `Ny+1`. We will have redundancy in the computations but will sort the other issue. Otherwise we just want to call the vorticity kernel on those 3 points; do we do it in a different kernel? Before calling the kernel we need to ensure that the horizontal velocities have their halo regions filled right as the circulation around those points involves some velocities in the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758655160:115,Testability,test,test,115,"Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`. The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758655160
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758655160:38,Usability,simpl,simply,38,"Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`. The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758655160
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251:124,Testability,test,test,124,"> Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > ; > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251:422,Testability,test,test,422,"> Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > ; > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251:40,Usability,simpl,simply,40,"> Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > ; > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128:528,Modifiability,extend,extend,528,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128:124,Testability,test,test,124,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128:384,Testability,test,test,384,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128:42,Usability,simpl,simply,42,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1780283208:584,Security,validat,validation,584,"> Relative vorticity plot from before (with non-essential halos) ![vorticity](https://user-images.githubusercontent.com/12926768/276471090-687faff4-f50d-492e-a024-1e67c4e24da0.png); > ; > Relative vorticity plot now (with non-essential halos filled with NaNs) ![vorticity](https://user-images.githubusercontent.com/12926768/276471138-aa5fac3f-b948-429c-a3e1-4f33a75bd0f4.png); > ; > At least the south-east corners of the odd panels are incorrect. Based on discussion with @navidcy, I overwrote the vorticity computation at the corners of all panels using only interior values in the validation script validation/multi_region/cubed_sphere_vorticity.jl. The vorticity field looks better now. However, the source code still needs to be fixed. . ![vorticity](https://github.com/CliMA/Oceananigans.jl/assets/12926768/2f8a203f-08f4-4541-9022-388b58fcbd50)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1780283208
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1780283208:602,Security,validat,validation,602,"> Relative vorticity plot from before (with non-essential halos) ![vorticity](https://user-images.githubusercontent.com/12926768/276471090-687faff4-f50d-492e-a024-1e67c4e24da0.png); > ; > Relative vorticity plot now (with non-essential halos filled with NaNs) ![vorticity](https://user-images.githubusercontent.com/12926768/276471138-aa5fac3f-b948-429c-a3e1-4f33a75bd0f4.png); > ; > At least the south-east corners of the odd panels are incorrect. Based on discussion with @navidcy, I overwrote the vorticity computation at the corners of all panels using only interior values in the validation script validation/multi_region/cubed_sphere_vorticity.jl. The vorticity field looks better now. However, the source code still needs to be fixed. . ![vorticity](https://github.com/CliMA/Oceananigans.jl/assets/12926768/2f8a203f-08f4-4541-9022-388b58fcbd50)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1780283208
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1944385984:1172,Integrability,Message,Message,1172,"tagging the wrong Navid…. ___________________________________________; Multidisciplinary Composer | Media Alchemist | Artist-Researcher; Associate Director, Topological Media Lab; Research Associate: Matralab, Milieux, HEXAGRAM, LASG; navidnavab.com <http://navidnavab.com> | 514.432.6633; ----------------------------------------------------------------------------. On Wed, Feb 14, 2024 at 12:47 AM Navid C. Constantinou <; ***@***.***> wrote:. > Thanks @navid <https://github.com/navid> for your suggestions above. I; > will incorporate them in subsequent commits.; >; > You can just click the button next to them and they are committed!; > Screenshot.2024-02-14.at.07.46.47.png (view on web); > <https://github.com/CliMA/Oceananigans.jl/assets/7112768/34363045-e8b1-4776-8436-a551babaa02e>; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1943122887>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDTZNCXD3DWZHODH2M3JLYTRFXFAVCNFSM6AAAAAA5S3QE4CVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSNBTGEZDEOBYG4>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1944385984
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232:10,Integrability,wrap,wrap,10,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232:102,Testability,test,test,102,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232
https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232:126,Usability,learn,learned,126,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232
https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1747959143:6,Availability,error,error,6,"Tests error with `UndefVarError: `settings` not defined`, e.g.,. https://buildkite.com/clima/oceananigans/builds/12688#018afd6b-fb54-446d-a3cc-c4d1c4f99dd1/18-366. This is related I believe to #3238.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1747959143
https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1747959143:0,Testability,Test,Tests,0,"Tests error with `UndefVarError: `settings` not defined`, e.g.,. https://buildkite.com/clima/oceananigans/builds/12688#018afd6b-fb54-446d-a3cc-c4d1c4f99dd1/18-366. This is related I believe to #3238.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1747959143
https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1748709615:63,Integrability,interface,interface,63,"Let's try to deal with #3238. There are some glitches with the interface that, e.g., @djlikesdjs and @siddharthabishnu have been stumbling upon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1748709615
https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1751137602:21,Integrability,depend,depends,21,Ok two PRs that this depends on now: #3311 and #3314 . I'll mark as draft to indicate that this is on hold for a little,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1751137602
https://github.com/CliMA/Oceananigans.jl/issues/3309#issuecomment-1749205412:147,Deployability,upgrade,upgrade,147,"I don't have time to open a PR for this, but based on the listed breaking changes, it's very likely we'll have to modify the code in order for the upgrade to work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3309#issuecomment-1749205412
https://github.com/CliMA/Oceananigans.jl/issues/3309#issuecomment-1757799076:23,Deployability,release,released,23,NCDatasets v0.13.1 was released,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3309#issuecomment-1757799076
https://github.com/CliMA/Oceananigans.jl/pull/3310#issuecomment-1763173952:12,Testability,test,tests,12,Distributed tests fail on cpu. Something related to CUDA? Any ideas? @simone-silvestri?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3310#issuecomment-1763173952
https://github.com/CliMA/Oceananigans.jl/pull/3311#issuecomment-1748796662:757,Availability,error,error,757,"At the moment, . ```Julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 10×1×10 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-100.0, 100.0) regularly spaced with Δx=20.0; ├── Flat y; └── Bounded z ∈ [-100.0, 0.0] regularly spaced with Δz=10.0. julia> free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); SplitExplicitFreeSurface with Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float64, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}(0.44706193949348216, Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function); ```; doesn't error!. (A show method is in order though...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3311#issuecomment-1748796662
https://github.com/CliMA/Oceananigans.jl/pull/3311#issuecomment-1748921269:564,Availability,avail,available,564,"> > > Why here we have `FT` as independent input and don't use `eltype(grid)`?; > > > https://github.com/CliMA/Oceananigans.jl/blob/afb46612df31dc7e841114b7f09229a2aca2a150/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L276; > > > ; > > > Can't this result to type instabilities?; > > ; > > ; > > I think the positional argument should be `grid` rather than `FT`.; > ; > I think so too. @simone-silvestri is there any reason it was done this way?. It's following the pattern for other constructors (but in those other cases, `grid` is not available). . We haven't written these conventions out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3311#issuecomment-1748921269
https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406:64,Integrability,interface,interface,64,"As part of this PR it would probably make sense to refactor the interface between `Simulation` and output writers a bit. For example, `Callback` has a place to insert custom `initialize!` but output writers do not:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Simulations/run.jl#L200-L214. The natural way to throw a warning would be during initialization, which should depend on both the output writer and the simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406
https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406:417,Integrability,depend,depend,417,"As part of this PR it would probably make sense to refactor the interface between `Simulation` and output writers a bit. For example, `Callback` has a place to insert custom `initialize!` but output writers do not:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Simulations/run.jl#L200-L214. The natural way to throw a warning would be during initialization, which should depend on both the output writer and the simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406
https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406:51,Modifiability,refactor,refactor,51,"As part of this PR it would probably make sense to refactor the interface between `Simulation` and output writers a bit. For example, `Callback` has a place to insert custom `initialize!` but output writers do not:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Simulations/run.jl#L200-L214. The natural way to throw a warning would be during initialization, which should depend on both the output writer and the simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749669791:14,Testability,test,tests,14,Are there any tests for distributed hydrostatic models?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749669791
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749687259:9,Testability,test,test,9,yeah in `test/test_distributed_models.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749687259
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749703750:284,Integrability,depend,depends,284,"@simone-silvestri `DistributedComputations` is imported before models here:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Oceananigans.jl#L221-L224. What was ""enable overlapping communication"" intended to support? Is there something that depends on whether `isnothing(mpi_requests)`? Perhaps more direct specification of this feature would help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749703750
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749705898:11,Testability,test,test,11,"> yeah in `test/test_distributed_models.jl`. There's no tests for `HydrostaticFreeSurfaceModel` there currently, just `NonhydrostaticModel`. . Is there another file with tests for `HydrostaticFreeSurfaceModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749705898
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749705898:56,Testability,test,tests,56,"> yeah in `test/test_distributed_models.jl`. There's no tests for `HydrostaticFreeSurfaceModel` there currently, just `NonhydrostaticModel`. . Is there another file with tests for `HydrostaticFreeSurfaceModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749705898
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749705898:170,Testability,test,tests,170,"> yeah in `test/test_distributed_models.jl`. There's no tests for `HydrostaticFreeSurfaceModel` there currently, just `NonhydrostaticModel`. . Is there another file with tests for `HydrostaticFreeSurfaceModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749705898
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1750495370:320,Safety,avoid,avoid,320,"Ok, I found in the docs for MPI.jl that. > Calling [MPI.Finalize()](https://juliaparallel.org/MPI.jl/stable/reference/environment/#MPI.Finalize) at the end of the program is optional, as it will be called automatically when Julia exits. This is good news. So we can call `MPI.Init()` when we build the architecture, and avoid `MPI.Finalize()`. This brings us one step closer to the ""one line to distributed simulations"" goal. https://github.com/JuliaParallel/MPI.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1750495370
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1751827723:118,Testability,test,tests,118,I don’t think we should fix the untested features in this PR. We need to merge this ASAP so we can open a new PR with tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1751827723
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1751827901:42,Testability,test,test,42,@simone-silvestri can you fix the failing test? As soon as tests pass please merge. We need a another PR that implements tests following this one.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1751827901
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1751827901:59,Testability,test,tests,59,@simone-silvestri can you fix the failing test? As soon as tests pass please merge. We need a another PR that implements tests following this one.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1751827901
https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1751827901:121,Testability,test,tests,121,@simone-silvestri can you fix the failing test? As soon as tests pass please merge. We need a another PR that implements tests following this one.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1751827901
https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718:357,Availability,ERROR,ERROR,357,"Done!. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0. julia> grid = RectilinearGrid(size=3, z= x->-x^2, topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z should have increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::var""#41#42"", dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:126; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::var""#41#42""); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Function); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[22]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718
https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718:227,Modifiability,variab,variably,227,"Done!. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0. julia> grid = RectilinearGrid(size=3, z= x->-x^2, topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z should have increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::var""#41#42"", dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:126; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::var""#41#42""); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Function); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[22]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718
https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751826882:126,Integrability,message,message,126,"If we check after the coordinate is created, we may only need to check once (the check is the same for all user input and the message is the same: the coordinate must be increasing)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751826882
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751595363:86,Security,access,access,86,"huh, do you think there is a bug in interpolation that causes an out of bounds memory access?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751595363
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991:56,Availability,error,errors,56,I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991:222,Availability,error,error,222,I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991:49,Security,access,access,49,I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751626241:37,Availability,error,error,37,I don't think this is the same as my error linked from before.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751626241
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:58,Availability,error,errors,58,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:224,Availability,error,error,224,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:370,Integrability,depend,depends,370,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:51,Security,access,access,51,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:304,Security,access,accessed,304,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:60,Availability,error,errors,60,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:226,Availability,error,error,226,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:379,Integrability,depend,depends,379,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:53,Security,access,access,53,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:313,Security,access,accessed,313,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853:20,Availability,error,error,20,Reading through the error message again I'm not sure its what I thought.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853:26,Integrability,message,message,26,Reading through the error message again I'm not sure its what I thought.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918:387,Availability,error,error,387,I find that the code for boundary conditions for particles cannot deal with unusually large velocity \(when $u\Delta t$ has the order of the domain size\). Fixing the related code \(Yixiao-Zhang/Oceananigans.jl@95f68a1\) enables running the script that I posted previously in this page. Do we need an additional test for such cases?. One remaining question is why the log shows that the error occurs from the pressure solver. Can we do anything to improve the accuracy of error messages?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918:472,Availability,error,error,472,I find that the code for boundary conditions for particles cannot deal with unusually large velocity \(when $u\Delta t$ has the order of the domain size\). Fixing the related code \(Yixiao-Zhang/Oceananigans.jl@95f68a1\) enables running the script that I posted previously in this page. Do we need an additional test for such cases?. One remaining question is why the log shows that the error occurs from the pressure solver. Can we do anything to improve the accuracy of error messages?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918:478,Integrability,message,messages,478,I find that the code for boundary conditions for particles cannot deal with unusually large velocity \(when $u\Delta t$ has the order of the domain size\). Fixing the related code \(Yixiao-Zhang/Oceananigans.jl@95f68a1\) enables running the script that I posted previously in this page. Do we need an additional test for such cases?. One remaining question is why the log shows that the error occurs from the pressure solver. Can we do anything to improve the accuracy of error messages?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918:312,Testability,test,test,312,I find that the code for boundary conditions for particles cannot deal with unusually large velocity \(when $u\Delta t$ has the order of the domain size\). Fixing the related code \(Yixiao-Zhang/Oceananigans.jl@95f68a1\) enables running the script that I posted previously in this page. Do we need an additional test for such cases?. One remaining question is why the log shows that the error occurs from the pressure solver. Can we do anything to improve the accuracy of error messages?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918:368,Testability,log,log,368,I find that the code for boundary conditions for particles cannot deal with unusually large velocity \(when $u\Delta t$ has the order of the domain size\). Fixing the related code \(Yixiao-Zhang/Oceananigans.jl@95f68a1\) enables running the script that I posted previously in this page. Do we need an additional test for such cases?. One remaining question is why the log shows that the error occurs from the pressure solver. Can we do anything to improve the accuracy of error messages?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:4,Availability,error,error,4,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:89,Availability,error,error,89,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:278,Availability,error,errors,278,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:10,Integrability,message,messages,10,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:69,Integrability,synchroniz,synchronized,69,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:188,Integrability,synchroniz,synchronized,188,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:50,Availability,error,errors,50,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:248,Availability,error,error,248,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:390,Availability,error,error,390,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:428,Availability,ERROR,ERROR,428,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:451,Availability,error,error,451,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:435,Performance,Load,LoadError,435,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:273,Security,access,access,273,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:476,Security,access,access,476,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105:69,Availability,error,errors,69,"It will be good if we have a standard procedure to debug certain GPU errors. However, after trying Simone's suggestions, I found that using `--check-bounds=yes` or running the code on a CPU cannot reproduce the error in the original script posted by me. The script just finishes without reporting any error. I understand that these suggested methods to debug CUDA errors are helpful generally, but they do not work in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105:211,Availability,error,error,211,"It will be good if we have a standard procedure to debug certain GPU errors. However, after trying Simone's suggestions, I found that using `--check-bounds=yes` or running the code on a CPU cannot reproduce the error in the original script posted by me. The script just finishes without reporting any error. I understand that these suggested methods to debug CUDA errors are helpful generally, but they do not work in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105:301,Availability,error,error,301,"It will be good if we have a standard procedure to debug certain GPU errors. However, after trying Simone's suggestions, I found that using `--check-bounds=yes` or running the code on a CPU cannot reproduce the error in the original script posted by me. The script just finishes without reporting any error. I understand that these suggested methods to debug CUDA errors are helpful generally, but they do not work in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105:364,Availability,error,errors,364,"It will be good if we have a standard procedure to debug certain GPU errors. However, after trying Simone's suggestions, I found that using `--check-bounds=yes` or running the code on a CPU cannot reproduce the error in the original script posted by me. The script just finishes without reporting any error. I understand that these suggested methods to debug CUDA errors are helpful generally, but they do not work in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783:90,Availability,error,error,90,"> I found that using --check-bounds=yes or running the code on a CPU cannot reproduce the error in the original script posted by me. Interesting --- does that mean that this is not an out-of-bounds issue?. > I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Are the NaNs appearing in the particle coordinates, or in the model velocity fields? The _default_ `NaNChecker` only checks the first entry in the model's prognostic field:. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Simulations/simulation.jl#L71. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Models/Models.jl#L163-L169. Note also that by default, the `NaNChecker` is only actuated every 100 iterations. You are free to use a different NaNChecker, however. The balance between the computational cost of checking NaNs / frequency of NaN checking and the cost of a time-step is use-case-specific. Can you clarify why you expect the model to abort itself when NaNs appear? Are you suggesting that we can improve the default NaN checker?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783:316,Availability,error,error,316,"> I found that using --check-bounds=yes or running the code on a CPU cannot reproduce the error in the original script posted by me. Interesting --- does that mean that this is not an out-of-bounds issue?. > I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Are the NaNs appearing in the particle coordinates, or in the model velocity fields? The _default_ `NaNChecker` only checks the first entry in the model's prognostic field:. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Simulations/simulation.jl#L71. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Models/Models.jl#L163-L169. Note also that by default, the `NaNChecker` is only actuated every 100 iterations. You are free to use a different NaNChecker, however. The balance between the computational cost of checking NaNs / frequency of NaN checking and the cost of a time-step is use-case-specific. Can you clarify why you expect the model to abort itself when NaNs appear? Are you suggesting that we can improve the default NaN checker?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783:235,Safety,abort,abort,235,"> I found that using --check-bounds=yes or running the code on a CPU cannot reproduce the error in the original script posted by me. Interesting --- does that mean that this is not an out-of-bounds issue?. > I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Are the NaNs appearing in the particle coordinates, or in the model velocity fields? The _default_ `NaNChecker` only checks the first entry in the model's prognostic field:. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Simulations/simulation.jl#L71. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Models/Models.jl#L163-L169. Note also that by default, the `NaNChecker` is only actuated every 100 iterations. You are free to use a different NaNChecker, however. The balance between the computational cost of checking NaNs / frequency of NaN checking and the cost of a time-step is use-case-specific. Can you clarify why you expect the model to abort itself when NaNs appear? Are you suggesting that we can improve the default NaN checker?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783:1056,Safety,abort,abort,1056,"> I found that using --check-bounds=yes or running the code on a CPU cannot reproduce the error in the original script posted by me. Interesting --- does that mean that this is not an out-of-bounds issue?. > I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Are the NaNs appearing in the particle coordinates, or in the model velocity fields? The _default_ `NaNChecker` only checks the first entry in the model's prognostic field:. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Simulations/simulation.jl#L71. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Models/Models.jl#L163-L169. Note also that by default, the `NaNChecker` is only actuated every 100 iterations. You are free to use a different NaNChecker, however. The balance between the computational cost of checking NaNs / frequency of NaN checking and the cost of a time-step is use-case-specific. Can you clarify why you expect the model to abort itself when NaNs appear? Are you suggesting that we can improve the default NaN checker?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783:309,Security,access,access,309,"> I found that using --check-bounds=yes or running the code on a CPU cannot reproduce the error in the original script posted by me. Interesting --- does that mean that this is not an out-of-bounds issue?. > I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Are the NaNs appearing in the particle coordinates, or in the model velocity fields? The _default_ `NaNChecker` only checks the first entry in the model's prognostic field:. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Simulations/simulation.jl#L71. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Models/Models.jl#L163-L169. Note also that by default, the `NaNChecker` is only actuated every 100 iterations. You are free to use a different NaNChecker, however. The balance between the computational cost of checking NaNs / frequency of NaN checking and the cost of a time-step is use-case-specific. Can you clarify why you expect the model to abort itself when NaNs appear? Are you suggesting that we can improve the default NaN checker?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:225,Availability,error,error,225,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:294,Availability,error,error,294,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:333,Availability,error,error,333,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:339,Integrability,message,message,339,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:77,Safety,abort,abort,77,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:129,Safety,abort,abort,129,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:195,Safety,abort,abort,195,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:320,Safety,abort,abort,320,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771934998:938,Security,access,access,938,"I went back to check your script and you should not expect NaNs in this simulation.; The model is initiated only with a u-velocity which is constant in x, there are no x-gradients, the grid is periodic in x and there are no boundary conditions nor viscosity that could affect the velocity field, thus the flow field is steady, and would not change also with much higher CFL numbers.; There are no tracers, so no possible NaNs there as well. Particles are lagrangian, they cannot NaN because they do not undergo numerical instability, the only thing that can happen is that they are shot in the x direction way beyond the periodic x-domain which will understandably produce out-of-bounds results when trying to interpolate the location in the grid. I believe that If you find NaNs there is a bug because that simulation should not produce any. You can set debugging level 2 in the Julia invocation (`julia -g2 --check-bounds=yes`) to have access to a more detailed stack trace on the GPU. ; https://cuda.juliagpu.org/stable/development/debugging/; Note that you need CUDA version 11.5 or higher to have access to a detailed stack trace",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771934998
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771934998:1102,Security,access,access,1102,"I went back to check your script and you should not expect NaNs in this simulation.; The model is initiated only with a u-velocity which is constant in x, there are no x-gradients, the grid is periodic in x and there are no boundary conditions nor viscosity that could affect the velocity field, thus the flow field is steady, and would not change also with much higher CFL numbers.; There are no tracers, so no possible NaNs there as well. Particles are lagrangian, they cannot NaN because they do not undergo numerical instability, the only thing that can happen is that they are shot in the x direction way beyond the periodic x-domain which will understandably produce out-of-bounds results when trying to interpolate the location in the grid. I believe that If you find NaNs there is a bug because that simulation should not produce any. You can set debugging level 2 in the Julia invocation (`julia -g2 --check-bounds=yes`) to have access to a more detailed stack trace on the GPU. ; https://cuda.juliagpu.org/stable/development/debugging/; Note that you need CUDA version 11.5 or higher to have access to a detailed stack trace",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771934998
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772894287:57,Availability,error,error,57,"Would a NaN in the velocity field cause an out-of-bounds error? Probably ensuring that does not happen would be relatively easy to fix. > will understandably produce out-of-bounds results when trying to interpolate the location in the grid. This is incorrect behavior though, right @simone-silvestri ? I thought the problem was with `Bounded`, not `Periodic`. The issue is when the velocity field + time-step is so high that multiple reflections across the entirety of a bounded direction occur in a single time-step. We don't model that situation. We can only handle a single reflection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772894287
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559:246,Availability,error,error,246,"I just checked the time evolution of the velocity field in this case. It seems to me that shear instability occurs when running the script on a GPU. However, the flow is steady when running the script on a CPU. Does CUDA introduce floating-point error that has x-dependence? Perhaps from the pressure solver?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559:263,Integrability,depend,dependence,263,"I just checked the time evolution of the velocity field in this case. It seems to me that shear instability occurs when running the script on a GPU. However, the flow is steady when running the script on a CPU. Does CUDA introduce floating-point error that has x-dependence? Perhaps from the pressure solver?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772922388:86,Testability,test,tests,86,"It shouldn't, unless you are looking at a regime that isn't covered in our regression tests / tests that closely inspect the difference between CPU and GPU results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772922388
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772922388:94,Testability,test,tests,94,"It shouldn't, unless you are looking at a regime that isn't covered in our regression tests / tests that closely inspect the difference between CPU and GPU results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772922388
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772995167:59,Availability,error,error,59,"> Would a NaN in the velocity field cause an out-of-bounds error? Probably ensuring that does not happen would be relatively easy to fix.; > ; > > will understandably produce out-of-bounds results when trying to interpolate the location in the grid.; > ; > This is incorrect behavior though, right @simone-silvestri ? I thought the problem was with `Bounded`, not `Periodic`. The issue is when the velocity field + time-step is so high that multiple reflections across the entirety of a bounded direction occur in a single time-step. We don't model that situation. We can only handle a single reflection. The particles should not move in `Bounded` directions as there is no v-velocity (and no way to produce one because of no Coriolis, no viscosity, and no friction at the boundaries). Particles should move only along the x-direction where they move out-of-bounds because `CFL=10` and the particle shoots out of the domain. Shear instability should not happen because there is no viscosity/coriolis/buoyancy. In my opinion the unexpected behavior (to be corrected) is to find a NaN or a reflection. @Yixiao-Zhang can you try running on CPU with `--check-bounds=yes` or on GPU with `-g2 --check-bounds=yes` you should get more information about the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772995167
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:95,Availability,error,errors,95,"When running the script on a CPU with `--check-bounds=yes`, the script can be finished without errors:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:825,Availability,error,error,825,"When running the script on a CPU with `--check-bounds=yes`, the script can be finished without errors:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:1041,Availability,ERROR,ERROR,1041,"imulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:2695,Availability,error,error,2695,"s).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:83 [inlined]; [9] macro expansion; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:145 [inlined]; [10] cpu__advect_particles!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; ...; ```. I do not see why viscosity/Coriolis/buoyancy is required for shear instability. Anyway, I found another way to reproduce the error on CPU, while keeping `CFL = 10`, is to introduce a small perturbation to the initial velocity field:; ```Julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```. The output error message is the same as the previous one, in which `CFL = 51`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:2969,Availability,error,error,2969,"s).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:83 [inlined]; [9] macro expansion; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:145 [inlined]; [10] cpu__advect_particles!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; ...; ```. I do not see why viscosity/Coriolis/buoyancy is required for shear instability. Anyway, I found another way to reproduce the error on CPU, while keeping `CFL = 10`, is to introduce a small perturbation to the initial velocity field:; ```Julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```. The output error message is the same as the previous one, in which `CFL = 51`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:2975,Integrability,message,message,2975,"s).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:83 [inlined]; [9] macro expansion; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:145 [inlined]; [10] cpu__advect_particles!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; ...; ```. I do not see why viscosity/Coriolis/buoyancy is required for shear instability. Anyway, I found another way to reproduce the error on CPU, while keeping `CFL = 10`, is to introduce a small perturbation to the initial velocity field:; ```Julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```. The output error message is the same as the previous one, in which `CFL = 51`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:1048,Performance,Load,LoadError,1048,"imulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:1083,Security,access,access,1083,"imulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:457,Usability,clear,clear,457,"When running the script on a CPU with `--check-bounds=yes`, the script can be finished without errors:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773039874:58,Availability,error,error,58,"I think I understand how particles cause an out-of-bounds error when the velocity is large. However, the difference between CPU and GPU simulations is another issue. Let me see whether I can reproduce this issue with a smaller `CFL`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773039874
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:98,Availability,error,error,98,"It's a problem of particles being advected in the x-direction. You can see that the out-of-bounds error is in the x-direction; `ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]`; You are moving out of the periodic grid because the particle is being advanced beyond the periodic domain.; There is no bouncing happening and it is not a problem of Bounded directions because the particle is not moving in the y- or in the z-direction. You are prescribing a steady state flow which is characterized by a u-velocity only. There is no tendency term that can develop a shear instability since a y-gradient in u is stable if there are no additional frictional forces, i.e.:; $$\frac{\partial u}{\partial t} = - \frac{\partial uu}{\partial x} - \frac{\partial uv}{\partial y} - \frac{\partial uw}{\partial z} - \frac{\partial p}{\partial x}$$; All the terms on the RHS of this equation are zero because; - $v = 0$; - $w = 0$; - $\frac{\partial uu}{\partial x} = 0$; - $\frac{\partial p}{\partial x} = 0$ since $\delta_x u^* + \delta_y v^* + \delta_z w^* = 0$ and you have periodic boundary conditions in the x-direction. from how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either includi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:128,Availability,ERROR,ERROR,128,"It's a problem of particles being advected in the x-direction. You can see that the out-of-bounds error is in the x-direction; `ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]`; You are moving out of the periodic grid because the particle is being advanced beyond the periodic domain.; There is no bouncing happening and it is not a problem of Bounded directions because the particle is not moving in the y- or in the z-direction. You are prescribing a steady state flow which is characterized by a u-velocity only. There is no tendency term that can develop a shear instability since a y-gradient in u is stable if there are no additional frictional forces, i.e.:; $$\frac{\partial u}{\partial t} = - \frac{\partial uu}{\partial x} - \frac{\partial uv}{\partial y} - \frac{\partial uw}{\partial z} - \frac{\partial p}{\partial x}$$; All the terms on the RHS of this equation are zero because; - $v = 0$; - $w = 0$; - $\frac{\partial uu}{\partial x} = 0$; - $\frac{\partial p}{\partial x} = 0$ since $\delta_x u^* + \delta_y v^* + \delta_z w^* = 0$ and you have periodic boundary conditions in the x-direction. from how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either includi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:3052,Integrability,wrap,wrap,3052," how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either including a y-gradient in v, a z-gradient in w to balance the x-gradient of u or by removing the x-gradient in u (not sure what pressure decides to do here, but I suspect it will add lateral flow components). In principle, this is a different dynamical case because if you introduce lateral velocity then tendencies will not be null anymore and the flow is not steady anymore. In this case, the flow can experience numerical instabilities when `CFL > 1`. The out-of-bounds issue is not the problem of the CFL being larger than the grid size, it's a problem of the CFL being larger than the size of the halo. You see this issue when the CFL is larger than the grid size because you initialize your particles at `x = 0`. If you initialize your particles at `x = Lx` you will have out-of-bounds problems with a much lower CFL (still larger than 1). This said we have a couple of ways to tackle this problem; - we issue a warning when CFL > 1 (in theory we should not run a simulation with CFL > 1 but that might be desired when we prescribe the velocity); - we wrap around the particle location if it falls outside of the domain in the periodic direction. The issue of CPU vs GPU sounds quite concerning, I ll try to investigate what is going on in your script",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:135,Performance,Load,LoadError,135,"It's a problem of particles being advected in the x-direction. You can see that the out-of-bounds error is in the x-direction; `ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]`; You are moving out of the periodic grid because the particle is being advanced beyond the periodic domain.; There is no bouncing happening and it is not a problem of Bounded directions because the particle is not moving in the y- or in the z-direction. You are prescribing a steady state flow which is characterized by a u-velocity only. There is no tendency term that can develop a shear instability since a y-gradient in u is stable if there are no additional frictional forces, i.e.:; $$\frac{\partial u}{\partial t} = - \frac{\partial uu}{\partial x} - \frac{\partial uv}{\partial y} - \frac{\partial uw}{\partial z} - \frac{\partial p}{\partial x}$$; All the terms on the RHS of this equation are zero because; - $v = 0$; - $w = 0$; - $\frac{\partial uu}{\partial x} = 0$; - $\frac{\partial p}{\partial x} = 0$ since $\delta_x u^* + \delta_y v^* + \delta_z w^* = 0$ and you have periodic boundary conditions in the x-direction. from how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either includi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:170,Security,access,access,170,"It's a problem of particles being advected in the x-direction. You can see that the out-of-bounds error is in the x-direction; `ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]`; You are moving out of the periodic grid because the particle is being advanced beyond the periodic domain.; There is no bouncing happening and it is not a problem of Bounded directions because the particle is not moving in the y- or in the z-direction. You are prescribing a steady state flow which is characterized by a u-velocity only. There is no tendency term that can develop a shear instability since a y-gradient in u is stable if there are no additional frictional forces, i.e.:; $$\frac{\partial u}{\partial t} = - \frac{\partial uu}{\partial x} - \frac{\partial uv}{\partial y} - \frac{\partial uw}{\partial z} - \frac{\partial p}{\partial x}$$; All the terms on the RHS of this equation are zero because; - $v = 0$; - $w = 0$; - $\frac{\partial uu}{\partial x} = 0$; - $\frac{\partial p}{\partial x} = 0$ since $\delta_x u^* + \delta_y v^* + \delta_z w^* = 0$ and you have periodic boundary conditions in the x-direction. from how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either includi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277
https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773314840:181,Integrability,depend,depends,181,"> (in theory we should not run a simulation with CFL > 1 but that might be desired when we prescribe the velocity). Aren't there time stepping schemes that can handle CFL > 1? This depends on the time-stepping scheme. Le and Moin 1991 claim that the theoretical limit for RK3 is 1.6. But there are other RK schemes with more stages that can handle even higher CFLs. I'm not sure there is a ""theory"" that places an absolute limit on the CFL for all possible schemes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773314840
https://github.com/CliMA/Oceananigans.jl/issues/3322#issuecomment-1755753805:366,Deployability,pipeline,pipeline,366,"> Documenter 1.0 had a lot of breaking changes and the version isn't pinned here so maybe that's the issue?. Btw, just a note: . The version of Documenter is pinned since we use the Docs/Manifest.toml and build the docs _without_ calling `Pkg.develop`... See, e.g., . https://github.com/CliMA/Oceananigans.jl/blob/4f26afb2b509870a5448943198b1b5c404a86430/.buildkite/pipeline.yml#L614. https://github.com/CliMA/Oceananigans.jl/blob/4f26afb2b509870a5448943198b1b5c404a86430/docs/make.jl#L5-L11. The above enforce the docs built to use the package versions from the `docs/Manifest.toml`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3322#issuecomment-1755753805
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292:292,Availability,error,error,292,"I guess when we made it so auxiliary fields can be field dependencies for forcings we a) only tested on nonhydrostatic models, and b) didn't implement for functional boundary conditions. I also have no idea how this didn't cause OceanBioME models I've run on HydrostaticFreeSurface models to error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292:57,Integrability,depend,dependencies,57,"I guess when we made it so auxiliary fields can be field dependencies for forcings we a) only tested on nonhydrostatic models, and b) didn't implement for functional boundary conditions. I also have no idea how this didn't cause OceanBioME models I've run on HydrostaticFreeSurface models to error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292:94,Testability,test,tested,94,"I guess when we made it so auxiliary fields can be field dependencies for forcings we a) only tested on nonhydrostatic models, and b) didn't implement for functional boundary conditions. I also have no idea how this didn't cause OceanBioME models I've run on HydrostaticFreeSurface models to error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755972885:190,Integrability,depend,dependant,190,"I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?. For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755972885
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756073240:34,Testability,test,testing,34,@glwagner is there a problem with testing at the moment?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756073240
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756078797:92,Availability,error,erroring,92,nono we are adding another pipeline for distributed as part of #3326. You can disregard the erroring of `buildkite/oceananigans-distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756078797
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756078797:27,Deployability,pipeline,pipeline,27,nono we are adding another pipeline for distributed as part of #3326. You can disregard the erroring of `buildkite/oceananigans-distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756078797
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756080047:94,Availability,error,erroring,94,"> nono we are adding another pipeline for distributed as part of #3326. You can disregard the erroring of `buildkite/oceananigans-distributed`. I see, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756080047
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756080047:29,Deployability,pipeline,pipeline,29,"> nono we are adding another pipeline for distributed as part of #3326. You can disregard the erroring of `buildkite/oceananigans-distributed`. I see, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756080047
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1757338739:198,Integrability,depend,dependant,198,"> I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > ; > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum. Thought more about this and I think it might be quite complicated to change to this so I will leave for now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1757338739
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255:198,Integrability,depend,dependant,198,"> > I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.; > ; > Thought more about this and I think it might be quite complicated to change to this so I will leave for now. That isn't what `fields` means right now (in fact, it doesn't have much of a concrete meaning at all and is defined rather vaguely, as it arbitrary omits some model fields while including others). Possibly, there is scope for another utility that returns something like ""prognostic + background fields, and selected auxiliary fields). Perhaps `forcing_fields` or something. However, I would pause a moment to consider whether this is the most useful abstraction for users. It may actually prove more limiting than helpful from the user perspective, as it is typically the case that a forcing function (such as a sponge layer) should depend only on perturbation fields rather than a ""total"" field representing perturbation + background...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255:1030,Integrability,depend,depend,1030,"> > I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.; > ; > Thought more about this and I think it might be quite complicated to change to this so I will leave for now. That isn't what `fields` means right now (in fact, it doesn't have much of a concrete meaning at all and is defined rather vaguely, as it arbitrary omits some model fields while including others). Possibly, there is scope for another utility that returns something like ""prognostic + background fields, and selected auxiliary fields). Perhaps `forcing_fields` or something. However, I would pause a moment to consider whether this is the most useful abstraction for users. It may actually prove more limiting than helpful from the user perspective, as it is typically the case that a forcing function (such as a sponge layer) should depend only on perturbation fields rather than a ""total"" field representing perturbation + background...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255:788,Usability,pause,pause,788,"> > I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.; > ; > Thought more about this and I think it might be quite complicated to change to this so I will leave for now. That isn't what `fields` means right now (in fact, it doesn't have much of a concrete meaning at all and is defined rather vaguely, as it arbitrary omits some model fields while including others). Possibly, there is scope for another utility that returns something like ""prognostic + background fields, and selected auxiliary fields). Perhaps `forcing_fields` or something. However, I would pause a moment to consider whether this is the most useful abstraction for users. It may actually prove more limiting than helpful from the user perspective, as it is typically the case that a forcing function (such as a sponge layer) should depend only on perturbation fields rather than a ""total"" field representing perturbation + background...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758278820:49,Testability,test,tests,49,@glwagner do you know what the problems with the tests are?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758278820
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758658201:51,Testability,test,tests,51,"> @glwagner do you know what the problems with the tests are?. No idea, I've restarted the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758658201
https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758658201:91,Testability,test,tests,91,"> @glwagner do you know what the problems with the tests are?. No idea, I've restarted the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758658201
https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-1756201850:64,Security,validat,validation,64,I think we can't move forward with this until we have a working validation script that uses it. So let's wait until #3306 is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-1756201850
https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543:839,Deployability,Update,Updated,839,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543
https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543:282,Energy Efficiency,reduce,reduced,282,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543
https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543:656,Testability,Log,Logical,656,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543
https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543:715,Testability,log,logical,715,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543
https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543:1022,Testability,test,tests,1022,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543
https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543:451,Usability,simpl,simplifies,451,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543
https://github.com/CliMA/Oceananigans.jl/pull/3326#issuecomment-1757808403:22,Testability,test,tests,22,"Yeah let's merge when tests pass, thanks @simonbyrne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3326#issuecomment-1757808403
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1755997748:200,Integrability,depend,dependency,200,"On Julia < 1.9 you need requires [which is standard practice by extension packages], if Oceananigans enforces 1.9+, it's not necessary. Wasn't sure so added both here, and you can remove the requires dependency if desired.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1755997748
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051:303,Integrability,depend,dependency,303,"> Please add a small description of this PR in the top comment. Done. > Question: is Oceananigans the right place for the extension to be or an extension for Oceananigans in Enzyme?; > ; > (I'm not arguing for one or the other; I'm just wondering.). So I think here is the right place, since code has a dependency on Oceananigans itself and EnzymeCore (which is dependency free). It also is how other packages (like NNlib, LinearSolve, SciMLSensitivity, etc) work with Enzyme and other AD tools.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051:362,Integrability,depend,dependency,362,"> Please add a small description of this PR in the top comment. Done. > Question: is Oceananigans the right place for the extension to be or an extension for Oceananigans in Enzyme?; > ; > (I'm not arguing for one or the other; I'm just wondering.). So I think here is the right place, since code has a dependency on Oceananigans itself and EnzymeCore (which is dependency free). It also is how other packages (like NNlib, LinearSolve, SciMLSensitivity, etc) work with Enzyme and other AD tools.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756046079:38,Testability,test,tested,38,OK. How are these methods going to be tested and or maintained?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756046079
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531:150,Deployability,integrat,integration,150,So I added a unit test showing that checks that should test its functionality. Once we get more of Oceananigans differentiated we can add some bigger integration tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531:150,Integrability,integrat,integration,150,So I added a unit test showing that checks that should test its functionality. Once we get more of Oceananigans differentiated we can add some bigger integration tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531:18,Testability,test,test,18,So I added a unit test showing that checks that should test its functionality. Once we get more of Oceananigans differentiated we can add some bigger integration tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531:55,Testability,test,test,55,So I added a unit test showing that checks that should test its functionality. Once we get more of Oceananigans differentiated we can add some bigger integration tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531:162,Testability,test,tests,162,So I added a unit test showing that checks that should test its functionality. Once we get more of Oceananigans differentiated we can add some bigger integration tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759711880:128,Availability,failure,failures,128,"@wsmoses should we add a new buildkite run dedicated solely to the enzyme extension? It might help for debugging / interpreting failures. (If that makes sense, I can shuffle things around to make that work.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759711880
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409:309,Deployability,release,release,309,"What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra. . This PR https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426 added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: https://github.com/JuliaRegistries/General/pull/93272. Once that lands, this should succeed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409:323,Deployability,patch,patch,323,"What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra. . This PR https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426 added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: https://github.com/JuliaRegistries/General/pull/93272. Once that lands, this should succeed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409:329,Deployability,release,release,329,"What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra. . This PR https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426 added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: https://github.com/JuliaRegistries/General/pull/93272. Once that lands, this should succeed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409:89,Testability,test,tests,89,"What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra. . This PR https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426 added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: https://github.com/JuliaRegistries/General/pull/93272. Once that lands, this should succeed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409:144,Testability,test,testing,144,"What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra. . This PR https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426 added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: https://github.com/JuliaRegistries/General/pull/93272. Once that lands, this should succeed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759890409
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633:354,Deployability,release,release,354,"> What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra.; > ; > This PR [JuliaGPU/KernelAbstractions.jl#426](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426) added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: [JuliaRegistries/General#93272](https://github.com/JuliaRegistries/General/pull/93272); > ; > Once that lands, this should succeed. Ok great!. Also let me know if its ok with you if I set up a new buildkite step for the enzyme extension.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633:368,Deployability,patch,patch,368,"> What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra.; > ; > This PR [JuliaGPU/KernelAbstractions.jl#426](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426) added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: [JuliaRegistries/General#93272](https://github.com/JuliaRegistries/General/pull/93272); > ; > Once that lands, this should succeed. Ok great!. Also let me know if its ok with you if I set up a new buildkite step for the enzyme extension.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633:374,Deployability,release,release,374,"> What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra.; > ; > This PR [JuliaGPU/KernelAbstractions.jl#426](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426) added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: [JuliaRegistries/General#93272](https://github.com/JuliaRegistries/General/pull/93272); > ; > Once that lands, this should succeed. Ok great!. Also let me know if its ok with you if I set up a new buildkite step for the enzyme extension.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633:91,Testability,test,tests,91,"> What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra.; > ; > This PR [JuliaGPU/KernelAbstractions.jl#426](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426) added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: [JuliaRegistries/General#93272](https://github.com/JuliaRegistries/General/pull/93272); > ; > Once that lands, this should succeed. Ok great!. Also let me know if its ok with you if I set up a new buildkite step for the enzyme extension.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633:146,Testability,test,testing,146,"> What's happening presently is KA is forcing an older version of Enzyme to be used in the tests, that doesn't have the inactive_type used by the testing infra.; > ; > This PR [JuliaGPU/KernelAbstractions.jl#426](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/426) added relevant parts to KA, which currently is waiting for the julia registry to release a new patch release: [JuliaRegistries/General#93272](https://github.com/JuliaRegistries/General/pull/93272); > ; > Once that lands, this should succeed. Ok great!. Also let me know if its ok with you if I set up a new buildkite step for the enzyme extension.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759975633
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1760548442:45,Deployability,release,releases,45,"@glwagner the prerequisites have landed with releases cut. Hopefully this is happy (and finds the correct versions of KA/Enzyme), but it was just tagged a few hours ago, so we'll see",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1760548442
https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1760663048:14,Deployability,update,update,14,Might need to update the Manifest,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1760663048
https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758077354:146,Usability,clear,clearly,146,Can you explain how topology was removed? I was under the impression this was necessary for determining connectivity (or something like that) but clearly this is wrong. A detailed explanation would be helpful...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758077354
https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:309,Deployability,configurat,configuration,309,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187
https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:193,Integrability,wrap,wrap,193,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187
https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:309,Modifiability,config,configuration,309,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187
https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:342,Performance,perform,perform,342,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187
https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:735,Performance,perform,perform,735,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187
https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758171611:30,Testability,test,tests,30,Should be ready to merge when tests pass,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758171611
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1756586591:17,Testability,test,tests,17,I will fix these tests later today (Sydney time..)!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1756586591
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970:62,Energy Efficiency,reduce,reduce,62,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970:10,Testability,test,tests,10,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970:89,Testability,test,testing,89,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970:166,Testability,test,tests,166,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970:51,Usability,simpl,simplify,51,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970:257,Usability,simpl,simple,257,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047:172,Availability,error,error,172,"@glwagner I have simplified the test script (good idea as it was clunky for me to sieve through and I wrote it..) and the new tests pass on both `CPU()` and `GPU()`. ~~The error from the docs build does not look related to this PR as far as I can tell! The docs built on a previous version and I do not think I changed any code related to the docstring.~~. This PR is already likely enough but one thing that could be done is to move `src/Buoyancy/buoyancy_field.jl`. ```julia; # TODO: move to Models; buoyancy(model) = buoyancy(model.buoyancy, model.grid, model.tracers); buoyancy(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); BuoyancyField(model) = Field(buoyancy(model)); ```. to `Oceananigans.Models` and alter this so instead of returning `BuoyancyField` it returns the `KernelFunctionOperation`. ```julia; sewater_buoyancy_perturbation(model) = sewater_buoyancy_perturbation(model.buoyancy, model.grid, model.tracers); sewater_buoyancy_perturbation(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); SewaterBuoyancyPerturbation(model) = sewater_buoyancy_perturbation(model); ```. to match the behaviour of `SeawaterDensity`.; Likely better to do another day but if you think it worth doing in this PR let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047:32,Testability,test,test,32,"@glwagner I have simplified the test script (good idea as it was clunky for me to sieve through and I wrote it..) and the new tests pass on both `CPU()` and `GPU()`. ~~The error from the docs build does not look related to this PR as far as I can tell! The docs built on a previous version and I do not think I changed any code related to the docstring.~~. This PR is already likely enough but one thing that could be done is to move `src/Buoyancy/buoyancy_field.jl`. ```julia; # TODO: move to Models; buoyancy(model) = buoyancy(model.buoyancy, model.grid, model.tracers); buoyancy(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); BuoyancyField(model) = Field(buoyancy(model)); ```. to `Oceananigans.Models` and alter this so instead of returning `BuoyancyField` it returns the `KernelFunctionOperation`. ```julia; sewater_buoyancy_perturbation(model) = sewater_buoyancy_perturbation(model.buoyancy, model.grid, model.tracers); sewater_buoyancy_perturbation(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); SewaterBuoyancyPerturbation(model) = sewater_buoyancy_perturbation(model); ```. to match the behaviour of `SeawaterDensity`.; Likely better to do another day but if you think it worth doing in this PR let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047:126,Testability,test,tests,126,"@glwagner I have simplified the test script (good idea as it was clunky for me to sieve through and I wrote it..) and the new tests pass on both `CPU()` and `GPU()`. ~~The error from the docs build does not look related to this PR as far as I can tell! The docs built on a previous version and I do not think I changed any code related to the docstring.~~. This PR is already likely enough but one thing that could be done is to move `src/Buoyancy/buoyancy_field.jl`. ```julia; # TODO: move to Models; buoyancy(model) = buoyancy(model.buoyancy, model.grid, model.tracers); buoyancy(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); BuoyancyField(model) = Field(buoyancy(model)); ```. to `Oceananigans.Models` and alter this so instead of returning `BuoyancyField` it returns the `KernelFunctionOperation`. ```julia; sewater_buoyancy_perturbation(model) = sewater_buoyancy_perturbation(model.buoyancy, model.grid, model.tracers); sewater_buoyancy_perturbation(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); SewaterBuoyancyPerturbation(model) = sewater_buoyancy_perturbation(model); ```. to match the behaviour of `SeawaterDensity`.; Likely better to do another day but if you think it worth doing in this PR let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047
https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047:17,Usability,simpl,simplified,17,"@glwagner I have simplified the test script (good idea as it was clunky for me to sieve through and I wrote it..) and the new tests pass on both `CPU()` and `GPU()`. ~~The error from the docs build does not look related to this PR as far as I can tell! The docs built on a previous version and I do not think I changed any code related to the docstring.~~. This PR is already likely enough but one thing that could be done is to move `src/Buoyancy/buoyancy_field.jl`. ```julia; # TODO: move to Models; buoyancy(model) = buoyancy(model.buoyancy, model.grid, model.tracers); buoyancy(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); BuoyancyField(model) = Field(buoyancy(model)); ```. to `Oceananigans.Models` and alter this so instead of returning `BuoyancyField` it returns the `KernelFunctionOperation`. ```julia; sewater_buoyancy_perturbation(model) = sewater_buoyancy_perturbation(model.buoyancy, model.grid, model.tracers); sewater_buoyancy_perturbation(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); SewaterBuoyancyPerturbation(model) = sewater_buoyancy_perturbation(model); ```. to match the behaviour of `SeawaterDensity`.; Likely better to do another day but if you think it worth doing in this PR let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047
https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757833504:14,Availability,error,errors,14,"The following errors but I don't think it should... ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); ERROR: AssertionError: c₁ < c₂; Stacktrace:; [1] generate_coordinate(FT::Type{Float64}, topo::Flat, N::Int64, H::Int64, node_interval::Tuple{Float64, Float64}, coordinate_name::Symbol, arch::CPU); @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/grid_generation.jl:100; [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:273; [3] RectilinearGrid; @ ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [4] top-level scope; @ REPL[4]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757833504
https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757833504:144,Availability,ERROR,ERROR,144,"The following errors but I don't think it should... ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); ERROR: AssertionError: c₁ < c₂; Stacktrace:; [1] generate_coordinate(FT::Type{Float64}, topo::Flat, N::Int64, H::Int64, node_interval::Tuple{Float64, Float64}, coordinate_name::Symbol, arch::CPU); @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/grid_generation.jl:100; [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:273; [3] RectilinearGrid; @ ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [4] top-level scope; @ REPL[4]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757833504
https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757833504:151,Testability,Assert,AssertionError,151,"The following errors but I don't think it should... ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); ERROR: AssertionError: c₁ < c₂; Stacktrace:; [1] generate_coordinate(FT::Type{Float64}, topo::Flat, N::Int64, H::Int64, node_interval::Tuple{Float64, Float64}, coordinate_name::Symbol, arch::CPU); @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/grid_generation.jl:100; [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:273; [3] RectilinearGrid; @ ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [4] top-level scope; @ REPL[4]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757833504
https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331:16,Availability,error,errors,16,"> The following errors but I don't think it should...; > ; > ```julia; > julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); > ERROR: AssertionError: c₁ < c₂; > Stacktrace:; > [1] generate_coordinate(FT::Type{Float64}, topo::Flat, N::Int64, H::Int64, node_interval::Tuple{Float64, Float64}, coordinate_name::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/grid_generation.jl:100; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:273; > [3] RectilinearGrid; > @ ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; > [4] top-level scope; > @ REPL[4]:1; > ```. This errors on `main` as well right? I didn't change that line",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331
https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331:157,Availability,ERROR,ERROR,157,"> The following errors but I don't think it should...; > ; > ```julia; > julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); > ERROR: AssertionError: c₁ < c₂; > Stacktrace:; > [1] generate_coordinate(FT::Type{Float64}, topo::Flat, N::Int64, H::Int64, node_interval::Tuple{Float64, Float64}, coordinate_name::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/grid_generation.jl:100; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:273; > [3] RectilinearGrid; > @ ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; > [4] top-level scope; > @ REPL[4]:1; > ```. This errors on `main` as well right? I didn't change that line",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331
https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331:834,Availability,error,errors,834,"> The following errors but I don't think it should...; > ; > ```julia; > julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); > ERROR: AssertionError: c₁ < c₂; > Stacktrace:; > [1] generate_coordinate(FT::Type{Float64}, topo::Flat, N::Int64, H::Int64, node_interval::Tuple{Float64, Float64}, coordinate_name::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/grid_generation.jl:100; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:273; > [3] RectilinearGrid; > @ ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; > [4] top-level scope; > @ REPL[4]:1; > ```. This errors on `main` as well right? I didn't change that line",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331
https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331:164,Testability,Assert,AssertionError,164,"> The following errors but I don't think it should...; > ; > ```julia; > julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); > ERROR: AssertionError: c₁ < c₂; > Stacktrace:; > [1] generate_coordinate(FT::Type{Float64}, topo::Flat, N::Int64, H::Int64, node_interval::Tuple{Float64, Float64}, coordinate_name::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/grid_generation.jl:100; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:273; > [3] RectilinearGrid; > @ ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; > [4] top-level scope; > @ REPL[4]:1; > ```. This errors on `main` as well right? I didn't change that line",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331
https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869:92,Availability,error,erroring,92,"> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)). Nope, it's not erroring on main. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869
https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869:330,Modifiability,variab,variably,330,"> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)). Nope, it's not erroring on main. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777:143,Availability,ERROR,ERROR,143,"Some of the validations are failing...?. What previously gave. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; [5] top-level scope; @ REPL[3]:1; ```. now it goes through:. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; ```. Note that it creates an x and y coord `[1.0, 1.0)`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777:1509,Modifiability,variab,variably,1509,"Some of the validations are failing...?. What previously gave. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; [5] top-level scope; @ REPL[3]:1; ```. now it goes through:. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; ```. Note that it creates an x and y coord `[1.0, 1.0)`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777:1584,Modifiability,variab,variably,1584,"Some of the validations are failing...?. What previously gave. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; [5] top-level scope; @ REPL[3]:1; ```. now it goes through:. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; ```. Note that it creates an x and y coord `[1.0, 1.0)`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777:12,Security,validat,validations,12,"Some of the validations are failing...?. What previously gave. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; [5] top-level scope; @ REPL[3]:1; ```. now it goes through:. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; ```. Note that it creates an x and y coord `[1.0, 1.0)`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:161,Availability,ERROR,ERROR,161,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:1569,Modifiability,variab,variably,1569,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:1646,Modifiability,variab,variably,1646,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:14,Security,validat,validations,14,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762168392:198,Availability,ERROR,ERROR,198,"Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?. ```Julia; julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64). Closest candidates are:; get_face_node(::Function, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; get_face_node(::AbstractVector, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; get_face_node(::Nothing, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11. Stacktrace:; [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; [3] top-level scope; @ REPL[4]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762168392
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762168392:81,Security,validat,validation,81,"Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?. ```Julia; julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64). Closest candidates are:; get_face_node(::Function, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; get_face_node(::AbstractVector, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; get_face_node(::Nothing, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11. Stacktrace:; [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; [3] top-level scope; @ REPL[4]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762168392
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762168392:15,Testability,test,tests,15,"Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?. ```Julia; julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64). Closest candidates are:; get_face_node(::Function, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; get_face_node(::AbstractVector, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; get_face_node(::Nothing, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11. Stacktrace:; [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; [3] top-level scope; @ REPL[4]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762168392
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344:210,Availability,ERROR,ERROR,210,"> Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); > ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64); > ; > Closest candidates are:; > get_face_node(::Function, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; > get_face_node(::AbstractVector, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; > get_face_node(::Nothing, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11; > ; > Stacktrace:; > [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; > [3] top-level scope; > @ REPL[4]:1; > ```. I wanted to make it so that grid generators don't have to subtype functions. However, that doesn't support the kind of error checking that you're mentioning. I guess I'll go back to explicitly requiring somethign to be subtyped `Function`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344:1282,Availability,error,error,1282,"> Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); > ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64); > ; > Closest candidates are:; > get_face_node(::Function, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; > get_face_node(::AbstractVector, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; > get_face_node(::Nothing, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11; > ; > Stacktrace:; > [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; > [3] top-level scope; > @ REPL[4]:1; > ```. I wanted to make it so that grid generators don't have to subtype functions. However, that doesn't support the kind of error checking that you're mentioning. I guess I'll go back to explicitly requiring somethign to be subtyped `Function`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344:83,Security,validat,validation,83,"> Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); > ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64); > ; > Closest candidates are:; > get_face_node(::Function, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; > get_face_node(::AbstractVector, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; > get_face_node(::Nothing, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11; > ; > Stacktrace:; > [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; > [3] top-level scope; > @ REPL[4]:1; > ```. I wanted to make it so that grid generators don't have to subtype functions. However, that doesn't support the kind of error checking that you're mentioning. I guess I'll go back to explicitly requiring somethign to be subtyped `Function`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344
https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344:17,Testability,test,tests,17,"> Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); > ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64); > ; > Closest candidates are:; > get_face_node(::Function, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; > get_face_node(::AbstractVector, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; > get_face_node(::Nothing, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11; > ; > Stacktrace:; > [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; > [3] top-level scope; > @ REPL[4]:1; > ```. I wanted to make it so that grid generators don't have to subtype functions. However, that doesn't support the kind of error checking that you're mentioning. I guess I'll go back to explicitly requiring somethign to be subtyped `Function`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344
https://github.com/CliMA/Oceananigans.jl/issues/3335#issuecomment-1791138584:66,Testability,test,test,66,"@simone-silvestri we do have some of these now in the distributed test suite, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3335#issuecomment-1791138584
https://github.com/CliMA/Oceananigans.jl/issues/3335#issuecomment-1791152312:228,Availability,down,download,228,"They are already there, https://github.com/CliMA/Oceananigans.jl/blob/7291ada057afc9cfcefb2b6e9351cff8782d9217/test/test_hydrostatic_regression.jl#L80; we have to merge in `OceananaigansArtifacts` the branch and correct main to download from `OceananaigansArtifacts#main`. I ll open a PR there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3335#issuecomment-1791152312
https://github.com/CliMA/Oceananigans.jl/issues/3335#issuecomment-1791152312:111,Testability,test,test,111,"They are already there, https://github.com/CliMA/Oceananigans.jl/blob/7291ada057afc9cfcefb2b6e9351cff8782d9217/test/test_hydrostatic_regression.jl#L80; we have to merge in `OceananaigansArtifacts` the branch and correct main to download from `OceananaigansArtifacts#main`. I ll open a PR there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3335#issuecomment-1791152312
https://github.com/CliMA/Oceananigans.jl/issues/3336#issuecomment-1760201985:165,Energy Efficiency,reduce,reduce,165,"Another design is to use something like . ```julia; set_Δt!(sim, new_Δt); ```. While overloading `setproperty` is nicer syntax, it is a little implicit to do an all reduce within setproperty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3336#issuecomment-1760201985
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1762308124:77,Testability,test,tests,77,I think I caught two small bugs that were disallowing y-partitioning. If the tests pass now we should be ready to merge,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1762308124
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1764795630:89,Modifiability,extend,extend,89,"I think so, the issue #3342 applies also to multi-region, so I think in a next PR we can extend this halo splitting to multi region boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1764795630
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765215973:323,Availability,toler,tolerance,323,"The Y-partition tests with Periodic longitude do not pass because of one point near the boundary where values are really low. I am kind of confident that the implementation is correct, we might be hitting a Floating point ordering problem that does not allow perfect reproducibility. I am considering relaxing the relative tolerance for distributed tests because I do not really see a way out for regression tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765215973
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765215973:16,Testability,test,tests,16,"The Y-partition tests with Periodic longitude do not pass because of one point near the boundary where values are really low. I am kind of confident that the implementation is correct, we might be hitting a Floating point ordering problem that does not allow perfect reproducibility. I am considering relaxing the relative tolerance for distributed tests because I do not really see a way out for regression tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765215973
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765215973:349,Testability,test,tests,349,"The Y-partition tests with Periodic longitude do not pass because of one point near the boundary where values are really low. I am kind of confident that the implementation is correct, we might be hitting a Floating point ordering problem that does not allow perfect reproducibility. I am considering relaxing the relative tolerance for distributed tests because I do not really see a way out for regression tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765215973
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765215973:408,Testability,test,tests,408,"The Y-partition tests with Periodic longitude do not pass because of one point near the boundary where values are really low. I am kind of confident that the implementation is correct, we might be hitting a Floating point ordering problem that does not allow perfect reproducibility. I am considering relaxing the relative tolerance for distributed tests because I do not really see a way out for regression tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765215973
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765267741:184,Testability,test,tests,184,especially because we are comparing `Float64` model output with `Float32` saved data.; I propose to regenerate regression data in `Float64` in another PR so we can make the regression tests more repetible,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765267741
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765285533:185,Testability,test,tests,185,> especially because we are comparing `Float64` model output with `Float32` saved data. I propose to regenerate regression data in `Float64` in another PR so we can make the regression tests more repetible. The regression test data should be saved in Float64. Regenerate in serial with Float64?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765285533
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765285533:222,Testability,test,test,222,> especially because we are comparing `Float64` model output with `Float32` saved data. I propose to regenerate regression data in `Float64` in another PR so we can make the regression tests more repetible. The regression test data should be saved in Float64. Regenerate in serial with Float64?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765285533
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765286118:33,Testability,test,test,33,"If you regenerate the regression test data in serial, it's still a valid test of the distributed code. I think you can do that here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765286118
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765286118:73,Testability,test,test,73,"If you regenerate the regression test data in serial, it's still a valid test of the distributed code. I think you can do that here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765286118
https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765439199:109,Testability,test,test,109,Since I had to regenerate the data I thought to add some data for `SplitExplicitFreeSurface`. If we want the test I ll keep it as part of this PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1765439199
https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912:134,Modifiability,extend,extends,134,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912
https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912:146,Testability,test,tests,146,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912
https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912:28,Usability,simpl,simplify,28,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912
https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912:673,Usability,clear,clear,673,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912
https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762141808:702,Availability,avail,available,702,"Here's another concept for an API. As I understand this, the basic operations we want to support divide a 2D plane into a rectilinear grid. Based on this principle, we can support only a dimension-by-dimension specification (ie x and y are specified independently). Example use cases are:. * equal partitioning of one or both dimensions among `R` ranks; * non-uniform partitioning based on the number of grid points carried by each rank; * non-uniform partitioning based on the relative size (necessarily approximate) associated with each rank. Is there anything else we want to support?. Here's a syntax that achieves those:. ```julia; p = Partition(x=Equal()) # computation equally partitioned among available ranks, however many are available.; p = Partition(x=4) # computation equally partitioned between 4 ranks. There must be 4 available ranks; p = Partition(x=2, y=Equal()) # computational divided among 2 ranks in x, and the remaining distributed equally in y. There must be at least 2 ranks.; p = Partition(x=Equal(), y=Equal()) # somehow ""almost evenly"" divided among xy?; p = Partition(x=Relative(0.1, 0.3, 0.6)) # computational unevenly distributed among 3 ranks in x each given grids that contain 10%, 30%, 60% of the total grid points. There must be 3 ranks.; p = Partition(x=Relative(1, 3, 6)) # same as above (eg we normalize by the total amount, not requiring =1); p = Partition(x=Equal(), y=Relative(1, 3, 6)) # computation unevenly distributed in y among 3 ranks, but evenly distributed in x amoung remaining ranks. There must be at least 3 ranks.; p = Partition(x=[16, 32, 64]) # computational distributed among 3 ranks each with 16, 32, and 64 grid points total. The total size of the grid must be 16 + 32 + 64 = 112 and there must be 3 ranks.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762141808
https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762141808:736,Availability,avail,available,736,"Here's another concept for an API. As I understand this, the basic operations we want to support divide a 2D plane into a rectilinear grid. Based on this principle, we can support only a dimension-by-dimension specification (ie x and y are specified independently). Example use cases are:. * equal partitioning of one or both dimensions among `R` ranks; * non-uniform partitioning based on the number of grid points carried by each rank; * non-uniform partitioning based on the relative size (necessarily approximate) associated with each rank. Is there anything else we want to support?. Here's a syntax that achieves those:. ```julia; p = Partition(x=Equal()) # computation equally partitioned among available ranks, however many are available.; p = Partition(x=4) # computation equally partitioned between 4 ranks. There must be 4 available ranks; p = Partition(x=2, y=Equal()) # computational divided among 2 ranks in x, and the remaining distributed equally in y. There must be at least 2 ranks.; p = Partition(x=Equal(), y=Equal()) # somehow ""almost evenly"" divided among xy?; p = Partition(x=Relative(0.1, 0.3, 0.6)) # computational unevenly distributed among 3 ranks in x each given grids that contain 10%, 30%, 60% of the total grid points. There must be 3 ranks.; p = Partition(x=Relative(1, 3, 6)) # same as above (eg we normalize by the total amount, not requiring =1); p = Partition(x=Equal(), y=Relative(1, 3, 6)) # computation unevenly distributed in y among 3 ranks, but evenly distributed in x amoung remaining ranks. There must be at least 3 ranks.; p = Partition(x=[16, 32, 64]) # computational distributed among 3 ranks each with 16, 32, and 64 grid points total. The total size of the grid must be 16 + 32 + 64 = 112 and there must be 3 ranks.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762141808
https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762141808:834,Availability,avail,available,834,"Here's another concept for an API. As I understand this, the basic operations we want to support divide a 2D plane into a rectilinear grid. Based on this principle, we can support only a dimension-by-dimension specification (ie x and y are specified independently). Example use cases are:. * equal partitioning of one or both dimensions among `R` ranks; * non-uniform partitioning based on the number of grid points carried by each rank; * non-uniform partitioning based on the relative size (necessarily approximate) associated with each rank. Is there anything else we want to support?. Here's a syntax that achieves those:. ```julia; p = Partition(x=Equal()) # computation equally partitioned among available ranks, however many are available.; p = Partition(x=4) # computation equally partitioned between 4 ranks. There must be 4 available ranks; p = Partition(x=2, y=Equal()) # computational divided among 2 ranks in x, and the remaining distributed equally in y. There must be at least 2 ranks.; p = Partition(x=Equal(), y=Equal()) # somehow ""almost evenly"" divided among xy?; p = Partition(x=Relative(0.1, 0.3, 0.6)) # computational unevenly distributed among 3 ranks in x each given grids that contain 10%, 30%, 60% of the total grid points. There must be 3 ranks.; p = Partition(x=Relative(1, 3, 6)) # same as above (eg we normalize by the total amount, not requiring =1); p = Partition(x=Equal(), y=Relative(1, 3, 6)) # computation unevenly distributed in y among 3 ranks, but evenly distributed in x amoung remaining ranks. There must be at least 3 ranks.; p = Partition(x=[16, 32, 64]) # computational distributed among 3 ranks each with 16, 32, and 64 grid points total. The total size of the grid must be 16 + 32 + 64 = 112 and there must be 3 ranks.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762141808
https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1783140367:8,Deployability,update,update,8,"Can you update the top-level description, and add a docstring for `Partition` with a few examples that enumerates the various possible syntaxes for common important cases?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1783140367
https://github.com/CliMA/Oceananigans.jl/pull/3340#issuecomment-1763142265:21,Testability,test,tested,21,"Sounds good. Is this tested, do you know?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3340#issuecomment-1763142265
https://github.com/CliMA/Oceananigans.jl/pull/3340#issuecomment-1763142776:37,Testability,test,tests,37,I was thinking we'd find out via the tests,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3340#issuecomment-1763142776
https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1763226993:32,Energy Efficiency,Energy,EnergyConservingScheme,32,"> With the name changes, e.g., `EnergyConservingScheme -> EnergyConserving`, this PR introduces a breaking change, right?. True. We can revert that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1763226993
https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1763226993:58,Energy Efficiency,Energy,EnergyConserving,58,"> With the name changes, e.g., `EnergyConservingScheme -> EnergyConserving`, this PR introduces a breaking change, right?. True. We can revert that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1763226993
https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1763229373:45,Deployability,release,release,45,Leave it. I approve. Let's just bump a minor release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1763229373
https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1763709750:47,Deployability,release,release,47,"> Leave it. I approve. Let's just bump a minor release. We should have rules about what is ""official"" API and what isn't. Because it doesn't really make sense to bump here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1763709750
https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1780255367:44,Energy Efficiency,Energy,EnergyConservingScheme,44,"These are exported types that got renamed: `EnergyConservingScheme` -> `EnergyConserving`, `EnstrophyConservingScheme` -> `EnstrophyConserving`,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1780255367
https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1780255367:72,Energy Efficiency,Energy,EnergyConserving,72,"These are exported types that got renamed: `EnergyConservingScheme` -> `EnergyConserving`, `EnstrophyConservingScheme` -> `EnstrophyConserving`,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1780255367
https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174:589,Integrability,wrap,wrapping,589,"ordering requirements are necessary for filling corner halos. ; This is done by `Periodic` boundary conditions in non-distributed simulations.; Additionally, since communication boundary conditions can be asynchronous, distributed (and multi-region) BCS need to be filled last. To remove order requirements we would need to fill the halo for flux, value, and gradient also in the corners.; I thought that might be a good idea but we hit a problem when having an `AbstractArray` boundary condition because we would need to construct the associated `OffsetArray`. . This can be prevented by wrapping the array in a `Field` and filling the halo regions but it seems like a heavy requirement to do it, and generally, a large API change that we might want to think about a little more. In #3338 I fixed the problem by separating out communicating boundary conditions which wasn't that complicated and maintained the current logic. . Maybe in the future, we might want to eliminate the order requirement though. So we can keep this issue open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174
https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174:919,Testability,log,logic,919,"ordering requirements are necessary for filling corner halos. ; This is done by `Periodic` boundary conditions in non-distributed simulations.; Additionally, since communication boundary conditions can be asynchronous, distributed (and multi-region) BCS need to be filled last. To remove order requirements we would need to fill the halo for flux, value, and gradient also in the corners.; I thought that might be a good idea but we hit a problem when having an `AbstractArray` boundary condition because we would need to construct the associated `OffsetArray`. . This can be prevented by wrapping the array in a `Field` and filling the halo regions but it seems like a heavy requirement to do it, and generally, a large API change that we might want to think about a little more. In #3338 I fixed the problem by separating out communicating boundary conditions which wasn't that complicated and maintained the current logic. . Maybe in the future, we might want to eliminate the order requirement though. So we can keep this issue open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174
https://github.com/CliMA/Oceananigans.jl/pull/3344#issuecomment-1769755929:479,Integrability,depend,depends,479,"> > Even if curvilinear grids are not supported yet for the non-hydrostatic model, I like the idea of moving `validate_momentum_advection` to `Models` like `validate_tracer_advection`.; > ; > does this mean that I should actually write separate versions of `validate_momentum_advection` for `HydrostaticFreeSurfaceModels` and 'NonhydrostaticModel` instead?. Just moving `validate_momentum_advection` to the `Models` module is fine. In the end, `validate_momentum_advection` only depends on the grid and the advection scheme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3344#issuecomment-1769755929
https://github.com/CliMA/Oceananigans.jl/pull/3347#issuecomment-1765226078:20,Testability,test,tests,20,"FYI, the GPU Enzyme tests probably fail, because GPU reverse-mode rules are not added to KA (forward mode, however exists).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3347#issuecomment-1765226078
https://github.com/CliMA/Oceananigans.jl/pull/3347#issuecomment-1765230062:22,Testability,test,tests,22,"> FYI, the GPU Enzyme tests probably fail, because GPU reverse-mode rules are not added to KA (forward mode, however exists). They did pass previously though! (GPU tests ran on #3327.) We'll see what happens here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3347#issuecomment-1765230062
https://github.com/CliMA/Oceananigans.jl/pull/3347#issuecomment-1765230062:164,Testability,test,tests,164,"> FYI, the GPU Enzyme tests probably fail, because GPU reverse-mode rules are not added to KA (forward mode, however exists). They did pass previously though! (GPU tests ran on #3327.) We'll see what happens here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3347#issuecomment-1765230062
https://github.com/CliMA/Oceananigans.jl/pull/3347#issuecomment-1765418512:45,Testability,test,test,45,"Oh, actually that makes sense since the unit test here just does the field allocation, and doesn't hit a KA call that would result in an issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3347#issuecomment-1765418512
https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750:176,Performance,perform,performance,176,"Should we also try things like. ```julia; node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; ```. I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. I still want to clean up and streamline `xspacings` and `xnodes` (etc) so that they use `xnode` directly (rather than ""re-implementing"" the nodes) but that'll have to wait for another PR I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750
https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750:229,Usability,simpl,simpler,229,"Should we also try things like. ```julia; node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; ```. I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. I still want to clean up and streamline `xspacings` and `xnodes` (etc) so that they use `xnode` directly (rather than ""re-implementing"" the nodes) but that'll have to wait for another PR I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750
https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960:194,Performance,perform,performance,194,"> Should we also try things like; > ; > ```julia; > node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; > ```; > ; > I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. Hmm this is more annoying than I thought so I'll leave it for later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960
https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960:247,Usability,simpl,simpler,247,"> Should we also try things like; > ; > ```julia; > node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; > ```; > ; > I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. Hmm this is more annoying than I thought so I'll leave it for later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960
https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1778010998:103,Availability,error,error,103,"Ok, we now emit warnings like. ```julia; julia> include(""one_dimensional_diffusion.jl""); ┌ Warning: An error was encountered within set! while setting the field; │; │ 1×1×128 Field{Center, Center, Center} on RectilinearGrid on CPU; │; │ Note that to use set!(field, func::Function) on a field at location (Center, Center, Center); │ and on a grid with topology (Flat, Flat, Bounded), func must be callable via; │; │ func(z); └ @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/set!.jl:59; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1778010998
https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1783617373:41,Integrability,interface,interface,41,"Since this is such a major change in the interface, I think we should get the docs back up again before registering 0.90 (i.e. fix https://github.com/CliMA/Oceananigans.jl/issues/3191).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1783617373
https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1785633451:136,Usability,simpl,simply,136,"> That’s a good point. Unfortunately, we don’t know how to do that unfortunately. We tried bunch of things. I’ll give it a go. Can't we simply revert the commit/PR that introduced the issue for the time being?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1785633451
https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1789028157:41,Testability,test,test,41,I changed a setting. I don't know how to test it though other than registering a new version... But what if it doesn't work?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1789028157
https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1789302908:79,Safety,risk,risk,79,I think it's not the end of the world if we go a few days without docs. It's a risk but it's not worth losing sleep and mental health over this,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1789302908
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775526816:22,Performance,perform,performance,22,Is there some kind of performance benefit of. https://github.com/CliMA/Oceananigans.jl/blob/d0b7ec8f98c860ce49927e0a7214961d2f47fb75/src/Fields/interpolate.jl#L63-L67. compared to. https://github.com/CliMA/Oceananigans.jl/blob/d0b7ec8f98c860ce49927e0a7214961d2f47fb75/src/Fields/interpolate.jl#L75-L81. ?. Why do we have both?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775526816
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157:57,Performance,perform,performance,57,I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. It would probably be sensible to change the differentiation between the methods to just `fractional_index` though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157:22,Testability,test,tested,22,I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. It would probably be sensible to change the differentiation between the methods to just `fractional_index` though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157:84,Usability,simpl,simpler,84,I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. It would probably be sensible to change the differentiation between the methods to just `fractional_index` though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546:59,Performance,perform,performance,59,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546:24,Testability,test,tested,24,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546:198,Testability,benchmark,benchmarked,198,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546:86,Usability,simpl,simpler,86,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431:99,Integrability,depend,depend,99,I have never tried benchmarking this. maybe the gain in performance is negligible. I guess it will depend on the number of particles and the size of the grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431:56,Performance,perform,performance,56,I have never tried benchmarking this. maybe the gain in performance is negligible. I guess it will depend on the number of particles and the size of the grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431
https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431:19,Testability,benchmark,benchmarking,19,I have never tried benchmarking this. maybe the gain in performance is negligible. I guess it will depend on the number of particles and the size of the grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570:7,Availability,error,error,7,"Latest error:. ```julia; ERROR: LoadError: task switch not allowed from inside staged nor pure functions; Stacktrace:; [1] try_yieldto(undo::typeof(Base.ensure_rescheduled)); @ Base ./task.jl:921; [2] wait(); @ Base ./task.jl:995; [3] uv_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1048; [4] unsafe_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1120; [5] write; @ Base ./strings/io.jl:248 [inlined]; [6] print; @ Base ./strings/io.jl:250 [inlined]; [7] print(::Base.TTY, ::String, ::String, ::Vararg{String}); @ Base ./strings/io.jl:46; [8] println(::Base.TTY, ::String, ::Vararg{String}); @ Base ./strings/io.jl:75; [9] println(::String, ::String); @ Base ./coreio.jl:4; [10] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{…}, ridxs::Vector{…}); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:270; [11] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [12] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183; [13] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{…}, shadowR::Ptr{…}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4610; [14] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4770; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570:25,Availability,ERROR,ERROR,25,"Latest error:. ```julia; ERROR: LoadError: task switch not allowed from inside staged nor pure functions; Stacktrace:; [1] try_yieldto(undo::typeof(Base.ensure_rescheduled)); @ Base ./task.jl:921; [2] wait(); @ Base ./task.jl:995; [3] uv_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1048; [4] unsafe_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1120; [5] write; @ Base ./strings/io.jl:248 [inlined]; [6] print; @ Base ./strings/io.jl:250 [inlined]; [7] print(::Base.TTY, ::String, ::String, ::Vararg{String}); @ Base ./strings/io.jl:46; [8] println(::Base.TTY, ::String, ::Vararg{String}); @ Base ./strings/io.jl:75; [9] println(::String, ::String); @ Base ./coreio.jl:4; [10] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{…}, ridxs::Vector{…}); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:270; [11] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [12] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183; [13] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{…}, shadowR::Ptr{…}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4610; [14] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4770; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570:32,Performance,Load,LoadError,32,"Latest error:. ```julia; ERROR: LoadError: task switch not allowed from inside staged nor pure functions; Stacktrace:; [1] try_yieldto(undo::typeof(Base.ensure_rescheduled)); @ Base ./task.jl:921; [2] wait(); @ Base ./task.jl:995; [3] uv_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1048; [4] unsafe_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1120; [5] write; @ Base ./strings/io.jl:248 [inlined]; [6] print; @ Base ./strings/io.jl:250 [inlined]; [7] print(::Base.TTY, ::String, ::String, ::Vararg{String}); @ Base ./strings/io.jl:46; [8] println(::Base.TTY, ::String, ::Vararg{String}); @ Base ./strings/io.jl:75; [9] println(::String, ::String); @ Base ./coreio.jl:4; [10] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{…}, ridxs::Vector{…}); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:270; [11] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [12] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183; [13] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{…}, shadowR::Ptr{…}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4610; [14] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4770; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570:135,Usability,undo,undo,135,"Latest error:. ```julia; ERROR: LoadError: task switch not allowed from inside staged nor pure functions; Stacktrace:; [1] try_yieldto(undo::typeof(Base.ensure_rescheduled)); @ Base ./task.jl:921; [2] wait(); @ Base ./task.jl:995; [3] uv_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1048; [4] unsafe_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1120; [5] write; @ Base ./strings/io.jl:248 [inlined]; [6] print; @ Base ./strings/io.jl:250 [inlined]; [7] print(::Base.TTY, ::String, ::String, ::Vararg{String}); @ Base ./strings/io.jl:46; [8] println(::Base.TTY, ::String, ::Vararg{String}); @ Base ./strings/io.jl:75; [9] println(::String, ::String); @ Base ./coreio.jl:4; [10] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{…}, ridxs::Vector{…}); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:270; [11] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [12] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183; [13] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{…}, shadowR::Ptr{…}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4610; [14] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4770; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710:22,Availability,error,error,22,That is ironically an error in the error printer. Can you convert that to an assertion so we can see the actual error message?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710:35,Availability,error,error,35,That is ironically an error in the error printer. Can you convert that to an assertion so we can see the actual error message?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710:112,Availability,error,error,112,That is ironically an error in the error printer. Can you convert that to an assertion so we can see the actual error message?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710:118,Integrability,message,message,118,That is ironically an error in the error printer. Can you convert that to an assertion so we can see the actual error message?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710:77,Testability,assert,assertion,77,That is ironically an error in the error printer. Can you convert that to an assertion so we can see the actual error message?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:26,Availability,ERROR,ERROR,26,"you mean like this?. ```; ERROR: LoadError: AssertionError: false; Stacktrace:; [1] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{UInt32}, ridxs::Vector{UInt32}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:271; [2] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [3] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183; [4] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{Nothing}, shadowR::Ptr{Nothing}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4610; [5] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:1994,Integrability,wrap,wrap,1994,"nst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9278; [10] codegen; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:8886 [inlined]; [11] _thunk(job::GPUCompiler.CompilerJob{Enzyme.Compiler.EnzymeTarget, Enzyme.Compiler.EnzymeCompilerParams}, postopt::Bool) (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9830; [12] cached_compilation; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9864 [inlined]; [13] (::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:33,Performance,Load,LoadError,33,"you mean like this?. ```; ERROR: LoadError: AssertionError: false; Stacktrace:; [1] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{UInt32}, ridxs::Vector{UInt32}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:271; [2] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [3] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183; [4] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{Nothing}, shadowR::Ptr{Nothing}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4610; [5] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:2313,Performance,optimiz,optimize,2313,"src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9278; [10] codegen; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:8886 [inlined]; [11] _thunk(job::GPUCompiler.CompilerJob{Enzyme.Compiler.EnzymeTarget, Enzyme.Compiler.EnzymeCompilerParams}, postopt::Bool) (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9830; [12] cached_compilation; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9864 [inlined]; [13] (::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType})(ctx::LLVM.Context); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9921; [14] JuliaContext(f::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType}); @ GPUC",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:2358,Security,validat,validate,2358,"src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9278; [10] codegen; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:8886 [inlined]; [11] _thunk(job::GPUCompiler.CompilerJob{Enzyme.Compiler.EnzymeTarget, Enzyme.Compiler.EnzymeCompilerParams}, postopt::Bool) (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9830; [12] cached_compilation; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9864 [inlined]; [13] (::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType})(ctx::LLVM.Context); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9921; [14] JuliaContext(f::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType}); @ GPUC",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:44,Testability,Assert,AssertionError,44,"you mean like this?. ```; ERROR: LoadError: AssertionError: false; Stacktrace:; [1] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{UInt32}, ridxs::Vector{UInt32}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:271; [2] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [3] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183; [4] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{Nothing}, shadowR::Ptr{Nothing}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4610; [5] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:1395,Testability,log,logic,1395,"Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [3] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183; [4] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{Nothing}, shadowR::Ptr{Nothing}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4610; [5] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_en",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:1409,Testability,Log,Logic,1409,"jl/src/compiler/utils.jl:183 [inlined]; [3] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183; [4] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{Nothing}, shadowR::Ptr{Nothing}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4610; [5] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enz",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:4170,Testability,assert,assert,4170,"ompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9278; [10] codegen; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:8886 [inlined]; [11] _thunk(job::GPUCompiler.CompilerJob{Enzyme.Compiler.EnzymeTarget, Enzyme.Compiler.EnzymeCompilerParams}, postopt::Bool) (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9830; [12] cached_compilation; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9864 [inlined]; [13] (::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType})(ctx::LLVM.Context); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9921; [14] JuliaContext(f::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2mJjc/src/driver.jl:47; [15] #s324#473; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9882 [inlined]; [16]; @ Enzyme.Compiler ./none:0; [17] (::Core.GeneratedFunctionStub)(::UInt64, ::LineNumberNode, ::Any, ::Vararg{Any}); @ Core ./boot.jl:600; [18] runtime_generic_augfwd(activity::Type{…}, width::Val{…}, ModifiedBetween::Val{…}, RT::Val{…}, f::Type{…}, df::Nothing, primal_1::var""#cᵢ#1""{…}, shadow_1_1::var""#cᵢ#1""{…}, primal_2::RectilinearGrid{…}, shadow_2_1::RectilinearGrid{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:1386; [19] FunctionField; @ ~/Projects/Enzymantics/Oceananigans.jl/src/Fields/function_field.jl:54 [inlined]; ```. I guess we don't hit any of the `if` statments in `calling_conv_fixup` so then we get to the end where `@assert false`. The problem is that we don't match any of those conditions?????",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1915012052:53,Availability,failure,failures,53,@glwagner the Enzyme CI appears to pass here whereas failures appear unrelated.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1915012052
https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1915800944:14,Availability,failure,failure,14,Weird doctest failure: https://buildkite.com/clima/oceananigans/builds/14179#018d5706-2ebd-4dd5-83db-cc952c58504b/32-19202,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1915800944
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721:637,Availability,error,error,637,"The issue reappears when `view` is used with `reverse`. Consider the MWE:; ```julia; julia> using Oceananigans; julia> grid = ConformalCubedSphereGrid(; z=(-1, 0), panel_size=(4, 4, 1), horizontal_direction_halo = 4, z_halo = 1); julia> u = Field{Face, Center, Center}(grid); julia> set!(u, 1); julia> region, region_E, region_W, Nc, Hc, k, plmn = 1, 2, 5, grid.Nx, grid.Hx, 1, -1; ```; Now, typing ; ```julia; julia> u[region][1, Nc+1:Nc+Hc, k] = reverse(u[region_W][1, Nc+1-Hc:Nc, k]) * plmn; ```; works, but typing ; ```julia; julia> u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)) * plmn; ```; throws the error; ```julia; ERROR: MethodError: no method matching isinteger(::CartesianIndices{3, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}}). Closest candidates are:; isinteger(::BigFloat); @ Base mpfr.jl:960; isinteger(::Missing); @ Base missing.jl:101; isinteger(::FixedPointNumbers.FixedPoint); @ FixedPointNumbers ~/.julia/packages/FixedPointNumbers/HAGk2/src/FixedPointNumbers.jl:101; ... Stacktrace:; [1] validate_index(idx::CartesianIndices{3, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}}, loc::Face, topo::FullyConnected, N::Int64, H::Int64); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/input_validation.jl:196; [2] map; @ ./tuple.jl:342 [inlined]; [3] validate_indices(indices::Tuple{…}, loc::Tuple{…}, topo::Tuple{…}, sz::Tuple{…}, halo_sz::Tuple{…}); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/input_validation.jl:214; [4] validate_indices(indices::Tuple{…}, loc::Tuple{…}, grid::ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/input_validation.jl:211; [5] view(f::Field{…}, i::CartesianIndices{…}, j::Function, k::Fu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721:654,Availability,ERROR,ERROR,654,"The issue reappears when `view` is used with `reverse`. Consider the MWE:; ```julia; julia> using Oceananigans; julia> grid = ConformalCubedSphereGrid(; z=(-1, 0), panel_size=(4, 4, 1), horizontal_direction_halo = 4, z_halo = 1); julia> u = Field{Face, Center, Center}(grid); julia> set!(u, 1); julia> region, region_E, region_W, Nc, Hc, k, plmn = 1, 2, 5, grid.Nx, grid.Hx, 1, -1; ```; Now, typing ; ```julia; julia> u[region][1, Nc+1:Nc+Hc, k] = reverse(u[region_W][1, Nc+1-Hc:Nc, k]) * plmn; ```; works, but typing ; ```julia; julia> u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)) * plmn; ```; throws the error; ```julia; ERROR: MethodError: no method matching isinteger(::CartesianIndices{3, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}}). Closest candidates are:; isinteger(::BigFloat); @ Base mpfr.jl:960; isinteger(::Missing); @ Base missing.jl:101; isinteger(::FixedPointNumbers.FixedPoint); @ FixedPointNumbers ~/.julia/packages/FixedPointNumbers/HAGk2/src/FixedPointNumbers.jl:101; ... Stacktrace:; [1] validate_index(idx::CartesianIndices{3, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}}, loc::Face, topo::FullyConnected, N::Int64, H::Int64); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/input_validation.jl:196; [2] map; @ ./tuple.jl:342 [inlined]; [3] validate_indices(indices::Tuple{…}, loc::Tuple{…}, topo::Tuple{…}, sz::Tuple{…}, halo_sz::Tuple{…}); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/input_validation.jl:214; [4] validate_indices(indices::Tuple{…}, loc::Tuple{…}, grid::ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/input_validation.jl:211; [5] view(f::Field{…}, i::CartesianIndices{…}, j::Function, k::Fu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721:3207,Availability,error,error,3207,".jl:211; [5] view(f::Field{…}, i::CartesianIndices{…}, j::Function, k::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:308; [6] view(f::Field{…}, i::CartesianIndices{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:339; [7] _reverse!(A::Field{…}, dims::Tuple{…}); @ Base ./arraymath.jl:95; [8] _reverse!; @ ./arraymath.jl:71 [inlined]; [9] #reverse!#274; @ ./arraymath.jl:70 [inlined]; [10] _reverse(A::Field{…}, dims::Function); @ Base ./arraymath.jl:60; [11] reverse(A::Field{Face, Center, Center, Nothing, ZRegOrthogonalSphericalShellGrid{…}, Tuple{…}, OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}); @ Base ./arraymath.jl:59; [12] top-level scope; @ REPL[199]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; If the vector is formed by extracting multiple elements from the first dimension of the field on the RHS (as opposed to the second dimension as above), e.g.,; ```julia; julia> u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; no error message pops up but `u[region][Nc+1, 1-Hc:0, k]` is filled with junk values as shown below:; ```julia; 1×4×1 Field{Face, Center, Center} on OrthogonalSphericalShellGrid on CPU; ├── grid: 4×4×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 4×4×1 halo and with precomputed metrics; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (5:5, -3:0, 1:1); └── data: 1×4×1 OffsetArray(view(::Array{Float64, 3}, 9:9, 1:4, 2:2), 5:5, -3:0, 1:1) with eltype Float64 with indices 5:5×-3:0×1:1; └── max=2.1234e-314, min=5.0e-324, mean=5.30853e-315; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721:3213,Integrability,message,message,3213,".jl:211; [5] view(f::Field{…}, i::CartesianIndices{…}, j::Function, k::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:308; [6] view(f::Field{…}, i::CartesianIndices{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:339; [7] _reverse!(A::Field{…}, dims::Tuple{…}); @ Base ./arraymath.jl:95; [8] _reverse!; @ ./arraymath.jl:71 [inlined]; [9] #reverse!#274; @ ./arraymath.jl:70 [inlined]; [10] _reverse(A::Field{…}, dims::Function); @ Base ./arraymath.jl:60; [11] reverse(A::Field{Face, Center, Center, Nothing, ZRegOrthogonalSphericalShellGrid{…}, Tuple{…}, OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}); @ Base ./arraymath.jl:59; [12] top-level scope; @ REPL[199]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; If the vector is formed by extracting multiple elements from the first dimension of the field on the RHS (as opposed to the second dimension as above), e.g.,; ```julia; julia> u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; no error message pops up but `u[region][Nc+1, 1-Hc:0, k]` is filled with junk values as shown below:; ```julia; 1×4×1 Field{Face, Center, Center} on OrthogonalSphericalShellGrid on CPU; ├── grid: 4×4×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 4×4×1 halo and with precomputed metrics; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (5:5, -3:0, 1:1); └── data: 1×4×1 OffsetArray(view(::Array{Float64, 3}, 9:9, 1:4, 2:2), 5:5, -3:0, 1:1) with eltype Float64 with indices 5:5×-3:0×1:1; └── max=2.1234e-314, min=5.0e-324, mean=5.30853e-315; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769:732,Availability,error,error,732,"> Hmm. What is; > ; > ```julia; > view(u[region_W], 1, Nc+1-Hc:Nc, k); > ```; > ; > is this a `Field`? Next question, what is; > ; > ```julia; > reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)); > ```; > ; > If the former is a `Field` I don't think we've defined `reverse` on `Field`. But you could do that... @glwagner, yes, `view(u[region_W], 1, Nc+1-Hc:Nc, k)` is a `WindowedField`, on which `reverse` is not defined yet. But `reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data)` is a valid operation. However, simply typing ; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; might throw the above-mentioned error due to a dimension mismatch or fill the LHS with junk or incorrect values. So, a safe solution is ; ```julia; view(u[region], 1, Nc+1:Nc+Hc, k).data .= reshape(reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn, 1:1, Nc+1:Nc+Hc, k:k); view(u[region], Nc+1, 1-Hc:0, k).data .= reshape(reverse(view(u[region_E], 2:Hc+1, 1, k).data), Nc+1:Nc+1, 1-Hc:0, k:k); ```; @glwagner, @navidcy, if you guys are fine with this fix, I will close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769:819,Safety,safe,safe,819,"> Hmm. What is; > ; > ```julia; > view(u[region_W], 1, Nc+1-Hc:Nc, k); > ```; > ; > is this a `Field`? Next question, what is; > ; > ```julia; > reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)); > ```; > ; > If the former is a `Field` I don't think we've defined `reverse` on `Field`. But you could do that... @glwagner, yes, `view(u[region_W], 1, Nc+1-Hc:Nc, k)` is a `WindowedField`, on which `reverse` is not defined yet. But `reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data)` is a valid operation. However, simply typing ; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; might throw the above-mentioned error due to a dimension mismatch or fill the LHS with junk or incorrect values. So, a safe solution is ; ```julia; view(u[region], 1, Nc+1:Nc+Hc, k).data .= reshape(reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn, 1:1, Nc+1:Nc+Hc, k:k); view(u[region], Nc+1, 1-Hc:0, k).data .= reshape(reverse(view(u[region_E], 2:Hc+1, 1, k).data), Nc+1:Nc+1, 1-Hc:0, k:k); ```; @glwagner, @navidcy, if you guys are fine with this fix, I will close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769:508,Usability,simpl,simply,508,"> Hmm. What is; > ; > ```julia; > view(u[region_W], 1, Nc+1-Hc:Nc, k); > ```; > ; > is this a `Field`? Next question, what is; > ; > ```julia; > reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)); > ```; > ; > If the former is a `Field` I don't think we've defined `reverse` on `Field`. But you could do that... @glwagner, yes, `view(u[region_W], 1, Nc+1-Hc:Nc, k)` is a `WindowedField`, on which `reverse` is not defined yet. But `reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data)` is a valid operation. However, simply typing ; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; might throw the above-mentioned error due to a dimension mismatch or fill the LHS with junk or incorrect values. So, a safe solution is ; ```julia; view(u[region], 1, Nc+1:Nc+Hc, k).data .= reshape(reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn, 1:1, Nc+1:Nc+Hc, k:k); view(u[region], Nc+1, 1-Hc:0, k).data .= reshape(reverse(view(u[region_E], 2:Hc+1, 1, k).data), Nc+1:Nc+1, 1-Hc:0, k:k); ```; @glwagner, @navidcy, if you guys are fine with this fix, I will close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033504577:24,Availability,error,error,24,"> might either throw an error or fill the LHS with junk or incorrect values . I'm not that happy mostly because it seems we don't understand? Why ""might""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033504577
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034626926:26,Availability,error,error,26,"> > might either throw an error or fill the LHS with junk or incorrect values; > ; > I'm not that happy mostly because it seems we don't understand? Why ""might""?. I guess I used ""might"" because I don't fully understand it either. What I meant to say is that the line; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; ```; throws an error due to a dimension mismatch and the line; ```julia; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; fills the LHS with junk values. Hence the workaround I proposed above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034626926
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034626926:382,Availability,error,error,382,"> > might either throw an error or fill the LHS with junk or incorrect values; > ; > I'm not that happy mostly because it seems we don't understand? Why ""might""?. I guess I used ""might"" because I don't fully understand it either. What I meant to say is that the line; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; ```; throws an error due to a dimension mismatch and the line; ```julia; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; fills the LHS with junk values. Hence the workaround I proposed above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034626926
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034695371:163,Availability,error,error,163,"Here's another observation:; ```julia; u[region][1, 1-Hc:0, k] .= view(u[region_W], Nc+1-Hc:Nc, 1, k); ```; neither updates the LHS with any value nor triggers an error. The fix is either; ```julia; u[region][1, 1-Hc:0, k] = u[region_W][Nc+1-Hc:Nc, 1, k]; ```; or; ```julia; view(u[region], 1, 1-Hc:0, k).data .= reshape(view(u[region_W], Nc+1-Hc:Nc, 1, k).data, 1:1, 1-Hc:0, k:k); ```; (preferred).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034695371
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034695371:116,Deployability,update,updates,116,"Here's another observation:; ```julia; u[region][1, 1-Hc:0, k] .= view(u[region_W], Nc+1-Hc:Nc, 1, k); ```; neither updates the LHS with any value nor triggers an error. The fix is either; ```julia; u[region][1, 1-Hc:0, k] = u[region_W][Nc+1-Hc:Nc, 1, k]; ```; or; ```julia; view(u[region], 1, 1-Hc:0, k).data .= reshape(view(u[region_W], Nc+1-Hc:Nc, 1, k).data, 1:1, 1-Hc:0, k:k); ```; (preferred).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034695371
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035263877:18,Energy Efficiency,allocate,allocates,18,"I think `reverse` allocates memory though, so I don't know if we want to use it...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035263877
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035289669:17,Safety,avoid,avoid,17,"True , we should avoid `reverse`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035289669
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:490,Availability,error,error,490,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:450,Energy Efficiency,power,power,450,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:459,Modifiability,extend,extending,459,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:773,Modifiability,extend,extend,773,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:758,Usability,simpl,simply,758,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035358102:75,Energy Efficiency,allocate,allocates,75,We don’t need reverse for Fields. We need to go away from reverse since it allocates,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035358102
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035885538:9459,Availability,error,error,9459," 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 2.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 2.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 2.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 2.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. This is because in broadcast assignment operations, such as `u[1][1:Nc, 1, k] .= u[5][2:Nc+1, 2, k]`, the data of the `WindowedField` is assigned. So, where's the issue? It's when we try any of the following operations:. 1. `u[1][1, 1:Nc, k] .= u[5][2:Nc+1, 2, k]`; 2. `view(u[1], 1, 1:Nc, k) .= u[5][2:Nc+1, 2, k]`; 3. `u[1][1, 1:Nc, k] .= u[5][2, 2:Nc+1, k]`; 4. `view(u[1], 1, 1:Nc, k) .= u[5][2, 2:Nc+1, k]`. Here the data extracted from the `WindowedField` on the RHS is always in the form of a column vector resulting in a dimension mismatch error. As a potential solution, we can consider assigning a `view` of the `WindowedField` as. 1. `u[1][1, 1:Nc, k] .= view(u[5], 2:Nc+1, 2, k)`; 2. `view(u[1], 1, 1:Nc, k) .= view(u[5], 2:Nc+1, 2, k)`; 3. `u[1][1, 1:Nc, k] .= view(u[5], 2, 2:Nc+1, k)`; 4. `view(u[1], 1, 1:Nc, k) .= view(u[5], 2, 2:Nc+1, k)`. or the transpose of the `WindowedField` as. 1. `u[1][1, 1:Nc, k] .= u[5][2:Nc+1, 2, k]'`; 2. `view(u[1], 1, 1:Nc, k) .= u[5][2:Nc+1, 2, k]'`; 3. `u[1][1, 1:Nc, k] .= u[5][2, 2:Nc+1, k]'`; 4. `view(u[1], 1, 1:Nc, k) .= u[5][2, 2:Nc+1, k]'`. It turns out only the second approach results in the correct solution. ```julia; julia> u[1][:, :, 1]; 12×12 OffsetArray(::Matrix{Float64}, -3:8, -3:8) with eltype Float64 with indices -3:8×-3:8:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035885538
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481:50,Availability,recover,recover,50,"I think you're right that `view(::Field)` doesn't recover the same behavior as `view(::Array)`. This is because `Field` are fixed to three dimensions; we don't have a way to express the concept of a `Field` with one dimension. So for example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid);. julia> size(view(c, 1, :, 2)); (1, 3, 1). julia> size(view(parent(c), 1, :, 2)); (9,); ```. If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481:655,Energy Efficiency,reduce,reduced-dimensionality,655,"I think you're right that `view(::Field)` doesn't recover the same behavior as `view(::Array)`. This is because `Field` are fixed to three dimensions; we don't have a way to express the concept of a `Field` with one dimension. So for example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid);. julia> size(view(c, 1, :, 2)); (1, 3, 1). julia> size(view(parent(c), 1, :, 2)); (9,); ```. If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481:50,Safety,recover,recover,50,"I think you're right that `view(::Field)` doesn't recover the same behavior as `view(::Array)`. This is because `Field` are fixed to three dimensions; we don't have a way to express the concept of a `Field` with one dimension. So for example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid);. julia> size(view(c, 1, :, 2)); (1, 3, 1). julia> size(view(parent(c), 1, :, 2)); (9,); ```. If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038161718:1250,Availability,down,down,1250,"Rather than working in the complicated setting of a multiregion grid, it might be better to have a simpler context to look at the issue. Here's an MWE:. ```julia; julia> grid = RectilinearGrid(size=(3, 3, 3), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); set!(c, (x, y, z) -> randn()); 3×3×3 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 9×9×9 OffsetArray(::Array{Float64, 3}, -2:6, -2:6, -2:6) with eltype Float64 with indices -2:6×-2:6×-2:6; └── max=2.47269, min=-2.49748, mean=-0.0773234. julia> a = rand(3, 3, 3); b = rand(3, 3, 3);; ```. Now we can illustrate how `Field` does not behave like `Array`. This works:. ```julia; julia> view(a, :, 1, 1) .= view(b, 1, :, 1); 3-element view(::Array{Float64, 3}, :, 1, 1) with eltype Float64:; 0.23703924592859704; 0.02820508483630202; 0.7546236569353038; ```. but this does not:. ```julia; julia> view(a, :, 1, 1) .= view(c, 1, :, 1); ```. and instead throws `DimensionMismatch`. Does that boil down the issue @siddharthabishnu ?. Actually, it is curious that for some reason things do work out correctly if setting to a `Field`:. ```julia; julia> d = CenterField(grid);. julia> view(d, :, 1, 1) .= view(c, 1, :, 1);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.06779701769558852; -1.1932513091536738; -1.1239966299690682. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.06779701769558852; -0.5935171905074843; 1.399692772040493; ```. No idea why that works...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038161718
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038161718:99,Usability,simpl,simpler,99,"Rather than working in the complicated setting of a multiregion grid, it might be better to have a simpler context to look at the issue. Here's an MWE:. ```julia; julia> grid = RectilinearGrid(size=(3, 3, 3), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); set!(c, (x, y, z) -> randn()); 3×3×3 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 9×9×9 OffsetArray(::Array{Float64, 3}, -2:6, -2:6, -2:6) with eltype Float64 with indices -2:6×-2:6×-2:6; └── max=2.47269, min=-2.49748, mean=-0.0773234. julia> a = rand(3, 3, 3); b = rand(3, 3, 3);; ```. Now we can illustrate how `Field` does not behave like `Array`. This works:. ```julia; julia> view(a, :, 1, 1) .= view(b, 1, :, 1); 3-element view(::Array{Float64, 3}, :, 1, 1) with eltype Float64:; 0.23703924592859704; 0.02820508483630202; 0.7546236569353038; ```. but this does not:. ```julia; julia> view(a, :, 1, 1) .= view(c, 1, :, 1); ```. and instead throws `DimensionMismatch`. Does that boil down the issue @siddharthabishnu ?. Actually, it is curious that for some reason things do work out correctly if setting to a `Field`:. ```julia; julia> d = CenterField(grid);. julia> view(d, :, 1, 1) .= view(c, 1, :, 1);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.06779701769558852; -1.1932513091536738; -1.1239966299690682. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.06779701769558852; -0.5935171905074843; 1.399692772040493; ```. No idea why that works...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038161718
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542:688,Availability,down,down,688,"> Actually, it is curious that for some reason things do work out correctly if setting to a `Field`:; > ; > ```julia; > julia> d = CenterField(grid);; > ; > julia> view(d, :, 1, 1) .= view(c, 1, :, 1);; > ; > julia> interior(d, :, 1, 1); > 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; > 0.06779701769558852; > -1.1932513091536738; > -1.1239966299690682; > ; > julia> interior(c, 1, :, 1); > 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; > 0.06779701769558852; > -0.5935171905074843; > 1.399692772040493; > ```; > ; > No idea why that works... @glwagner, Thanks for creating the MWE without the complication of a multiregion grid and boiling down the issue. However, I disagree on your last point. Things do not work correctly in case of a `Field`. Yes, it doesn't throw an error, but the data of `interior(c, 1, :, 1)` is not assigned to `interior(d, :, 1, 1)` except for the **first** element (as seen in your MWE and mine below). ```julia; julia> a = rand(3, 3, 3); b = rand(3, 3, 3);. julia> grid = RectilinearGrid(size=(3, 3, 3), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); d = CenterField(grid);. julia> set!(c,a); set!(d,b);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.006219191907858468; 0.8963174540626572; 0.06824259256136866. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.45223462463057673; 0.18046843834182114; 0.9782543808912043. julia> view(d, :, 1, 1) .= view(c, 1, :, 1); 3×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, 1:1, 1:1); └── data: 9×1×1 OffsetArray(view(::Array{Float64, 3}, :, 4:4, 4:4), -2:6, 1:1, 1:1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542:820,Availability,error,error,820,"> Actually, it is curious that for some reason things do work out correctly if setting to a `Field`:; > ; > ```julia; > julia> d = CenterField(grid);; > ; > julia> view(d, :, 1, 1) .= view(c, 1, :, 1);; > ; > julia> interior(d, :, 1, 1); > 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; > 0.06779701769558852; > -1.1932513091536738; > -1.1239966299690682; > ; > julia> interior(c, 1, :, 1); > 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; > 0.06779701769558852; > -0.5935171905074843; > 1.399692772040493; > ```; > ; > No idea why that works... @glwagner, Thanks for creating the MWE without the complication of a multiregion grid and boiling down the issue. However, I disagree on your last point. Things do not work correctly in case of a `Field`. Yes, it doesn't throw an error, but the data of `interior(c, 1, :, 1)` is not assigned to `interior(d, :, 1, 1)` except for the **first** element (as seen in your MWE and mine below). ```julia; julia> a = rand(3, 3, 3); b = rand(3, 3, 3);. julia> grid = RectilinearGrid(size=(3, 3, 3), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); d = CenterField(grid);. julia> set!(c,a); set!(d,b);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.006219191907858468; 0.8963174540626572; 0.06824259256136866. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.45223462463057673; 0.18046843834182114; 0.9782543808912043. julia> view(d, :, 1, 1) .= view(c, 1, :, 1); 3×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, 1:1, 1:1); └── data: 9×1×1 OffsetArray(view(::Array{Float64, 3}, :, 4:4, 4:4), -2:6, 1:1, 1:1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542:2749,Availability,error,error,2749," julia> set!(c,a); set!(d,b);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.006219191907858468; 0.8963174540626572; 0.06824259256136866. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.45223462463057673; 0.18046843834182114; 0.9782543808912043. julia> view(d, :, 1, 1) .= view(c, 1, :, 1); 3×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, 1:1, 1:1); └── data: 9×1×1 OffsetArray(view(::Array{Float64, 3}, :, 4:4, 4:4), -2:6, 1:1, 1:1) with eltype Float64 with indices -2:6×1:1×1:1; └── max=0.697903, min=0.452235, mean=0.568357. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.45223462463057673; 0.6979033041564312; 0.5549323977919884; ```. However, the following works for the interior of the `Field`:; ```julia; julia> interior(d, :, 1, 1) .= interior(c, 1, :, 1);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.45223462463057673; 0.18046843834182114; 0.9782543808912043; ```. Moreover, since `view(d, :, 1, 1).data` is a 9x1x1 OffsetArray and `view(c, 1, :, 1).data` is a 1x9x1 OffsetArray, ; `view(d, :, 1, 1).data .= view(c, 1, :, 1).data` leads to a dimension mismatch error. However, the following approach gives the correct result. . ```julia; julia> set!(c,a); set!(d,b);. julia> view(d, :, 1, 1).data .= reshape(view(c, 1, :, 1).data, -2:6, 1:1, 1:1); 9×1×1 OffsetArray(view(::Array{Float64, 3}, :, 4:4, 4:4), -2:6, 1:1, 1:1) with eltype Float64 with indices -2:6×1:1×1:1:; [:, :, 1] =; 0.0; 0.0; 0.0; 0.45223462463057673; 0.18046843834182114; 0.9782543808912043; 0.0; 0.0; 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038634081:175,Energy Efficiency,reduce,reduced-dimensionality,175,"> If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?. Yes, it would be nice to have that feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038634081
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038968197:27,Availability,error,error,27,"> Yes, it doesn't throw an error, but the data of interior(c, 1, :, 1) is not assigned to interior(d, :, 1, 1) except for the first element (as seen in your MWE and mine below). Heh, true. That's a relief actually...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038968197
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357:177,Energy Efficiency,reduce,reduced-dimensionality,177,"> > If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?; > ; > Yes, it would be nice to have that feature. Do you want to have a crack at it? I don't use broadcasting with fields so much personally. It's a bit slow for some reason, which we have never quite figured out. Convenient for some things but not to be relied on unless we can solve the performance issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357
https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357:534,Performance,perform,performance,534,"> > If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?; > ; > Yes, it would be nice to have that feature. Do you want to have a crack at it? I don't use broadcasting with fields so much personally. It's a bit slow for some reason, which we have never quite figured out. Convenient for some things but not to be relied on unless we can solve the performance issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782185223:272,Availability,down,downside,272,"This is the issue that described what I was seeing: https://github.com/CliMA/Oceananigans.jl/issues/3290. @johnryantaylor does that looks like what you're seeing?. If so, the two workarounds that I have come up with are. - to run on branch #3080 like @glwagner suggested (downside here is that this branch is kinda out-of-date and apparently stale); - Make the `x` (or `y`) directions periodic (seems like `x`already is in your case) and tilt the domain accordingly. (The second video in https://github.com/CliMA/Oceananigans.jl/issues/3290 illustrates that). If that's not your issue, do you mind posting the animatino you're generating?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782185223
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782219409:187,Performance,perform,performance,187,"Given that there seems to be increasing interest in vertically-periodic simulations, we could revive #3080 (despite the caveats mentioned there, which mainly unknowns associated with the performance of potential future nonhydrostatic solvers for complex domains), since it's always possible to reverse course in the future and restore the separation (perhaps when the separation is restored, it can be done in a way that's compatible with vertically periodic domains).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782219409
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782221137:388,Availability,down,downside,388,"> This is the issue that described what I was seeing: #3290; > ; > @johnryantaylor does that looks like what you're seeing?; > ; > If so, the two workarounds that I have come up with are; > ; > * to run on branch [Don't separate the pressure into hydrostatic and nonhydrostatic in `NonhydrostaticModel` #3080](https://github.com/CliMA/Oceananigans.jl/pull/3080) like @glwagner suggested (downside here is that this branch is kinda out-of-date and apparently stale); > * Make the `x` (or `y`) directions periodic (seems like `x`already is in your case) and tilt the domain accordingly. (The second video in [Having a domain that's periodic in the ""gravity"" direction doesn't work for `gravity_unit_vector = NegativeZDirection()` #3290](https://github.com/CliMA/Oceananigans.jl/issues/3290) illustrates that); > ; > If that's not your issue, do you mind posting the animatino you're generating?. And just to confirm @tomchor those issues are not associated with BackgroundField, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782221137
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782230866:1376,Energy Efficiency,schedul,schedule,1376,"ta3,; closure = ScalarDiffusivity(ν=1e-6, κ=1e-6),; tracers = :b,; buoyancy = BuoyancyTracer(),; background_fields = (; b=B)) # `background_fields` is a `NamedTuple`. A = 0.01; u_ic(x, y, z) = A * randn(); w_ic(x, y, z) = A * randn(). set!(model, u=u_ic, w=w_ic). simulation = Simulation(model, Δt=0.01, stop_iteration=200). wizard = TimeStepWizard(cfl=0.3, diffusive_cfl=0.3, max_change=1.2, max_Δt=1); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(1)). progress(sim) = @printf(""i: % 6d, sim time: % 1.3f, wall time: % 10s, Δt: % 1.4f, advective CFL: %.2e, diffusive CFL: %.2e\n"",; iteration(sim), time(sim), prettytime(sim.run_wall_time),; sim.Δt,; AdvectiveCFL(sim.Δt)(sim.model),; DiffusiveCFL(sim.Δt)(sim.model)). simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""background_field_test.jld2""; simulation.output_writers[:velocities] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),; filename = filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); bt = FieldTimeSeries(filename, ""b""); t = wt.times; Nt = length(t); n = Observable(1). wn = @lift interior(wt[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). fig = Figure(resolution=(1500, 700)); axw = Axis(fig[1, 1]); axb = Axis(fig[1, 2]). heatmap!(axw, wn); heatmap!(axb, bn). topostr = string(Oceananigans.Grids.topology(grid, 3)). record(fig, ""vertically_$topostr.mp4"", 1:Nt, framerate=12) do nn; @info ""Drawing frame $nn of $Nt...""; n[] = nn; end; ```. # `vertically_Bounded.mp4`. https://github.com/CliMA/Oceananigans.jl/assets/15271942/8b63ae62-1a44-47c2-931b-9db154adddc2. # `vertically_Periodic.mp4`. https://github.com/CliMA/Oceananigans.jl/assets/15271942/8af44a0f-451e-4f58-a6f0-e204a4e65bd3. The easiest fix is to eliminate the pressure separation. Another solution is to fix the hydrostatic pressure algorithm. We should also note that the vertical tridiagonal solve is not corr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782230866
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782233834:390,Availability,down,downside,390,"> > This is the issue that described what I was seeing: #3290; > > @johnryantaylor does that looks like what you're seeing?; > > If so, the two workarounds that I have come up with are; > > ; > > * to run on branch [Don't separate the pressure into hydrostatic and nonhydrostatic in `NonhydrostaticModel` #3080](https://github.com/CliMA/Oceananigans.jl/pull/3080) like @glwagner suggested (downside here is that this branch is kinda out-of-date and apparently stale); > > * Make the `x` (or `y`) directions periodic (seems like `x`already is in your case) and tilt the domain accordingly. (The second video in [Having a domain that's periodic in the ""gravity"" direction doesn't work for `gravity_unit_vector = NegativeZDirection()` #3290](https://github.com/CliMA/Oceananigans.jl/issues/3290) illustrates that); > > ; > > If that's not your issue, do you mind posting the animatino you're generating?; > ; > And just to confirm @tomchor those issues are not associated with BackgroundField, right?. If it's the same issue as the one I pointed out in #3290 (which is not 100% clear atm), then you're right, they're not associated with `BackgroundField`. They have to do with trying to enforce a periodic pressure when the hydrostatic pressure is aperiodic on `z` due to the fact that it comes from a `b` integral in `z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782233834
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782233834:1075,Usability,clear,clear,1075,"> > This is the issue that described what I was seeing: #3290; > > @johnryantaylor does that looks like what you're seeing?; > > If so, the two workarounds that I have come up with are; > > ; > > * to run on branch [Don't separate the pressure into hydrostatic and nonhydrostatic in `NonhydrostaticModel` #3080](https://github.com/CliMA/Oceananigans.jl/pull/3080) like @glwagner suggested (downside here is that this branch is kinda out-of-date and apparently stale); > > * Make the `x` (or `y`) directions periodic (seems like `x`already is in your case) and tilt the domain accordingly. (The second video in [Having a domain that's periodic in the ""gravity"" direction doesn't work for `gravity_unit_vector = NegativeZDirection()` #3290](https://github.com/CliMA/Oceananigans.jl/issues/3290) illustrates that); > > ; > > If that's not your issue, do you mind posting the animatino you're generating?; > ; > And just to confirm @tomchor those issues are not associated with BackgroundField, right?. If it's the same issue as the one I pointed out in #3290 (which is not 100% clear atm), then you're right, they're not associated with `BackgroundField`. They have to do with trying to enforce a periodic pressure when the hydrostatic pressure is aperiodic on `z` due to the fact that it comes from a `b` integral in `z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782233834
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151:517,Integrability,interface,interface,517,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151:25,Testability,test,tests,25,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151:535,Usability,simpl,simplifications,535,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267:1124,Safety,safe,safe,1124,"Hi both, Thanks for the quick replies on this. I agree that it seems like it is likely coming from the background gradient and lack of periodicity when applied to the hydrostatic presssure. As far as I can tell there aren't any problems for passive scalars which supports that interpretation. As an aside, I think that there are also boundary artifacts in the internal_wave.jl example (although you need to run the simulation longer and you can't see them with the default contouring of the plots). . A solution that should work is to implicitly cancel the hydrostatic pressure gradient associated with the background field with the buoyancy term. This is what we do in Diablo (although we don't decompose the pressure into hydrostatic and nonhydrostatic components). Implementing this is simple since you just don't include the background gradient when calculating the hydrostatic pressure. The only trouble that I see is figuring out when to do this. In other contexts you want to keep this term. E.g. in the geostrophic adjustment problem, the hydrostatic pressure gradient is needed to drive the flow. Maybe it would be safe to exclude the background buoyancy field in the calculation of the hydrostatic pressure anytime when the topology is periodic in the vertical direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267:789,Usability,simpl,simple,789,"Hi both, Thanks for the quick replies on this. I agree that it seems like it is likely coming from the background gradient and lack of periodicity when applied to the hydrostatic presssure. As far as I can tell there aren't any problems for passive scalars which supports that interpretation. As an aside, I think that there are also boundary artifacts in the internal_wave.jl example (although you need to run the simulation longer and you can't see them with the default contouring of the plots). . A solution that should work is to implicitly cancel the hydrostatic pressure gradient associated with the background field with the buoyancy term. This is what we do in Diablo (although we don't decompose the pressure into hydrostatic and nonhydrostatic components). Implementing this is simple since you just don't include the background gradient when calculating the hydrostatic pressure. The only trouble that I see is figuring out when to do this. In other contexts you want to keep this term. E.g. in the geostrophic adjustment problem, the hydrostatic pressure gradient is needed to drive the flow. Maybe it would be safe to exclude the background buoyancy field in the calculation of the hydrostatic pressure anytime when the topology is periodic in the vertical direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267
https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783860681:212,Testability,test,test,212,"Actually, I think I misunderstood the problem... Based on update_hydrostatic_pressure.jl, it doesn't look like the background buoyancy field is used in the calculation of the hydrostatic pressure. Indeed a quick test with a background horizontal buoyancy gradient and no initial velocity doesn't drive a flow. Now I think I understand what @tomchor and @glwagner were saying: the problem arises due to the vertical periodicity and not the background buoyancy field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783860681
https://github.com/CliMA/Oceananigans.jl/pull/3368#issuecomment-1814763703:67,Testability,test,tests,67,@simone-silvestri so close! Can you take a look at the distributed tests?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3368#issuecomment-1814763703
https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1789395517:671,Energy Efficiency,allocate,allocate,671,"To include an updatable friction velocity in the model constant calculation, we'd do something like. ```julia; @inline function van_driest_damping_function(x, y, z, p); # Position of first grid cell; z₀ = p.Δz₀ / 2; z₁ = 1 - p.Δz₁ / 2. # Distances to the wall, noting that `δ⁺₀` and `δ⁺₁` are `Ref`; d⁺₀ = (z - z₀) / p.δ⁺₀[]; d⁺₁ = (z₁ - z) / p.δ⁺₁[]; d⁺ = min(d⁺₀, d⁺₁). # Model constants; A⁺ = p.A⁺; C = p.C. return C * (1 - exp(d⁺ / A⁺)); end; # Find grid spacing at top and bottom, assuming rectilinearity; Nz = size(grid, 3); Δz₀ = zspacing(1, 1, 1, grid, Center(), Center(), Center()); Δz₁ = zspacing(1, 1, Nz, grid, Center(), Center(), Center()). δ⁺₀ = Ref(0.0) # allocate an updatable reference to `δ⁺` (for the top and bottom separately), which we will compute within a Callback; δ⁺₁ = Ref(0.0) # Reference to the bottom `δ⁺`. parameters = (C = 0.16,; A⁺ = 26, # :-D; Δz₀ = Δz₀, # vertical grid spacing at the bottom; Δz₁ = Δz₁, # vertical grid spacing at the top; δ⁺₀ = δ⁺₀,; δ⁺₁ = δ⁺₁) # function of molecular_diffusivity.ν. van_driest_damping = FunctionField{Center, Center, Center}(van_driest_damping_function, grid; parameters). # later... function compute_wall_length_scales!(sim); δ⁺₀[] = # computed as function of sim.model.velocities; return nothing; end. simulaton.callbacks[:length_scale_computation] = Callback(compute_wall_length_scales!); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1789395517
https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801735572:49,Availability,error,error,49,"@glwagner When I run the example above, I get an error: Cannot `convert` an object of type FunctionField to an object of type Float64 from the line where you set the smagorinksy closure. ```; van_driest_damping = FunctionField{Center, Center, Center}(van_driest_damping_function, grid; parameters). smagorinsky_lilly = SmagorinskyLilly(vitd, C=van_driest_damping); ```; I also noticed that the new function SmagorinskyLilly you changed in smagorinksy_lilly.jl isn't in the file under ""main"". So is this error because the change hasn't been fully implemented yet?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801735572
https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801735572:503,Availability,error,error,503,"@glwagner When I run the example above, I get an error: Cannot `convert` an object of type FunctionField to an object of type Float64 from the line where you set the smagorinksy closure. ```; van_driest_damping = FunctionField{Center, Center, Center}(van_driest_damping_function, grid; parameters). smagorinsky_lilly = SmagorinskyLilly(vitd, C=van_driest_damping); ```; I also noticed that the new function SmagorinskyLilly you changed in smagorinksy_lilly.jl isn't in the file under ""main"". So is this error because the change hasn't been fully implemented yet?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801735572
https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801867651:61,Deployability,install,install,61,"The PR isn't merged. To use the code on this PR, you have to install it at the Julia REPL by first typing `]` to enter package manager mode, and then writing:. ```julia; pkg> add Oceananigans#glw/closure-constant; ```. Once you've updated your local version of Oceananigans to use the code on this PR, you can test the source code changes that we've made.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801867651
https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801867651:231,Deployability,update,updated,231,"The PR isn't merged. To use the code on this PR, you have to install it at the Julia REPL by first typing `]` to enter package manager mode, and then writing:. ```julia; pkg> add Oceananigans#glw/closure-constant; ```. Once you've updated your local version of Oceananigans to use the code on this PR, you can test the source code changes that we've made.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801867651
https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801867651:310,Testability,test,test,310,"The PR isn't merged. To use the code on this PR, you have to install it at the Julia REPL by first typing `]` to enter package manager mode, and then writing:. ```julia; pkg> add Oceananigans#glw/closure-constant; ```. Once you've updated your local version of Oceananigans to use the code on this PR, you can test the source code changes that we've made.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801867651
https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155:118,Energy Efficiency,adapt,adapt,118,That was just an example. There's a lot of erroneous usage. This might help:. ```; (base) gregorywagner:src/ (glw/fix-adapt) $ grep -r unroll ./* [11:11:55]; ./Advection/Advection.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./BoundaryConditions/fill_halo_regions_open.jl:# and need to unroll a loop over the boundary normal direction.; ./BoundaryConditions/fill_halo_regions.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_flux.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl: @inbounds @unroll for k = 1:target_grid.Nz; ./Fields/regridding_fields.jl: @unroll for k_src = k₋_src:k₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for j = 1:target_grid.Ny; ./Fields/regridding_fields.jl: @unroll for j_src = j₋_src:j₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for i = 1:target_grid.Nx; ./Fields/regridding_fields.jl: @unroll for i_src = i₋_src:i₊_src-1; ./Fields/field_boundary_buffers.jl:using KernelAbstractions.Extras.Lo,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155
https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155:118,Modifiability,adapt,adapt,118,That was just an example. There's a lot of erroneous usage. This might help:. ```; (base) gregorywagner:src/ (glw/fix-adapt) $ grep -r unroll ./* [11:11:55]; ./Advection/Advection.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./BoundaryConditions/fill_halo_regions_open.jl:# and need to unroll a loop over the boundary normal direction.; ./BoundaryConditions/fill_halo_regions.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_flux.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl: @inbounds @unroll for k = 1:target_grid.Nz; ./Fields/regridding_fields.jl: @unroll for k_src = k₋_src:k₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for j = 1:target_grid.Ny; ./Fields/regridding_fields.jl: @unroll for j_src = j₋_src:j₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for i = 1:target_grid.Nx; ./Fields/regridding_fields.jl: @unroll for i_src = i₋_src:i₊_src-1; ./Fields/field_boundary_buffers.jl:using KernelAbstractions.Extras.Lo,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155
https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874465464:647,Safety,safe,safe,647,"> Any place where the loop limits are not types, it's wrong. It only works if the limits are known via types (so they are known at compile time rather than runtime). Typically this would require uusing `Val{N}` or `Val{H}` but even then it can fail sometimes. I'm not sure I understand what you mean here. Can you give an example that's OK and one that's not?; Also, @unroll comes from `KernelAbstractions.Extras.LoopInfo.@unroll`, right? The docstring is not really helping me on this:. ```Julia; help?> KernelAbstractions.Extras.LoopInfo.@unroll; @unroll expr. Takes a for loop as expr and informs the LLVM unroller to fully unroll it, if it is safe to do so and the loop count is known. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. @unroll N expr. Takes a for loop as expr and informs the LLVM unroller to unroll it N times, if it is safe to do so.; ```. In particular, I don't know what ""if it is safe to do so"" refers to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874465464
https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874465464:920,Safety,safe,safe,920,"> Any place where the loop limits are not types, it's wrong. It only works if the limits are known via types (so they are known at compile time rather than runtime). Typically this would require uusing `Val{N}` or `Val{H}` but even then it can fail sometimes. I'm not sure I understand what you mean here. Can you give an example that's OK and one that's not?; Also, @unroll comes from `KernelAbstractions.Extras.LoopInfo.@unroll`, right? The docstring is not really helping me on this:. ```Julia; help?> KernelAbstractions.Extras.LoopInfo.@unroll; @unroll expr. Takes a for loop as expr and informs the LLVM unroller to fully unroll it, if it is safe to do so and the loop count is known. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. @unroll N expr. Takes a for loop as expr and informs the LLVM unroller to unroll it N times, if it is safe to do so.; ```. In particular, I don't know what ""if it is safe to do so"" refers to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874465464
https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874465464:984,Safety,safe,safe,984,"> Any place where the loop limits are not types, it's wrong. It only works if the limits are known via types (so they are known at compile time rather than runtime). Typically this would require uusing `Val{N}` or `Val{H}` but even then it can fail sometimes. I'm not sure I understand what you mean here. Can you give an example that's OK and one that's not?; Also, @unroll comes from `KernelAbstractions.Extras.LoopInfo.@unroll`, right? The docstring is not really helping me on this:. ```Julia; help?> KernelAbstractions.Extras.LoopInfo.@unroll; @unroll expr. Takes a for loop as expr and informs the LLVM unroller to fully unroll it, if it is safe to do so and the loop count is known. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. @unroll N expr. Takes a for loop as expr and informs the LLVM unroller to unroll it N times, if it is safe to do so.; ```. In particular, I don't know what ""if it is safe to do so"" refers to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874465464
https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874467696:267,Usability,simpl,simply,267,"> Any place where the loop limits are not types, it's wrong. It only works if the limits are known via types (so they are known at compile time rather than runtime). Typically this would require uusing `Val{N}` or `Val{H}` but even then it can fail sometimes. Do you simply mean that. ```Julia; @unroll for j in 1:4; do_this(); end; ```; is OK but; ```Julia; N=4; @unroll for j in 1:N; do_this(); end; ```; is not?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874467696
https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1877550519:276,Usability,simpl,simply,276,"> > Any place where the loop limits are not types, it's wrong. It only works if the limits are known via types (so they are known at compile time rather than runtime). Typically this would require uusing `Val{N}` or `Val{H}` but even then it can fail sometimes.; > ; > Do you simply mean that; > ; > ```julia; > @unroll for j in 1:4; do_this(); end; > ```; > ; > is OK but; > ; > ```julia; > N=4; > @unroll for j in 1:N; do_this(); end; > ```; > ; > is not?. Both are fine the way you have written them, because even in the second case the compiler is able to infer that `N` is always `4`, the way you've written it. But `@unroll for i = 1:grid.Nx` is not fine because `grid.Nx` is not known at compile time, it is passed into the function as a property of the `grid`. At compile time, only the type of the grid is known, and not the values that are contained in it. If one is careful to pass the limits of the loop as _compile-time information_, then we can pass information into a function. Typically this is done with objects like like `Val(N)` which have type signature `::Val{N}`. Since here `N` is type information it is known to the compiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1877550519
https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1877552215:254,Usability,clear,clear,254,"> Can you give an example that's OK and one that's not?. The example that is ok is when the limit of the loop `N` is passed in via an argument with _type_ `Val{N}`. Then `N` is known to the compiler. This is what I tried to indicate, sorry for not being clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1877552215
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1798383060:182,Testability,log,log,182,"> When you say ""initialization"" you mean the time between when you call `run!(simulation)` and before the simulation actually starts?. I think so, it corresponds to this line in the log for example:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (16.509 minutes); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1798383060
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799252941:518,Availability,down,down,518,"> > Interesting! Which version were you before updating?; > ; > I used v0.88.0 before. But even if I pin Oceananigans to v0.88.0, the issue still occurs, and the contents of `Manifest.toml` are not the same as before. That suggests that this could be an issue with your environment... What other packages are you using?. What can happen is that a package got upgraded when you bumped up to 0.90.0, but then because compat was satisfied with that upgraded package, it did _not_ get changed when you subsequently bumped down to 0.88.0. Upgrading is conservative, it doesn't happen unless you ask for it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799252941
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799252941:359,Deployability,upgrade,upgraded,359,"> > Interesting! Which version were you before updating?; > ; > I used v0.88.0 before. But even if I pin Oceananigans to v0.88.0, the issue still occurs, and the contents of `Manifest.toml` are not the same as before. That suggests that this could be an issue with your environment... What other packages are you using?. What can happen is that a package got upgraded when you bumped up to 0.90.0, but then because compat was satisfied with that upgraded package, it did _not_ get changed when you subsequently bumped down to 0.88.0. Upgrading is conservative, it doesn't happen unless you ask for it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799252941
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799252941:446,Deployability,upgrade,upgraded,446,"> > Interesting! Which version were you before updating?; > ; > I used v0.88.0 before. But even if I pin Oceananigans to v0.88.0, the issue still occurs, and the contents of `Manifest.toml` are not the same as before. That suggests that this could be an issue with your environment... What other packages are you using?. What can happen is that a package got upgraded when you bumped up to 0.90.0, but then because compat was satisfied with that upgraded package, it did _not_ get changed when you subsequently bumped down to 0.88.0. Upgrading is conservative, it doesn't happen unless you ask for it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799252941
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799285569:115,Testability,Test,Test-LK,115,> Can you post the output of; > ; > ```julia; > using Pkg; Pkg.status(); > ```. ```; Status `~/Projects/TRACE-SEAS/Test-LK/Project.toml`; [9e8cae18] Oceananigans v0.90.0; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799285569
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799289983:127,Testability,Test,Test-LK,127,"> > Can you post the output of; > > ```julia; > > using Pkg; Pkg.status(); > > ```; > ; > ```; > Status `~/Projects/TRACE-SEAS/Test-LK/Project.toml`; > [9e8cae18] Oceananigans v0.90.0; > ```. OK, I see. Pretty clean environment! :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799289983
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804711654:525,Energy Efficiency,schedul,schedule,525,"So I did a bench. I run this:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid). Δt=20minutes; simulation = Simulation(model, Δt=20minutes, stop_time=4Δt). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)). @time run!(simulation); ```. on my laptop on an evnironment with _only_ Oceananigans. Just for the record, my general env contains:. ```Julia; (@v1.9) pkg> st; Status `~/.julia/environments/v1.9/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [13f3f980] CairoMakie v0.10.12; [e9467ef8] GLMakie v0.8.12; [db073c08] GeoMakie v0.5.1; [7073ff75] IJulia v1.24.2; [12c4ca38] Imaginocean v0.1.0 `https://github.com/navidcy/Imaginocean.jl#main`; [85f8d34a] NCDatasets v0.13.1; [5fb14364] OhMyREPL v0.5.23; [c3e4b0f8] Pluto v0.19.32; [295af30f] Revise v3.5.7; ```. Now on an environment with **Oceananigans v0.89.3** I get:. ```Julia; julia> @time run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (18.715 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (7.933 seconds).; [ Info: Simulation is stopping after running for 18.861 minutes.; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 1134.663423 seconds (2.18 G allocations: 1.143 TiB, 10.69% gc time, 100.03% compilation time); ```. while with **Oceananigans v0.90.1** I get:. ```Julia; julia> @time run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (13.845 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.351 seconds).; [ I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804711654
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804711654:836,Testability,Benchmark,BenchmarkTools,836,"So I did a bench. I run this:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid). Δt=20minutes; simulation = Simulation(model, Δt=20minutes, stop_time=4Δt). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)). @time run!(simulation); ```. on my laptop on an evnironment with _only_ Oceananigans. Just for the record, my general env contains:. ```Julia; (@v1.9) pkg> st; Status `~/.julia/environments/v1.9/Project.toml`; [6e4b80f9] BenchmarkTools v1.3.2; [13f3f980] CairoMakie v0.10.12; [e9467ef8] GLMakie v0.8.12; [db073c08] GeoMakie v0.5.1; [7073ff75] IJulia v1.24.2; [12c4ca38] Imaginocean v0.1.0 `https://github.com/navidcy/Imaginocean.jl#main`; [85f8d34a] NCDatasets v0.13.1; [5fb14364] OhMyREPL v0.5.23; [c3e4b0f8] Pluto v0.19.32; [295af30f] Revise v3.5.7; ```. Now on an environment with **Oceananigans v0.89.3** I get:. ```Julia; julia> @time run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (18.715 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (7.933 seconds).; [ Info: Simulation is stopping after running for 18.861 minutes.; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 1134.663423 seconds (2.18 G allocations: 1.143 TiB, 10.69% gc time, 100.03% compilation time); ```. while with **Oceananigans v0.90.1** I get:. ```Julia; julia> @time run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (13.845 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.351 seconds).; [ I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804711654
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804781556:321,Availability,avail,available,321,"I'm on an Apple Silicon M1:. ```Julia; julia> versioninfo(); Julia Version 1.9.3; Commit bed2cd540a (2023-08-24 14:43 UTC); Build Info:. Note: This is an unofficial build, please report bugs to the project; responsible for this build and not to the Julia project unless you can; reproduce the issue using official builds available at https://julialang.org/downloads. Platform Info:; OS: macOS (arm64-apple-darwin22.6.0); CPU: 10 × Apple M1 Max; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, apple-m1); Threads: 8 on 8 virtual cores; Environment:; JULIA_EDITOR = code; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804781556
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804781556:356,Availability,down,downloads,356,"I'm on an Apple Silicon M1:. ```Julia; julia> versioninfo(); Julia Version 1.9.3; Commit bed2cd540a (2023-08-24 14:43 UTC); Build Info:. Note: This is an unofficial build, please report bugs to the project; responsible for this build and not to the Julia project unless you can; reproduce the issue using official builds available at https://julialang.org/downloads. Platform Info:; OS: macOS (arm64-apple-darwin22.6.0); CPU: 10 × Apple M1 Max; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, apple-m1); Threads: 8 on 8 virtual cores; Environment:; JULIA_EDITOR = code; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804781556
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804812622:226,Integrability,wrap,wrap,226,"> Well, I don't know what is long or short (but I agree, O(10mins) seems bit long). But most importantly, in my benches I find that v0.90.1 is **faster** than 0.89.3, contrary to what you claim. Do you see a difference if you wrap `ζ` in `Field`? I guess that is my major claim.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804812622
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189:148,Modifiability,variab,variable,148,"Ah yes as noted here:. > This speed issue disappears either when ζ = ∂x(v) - ∂y(u) is replaced with ζ = Field(∂x(v) - ∂y(u)), or when ζ is the only variable in fields_slice. That's pretty bizarre. That makes me think it's some kind of weird interaction between `NCDatasets` and `Oceananigans`. I can say, with `ζ = Field(∂x(v) - ∂y(u))` the output type is different. It would seem more complex in fact, because it has one more layer of indirection (ie it's the window that refers to a 3D computed field, rather than a windowed computed field). So I don't know why that would compile faster. Honestly I don't think any of us has much experience optimizing compile time. Perhaps first reading this blog post:. https://julialang.org/blog/2020/08/invalidations/. and then the source code for `NetCDFOutputWriter` will lead to revelations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189:644,Performance,optimiz,optimizing,644,"Ah yes as noted here:. > This speed issue disappears either when ζ = ∂x(v) - ∂y(u) is replaced with ζ = Field(∂x(v) - ∂y(u)), or when ζ is the only variable in fields_slice. That's pretty bizarre. That makes me think it's some kind of weird interaction between `NCDatasets` and `Oceananigans`. I can say, with `ζ = Field(∂x(v) - ∂y(u))` the output type is different. It would seem more complex in fact, because it has one more layer of indirection (ie it's the window that refers to a 3D computed field, rather than a windowed computed field). So I don't know why that would compile faster. Honestly I don't think any of us has much experience optimizing compile time. Perhaps first reading this blog post:. https://julialang.org/blog/2020/08/invalidations/. and then the source code for `NetCDFOutputWriter` will lead to revelations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775:9,Deployability,update,updated,9,Before I updated and induced the problem I was getting O(seconds) initialisation time on M1 Mac so I think you're experiencing the problem with both versions @navidcy . I tried using JLD2 and got the same slow initialisation. Do they have a common dependency that does something to the field?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775:248,Integrability,depend,dependency,248,Before I updated and induced the problem I was getting O(seconds) initialisation time on M1 Mac so I think you're experiencing the problem with both versions @navidcy . I tried using JLD2 and got the same slow initialisation. Do they have a common dependency that does something to the field?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806441042:118,Deployability,install,installed,118,Hmm I'll have a go at that tomorrow. Weirdly when I try and run the above script from the Oceananigans repo (i.e. not installed with Pkg) I do not get this problem.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806441042
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806472691:120,Deployability,install,installed,120,"> Hmm I'll have a go at that tomorrow. Weirdly when I try and run the above script from the Oceananigans repo (i.e. not installed with Pkg) I do not get this problem. That might suggest its an interaction with another package, because when you use Oceananigans' repo you probably use the repo's Manifest.toml; otherwise you may be pulling in different packages. You can compare the Oceananigans Manifest to whatever Manifest gets used in the slow case. I think there may be tools for comparing Manifests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806472691
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:355,Availability,down,downgrade,355,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:574,Availability,Down,Downgrading,574,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:597,Availability,down,downgrades,597,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:736,Availability,down,downgraded,736,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:390,Integrability,Wrap,Wrapping,390,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:614,Integrability,depend,dependencies,614,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:2212,Availability,down,downgrading,2212,"was recompilation); ```. much better. (Note that on 1.10 we get a lot of annoying warnings which is documented on #3374 and is relatively easily fixed.). Also, things are fine if I use the Oceananigans Manifest.toml, even with julia 1.9:. ```; (base) gregorywagner:Oceananigans.jl/ (main✗) $ julia19 --project test.jl [3:13:09]; ┌ Warning: Overwriting existing ./mwe.nc.; └ @ Oceananigans.OutputWriters ~/Projects/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:359; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.381 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.751 seconds).; [ Info: Simulation is stopping after running for 12.013 seconds.; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 16.285006 seconds (38.66 M allocations: 2.598 GiB, 5.35% gc time, 99.82% compilation time); ```. That's weird... # What's the problem?. We haven't figured it out. One clue could be that downgrading to 0.85.0 fixes the problem. For completeness, here's a `diff` of the Oceananigans Manifest.toml, and the Manifest.toml in my ""clean"" environment:. <details>; <summary>Click me</summary>; ; ```; 3c3; < julia_version = ""1.9.3""; ---; > julia_version = ""1.9.2""; 5c5; < project_hash = ""72ed8b1b7715053c6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3036,Energy Efficiency,Adapt,Adapt,3036,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3540,Energy Efficiency,Adapt,Adapt,3540,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:7871,Energy Efficiency,Adapt,Adapt,7871,"pInfo]]; > git-tree-sha1 = ""2e5c102cfc41f48ae4740c7eca7743cc7e7b75ea""; > uuid = ""8b046642-f1f6-4319-8d3c-209ddc03c586""; > version = ""1.0.0""; 412c431; < git-tree-sha1 = ""f2355693d6778a178ade15952b7ac47a4ff97996""; ---; > git-tree-sha1 = ""50901ebc375ed41dbf8058da26f9de442febbbec""; 414c433; < version = ""1.3.0""; ---; > version = ""1.3.1""; 499c518; < git-tree-sha1 = ""781916a2ebf2841467cda03b6f1af43e23839d85""; ---; > git-tree-sha1 = ""8f6af051b9e8ec597fa09d8885ed79fd582f33c9""; 501c520; < version = ""0.1.9""; ---; > version = ""0.1.10""; 526c545; < git-tree-sha1 = ""a7023883872e52bc29bcaac74f19adf39347d2d5""; ---; > git-tree-sha1 = ""b01beb91d20b0d1312a9471a36017b5b339d26de""; 528c547; < version = ""10.1.4+0""; ---; > version = ""10.1.4+1""; 570a590,601; > [[deps.Oceananigans]]; > deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""Distances"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays""]; > path = ""/Users/gregorywagner/Projects/Oceananigans.jl""; > uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; > version = ""0.90.1""; >; > [deps.Oceananigans.extensions]; > OceananigansEnzymeCoreExt = ""EnzymeCore""; >; > [deps.Oceananigans.weakdeps]; > EnzymeCore = ""f151be2c-9106-41f4-ab19-57ee4f262869""; >; 588,589c619,620; < deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""TOML""]; < git-tree-sha1 = ""e25c1778a98e34219a00455d6e4384e017ea9762""; ---; > deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""Hwloc_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""PMIx_jll"", ""TOML"", ""Zlib_jll"", ""libevent_jll"", ""prrte_jll""]; > git-tree-sha1 = ""694458ae803b684f09c07f90459cb79655fb377d""; 591c622; < version = ""4.1.6+0""; ---; > versi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3036,Modifiability,Adapt,Adapt,3036,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3540,Modifiability,Adapt,Adapt,3540,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:7871,Modifiability,Adapt,Adapt,7871,"pInfo]]; > git-tree-sha1 = ""2e5c102cfc41f48ae4740c7eca7743cc7e7b75ea""; > uuid = ""8b046642-f1f6-4319-8d3c-209ddc03c586""; > version = ""1.0.0""; 412c431; < git-tree-sha1 = ""f2355693d6778a178ade15952b7ac47a4ff97996""; ---; > git-tree-sha1 = ""50901ebc375ed41dbf8058da26f9de442febbbec""; 414c433; < version = ""1.3.0""; ---; > version = ""1.3.1""; 499c518; < git-tree-sha1 = ""781916a2ebf2841467cda03b6f1af43e23839d85""; ---; > git-tree-sha1 = ""8f6af051b9e8ec597fa09d8885ed79fd582f33c9""; 501c520; < version = ""0.1.9""; ---; > version = ""0.1.10""; 526c545; < git-tree-sha1 = ""a7023883872e52bc29bcaac74f19adf39347d2d5""; ---; > git-tree-sha1 = ""b01beb91d20b0d1312a9471a36017b5b339d26de""; 528c547; < version = ""10.1.4+0""; ---; > version = ""10.1.4+1""; 570a590,601; > [[deps.Oceananigans]]; > deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""Distances"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays""]; > path = ""/Users/gregorywagner/Projects/Oceananigans.jl""; > uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; > version = ""0.90.1""; >; > [deps.Oceananigans.extensions]; > OceananigansEnzymeCoreExt = ""EnzymeCore""; >; > [deps.Oceananigans.weakdeps]; > EnzymeCore = ""f151be2c-9106-41f4-ab19-57ee4f262869""; >; 588,589c619,620; < deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""TOML""]; < git-tree-sha1 = ""e25c1778a98e34219a00455d6e4384e017ea9762""; ---; > deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""Hwloc_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""PMIx_jll"", ""TOML"", ""Zlib_jll"", ""libevent_jll"", ""prrte_jll""]; > git-tree-sha1 = ""694458ae803b684f09c07f90459cb79655fb377d""; 591c622; < version = ""4.1.6+0""; ---; > versi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3425,Safety,Unsafe,UnsafeAtomicsLLVM,3425,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3945,Safety,Unsafe,UnsafeAtomicsLLVM,3945,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:173,Testability,Benchmark,Benchmarks,173,"Thank you all for your informative responses! I dug into this a bit... *tl;dr* It looks like the issue _may_ be ""fixed"" on julia 1.10-beta3 (and there is a 1.10-rc1 now). # Benchmarks. Using an empty `Project.toml`, I can reproduce the issue when using julia 1.9:. ```; (base) gregorywagner:test/ $ julia19 --project test.jl [3:18:25]; ┌ Warning: Overwriting existing ./mwe.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/f5Cpw/src/OutputWriters/netcdf_output_writer.jl:359; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (15.100 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.244 seconds).; [ Info: Simulation is stopping after running for 15.251 minutes.; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 919.254871 seconds (2.19 G allocations: 1.143 TiB, 12.80% gc time, 100.00% compilation time); ```. Way, way too long. (So it's good we have this issue.). But on julia 1.10-beta3 I get. ```; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 17.237010 seconds (26.28 M allocations: 1.741 GiB, 2.14% gc time, 99.58% compilation time: <1% of which was recompilation); ```. much better. (Note that on 1.10 we get a lot of annoying warnings which is documented on #3374 and is relatively easily fixed.). Also, things are fine if I use the Oceananigans Manifest.toml, even with julia 1.9:. ```; (base) gregorywagner:Oceananigans.jl/ (main✗) $ julia19 --project test.jl [3:13:09]; ┌ Warning: Overwriting existing ./mwe.nc.; └ @ Oceananigans.OutputWriters ~/Projects/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:359; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.381 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.751 seconds).; [ Info: Simulation is stopping after running for 12.013 seconds.; [ Info: Simulation time 1.333 hours equals or exceeds",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:291,Testability,test,test,291,"Thank you all for your informative responses! I dug into this a bit... *tl;dr* It looks like the issue _may_ be ""fixed"" on julia 1.10-beta3 (and there is a 1.10-rc1 now). # Benchmarks. Using an empty `Project.toml`, I can reproduce the issue when using julia 1.9:. ```; (base) gregorywagner:test/ $ julia19 --project test.jl [3:18:25]; ┌ Warning: Overwriting existing ./mwe.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/f5Cpw/src/OutputWriters/netcdf_output_writer.jl:359; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (15.100 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.244 seconds).; [ Info: Simulation is stopping after running for 15.251 minutes.; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 919.254871 seconds (2.19 G allocations: 1.143 TiB, 12.80% gc time, 100.00% compilation time); ```. Way, way too long. (So it's good we have this issue.). But on julia 1.10-beta3 I get. ```; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 17.237010 seconds (26.28 M allocations: 1.741 GiB, 2.14% gc time, 99.58% compilation time: <1% of which was recompilation); ```. much better. (Note that on 1.10 we get a lot of annoying warnings which is documented on #3374 and is relatively easily fixed.). Also, things are fine if I use the Oceananigans Manifest.toml, even with julia 1.9:. ```; (base) gregorywagner:Oceananigans.jl/ (main✗) $ julia19 --project test.jl [3:13:09]; ┌ Warning: Overwriting existing ./mwe.nc.; └ @ Oceananigans.OutputWriters ~/Projects/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:359; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.381 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.751 seconds).; [ Info: Simulation is stopping after running for 12.013 seconds.; [ Info: Simulation time 1.333 hours equals or exceeds",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:317,Testability,test,test,317,"Thank you all for your informative responses! I dug into this a bit... *tl;dr* It looks like the issue _may_ be ""fixed"" on julia 1.10-beta3 (and there is a 1.10-rc1 now). # Benchmarks. Using an empty `Project.toml`, I can reproduce the issue when using julia 1.9:. ```; (base) gregorywagner:test/ $ julia19 --project test.jl [3:18:25]; ┌ Warning: Overwriting existing ./mwe.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/f5Cpw/src/OutputWriters/netcdf_output_writer.jl:359; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (15.100 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.244 seconds).; [ Info: Simulation is stopping after running for 15.251 minutes.; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 919.254871 seconds (2.19 G allocations: 1.143 TiB, 12.80% gc time, 100.00% compilation time); ```. Way, way too long. (So it's good we have this issue.). But on julia 1.10-beta3 I get. ```; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 17.237010 seconds (26.28 M allocations: 1.741 GiB, 2.14% gc time, 99.58% compilation time: <1% of which was recompilation); ```. much better. (Note that on 1.10 we get a lot of annoying warnings which is documented on #3374 and is relatively easily fixed.). Also, things are fine if I use the Oceananigans Manifest.toml, even with julia 1.9:. ```; (base) gregorywagner:Oceananigans.jl/ (main✗) $ julia19 --project test.jl [3:13:09]; ┌ Warning: Overwriting existing ./mwe.nc.; └ @ Oceananigans.OutputWriters ~/Projects/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:359; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.381 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.751 seconds).; [ Info: Simulation is stopping after running for 12.013 seconds.; [ Info: Simulation time 1.333 hours equals or exceeds",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:1518,Testability,test,test,1518,"itializing simulation...; [ Info: ... simulation initialization complete (15.100 minutes); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.244 seconds).; [ Info: Simulation is stopping after running for 15.251 minutes.; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 919.254871 seconds (2.19 G allocations: 1.143 TiB, 12.80% gc time, 100.00% compilation time); ```. Way, way too long. (So it's good we have this issue.). But on julia 1.10-beta3 I get. ```; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 17.237010 seconds (26.28 M allocations: 1.741 GiB, 2.14% gc time, 99.58% compilation time: <1% of which was recompilation); ```. much better. (Note that on 1.10 we get a lot of annoying warnings which is documented on #3374 and is relatively easily fixed.). Also, things are fine if I use the Oceananigans Manifest.toml, even with julia 1.9:. ```; (base) gregorywagner:Oceananigans.jl/ (main✗) $ julia19 --project test.jl [3:13:09]; ┌ Warning: Overwriting existing ./mwe.nc.; └ @ Oceananigans.OutputWriters ~/Projects/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:359; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.381 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (8.751 seconds).; [ Info: Simulation is stopping after running for 12.013 seconds.; [ Info: Simulation time 1.333 hours equals or exceeds stop time 1.333 hours.; 16.285006 seconds (38.66 M allocations: 2.598 GiB, 5.35% gc time, 99.82% compilation time); ```. That's weird... # What's the problem?. We haven't figured it out. One clue could be that downgrading to 0.85.0 fixes the problem. For completeness, here's a `diff` of the Oceananigans Manifest.toml, and the Manifest.toml in my ""clean"" environment:. <details>; <summary>Click me</summary>; ; ```; 3c3; < julia_version = ""1.9.3""; ---; > julia_version = ""1.9.2""; 5c5; < project_hash = ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3271,Testability,Log,Logging,3271,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3791,Testability,Log,Logging,3791,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:8078,Testability,Log,Logging,8078,"pInfo]]; > git-tree-sha1 = ""2e5c102cfc41f48ae4740c7eca7743cc7e7b75ea""; > uuid = ""8b046642-f1f6-4319-8d3c-209ddc03c586""; > version = ""1.0.0""; 412c431; < git-tree-sha1 = ""f2355693d6778a178ade15952b7ac47a4ff97996""; ---; > git-tree-sha1 = ""50901ebc375ed41dbf8058da26f9de442febbbec""; 414c433; < version = ""1.3.0""; ---; > version = ""1.3.1""; 499c518; < git-tree-sha1 = ""781916a2ebf2841467cda03b6f1af43e23839d85""; ---; > git-tree-sha1 = ""8f6af051b9e8ec597fa09d8885ed79fd582f33c9""; 501c520; < version = ""0.1.9""; ---; > version = ""0.1.10""; 526c545; < git-tree-sha1 = ""a7023883872e52bc29bcaac74f19adf39347d2d5""; ---; > git-tree-sha1 = ""b01beb91d20b0d1312a9471a36017b5b339d26de""; 528c547; < version = ""10.1.4+0""; ---; > version = ""10.1.4+1""; 570a590,601; > [[deps.Oceananigans]]; > deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""Distances"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays""]; > path = ""/Users/gregorywagner/Projects/Oceananigans.jl""; > uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; > version = ""0.90.1""; >; > [deps.Oceananigans.extensions]; > OceananigansEnzymeCoreExt = ""EnzymeCore""; >; > [deps.Oceananigans.weakdeps]; > EnzymeCore = ""f151be2c-9106-41f4-ab19-57ee4f262869""; >; 588,589c619,620; < deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""TOML""]; < git-tree-sha1 = ""e25c1778a98e34219a00455d6e4384e017ea9762""; ---; > deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""Hwloc_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""PMIx_jll"", ""TOML"", ""Zlib_jll"", ""libevent_jll"", ""prrte_jll""]; > git-tree-sha1 = ""694458ae803b684f09c07f90459cb79655fb377d""; 591c622; < version = ""4.1.6+0""; ---; > versi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:10768,Testability,Test,Test,10768,"; ---; > git-tree-sha1 = ""6842ce83a836fbbc0cfeca0b5a4de1a4dcbdb8d1""; 675c712; < version = ""2.2.7""; ---; > version = ""2.2.8""; 748c785; < git-tree-sha1 = ""30449ee12237627992a99d5e30ae63e4d78cd24a""; ---; > git-tree-sha1 = ""3bac05bc7e74a75fd9cba4295cde4045d9fe2386""; 750c787; < version = ""1.2.0""; ---; > version = ""1.2.1""; 759c796; < git-tree-sha1 = ""04bdff0b09c65ff3e06a05e3eb7b120223da3d39""; ---; > git-tree-sha1 = ""0e7508ff27ba32f26cd459474ca2ede1bc10991f""; 761c798; < version = ""1.4.0""; ---; > version = ""1.4.1""; 771c808; < git-tree-sha1 = ""c60ec5c62180f27efea3ba2908480f8055e17cee""; ---; > git-tree-sha1 = ""5165dfb9fd131cf0c6957a3a7605dede376e7b63""; 773c810; < version = ""1.1.1""; ---; > version = ""1.2.0""; 895c932; < git-tree-sha1 = ""a1f34829d5ac0ef499f6d84428bd6b4c71f02ead""; ---; > git-tree-sha1 = ""cb76cf677714c095e535e3501ac7954732aeea2d""; 897c934; < version = ""1.11.0""; ---; > version = ""1.11.1""; 927,928c964; < deps = [""Random"", ""Test""]; < git-tree-sha1 = ""9a6ae7ed916312b41236fcef7e0af564ef934769""; ---; > git-tree-sha1 = ""1fbeaaca45801b4ba17c251dd8603ef24801dd84""; 930c966,970; < version = ""0.9.13""; ---; > version = ""0.10.2""; > weakdeps = [""Random"", ""Test""]; >; > [deps.TranscodingStreams.extensions]; > TestExt = [""Test"", ""Random""]; 987a1028,1033; > [[deps.libevent_jll]]; > deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""OpenSSL_jll""]; > git-tree-sha1 = ""f04ec6d9a186115fb38f858f05c0c4e1b7fc9dcb""; > uuid = ""1080aeaf-3a6a-583e-a51c-c537b09f60ec""; > version = ""2.1.13+1""; >; 996a1043,1048; >; > [[deps.prrte_jll]]; > deps = [""Artifacts"", ""Hwloc_jll"", ""JLLWrappers"", ""Libdl"", ""PMIx_jll"", ""libevent_jll""]; > git-tree-sha1 = ""5adb2d7a18a30280feb66cad6f1a1dfdca2dc7b0""; > uuid = ""eb928a42-fffd-568d-ab9c-3f5d54fc65b9""; > version = ""3.0.2+0""; ```. </details>. There are quite a few differences to some suspicious packages (eg those involved in LLVM) so... (PS, is there a better way to compare Manifests? I wonder.). It might not be anything to do with our code. Nevertheless, @navidcy and I comb",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:10992,Testability,Test,Test,10992,"49ee12237627992a99d5e30ae63e4d78cd24a""; ---; > git-tree-sha1 = ""3bac05bc7e74a75fd9cba4295cde4045d9fe2386""; 750c787; < version = ""1.2.0""; ---; > version = ""1.2.1""; 759c796; < git-tree-sha1 = ""04bdff0b09c65ff3e06a05e3eb7b120223da3d39""; ---; > git-tree-sha1 = ""0e7508ff27ba32f26cd459474ca2ede1bc10991f""; 761c798; < version = ""1.4.0""; ---; > version = ""1.4.1""; 771c808; < git-tree-sha1 = ""c60ec5c62180f27efea3ba2908480f8055e17cee""; ---; > git-tree-sha1 = ""5165dfb9fd131cf0c6957a3a7605dede376e7b63""; 773c810; < version = ""1.1.1""; ---; > version = ""1.2.0""; 895c932; < git-tree-sha1 = ""a1f34829d5ac0ef499f6d84428bd6b4c71f02ead""; ---; > git-tree-sha1 = ""cb76cf677714c095e535e3501ac7954732aeea2d""; 897c934; < version = ""1.11.0""; ---; > version = ""1.11.1""; 927,928c964; < deps = [""Random"", ""Test""]; < git-tree-sha1 = ""9a6ae7ed916312b41236fcef7e0af564ef934769""; ---; > git-tree-sha1 = ""1fbeaaca45801b4ba17c251dd8603ef24801dd84""; 930c966,970; < version = ""0.9.13""; ---; > version = ""0.10.2""; > weakdeps = [""Random"", ""Test""]; >; > [deps.TranscodingStreams.extensions]; > TestExt = [""Test"", ""Random""]; 987a1028,1033; > [[deps.libevent_jll]]; > deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""OpenSSL_jll""]; > git-tree-sha1 = ""f04ec6d9a186115fb38f858f05c0c4e1b7fc9dcb""; > uuid = ""1080aeaf-3a6a-583e-a51c-c537b09f60ec""; > version = ""2.1.13+1""; >; 996a1043,1048; >; > [[deps.prrte_jll]]; > deps = [""Artifacts"", ""Hwloc_jll"", ""JLLWrappers"", ""Libdl"", ""PMIx_jll"", ""libevent_jll""]; > git-tree-sha1 = ""5adb2d7a18a30280feb66cad6f1a1dfdca2dc7b0""; > uuid = ""eb928a42-fffd-568d-ab9c-3f5d54fc65b9""; > version = ""3.0.2+0""; ```. </details>. There are quite a few differences to some suspicious packages (eg those involved in LLVM) so... (PS, is there a better way to compare Manifests? I wonder.). It might not be anything to do with our code. Nevertheless, @navidcy and I combed through the `git blame` for two files: [`output_construction.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_constructi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:11045,Testability,Test,TestExt,11045,"75fd9cba4295cde4045d9fe2386""; 750c787; < version = ""1.2.0""; ---; > version = ""1.2.1""; 759c796; < git-tree-sha1 = ""04bdff0b09c65ff3e06a05e3eb7b120223da3d39""; ---; > git-tree-sha1 = ""0e7508ff27ba32f26cd459474ca2ede1bc10991f""; 761c798; < version = ""1.4.0""; ---; > version = ""1.4.1""; 771c808; < git-tree-sha1 = ""c60ec5c62180f27efea3ba2908480f8055e17cee""; ---; > git-tree-sha1 = ""5165dfb9fd131cf0c6957a3a7605dede376e7b63""; 773c810; < version = ""1.1.1""; ---; > version = ""1.2.0""; 895c932; < git-tree-sha1 = ""a1f34829d5ac0ef499f6d84428bd6b4c71f02ead""; ---; > git-tree-sha1 = ""cb76cf677714c095e535e3501ac7954732aeea2d""; 897c934; < version = ""1.11.0""; ---; > version = ""1.11.1""; 927,928c964; < deps = [""Random"", ""Test""]; < git-tree-sha1 = ""9a6ae7ed916312b41236fcef7e0af564ef934769""; ---; > git-tree-sha1 = ""1fbeaaca45801b4ba17c251dd8603ef24801dd84""; 930c966,970; < version = ""0.9.13""; ---; > version = ""0.10.2""; > weakdeps = [""Random"", ""Test""]; >; > [deps.TranscodingStreams.extensions]; > TestExt = [""Test"", ""Random""]; 987a1028,1033; > [[deps.libevent_jll]]; > deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""OpenSSL_jll""]; > git-tree-sha1 = ""f04ec6d9a186115fb38f858f05c0c4e1b7fc9dcb""; > uuid = ""1080aeaf-3a6a-583e-a51c-c537b09f60ec""; > version = ""2.1.13+1""; >; 996a1043,1048; >; > [[deps.prrte_jll]]; > deps = [""Artifacts"", ""Hwloc_jll"", ""JLLWrappers"", ""Libdl"", ""PMIx_jll"", ""libevent_jll""]; > git-tree-sha1 = ""5adb2d7a18a30280feb66cad6f1a1dfdca2dc7b0""; > uuid = ""eb928a42-fffd-568d-ab9c-3f5d54fc65b9""; > version = ""3.0.2+0""; ```. </details>. There are quite a few differences to some suspicious packages (eg those involved in LLVM) so... (PS, is there a better way to compare Manifests? I wonder.). It might not be anything to do with our code. Nevertheless, @navidcy and I combed through the `git blame` for two files: [`output_construction.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_construction.jl) and [`computed_field.jl`](https://github.com/CliMA/Oceananigans.jl/blob",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:11057,Testability,Test,Test,11057,"75fd9cba4295cde4045d9fe2386""; 750c787; < version = ""1.2.0""; ---; > version = ""1.2.1""; 759c796; < git-tree-sha1 = ""04bdff0b09c65ff3e06a05e3eb7b120223da3d39""; ---; > git-tree-sha1 = ""0e7508ff27ba32f26cd459474ca2ede1bc10991f""; 761c798; < version = ""1.4.0""; ---; > version = ""1.4.1""; 771c808; < git-tree-sha1 = ""c60ec5c62180f27efea3ba2908480f8055e17cee""; ---; > git-tree-sha1 = ""5165dfb9fd131cf0c6957a3a7605dede376e7b63""; 773c810; < version = ""1.1.1""; ---; > version = ""1.2.0""; 895c932; < git-tree-sha1 = ""a1f34829d5ac0ef499f6d84428bd6b4c71f02ead""; ---; > git-tree-sha1 = ""cb76cf677714c095e535e3501ac7954732aeea2d""; 897c934; < version = ""1.11.0""; ---; > version = ""1.11.1""; 927,928c964; < deps = [""Random"", ""Test""]; < git-tree-sha1 = ""9a6ae7ed916312b41236fcef7e0af564ef934769""; ---; > git-tree-sha1 = ""1fbeaaca45801b4ba17c251dd8603ef24801dd84""; 930c966,970; < version = ""0.9.13""; ---; > version = ""0.10.2""; > weakdeps = [""Random"", ""Test""]; >; > [deps.TranscodingStreams.extensions]; > TestExt = [""Test"", ""Random""]; 987a1028,1033; > [[deps.libevent_jll]]; > deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""OpenSSL_jll""]; > git-tree-sha1 = ""f04ec6d9a186115fb38f858f05c0c4e1b7fc9dcb""; > uuid = ""1080aeaf-3a6a-583e-a51c-c537b09f60ec""; > version = ""2.1.13+1""; >; 996a1043,1048; >; > [[deps.prrte_jll]]; > deps = [""Artifacts"", ""Hwloc_jll"", ""JLLWrappers"", ""Libdl"", ""PMIx_jll"", ""libevent_jll""]; > git-tree-sha1 = ""5adb2d7a18a30280feb66cad6f1a1dfdca2dc7b0""; > uuid = ""eb928a42-fffd-568d-ab9c-3f5d54fc65b9""; > version = ""3.0.2+0""; ```. </details>. There are quite a few differences to some suspicious packages (eg those involved in LLVM) so... (PS, is there a better way to compare Manifests? I wonder.). It might not be anything to do with our code. Nevertheless, @navidcy and I combed through the `git blame` for two files: [`output_construction.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_construction.jl) and [`computed_field.jl`](https://github.com/CliMA/Oceananigans.jl/blob",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:12279,Testability,test,tested,12279,"27efea3ba2908480f8055e17cee""; ---; > git-tree-sha1 = ""5165dfb9fd131cf0c6957a3a7605dede376e7b63""; 773c810; < version = ""1.1.1""; ---; > version = ""1.2.0""; 895c932; < git-tree-sha1 = ""a1f34829d5ac0ef499f6d84428bd6b4c71f02ead""; ---; > git-tree-sha1 = ""cb76cf677714c095e535e3501ac7954732aeea2d""; 897c934; < version = ""1.11.0""; ---; > version = ""1.11.1""; 927,928c964; < deps = [""Random"", ""Test""]; < git-tree-sha1 = ""9a6ae7ed916312b41236fcef7e0af564ef934769""; ---; > git-tree-sha1 = ""1fbeaaca45801b4ba17c251dd8603ef24801dd84""; 930c966,970; < version = ""0.9.13""; ---; > version = ""0.10.2""; > weakdeps = [""Random"", ""Test""]; >; > [deps.TranscodingStreams.extensions]; > TestExt = [""Test"", ""Random""]; 987a1028,1033; > [[deps.libevent_jll]]; > deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""OpenSSL_jll""]; > git-tree-sha1 = ""f04ec6d9a186115fb38f858f05c0c4e1b7fc9dcb""; > uuid = ""1080aeaf-3a6a-583e-a51c-c537b09f60ec""; > version = ""2.1.13+1""; >; 996a1043,1048; >; > [[deps.prrte_jll]]; > deps = [""Artifacts"", ""Hwloc_jll"", ""JLLWrappers"", ""Libdl"", ""PMIx_jll"", ""libevent_jll""]; > git-tree-sha1 = ""5adb2d7a18a30280feb66cad6f1a1dfdca2dc7b0""; > uuid = ""eb928a42-fffd-568d-ab9c-3f5d54fc65b9""; > version = ""3.0.2+0""; ```. </details>. There are quite a few differences to some suspicious packages (eg those involved in LLVM) so... (PS, is there a better way to compare Manifests? I wonder.). It might not be anything to do with our code. Nevertheless, @navidcy and I combed through the `git blame` for two files: [`output_construction.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_construction.jl) and [`computed_field.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl). This line was changed. https://github.com/CliMA/Oceananigans.jl/blob/70536571523ad2eb71fd9a2200121eca63998ac4/src/AbstractOperations/computed_field.jl#L47. but... I tested this by changing just that line back to the 0.85 version, and still hit the very long compile time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808251360:54,Deployability,install,installing,54,"Just to add to this, I started going through manually installing the version of packages in the Oceananigans manifest to try and weed out which one it was and none of the suspicious ones like `LLVM` made a difference. I didn't get round to trying them all.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808251360
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651:397,Deployability,release,releases,397,"Thanks, that's helpful @jagoosw. Just one more thought... I realized after I did the testing for my previous post that the hang occurs at ""Initializing simulation..."". This implies that the problem isn't with any constructors (eg the `Field` constructor above) but rather the actual computations, probably. A big change from 0.85 (which [occurred in 0.88](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.88.0)) is the [introduction of the `KernelParameters` abstraction](https://github.com/CliMA/Oceananigans.jl/pull/3125) for offsetting indices within kernels, used here:. https://github.com/CliMA/Oceananigans.jl/blob/70536571523ad2eb71fd9a2200121eca63998ac4/src/AbstractOperations/computed_field.jl#L78. and I think other places, which @simone-silvestri can advise. `KernelParameters` extends some `KernelAbstractions` functionality in a non-trivial way I think. Maybe there are some things we can improve there:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Utils/kernel_launching.jl. Even if the issue is fixed on 1.10, I think we still ought to understand this problem better since it might come back in the future (things like this often do...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651:797,Modifiability,extend,extends,797,"Thanks, that's helpful @jagoosw. Just one more thought... I realized after I did the testing for my previous post that the hang occurs at ""Initializing simulation..."". This implies that the problem isn't with any constructors (eg the `Field` constructor above) but rather the actual computations, probably. A big change from 0.85 (which [occurred in 0.88](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.88.0)) is the [introduction of the `KernelParameters` abstraction](https://github.com/CliMA/Oceananigans.jl/pull/3125) for offsetting indices within kernels, used here:. https://github.com/CliMA/Oceananigans.jl/blob/70536571523ad2eb71fd9a2200121eca63998ac4/src/AbstractOperations/computed_field.jl#L78. and I think other places, which @simone-silvestri can advise. `KernelParameters` extends some `KernelAbstractions` functionality in a non-trivial way I think. Maybe there are some things we can improve there:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Utils/kernel_launching.jl. Even if the issue is fixed on 1.10, I think we still ought to understand this problem better since it might come back in the future (things like this often do...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651:85,Testability,test,testing,85,"Thanks, that's helpful @jagoosw. Just one more thought... I realized after I did the testing for my previous post that the hang occurs at ""Initializing simulation..."". This implies that the problem isn't with any constructors (eg the `Field` constructor above) but rather the actual computations, probably. A big change from 0.85 (which [occurred in 0.88](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.88.0)) is the [introduction of the `KernelParameters` abstraction](https://github.com/CliMA/Oceananigans.jl/pull/3125) for offsetting indices within kernels, used here:. https://github.com/CliMA/Oceananigans.jl/blob/70536571523ad2eb71fd9a2200121eca63998ac4/src/AbstractOperations/computed_field.jl#L78. and I think other places, which @simone-silvestri can advise. `KernelParameters` extends some `KernelAbstractions` functionality in a non-trivial way I think. Maybe there are some things we can improve there:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Utils/kernel_launching.jl. Even if the issue is fixed on 1.10, I think we still ought to understand this problem better since it might come back in the future (things like this often do...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651
https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-2009053457:7,Testability,test,tested,7,"I just tested this with Julia v1.10 and Oceananigans v0.90.11 and the problem seems to have gone away. A simulation that had taken 18 minutes to initialize now takes about 20 seconds! I think we can close this issue now, but I'm still not sure what the underlying issue was, so something to keep in mind as @glwagner says above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-2009053457
https://github.com/CliMA/Oceananigans.jl/pull/3383#issuecomment-1804206049:72,Deployability,patch,patch,72,Hmm I just hit merge but then thought I should probably have bumped the patch number right?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3383#issuecomment-1804206049
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1813531626:22,Integrability,message,message,22,"Correction to my last message, I accidentally included a second prime. The form of the Stokes drift is actually:. $u^s(x,y,z)=f(x)g(y)h′(z)$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1813531626
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:290,Energy Efficiency,meter,meters,290,"@BrodiePearson I refactored `StokesDrifts.jl` very slightly --- I agree with the new terms you added!. I put together this script that reproduces the ""deep Eulerian return flow"" from McIntyre (1981):. ```julia; using Oceananigans; using Oceananigans.Units; using GLMakie. ϵ = 0.1; λ = 60 # meters; g = 9.81. const k = 2π / λ. c = sqrt(g / k); const δ = 1kilometer; const cᵍ = c / 2; const Uˢ = ϵ^2 * c. @inline A(ξ) = exp(- ξ^2 / 2δ^2); @inline A′(ξ) = - ξ / δ^2 * A(ξ); @inline A′′(ξ) = (ξ^2 / δ^2 - 1) * A(ξ) / δ^2. # Write the Stokes drift as; #; # uˢ(x, z, t) = A(x, t) * ûˢ(z); #; # which implies. @inline ûˢ(z) = Uˢ * exp(2k * z); @inline uˢ(x, z, t) = A(x - cᵍ * t) * ûˢ(z); @inline ∂z_uˢ(x, z, t) = 2k * A(x - cᵍ * t) * ûˢ(z); @inline ∂t_uˢ(x, z, t) = - cᵍ * A′(x - cᵍ * t) * ûˢ(z). # Note that if uˢ represents the solenoidal component of the Stokes drift,; # then; #; # ```math; # ∂z_wˢ = - ∂x_uˢ = - A′ * ûˢ .; # ```; #; # We therefore find that; #; # ```math; # wˢ = - A′ / 2k * ûˢ; # ```; #; # and. @inline ∂x_wˢ(x, z, t) = - 1 / 2k * A′′(x - cᵍ * t) * ûˢ(z); @inline ∂t_wˢ(x, z, t) = + cᵍ / 2k * A′′(x - cᵍ * t) * ûˢ(z). stokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂t_wˢ, ∂x_wˢ). grid = RectilinearGrid(size = (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2Ou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:2039,Energy Efficiency,schedul,schedule,2039,"z, t) = - 1 / 2k * A′′(x - cᵍ * t) * ûˢ(z); @inline ∂t_wˢ(x, z, t) = + cᵍ / 2k * A′′(x - cᵍ * t) * ûˢ(z). stokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂t_wˢ, ∂x_wˢ). grid = RectilinearGrid(size = (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). ut = FieldTimeSeries(filename, ""u""); wt = FieldTimeSeries(filename, ""w""). times = ut.times; Nt = length(times). n = Observable(1). un = @lift interior(ut[$n], :, 1, :); wn = @lift interior(wt[$n], :, 1, :). xu, yu, zu = nodes(ut); xw, yw, zw = nodes(wt). fig = Figure(resolution=(800, 300)). axu = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)""); axw = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)""). heatmap!(axu, xu, zu, un); heatmap!(axw, xw, zw, wn). record(fig, ""surface_wave_induced_flow.mp4"", 1:Nt, framerate=12) do nn; n[] = nn; end; ```. The result is. https://github.com/CliMA/Oceananigans.jl/assets/15271942/643ca8b4-0943-461d-8016-08bbba24faad. where the left panel is `u` and the right panel is `w`. @BrodiePearson I don't think we should add a new example for this feature (examples are expensive, because they have to run every time we run CI / build the documentation). However, another avenue to ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:17,Modifiability,refactor,refactored,17,"@BrodiePearson I refactored `StokesDrifts.jl` very slightly --- I agree with the new terms you added!. I put together this script that reproduces the ""deep Eulerian return flow"" from McIntyre (1981):. ```julia; using Oceananigans; using Oceananigans.Units; using GLMakie. ϵ = 0.1; λ = 60 # meters; g = 9.81. const k = 2π / λ. c = sqrt(g / k); const δ = 1kilometer; const cᵍ = c / 2; const Uˢ = ϵ^2 * c. @inline A(ξ) = exp(- ξ^2 / 2δ^2); @inline A′(ξ) = - ξ / δ^2 * A(ξ); @inline A′′(ξ) = (ξ^2 / δ^2 - 1) * A(ξ) / δ^2. # Write the Stokes drift as; #; # uˢ(x, z, t) = A(x, t) * ûˢ(z); #; # which implies. @inline ûˢ(z) = Uˢ * exp(2k * z); @inline uˢ(x, z, t) = A(x - cᵍ * t) * ûˢ(z); @inline ∂z_uˢ(x, z, t) = 2k * A(x - cᵍ * t) * ûˢ(z); @inline ∂t_uˢ(x, z, t) = - cᵍ * A′(x - cᵍ * t) * ûˢ(z). # Note that if uˢ represents the solenoidal component of the Stokes drift,; # then; #; # ```math; # ∂z_wˢ = - ∂x_uˢ = - A′ * ûˢ .; # ```; #; # We therefore find that; #; # ```math; # wˢ = - A′ / 2k * ûˢ; # ```; #; # and. @inline ∂x_wˢ(x, z, t) = - 1 / 2k * A′′(x - cᵍ * t) * ûˢ(z); @inline ∂t_wˢ(x, z, t) = + cᵍ / 2k * A′′(x - cᵍ * t) * ûˢ(z). stokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂t_wˢ, ∂x_wˢ). grid = RectilinearGrid(size = (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2Ou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:3069,Security,validat,validation,3069,"= (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). ut = FieldTimeSeries(filename, ""u""); wt = FieldTimeSeries(filename, ""w""). times = ut.times; Nt = length(times). n = Observable(1). un = @lift interior(ut[$n], :, 1, :); wn = @lift interior(wt[$n], :, 1, :). xu, yu, zu = nodes(ut); xw, yw, zw = nodes(wt). fig = Figure(resolution=(800, 300)). axu = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)""); axw = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)""). heatmap!(axu, xu, zu, un); heatmap!(axw, xw, zw, wn). record(fig, ""surface_wave_induced_flow.mp4"", 1:Nt, framerate=12) do nn; n[] = nn; end; ```. The result is. https://github.com/CliMA/Oceananigans.jl/assets/15271942/643ca8b4-0943-461d-8016-08bbba24faad. where the left panel is `u` and the right panel is `w`. @BrodiePearson I don't think we should add a new example for this feature (examples are expensive, because they have to run every time we run CI / build the documentation). However, another avenue to keep some code around is to add a ""validation"" case. If you're up for that, I'll move your code there, along with the above example. Let me know and then we can possibly merge this great addition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430:63,Modifiability,refactor,refactored,63,"@glwagner These changes look great!. I fixed some typos in the refactored file, which were terms that would not have affected your new validation case. I moved my original example to validation and provided some minor tweaks to your first validation case. I did not look much at the ``surface_wave_quasi_geostrophic_flow.jl`` case you created",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430:135,Security,validat,validation,135,"@glwagner These changes look great!. I fixed some typos in the refactored file, which were terms that would not have affected your new validation case. I moved my original example to validation and provided some minor tweaks to your first validation case. I did not look much at the ``surface_wave_quasi_geostrophic_flow.jl`` case you created",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430:183,Security,validat,validation,183,"@glwagner These changes look great!. I fixed some typos in the refactored file, which were terms that would not have affected your new validation case. I moved my original example to validation and provided some minor tweaks to your first validation case. I did not look much at the ``surface_wave_quasi_geostrophic_flow.jl`` case you created",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430:239,Security,validat,validation,239,"@glwagner These changes look great!. I fixed some typos in the refactored file, which were terms that would not have affected your new validation case. I moved my original example to validation and provided some minor tweaks to your first validation case. I did not look much at the ``surface_wave_quasi_geostrophic_flow.jl`` case you created",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940:181,Modifiability,maintainab,maintainable,181,Ok great then I think this is close. I'll just add a `Project.toml` to the new validation directory (hopefully eventually we will transition all validation directories to this more maintainable state).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940:79,Security,validat,validation,79,Ok great then I think this is close. I'll just add a `Project.toml` to the new validation directory (hopefully eventually we will transition all validation directories to this more maintainable state).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940
https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940:145,Security,validat,validation,145,Ok great then I think this is close. I'll just add a `Project.toml` to the new validation directory (hopefully eventually we will transition all validation directories to this more maintainable state).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940
https://github.com/CliMA/Oceananigans.jl/pull/3385#issuecomment-1805888321:8,Testability,test,tests,8,"idk why tests are failing here, but I think the change is good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3385#issuecomment-1805888321
https://github.com/CliMA/Oceananigans.jl/pull/3388#issuecomment-1809340514:32,Testability,test,test,32,I think you should add a simple test so this doesn't regress again,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3388#issuecomment-1809340514
https://github.com/CliMA/Oceananigans.jl/pull/3388#issuecomment-1809340514:25,Usability,simpl,simple,25,I think you should add a simple test so this doesn't regress again,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3388#issuecomment-1809340514
https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809223215:207,Performance,load,loaded,207,"Hi @roxyboy, we'll make some docs/examples soon! There are some tools in a different repo but they are rough on the edges at the moment and I'm bit reluctant to point you to it. If you have the `bathymetry` loaded as an array of the same size as a flat-bottom latitude-longitude grid then you can use [GridFittedBottom](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Oceananigans.ImmersedBoundaries.GridFittedBottom) to do something like:. ```Julia; underlying_grid = LatitudeLongitudeGrid(arch,; size = (Nx, Ny, Nz),; longitude = (-180, 180),; latitude = (-75, 75),; z = (-depth, 0),; topology = (Periodic, Bounded, Bounded)). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809223215
https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733:341,Availability,down,downloading,341,"@navidcy is a tease! The ""other repo"" is https://github.com/CliMA/ClimaOcean.jl. That's where we plan to build out the features needed for high-quality realistic simulations, eg interpolating bathymetry from one grid to another, ""recipes for realism"" such as parameterization and boundary condition choices. There's already a tool there for downloading some repeat-year forcing JRA55 data; we still need to build a tool for the entire dataset, and also tools for restricting to some region, etc. The vision in the end though is to get as close as possible to ""one click regional modeling"" as we can. @navidcy is right that the tools are not so useful now unless you want to get into the weeds. But if you want to help, it's greatly appreciated. Feedback on issues or wishlist features could also be fun to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733
https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733:259,Modifiability,parameteriz,parameterization,259,"@navidcy is a tease! The ""other repo"" is https://github.com/CliMA/ClimaOcean.jl. That's where we plan to build out the features needed for high-quality realistic simulations, eg interpolating bathymetry from one grid to another, ""recipes for realism"" such as parameterization and boundary condition choices. There's already a tool there for downloading some repeat-year forcing JRA55 data; we still need to build a tool for the entire dataset, and also tools for restricting to some region, etc. The vision in the end though is to get as close as possible to ""one click regional modeling"" as we can. @navidcy is right that the tools are not so useful now unless you want to get into the weeds. But if you want to help, it's greatly appreciated. Feedback on issues or wishlist features could also be fun to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733
https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733:745,Usability,Feedback,Feedback,745,"@navidcy is a tease! The ""other repo"" is https://github.com/CliMA/ClimaOcean.jl. That's where we plan to build out the features needed for high-quality realistic simulations, eg interpolating bathymetry from one grid to another, ""recipes for realism"" such as parameterization and boundary condition choices. There's already a tool there for downloading some repeat-year forcing JRA55 data; we still need to build a tool for the entire dataset, and also tools for restricting to some region, etc. The vision in the end though is to get as close as possible to ""one click regional modeling"" as we can. @navidcy is right that the tools are not so useful now unless you want to get into the weeds. But if you want to help, it's greatly appreciated. Feedback on issues or wishlist features could also be fun to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733
https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809330687:578,Modifiability,evolve,evolve,578,"Here's my latest work on setting up an OMIP simulation:. https://github.com/CliMA/ClimaOcean.jl/blob/glw-ss/ice-ocean-model/experiments/prototype_omip_simulation/omip_simulation.jl. which also includes an example of using `ImmersedBoundaryGrid` to implement bathymetry. Bathymetry is a little sad there; I ""diagnose"" it from the ECCO state rather than prescribing directly. We need initialization tools for reasonable ""in painting"" for cases where initial condition information and bathymetry are slightly different (ie filling in NaNs near boundaries, etc). All of this should evolve quite a bit in the next few months. PS I'm going to convert this to a Discussion so that we can continue the party without needing to make any source code changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809330687
https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813228038:11,Testability,test,tests,11,"As soon as tests pass I'll merge and then we can continue in #3384, how does that sound @BrodiePearson?. You should have rights to push commits there now! I sent you an invite for project collaborator.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813228038
https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813263507:118,Security,validat,validation,118,"I don't think we should add a new example for this feature though. Perhaps we can include a script as a reference in `validation`? Another possibility is to include an example in the docstring that sets up the Stokes drift profile described here, which will preserve it for future generations as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813263507
https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813278220:343,Usability,clear,clear,343,"Ah well I retract my comments about the validity of theory, based on this new information! We are good to go --- provided that the Stokes drift we use is the solenoidal Stokes drift. In that case, we can cope with rapid horizontal variation of the Stokes drift it seems, and still model a non-divergence Lagrangian-mean flow. But we should be clear about this in the documentation for this new type StokesDrift. > Also, based on your last comment should we just remove the vertical component of Stokes drift? It only appears in the Stokes-related forcing through its horizontal derivatives. I think we _need_ the vertical component to retain consistency in the case of modulated waves.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813278220
https://github.com/CliMA/Oceananigans.jl/pull/3393#issuecomment-1867013194:18,Testability,test,tests,18,It looks like GPU tests did not run for this PR. Any idea why it was merged?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3393#issuecomment-1867013194
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1942287636:187,Availability,error,error,187,"@simone-silvestri and I created a new branch to try and start tackle these issues, `fp-ss/shallow-water-version2`. When ran the `shallow_water_Bickley_jet.jl` on this branch there was an error. We were using superscripts `fcc` and `cfc` instead if `faa` and `cfc` on the averaging operators. I have since fixed that. . Now I'm going to try and merge main into this branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1942287636
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966700098:488,Testability,test,tests,488,"The branch `fp-ss/shallow-water-version2` has (hopefully) corrected the problems with the tendency calculations brought up by @glwagner in #2928 (and elsewhere). Does someone what to take a look to confirm that we have done this correctly? If yes the changes start [here](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L7). . I thought the next step might be to add in the regression tests one by one, which were removed in #3050. I am going to look into `test_shallow_water_models.jl` next to see what runs and what doesn't with the current code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966700098
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:41,Availability,error,errors,41,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:59,Availability,error,error,59,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:229,Availability,error,error,229,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:668,Availability,ERROR,ERROR,668,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:1102,Availability,error,error,1102,"_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broadcast.jl:1003 [inlined]; [15] copyto!; @ ./broadcast.jl:956 [inlined]; [16] copy; @ ./broadcast.jl:928 [i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:1129,Availability,error,error,1129,"field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broadcast.jl:1003 [inlined]; [15] copyto!; @ ./broadcast.jl:956 [inlined]; [16] copy; @ ./broadcast.jl:928 [inlined]; [17] materialize;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:554,Security,validat,validation,554,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:8,Testability,test,tests,8,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:309,Testability,Test,Testing,309,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:1146,Testability,assert,assertscalar,1146,"eFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broadcast.jl:1003 [inlined]; [15] copyto!; @ ./broadcast.jl:956 [inlined]; [16] copy; @ ./broadcast.jl:928 [inlined]; [17] materialize; @ ./broadcast.jl:903 [inlined]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:2481,Testability,test,test,2481,"n of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broadcast.jl:1003 [inlined]; [15] copyto!; @ ./broadcast.jl:956 [inlined]; [16] copy; @ ./broadcast.jl:928 [inlined]; [17] materialize; @ ./broadcast.jl:903 [inlined]; [18] isapprox(a::Field{…}, b::Field{…}; kw::@Kwargs{…}); @ Oceananigans.Fields ~/Software/Oceananigans.jl/src/Fields/field.jl:712; [19] test_shallow_water_diffusion_cosine(grid::RectilinearGrid{…}, formulation::ConservativeFormulation, fieldname::Symbol, ξ::Base.ReshapedArray{…}); @ Main ~/Software/Oceananigans.jl/test/test_shallow_water_models.jl:84; [20] top-level scope; @ ./REPL[25]:4; [21] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404:18,Availability,error,errors,18,"I was getting two errors but when I added `CUDA.allowscalar(true)` into `test_shallow_water_models.jl` the tests all passed on a CPU and GPU on my laptop. Note that in `dependencies_for_runtests.jl` this line [here](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/test/dependencies_for_runtests.jl#L78) only found a GPU on my computer. When I changed it temporarily to test both CPU and GPU and all 80 tests passed. I remember last year in #3050 @navidcy found that it ran on some computers but not others. I presume that is still a concern. But lots has changed since then, for example we are no longer using julia 1.8. @navidcy, might you be able to try the shallow water tests on the same computer you found the failers in last year to see if the problem persists?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404:107,Testability,test,tests,107,"I was getting two errors but when I added `CUDA.allowscalar(true)` into `test_shallow_water_models.jl` the tests all passed on a CPU and GPU on my laptop. Note that in `dependencies_for_runtests.jl` this line [here](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/test/dependencies_for_runtests.jl#L78) only found a GPU on my computer. When I changed it temporarily to test both CPU and GPU and all 80 tests passed. I remember last year in #3050 @navidcy found that it ran on some computers but not others. I presume that is still a concern. But lots has changed since then, for example we are no longer using julia 1.8. @navidcy, might you be able to try the shallow water tests on the same computer you found the failers in last year to see if the problem persists?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404:303,Testability,test,test,303,"I was getting two errors but when I added `CUDA.allowscalar(true)` into `test_shallow_water_models.jl` the tests all passed on a CPU and GPU on my laptop. Note that in `dependencies_for_runtests.jl` this line [here](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/test/dependencies_for_runtests.jl#L78) only found a GPU on my computer. When I changed it temporarily to test both CPU and GPU and all 80 tests passed. I remember last year in #3050 @navidcy found that it ran on some computers but not others. I presume that is still a concern. But lots has changed since then, for example we are no longer using julia 1.8. @navidcy, might you be able to try the shallow water tests on the same computer you found the failers in last year to see if the problem persists?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404:408,Testability,test,test,408,"I was getting two errors but when I added `CUDA.allowscalar(true)` into `test_shallow_water_models.jl` the tests all passed on a CPU and GPU on my laptop. Note that in `dependencies_for_runtests.jl` this line [here](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/test/dependencies_for_runtests.jl#L78) only found a GPU on my computer. When I changed it temporarily to test both CPU and GPU and all 80 tests passed. I remember last year in #3050 @navidcy found that it ran on some computers but not others. I presume that is still a concern. But lots has changed since then, for example we are no longer using julia 1.8. @navidcy, might you be able to try the shallow water tests on the same computer you found the failers in last year to see if the problem persists?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404:441,Testability,test,tests,441,"I was getting two errors but when I added `CUDA.allowscalar(true)` into `test_shallow_water_models.jl` the tests all passed on a CPU and GPU on my laptop. Note that in `dependencies_for_runtests.jl` this line [here](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/test/dependencies_for_runtests.jl#L78) only found a GPU on my computer. When I changed it temporarily to test both CPU and GPU and all 80 tests passed. I remember last year in #3050 @navidcy found that it ran on some computers but not others. I presume that is still a concern. But lots has changed since then, for example we are no longer using julia 1.8. @navidcy, might you be able to try the shallow water tests on the same computer you found the failers in last year to see if the problem persists?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404:713,Testability,test,tests,713,"I was getting two errors but when I added `CUDA.allowscalar(true)` into `test_shallow_water_models.jl` the tests all passed on a CPU and GPU on my laptop. Note that in `dependencies_for_runtests.jl` this line [here](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/test/dependencies_for_runtests.jl#L78) only found a GPU on my computer. When I changed it temporarily to test both CPU and GPU and all 80 tests passed. I remember last year in #3050 @navidcy found that it ran on some computers but not others. I presume that is still a concern. But lots has changed since then, for example we are no longer using julia 1.8. @navidcy, might you be able to try the shallow water tests on the same computer you found the failers in last year to see if the problem persists?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968103207:15,Testability,test,tests,15,I also ran the tests on a server and all the tests passed on both CPUs and GPUs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968103207
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968103207:45,Testability,test,tests,45,I also ran the tests on a server and all the tests passed on both CPUs and GPUs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968103207
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:43,Availability,error,errors,43,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:68,Availability,error,error,68,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:238,Availability,error,error,238,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:689,Availability,ERROR,ERROR,689,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:1137,Availability,error,error,1137," field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inlined]; > [13] macro expansion; > @ ./simdloop.jl:77 [inlined]; > [14] copyto!; > @ ./broadcast.jl:1003 [inlined]; > [15] copyto!; > @ ./bro",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:1166,Availability,error,error,1166,"ativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inlined]; > [13] macro expansion; > @ ./simdloop.jl:77 [inlined]; > [14] copyto!; > @ ./broadcast.jl:1003 [inlined]; > [15] copyto!; > @ ./broadcast.jl:956 [inlined]; > [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:573,Security,validat,validation,573,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:10,Testability,test,tests,10,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:326,Testability,Test,Testing,326,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:1185,Testability,assert,assertscalar,1185,"is in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inlined]; > [13] macro expansion; > @ ./simdloop.jl:77 [inlined]; > [14] copyto!; > @ ./broadcast.jl:1003 [inlined]; > [15] copyto!; > @ ./broadcast.jl:956 [inlined]; > [16] copy; > @ ./broadcast.jl:928 [",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:2590,Testability,test,test,2590,"ot* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inlined]; > [13] macro expansion; > @ ./simdloop.jl:77 [inlined]; > [14] copyto!; > @ ./broadcast.jl:1003 [inlined]; > [15] copyto!; > @ ./broadcast.jl:956 [inlined]; > [16] copy; > @ ./broadcast.jl:928 [inlined]; > [17] materialize; > @ ./broadcast.jl:903 [inlined]; > [18] isapprox(a::Field{…}, b::Field{…}; kw::@Kwargs{…}); > @ Oceananigans.Fields ~/Software/Oceananigans.jl/src/Fields/field.jl:712; > [19] test_shallow_water_diffusion_cosine(grid::RectilinearGrid{…}, formulation::ConservativeFormulation, fieldname::Symbol, ξ::Base.ReshapedArray{…}); > @ Main ~/Software/Oceananigans.jl/test/test_shallow_water_models.jl:84; > [20] top-level scope; > @ ./REPL[25]:4; > [21] top-level scope; > @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; > Some type information was truncated. Use `show(err)` to see complete types.; > ```. Looks like it's a problem with the test, not really with the model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:2875,Testability,test,test,2875,"ot* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inlined]; > [13] macro expansion; > @ ./simdloop.jl:77 [inlined]; > [14] copyto!; > @ ./broadcast.jl:1003 [inlined]; > [15] copyto!; > @ ./broadcast.jl:956 [inlined]; > [16] copy; > @ ./broadcast.jl:928 [inlined]; > [17] materialize; > @ ./broadcast.jl:903 [inlined]; > [18] isapprox(a::Field{…}, b::Field{…}; kw::@Kwargs{…}); > @ Oceananigans.Fields ~/Software/Oceananigans.jl/src/Fields/field.jl:712; > [19] test_shallow_water_diffusion_cosine(grid::RectilinearGrid{…}, formulation::ConservativeFormulation, fieldname::Symbol, ξ::Base.ReshapedArray{…}); > @ Main ~/Software/Oceananigans.jl/test/test_shallow_water_models.jl:84; > [20] top-level scope; > @ ./REPL[25]:4; > [21] top-level scope; > @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; > Some type information was truncated. Use `show(err)` to see complete types.; > ```. Looks like it's a problem with the test, not really with the model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1969101963:62,Testability,test,tests,62,"Thanks @simone-silvestri. The problem has been fixed. . These tests have all passed for me on CPUs and GPUs on my laptop and a server, and I presume they will for everyone else. But I don't beleive these tests were the regression tests that failed before. I am happy to look into those and revive them one by one, if someone can point me to where I might find them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1969101963
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1969101963:204,Testability,test,tests,204,"Thanks @simone-silvestri. The problem has been fixed. . These tests have all passed for me on CPUs and GPUs on my laptop and a server, and I presume they will for everyone else. But I don't beleive these tests were the regression tests that failed before. I am happy to look into those and revive them one by one, if someone can point me to where I might find them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1969101963
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1969101963:230,Testability,test,tests,230,"Thanks @simone-silvestri. The problem has been fixed. . These tests have all passed for me on CPUs and GPUs on my laptop and a server, and I presume they will for everyone else. But I don't beleive these tests were the regression tests that failed before. I am happy to look into those and revive them one by one, if someone can point me to where I might find them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1969101963
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516:2,Deployability,update,updated,2,I updated the regression tests for shallow water and added them to this branch. I tested it on my laptop and the a cluster and all tested passed on both the CPU and GPU. Does anyone else want to try out the regression tests to see if they work for them? . I am happy to do testing but I can't test it for me as everything seems to be working. Help on this would be greatly apprecited.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516:25,Testability,test,tests,25,I updated the regression tests for shallow water and added them to this branch. I tested it on my laptop and the a cluster and all tested passed on both the CPU and GPU. Does anyone else want to try out the regression tests to see if they work for them? . I am happy to do testing but I can't test it for me as everything seems to be working. Help on this would be greatly apprecited.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516:82,Testability,test,tested,82,I updated the regression tests for shallow water and added them to this branch. I tested it on my laptop and the a cluster and all tested passed on both the CPU and GPU. Does anyone else want to try out the regression tests to see if they work for them? . I am happy to do testing but I can't test it for me as everything seems to be working. Help on this would be greatly apprecited.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516:131,Testability,test,tested,131,I updated the regression tests for shallow water and added them to this branch. I tested it on my laptop and the a cluster and all tested passed on both the CPU and GPU. Does anyone else want to try out the regression tests to see if they work for them? . I am happy to do testing but I can't test it for me as everything seems to be working. Help on this would be greatly apprecited.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516:218,Testability,test,tests,218,I updated the regression tests for shallow water and added them to this branch. I tested it on my laptop and the a cluster and all tested passed on both the CPU and GPU. Does anyone else want to try out the regression tests to see if they work for them? . I am happy to do testing but I can't test it for me as everything seems to be working. Help on this would be greatly apprecited.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516:273,Testability,test,testing,273,I updated the regression tests for shallow water and added them to this branch. I tested it on my laptop and the a cluster and all tested passed on both the CPU and GPU. Does anyone else want to try out the regression tests to see if they work for them? . I am happy to do testing but I can't test it for me as everything seems to be working. Help on this would be greatly apprecited.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516
https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516:293,Testability,test,test,293,I updated the regression tests for shallow water and added them to this branch. I tested it on my laptop and the a cluster and all tested passed on both the CPU and GPU. Does anyone else want to try out the regression tests to see if they work for them? . I am happy to do testing but I can't test it for me as everything seems to be working. Help on this would be greatly apprecited.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1970044516
https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412:221,Testability,test,tests,221,"OK, I think I know what's the issue. The `interpolate!` now fills halos after interpolation:. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/src/Fields/interpolate.jl#L328. And the tests have a test that interpolates a $w$-velocity field with `Bounded` $z$-topology _but_ with non-zero values at top and bottom. When we fill the halos the boundary conditions are imposed and the interpolated field gets 0 at k=1 and k=Nz but the original field doesn't, so the test fails. This test in particular. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/test/test_field.jl#L171. fails when `f = w`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412
https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412:234,Testability,test,test,234,"OK, I think I know what's the issue. The `interpolate!` now fills halos after interpolation:. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/src/Fields/interpolate.jl#L328. And the tests have a test that interpolates a $w$-velocity field with `Bounded` $z$-topology _but_ with non-zero values at top and bottom. When we fill the halos the boundary conditions are imposed and the interpolated field gets 0 at k=1 and k=Nz but the original field doesn't, so the test fails. This test in particular. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/test/test_field.jl#L171. fails when `f = w`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412
https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412:500,Testability,test,test,500,"OK, I think I know what's the issue. The `interpolate!` now fills halos after interpolation:. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/src/Fields/interpolate.jl#L328. And the tests have a test that interpolates a $w$-velocity field with `Bounded` $z$-topology _but_ with non-zero values at top and bottom. When we fill the halos the boundary conditions are imposed and the interpolated field gets 0 at k=1 and k=Nz but the original field doesn't, so the test fails. This test in particular. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/test/test_field.jl#L171. fails when `f = w`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412
https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412:517,Testability,test,test,517,"OK, I think I know what's the issue. The `interpolate!` now fills halos after interpolation:. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/src/Fields/interpolate.jl#L328. And the tests have a test that interpolates a $w$-velocity field with `Bounded` $z$-topology _but_ with non-zero values at top and bottom. When we fill the halos the boundary conditions are imposed and the interpolated field gets 0 at k=1 and k=Nz but the original field doesn't, so the test fails. This test in particular. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/test/test_field.jl#L171. fails when `f = w`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412
https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412:624,Testability,test,test,624,"OK, I think I know what's the issue. The `interpolate!` now fills halos after interpolation:. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/src/Fields/interpolate.jl#L328. And the tests have a test that interpolates a $w$-velocity field with `Bounded` $z$-topology _but_ with non-zero values at top and bottom. When we fill the halos the boundary conditions are imposed and the interpolated field gets 0 at k=1 and k=Nz but the original field doesn't, so the test fails. This test in particular. https://github.com/CliMA/Oceananigans.jl/blob/29e4aaccc57b6391189700b8a6ac8324aff08805/test/test_field.jl#L171. fails when `f = w`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911600412
https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911617204:123,Testability,test,tests,123,[a8e2244](https://github.com/CliMA/Oceananigans.jl/pull/3395/commits/a8e224462a54b7856c6350934798317eae8ebc22) should make tests pass,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911617204
https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911936512:364,Energy Efficiency,reduce,reduced,364,"Looks like it does:. ```julia; julia> using Oceananigans. julia> using Oceananigans.Fields: interpolate!. julia> source_grid = RectilinearGrid(size=(2, 2), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat));. julia> source_field = Field{Center, Center, Nothing}(source_grid);. julia> set!(source_field, (x, y) -> x + y); 2×2×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 2×2×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 8×8×1 OffsetArray(::Array{Float64, 3}, -2:5, -2:5, 1:1) with eltype Float64 with indices -2:5×-2:5×1:1; └── max=1.5, min=0.5, mean=1.0. julia> to_grid = RectilinearGrid(size=(4, 4), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat));. julia> to_field = Field{Center, Center, Nothing}(to_grid); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=0.0, min=0.0, mean=0.0. julia> interpolate!(to_field, source_field). julia> to_field; 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911936512
https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911936512:1027,Energy Efficiency,reduce,reduced,1027,"> using Oceananigans.Fields: interpolate!. julia> source_grid = RectilinearGrid(size=(2, 2), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat));. julia> source_field = Field{Center, Center, Nothing}(source_grid);. julia> set!(source_field, (x, y) -> x + y); 2×2×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 2×2×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 8×8×1 OffsetArray(::Array{Float64, 3}, -2:5, -2:5, 1:1) with eltype Float64 with indices -2:5×-2:5×1:1; └── max=1.5, min=0.5, mean=1.0. julia> to_grid = RectilinearGrid(size=(4, 4), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat));. julia> to_field = Field{Center, Center, Nothing}(to_grid); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=0.0, min=0.0, mean=0.0. julia> interpolate!(to_field, source_field). julia> to_field; 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=1.25, min=0.75, mean=1.02539; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911936512
https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911936512:1590,Energy Efficiency,reduce,reduced,1590,"> using Oceananigans.Fields: interpolate!. julia> source_grid = RectilinearGrid(size=(2, 2), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat));. julia> source_field = Field{Center, Center, Nothing}(source_grid);. julia> set!(source_field, (x, y) -> x + y); 2×2×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 2×2×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 8×8×1 OffsetArray(::Array{Float64, 3}, -2:5, -2:5, 1:1) with eltype Float64 with indices -2:5×-2:5×1:1; └── max=1.5, min=0.5, mean=1.0. julia> to_grid = RectilinearGrid(size=(4, 4), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat));. julia> to_field = Field{Center, Center, Nothing}(to_grid); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=0.0, min=0.0, mean=0.0. julia> interpolate!(to_field, source_field). julia> to_field; 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=1.25, min=0.75, mean=1.02539; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395#issuecomment-1911936512
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592:23,Integrability,interface,interface,23,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592:121,Integrability,interface,interfaces,121,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592:181,Integrability,interface,interface,181,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592:441,Integrability,depend,depend,441,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592:376,Usability,simpl,simple,376,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:1072,Deployability,integrat,integrated,1072,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:35,Integrability,interface,interfaces,35,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:107,Integrability,interface,interface,107,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:618,Integrability,interface,interface,618,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:1072,Integrability,integrat,integrated,1072,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:889,Usability,simpl,simple,889,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238:284,Integrability,interface,interface,284,"> right, `particle` is a list of particles though. `p` is the index that we have to pass in. we can call it forcing but it is specifically an advective forcing (or velocity forcing) because it is added to the velocity. That's a detail and can be implemented regardless of the type of interface. The difference is. 1. Users _extend_ an Oceananigans function to implement a forcing, OR; 2. Users pass a function into `ParticleAdvectiveForcing` to implement a forcing. Option 1 is fine, no doubt. It's just that the rest of our user interfaces implements option 2. I think we should have a uniform interface across the code. Our original motivation for choosing option 2 is because we believed it would be easier to use for people who don't know Julia very well. People should be able to use Oceananigans without knowing what ""multiple dispatch"" is. We can revisit this. If we think that extending forcing function is a better pattern, we should change it throughout the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238:530,Integrability,interface,interfaces,530,"> right, `particle` is a list of particles though. `p` is the index that we have to pass in. we can call it forcing but it is specifically an advective forcing (or velocity forcing) because it is added to the velocity. That's a detail and can be implemented regardless of the type of interface. The difference is. 1. Users _extend_ an Oceananigans function to implement a forcing, OR; 2. Users pass a function into `ParticleAdvectiveForcing` to implement a forcing. Option 1 is fine, no doubt. It's just that the rest of our user interfaces implements option 2. I think we should have a uniform interface across the code. Our original motivation for choosing option 2 is because we believed it would be easier to use for people who don't know Julia very well. People should be able to use Oceananigans without knowing what ""multiple dispatch"" is. We can revisit this. If we think that extending forcing function is a better pattern, we should change it throughout the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238:595,Integrability,interface,interface,595,"> right, `particle` is a list of particles though. `p` is the index that we have to pass in. we can call it forcing but it is specifically an advective forcing (or velocity forcing) because it is added to the velocity. That's a detail and can be implemented regardless of the type of interface. The difference is. 1. Users _extend_ an Oceananigans function to implement a forcing, OR; 2. Users pass a function into `ParticleAdvectiveForcing` to implement a forcing. Option 1 is fine, no doubt. It's just that the rest of our user interfaces implements option 2. I think we should have a uniform interface across the code. Our original motivation for choosing option 2 is because we believed it would be easier to use for people who don't know Julia very well. People should be able to use Oceananigans without knowing what ""multiple dispatch"" is. We can revisit this. If we think that extending forcing function is a better pattern, we should change it throughout the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238:885,Modifiability,extend,extending,885,"> right, `particle` is a list of particles though. `p` is the index that we have to pass in. we can call it forcing but it is specifically an advective forcing (or velocity forcing) because it is added to the velocity. That's a detail and can be implemented regardless of the type of interface. The difference is. 1. Users _extend_ an Oceananigans function to implement a forcing, OR; 2. Users pass a function into `ParticleAdvectiveForcing` to implement a forcing. Option 1 is fine, no doubt. It's just that the rest of our user interfaces implements option 2. I think we should have a uniform interface across the code. Our original motivation for choosing option 2 is because we believed it would be easier to use for people who don't know Julia very well. People should be able to use Oceananigans without knowing what ""multiple dispatch"" is. We can revisit this. If we think that extending forcing function is a better pattern, we should change it throughout the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891:1128,Deployability,integrat,integrated,1128,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891:46,Integrability,interface,interface,46,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891:627,Integrability,interface,interface,627,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891:1128,Integrability,integrat,integrated,1128,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891:945,Usability,simpl,simple,945,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620:458,Integrability,interface,interface,458,"> The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > ; > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:. First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this. You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface. As I said though, I agree it's a good idea to make this kind of thing easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620:782,Integrability,interface,interface,782,"> The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > ; > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:. First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this. You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface. As I said though, I agree it's a good idea to make this kind of thing easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649:1245,Deployability,update,update,1245,"> > The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:; > ; > ; > First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this.; > You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface.; > > As I said though, I agree it's a good idea to make this kind of thing easier. Actually I realized that `dynamics` is called _before_ advection, which makes it more annoying:. https://github.com/CliMA/Oceananigans.jl/blob/dd893745e50fd7aef945f765df929d2a7510db6e/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L123-L132. That makes it a little trickier. It's still possible, since you can compute a ""fake particle update"", and then add the inertia term, before the ""real update"" that occurs in `advect_lagrangian_particles!`. But it's complicated. Why do we call `dynamics` before advection? Should we switch the order of those two? It also seems like we should update particle properties _after_ we advect the particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649:1302,Deployability,update,update,1302,"> > The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:; > ; > ; > First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this.; > You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface.; > > As I said though, I agree it's a good idea to make this kind of thing easier. Actually I realized that `dynamics` is called _before_ advection, which makes it more annoying:. https://github.com/CliMA/Oceananigans.jl/blob/dd893745e50fd7aef945f765df929d2a7510db6e/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L123-L132. That makes it a little trickier. It's still possible, since you can compute a ""fake particle update"", and then add the inertia term, before the ""real update"" that occurs in `advect_lagrangian_particles!`. But it's complicated. Why do we call `dynamics` before advection? Should we switch the order of those two? It also seems like we should update particle properties _after_ we advect the particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649:1493,Deployability,update,update,1493,"> > The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:; > ; > ; > First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this.; > You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface.; > > As I said though, I agree it's a good idea to make this kind of thing easier. Actually I realized that `dynamics` is called _before_ advection, which makes it more annoying:. https://github.com/CliMA/Oceananigans.jl/blob/dd893745e50fd7aef945f765df929d2a7510db6e/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L123-L132. That makes it a little trickier. It's still possible, since you can compute a ""fake particle update"", and then add the inertia term, before the ""real update"" that occurs in `advect_lagrangian_particles!`. But it's complicated. Why do we call `dynamics` before advection? Should we switch the order of those two? It also seems like we should update particle properties _after_ we advect the particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649:468,Integrability,interface,interface,468,"> > The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:; > ; > ; > First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this.; > You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface.; > > As I said though, I agree it's a good idea to make this kind of thing easier. Actually I realized that `dynamics` is called _before_ advection, which makes it more annoying:. https://github.com/CliMA/Oceananigans.jl/blob/dd893745e50fd7aef945f765df929d2a7510db6e/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L123-L132. That makes it a little trickier. It's still possible, since you can compute a ""fake particle update"", and then add the inertia term, before the ""real update"" that occurs in `advect_lagrangian_particles!`. But it's complicated. Why do we call `dynamics` before advection? Should we switch the order of those two? It also seems like we should update particle properties _after_ we advect the particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649:795,Integrability,interface,interface,795,"> > The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:; > ; > ; > First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this.; > You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface.; > > As I said though, I agree it's a good idea to make this kind of thing easier. Actually I realized that `dynamics` is called _before_ advection, which makes it more annoying:. https://github.com/CliMA/Oceananigans.jl/blob/dd893745e50fd7aef945f765df929d2a7510db6e/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L123-L132. That makes it a little trickier. It's still possible, since you can compute a ""fake particle update"", and then add the inertia term, before the ""real update"" that occurs in `advect_lagrangian_particles!`. But it's complicated. Why do we call `dynamics` before advection? Should we switch the order of those two? It also seems like we should update particle properties _after_ we advect the particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819491364:392,Integrability,depend,depend,392,"> > We could think about a `ParticleAdvectiveForcing` or also a `ParticleVelocityTendency` function that specifies the rhs of dvdt=G; > ; > One example that this might be tricky for this approach is where the particles have a constant sinking velocity on top of the fluid velocity. A constant sinking velocity is easy to implement using `dynamics`, since it's constant everywhere and doesn't depend on the position / fluid velocity experienced by the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819491364
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719:254,Integrability,interface,interface,254,"There used to be an example of using `dynamics` to implement particles that played ""rock, paper, scissors""; ie near-neighbors were identified, and then made to interact in some way that changed particle properties. There is scope for building out a user interface for more generic particle interactions of course. I'm not convinced that this is so important that we should spoon-feed users with an interface though. In principle, `dynamics` can do everything and advanced users can write their own code. It depends on how important the uses get, and how clever we can be with an interface (so it is easy to maintain and doesn't screw things up for future development)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719:398,Integrability,interface,interface,398,"There used to be an example of using `dynamics` to implement particles that played ""rock, paper, scissors""; ie near-neighbors were identified, and then made to interact in some way that changed particle properties. There is scope for building out a user interface for more generic particle interactions of course. I'm not convinced that this is so important that we should spoon-feed users with an interface though. In principle, `dynamics` can do everything and advanced users can write their own code. It depends on how important the uses get, and how clever we can be with an interface (so it is easy to maintain and doesn't screw things up for future development)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719:507,Integrability,depend,depends,507,"There used to be an example of using `dynamics` to implement particles that played ""rock, paper, scissors""; ie near-neighbors were identified, and then made to interact in some way that changed particle properties. There is scope for building out a user interface for more generic particle interactions of course. I'm not convinced that this is so important that we should spoon-feed users with an interface though. In principle, `dynamics` can do everything and advanced users can write their own code. It depends on how important the uses get, and how clever we can be with an interface (so it is easy to maintain and doesn't screw things up for future development)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719:579,Integrability,interface,interface,579,"There used to be an example of using `dynamics` to implement particles that played ""rock, paper, scissors""; ie near-neighbors were identified, and then made to interact in some way that changed particle properties. There is scope for building out a user interface for more generic particle interactions of course. I'm not convinced that this is so important that we should spoon-feed users with an interface though. In principle, `dynamics` can do everything and advanced users can write their own code. It depends on how important the uses get, and how clever we can be with an interface (so it is easy to maintain and doesn't screw things up for future development)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819556970:411,Integrability,depend,depend,411,"> > > We could think about a `ParticleAdvectiveForcing` or also a `ParticleVelocityTendency` function that specifies the rhs of dvdt=G; > > ; > > ; > > One example that this might be tricky for this approach is where the particles have a constant sinking velocity on top of the fluid velocity.; > ; > A constant sinking velocity is easy to implement using `dynamics`, since it's constant everywhere and doesn't depend on the position / fluid velocity experienced by the particle. I don't think a constant sinking velocity can be implemented in `dynamics` in this setup where `dynamics` comes before advection. You could imagine a particle being advected with its sinking velocity at the `dynamics` step, then later on at the `advect_lagrangian_particles!` it'll be advected by the field velocity at a new location, which will be of a different value. I suppose this is fine if `dynamics` and `advect_lagrangian_particles!` are reversed. However, I think that advection forcing should be run at the same time as `advect_lagrangian_particles!`. This would be important for cases where the additional advection is a function of its location for example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819556970
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819859736:429,Integrability,depend,depend,429,"> > > > We could think about a `ParticleAdvectiveForcing` or also a `ParticleVelocityTendency` function that specifies the rhs of dvdt=G; > > > ; > > > ; > > > One example that this might be tricky for this approach is where the particles have a constant sinking velocity on top of the fluid velocity.; > > ; > > ; > > A constant sinking velocity is easy to implement using `dynamics`, since it's constant everywhere and doesn't depend on the position / fluid velocity experienced by the particle.; > ; > I don't think a constant sinking velocity can be implemented in `dynamics` in this setup where `dynamics` comes before advection. You could imagine a particle being advected with its sinking velocity at the `dynamics` step, then later on at the `advect_lagrangian_particles!` it'll be advected by the field velocity at a new location, which will be of a different value. I suppose this is fine if `dynamics` and `advect_lagrangian_particles!` are reversed. For a constant velocity, the only difference that switching the order of function calls makes is the way we interpret the initial condition or final state. For example, if we call `dynamics` _after_ advection, but also shift the initial condition vertical positions by `dt * w_sinking`, then the result would be identical as calling `dynamics` before advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819859736
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837241191:426,Availability,ERROR,ERROR,426,"I added a `ParticleAdvectionForcing` that behaves similarly to `dynamics(particles, model, Δt)` which allows user to specify any velocities it wishes to add to the model by passing in `NonHydrostaticModel(..., advective_forcing = ParticleAdvectiveForcing(u=some_u, v=some_v, w=some_w))` . The arguments are functions that take `(particles, model, Δt)` as inputs. . When I am trying to test my code I ran into a problem:; ```; ERROR: UndefVarError: `flattened_node` not defined; ```. https://github.com/CliMA/Oceananigans.jl/blob/a73e845a7a7bce8e22e9453670c1c20b67dbfc3a/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L92. @simone-silvestri I see that you added this and I couldn't find anywhere in the code where `flattened_node` is defined. What is it supposed to be?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837241191
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837241191:385,Testability,test,test,385,"I added a `ParticleAdvectionForcing` that behaves similarly to `dynamics(particles, model, Δt)` which allows user to specify any velocities it wishes to add to the model by passing in `NonHydrostaticModel(..., advective_forcing = ParticleAdvectiveForcing(u=some_u, v=some_v, w=some_w))` . The arguments are functions that take `(particles, model, Δt)` as inputs. . When I am trying to test my code I ran into a problem:; ```; ERROR: UndefVarError: `flattened_node` not defined; ```. https://github.com/CliMA/Oceananigans.jl/blob/a73e845a7a7bce8e22e9453670c1c20b67dbfc3a/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L92. @simone-silvestri I see that you added this and I couldn't find anywhere in the code where `flattened_node` is defined. What is it supposed to be?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837241191
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837242844:441,Availability,ERROR,ERROR,441,"> I added a `ParticleAdvectionForcing` that behaves similarly to `dynamics(particles, model, Δt)` which allows user to specify any velocities it wishes to add to the model by passing in `NonHydrostaticModel(..., advective_forcing = ParticleAdvectiveForcing(u=some_u, v=some_v, w=some_w))` . The arguments are functions that take `(particles, model, Δt)` as inputs.; > ; > When I am trying to test my code I ran into a problem:; > ; > ```; > ERROR: UndefVarError: `flattened_node` not defined; > ```; > ; > https://github.com/CliMA/Oceananigans.jl/blob/a73e845a7a7bce8e22e9453670c1c20b67dbfc3a/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L92; > ; > @simone-silvestri I see that you added this and I couldn't find anywhere in the code where `flattened_node` is defined. What is it supposed to be?. This is from #3395. We should wait for that PR to be merged before merging this one",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837242844
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837242844:392,Testability,test,test,392,"> I added a `ParticleAdvectionForcing` that behaves similarly to `dynamics(particles, model, Δt)` which allows user to specify any velocities it wishes to add to the model by passing in `NonHydrostaticModel(..., advective_forcing = ParticleAdvectiveForcing(u=some_u, v=some_v, w=some_w))` . The arguments are functions that take `(particles, model, Δt)` as inputs.; > ; > When I am trying to test my code I ran into a problem:; > ; > ```; > ERROR: UndefVarError: `flattened_node` not defined; > ```; > ; > https://github.com/CliMA/Oceananigans.jl/blob/a73e845a7a7bce8e22e9453670c1c20b67dbfc3a/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L92; > ; > @simone-silvestri I see that you added this and I couldn't find anywhere in the code where `flattened_node` is defined. What is it supposed to be?. This is from #3395. We should wait for that PR to be merged before merging this one",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837242844
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837246301:3,Testability,test,test,3,to test the code you can merge #3395 in this PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837246301
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078:51,Integrability,depend,depend,51,"these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature. We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. ; I would include:; - buoyant particles (sinking or rising with a density-dependent vertical velocity); - particles with drag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078:520,Integrability,depend,dependent,520,"these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature. We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. ; I would include:; - buoyant particles (sinking or rising with a density-dependent vertical velocity); - particles with drag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078:118,Modifiability,variab,variables,118,"these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature. We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. ; I would include:; - buoyant particles (sinking or rising with a density-dependent vertical velocity); - particles with drag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287:53,Integrability,depend,depend,53,"> these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature.; > ; > We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. I would include:; > ; > * buoyant particles (sinking or rising with a density-dependent vertical velocity); > * particles with drag. The discussion is fine but we first need to resolve something more fundamental: the particles do not have indices `i, j, k`. The only way to use Eulerian fields to determine particle forcing is to `interpolate` the Eulerian fields to the location of the particle. Obviously, that's how advecting particles works in the first place, by interpolating the velocity field to the location of the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287:533,Integrability,depend,dependent,533,"> these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature.; > ; > We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. I would include:; > ; > * buoyant particles (sinking or rising with a density-dependent vertical velocity); > * particles with drag. The discussion is fine but we first need to resolve something more fundamental: the particles do not have indices `i, j, k`. The only way to use Eulerian fields to determine particle forcing is to `interpolate` the Eulerian fields to the location of the particle. Obviously, that's how advecting particles works in the first place, by interpolating the velocity field to the location of the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287:120,Modifiability,variab,variables,120,"> these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature.; > ; > We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. I would include:; > ; > * buoyant particles (sinking or rising with a density-dependent vertical velocity); > * particles with drag. The discussion is fine but we first need to resolve something more fundamental: the particles do not have indices `i, j, k`. The only way to use Eulerian fields to determine particle forcing is to `interpolate` the Eulerian fields to the location of the particle. Obviously, that's how advecting particles works in the first place, by interpolating the velocity field to the location of the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:173,Availability,avail,available,173,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:801,Integrability,interface,interface,801,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:571,Modifiability,extend,extend,571,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:558,Usability,simpl,simply,558,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1871616229:5,Deployability,update,updated,5,"I've updated the code to `ParticleVelocities` and changed the function signature to . ```julia; @inline particle_u_velocity(x, y, z, u_fluid, particles, p, advective_velocity::ParticleVelocities, grid, clock, Δt, model_fields) = advective_velocity.u(x, y, z, u_fluid, particles, p, grid, clock, Δt, model_fields); ```. I also swapped around `advect_lagrangian_particles!` and `dynamics`, so now the particles are advected before the `dynamics` function is applied. I found this to be easier when implementing an example with the drag. I've implemented a simple example with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1871616229
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1871616229:554,Usability,simpl,simple,554,"I've updated the code to `ParticleVelocities` and changed the function signature to . ```julia; @inline particle_u_velocity(x, y, z, u_fluid, particles, p, advective_velocity::ParticleVelocities, grid, clock, Δt, model_fields) = advective_velocity.u(x, y, z, u_fluid, particles, p, grid, clock, Δt, model_fields); ```. I also swapped around `advect_lagrangian_particles!` and `dynamics`, so now the particles are advected before the `dynamics` function is applied. I found this to be easier when implementing an example with the drag. I've implemented a simple example with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1871616229
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:832,Deployability,update,updated,832,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:1075,Deployability,update,update,1075,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:1203,Deployability,update,updated,1203,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:172,Integrability,depend,depending,172,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:277,Modifiability,evolve,evolve,277,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:914,Security,access,access,914,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873552345:41,Modifiability,evolve,evolve,41,"> In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873552345
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652:293,Integrability,depend,depends,293,"> > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > ; > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`. I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time $t$ before it is being advected to time $t + \Delta t$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652:43,Modifiability,evolve,evolve,43,"> > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > ; > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`. I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time $t$ before it is being advected to time $t + \Delta t$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919:649,Deployability,update,updated,649,"> > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > ; > > ; > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > ; > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt. But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919:312,Integrability,depend,depends,312,"> > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > ; > > ; > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > ; > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt. But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919:45,Modifiability,evolve,evolve,45,"> > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > ; > > ; > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > ; > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt. But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866:674,Deployability,update,updated,674,"> > > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > > ; > > > ; > > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > > ; > > ; > > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt.; > ; > But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another. Makes sense. `advect_lagrangian_particles!` first before `dynamics` it is!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866:330,Integrability,depend,depends,330,"> > > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > > ; > > > ; > > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > > ; > > ; > > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt.; > ; > But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another. Makes sense. `advect_lagrangian_particles!` first before `dynamics` it is!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866
https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866:47,Modifiability,evolve,evolve,47,"> > > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > > ; > > > ; > > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > > ; > > ; > > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt.; > ; > But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another. Makes sense. `advect_lagrangian_particles!` first before `dynamics` it is!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866
https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462:103,Integrability,depend,depends,103,"This velocity field:. ```julia; uᵢ(x, y, z) = (1-tanh((x-500)/10)); ```. is compressible, because `uᵢ` depends on `x`. When we project out the compressible component (the part that depends on `x`), we are left with just `u=1`. What do we expect to happen in this case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462
https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462:181,Integrability,depend,depends,181,"This velocity field:. ```julia; uᵢ(x, y, z) = (1-tanh((x-500)/10)); ```. is compressible, because `uᵢ` depends on `x`. When we project out the compressible component (the part that depends on `x`), we are left with just `u=1`. What do we expect to happen in this case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462
https://github.com/CliMA/Oceananigans.jl/pull/3398#issuecomment-1847520360:12,Availability,error,error,12,This is the error:. https://buildkite.com/clima/oceananigans/builds/13631#018c4474-4eeb-4e8f-94f0-f8a10df34e8d/18-206. It seems storage5 is full.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3398#issuecomment-1847520360
https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:1152,Availability,checkpoint,checkpoint,1152,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:1662,Availability,error,error,1662,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:1041,Integrability,interface,interface,1041,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:904,Safety,avoid,avoid,904,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:13,Usability,user experience,user experience,13,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:1829,Usability,simpl,simplified,1829,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
https://github.com/CliMA/Oceananigans.jl/pull/3401#issuecomment-1867012830:31,Testability,test,tests,31,This PR was merged even though tests never ran.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401#issuecomment-1867012830
https://github.com/CliMA/Oceananigans.jl/pull/3402#issuecomment-1854102445:13,Deployability,release,release,13,The relevant release of CUDA: https://github.com/JuliaGPU/CUDA.jl/releases/tag/v4.1.1,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402#issuecomment-1854102445
https://github.com/CliMA/Oceananigans.jl/pull/3402#issuecomment-1854102445:66,Deployability,release,releases,66,The relevant release of CUDA: https://github.com/JuliaGPU/CUDA.jl/releases/tag/v4.1.1,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402#issuecomment-1854102445
https://github.com/CliMA/Oceananigans.jl/pull/3402#issuecomment-1867011862:38,Testability,test,tests,38,"It looks like this PR was merged, but tests do not pass. We need to fix the tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402#issuecomment-1867011862
https://github.com/CliMA/Oceananigans.jl/pull/3402#issuecomment-1867011862:76,Testability,test,tests,76,"It looks like this PR was merged, but tests do not pass. We need to fix the tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402#issuecomment-1867011862
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:241,Integrability,depend,dependency,241,"Doctests fail because of all the `loop not unrolled` warnings we get.; We should remedy this before we move to Julia v1.10. @glwagner you bumped onto this previously, right?. ```Julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requeste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:845,Performance,optimiz,optimizer,845,"Doctests fail because of all the `loop not unrolled` warnings we get.; We should remedy this before we move to Julia v1.10. @glwagner you bumped onto this previously, right?. ```Julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requeste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:869,Performance,perform,perform,869,"Doctests fail because of all the `loop not unrolled` warnings we get.; We should remedy this before we move to Julia v1.10. @glwagner you bumped onto this previously, right?. ```Julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requeste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1123,Performance,optimiz,optimizer,1123,"eananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1147,Performance,perform,perform,1147,"eananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1401,Performance,optimiz,optimizer,1401,"nded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1425,Performance,perform,perform,1425,"nded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1679,Performance,optimiz,optimizer,1679,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1703,Performance,perform,perform,1703,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1957,Performance,optimiz,optimizer,1957,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1981,Performance,perform,perform,1981,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:2235,Performance,optimiz,optimizer,2235,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:2259,Performance,perform,perform,2259,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:2513,Performance,optimiz,optimizer,2513,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:2537,Performance,perform,perform,2537,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:2791,Performance,optimiz,optimizer,2791,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:2815,Performance,perform,perform,2815,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3069,Performance,optimiz,optimizer,3069,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3093,Performance,perform,perform,3093,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3347,Performance,optimiz,optimizer,3347,"ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3371,Performance,perform,perform,3371,"ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3625,Performance,optimiz,optimizer,3625,"ransformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3649,Performance,perform,perform,3649,"ransformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3903,Performance,optimiz,optimizer,3903,"ransformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3927,Performance,perform,perform,3927,"ransformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:4181,Performance,optimiz,optimizer,4181,"ransformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:4205,Performance,perform,perform,4205,"ransformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1884393184:8,Testability,test,tests,8,"OK, now tests pass but I believe I removed more `@unroll`s than I should. It was only for testing purposes to see if those were the culprit for the warnings. @glwagner could we zoom and put back in the `@unroll`s that we should?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1884393184
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1884393184:90,Testability,test,testing,90,"OK, now tests pass but I believe I removed more `@unroll`s than I should. It was only for testing purposes to see if those were the culprit for the warnings. @glwagner could we zoom and put back in the `@unroll`s that we should?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1884393184
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1895003358:48,Testability,test,test,48,@simone-silvestri any idea why this distributed test would fail on GPU?; https://buildkite.com/clima/oceananigans-distributed/builds/904#018d1323-015e-43f7-8bc6-dd8483c0acb4/168-5125,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1895003358
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1925160996:281,Availability,toler,tolerance,281,"@simone-silvestri any idea why the [gpu distributed hydrostatic model tests](https://buildkite.com/clima/oceananigans-distributed/builds/1102#018d6aa2-a044-4abd-8215-8d90ce471c50/186-4607) and how should I debug this? I mean, can I reproduce this on my laptop for example? Is it a tolerance issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1925160996
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1925160996:70,Testability,test,tests,70,"@simone-silvestri any idea why the [gpu distributed hydrostatic model tests](https://buildkite.com/clima/oceananigans-distributed/builds/1102#018d6aa2-a044-4abd-8215-8d90ce471c50/186-4607) and how should I debug this? I mean, can I reproduce this on my laptop for example? Is it a tolerance issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1925160996
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1927360091:24,Availability,toler,tolerance,24,"Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ). By the way, for unrolling loops we can look at this package which might be very useful to us https://github.com/cstjean/Unrolled.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1927360091
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1928865390:26,Availability,toler,tolerance,26,"> Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ). I checked and tests were failing because values of order 1e-19 or less were not agreeing... see https://buildkite.com/clima/oceananigans-distributed/builds/1131#018d7a2d-f6c5-4e22-8006-3e2d318465d1/170-5060. I replaced `a ≈ b` (which defaults to `atol=0` with `isapprox(a, b, atol=eps(eltype(grid)))`; see [385a05d](https://github.com/CliMA/Oceananigans.jl/pull/3403/commits/385a05d55dfe189eb0734c9120d0f9604eb070f7)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1928865390
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1928865390:177,Testability,test,tests,177,"> Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ). I checked and tests were failing because values of order 1e-19 or less were not agreeing... see https://buildkite.com/clima/oceananigans-distributed/builds/1131#018d7a2d-f6c5-4e22-8006-3e2d318465d1/170-5060. I replaced `a ≈ b` (which defaults to `atol=0` with `isapprox(a, b, atol=eps(eltype(grid)))`; see [385a05d](https://github.com/CliMA/Oceananigans.jl/pull/3403/commits/385a05d55dfe189eb0734c9120d0f9604eb070f7)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1928865390
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930121202:26,Availability,toler,tolerance,26,"> Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ); > ; > By the way, for unrolling loops we can look at this package which might be very useful to us https://github.com/cstjean/Unrolled.jl. What's the difference between that and what we are using from `KernelAbstractions.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930121202
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930124210:28,Availability,toler,tolerance,28,"> > Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ); > ; > I checked and tests were failing because values of order 1e-19 or less were not agreeing... see https://buildkite.com/clima/oceananigans-distributed/builds/1131#018d7a2d-f6c5-4e22-8006-3e2d318465d1/170-5060; > ; > I replaced `a ≈ b` (which defaults to `atol=0` with `isapprox(a, b, atol=eps(eltype(grid)))`; see [385a05d](https://github.com/CliMA/Oceananigans.jl/pull/3403/commits/385a05d55dfe189eb0734c9120d0f9604eb070f7). Makes sense. Are the differences associated with some of the unrolling that we added (eg to fill halo regions)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930124210
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930124210:185,Testability,test,tests,185,"> > Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ); > ; > I checked and tests were failing because values of order 1e-19 or less were not agreeing... see https://buildkite.com/clima/oceananigans-distributed/builds/1131#018d7a2d-f6c5-4e22-8006-3e2d318465d1/170-5060; > ; > I replaced `a ≈ b` (which defaults to `atol=0` with `isapprox(a, b, atol=eps(eltype(grid)))`; see [385a05d](https://github.com/CliMA/Oceananigans.jl/pull/3403/commits/385a05d55dfe189eb0734c9120d0f9604eb070f7). Makes sense. Are the differences associated with some of the unrolling that we added (eg to fill halo regions)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930124210
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1931591461:433,Testability,test,test,433,"oh I see, do you mean the proper use of `Val(grid.Hx)` e.g. in . https://github.com/CliMA/Oceananigans.jl/blob/079a88250d7bf9d01c31ce79fb8e756be222c58f/src/BoundaryConditions/fill_halo_regions_periodic.jl#L20. Unfortunately we don't know because the distributed CI was broken at that point; I only fixed it after with [e8da741](https://github.com/CliMA/Oceananigans.jl/pull/3403/commits/e8da74141d2b07c45b2d24f2f2e0f8b570ed14fa). To test this hypothesis we should remove the `Val(grid.Hx)` etc and see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1931591461
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1943177961:97,Deployability,update,updates,97,"This PR ready. I just wanted to wait until after OSM2024 to merge since it includes various deps updates as well. Or, @glwagner, feel free to merge at will whenever.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1943177961
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1944546930:81,Testability,test,tests,81,But this PR doesn't require users to use 1.10 right? It's just about running the tests on 1.10. I think it will be nice to get rid of the crazy warnings on 1.10.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1944546930
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1944573855:83,Testability,test,tests,83,> But this PR doesn't require users to use 1.10 right? It's just about running the tests on 1.10. yes!. > I think it will be nice to get rid of the crazy warnings on 1.10. yes,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1944573855
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022:144,Deployability,update,updates,144,"> But this PR doesn't require users to use 1.10 right? It's just about running the tests on 1.10. (Yes, but also the Manifest includes a lot of updates for various dependencies so that all pkgs versions are resolved with v1.10.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022:164,Integrability,depend,dependencies,164,"> But this PR doesn't require users to use 1.10 right? It's just about running the tests on 1.10. (Yes, but also the Manifest includes a lot of updates for various dependencies so that all pkgs versions are resolved with v1.10.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022:83,Testability,test,tests,83,"> But this PR doesn't require users to use 1.10 right? It's just about running the tests on 1.10. (Yes, but also the Manifest includes a lot of updates for various dependencies so that all pkgs versions are resolved with v1.10.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022
https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1964566780:26,Testability,test,tests,26,Shall we merge this (when tests pass)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1964566780
https://github.com/CliMA/Oceananigans.jl/pull/3405#issuecomment-1874431790:202,Energy Efficiency,schedul,schedule,202,"> src/Simulations/callback.jl. ```julia; conjure_wizard!(simulation; interval=5, cfl=0.5); ```. ```julia; progress(sim) = @info string(""Iteration "", iteration(sim)); add_callback!(simulation, progress, schedule=IterationInterval(10)); ```. Hmm, maybe `schedule` should be positional to make the API tight and concise. EDIT: this is outdated, see original post.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3405#issuecomment-1874431790
https://github.com/CliMA/Oceananigans.jl/pull/3405#issuecomment-1874431790:252,Energy Efficiency,schedul,schedule,252,"> src/Simulations/callback.jl. ```julia; conjure_wizard!(simulation; interval=5, cfl=0.5); ```. ```julia; progress(sim) = @info string(""Iteration "", iteration(sim)); add_callback!(simulation, progress, schedule=IterationInterval(10)); ```. Hmm, maybe `schedule` should be positional to make the API tight and concise. EDIT: this is outdated, see original post.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3405#issuecomment-1874431790
https://github.com/CliMA/Oceananigans.jl/pull/3405#issuecomment-1874460013:224,Energy Efficiency,schedul,schedule,224,"> > src/Simulations/callback.jl; > ; > ```julia; > conjure_wizard!(simulation; interval=5, cfl=0.5); > ```; > ; > ```julia; > progress(sim) = @info string(""Iteration "", iteration(sim)); > add_callback!(simulation, progress, schedule=IterationInterval(10)); > ```; > ; > Hmm, maybe `schedule` should be positional to make the API tight and concise. This is very nice. Yes, add it to a couple of examples!; Not sure about your dilemma regarding positional vs kwarg. I'll leave that up to you.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3405#issuecomment-1874460013
https://github.com/CliMA/Oceananigans.jl/pull/3405#issuecomment-1874460013:282,Energy Efficiency,schedul,schedule,282,"> > src/Simulations/callback.jl; > ; > ```julia; > conjure_wizard!(simulation; interval=5, cfl=0.5); > ```; > ; > ```julia; > progress(sim) = @info string(""Iteration "", iteration(sim)); > add_callback!(simulation, progress, schedule=IterationInterval(10)); > ```; > ; > Hmm, maybe `schedule` should be positional to make the API tight and concise. This is very nice. Yes, add it to a couple of examples!; Not sure about your dilemma regarding positional vs kwarg. I'll leave that up to you.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3405#issuecomment-1874460013
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838:35,Availability,failure,failures,35,"@glwagner can you review this? The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})` and I'm not sure what already is expected to fail",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838:140,Energy Efficiency,Adapt,Adapt,140,"@glwagner can you review this? The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})` and I'm not sure what already is expected to fail",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838:146,Energy Efficiency,adapt,adapt,146,"@glwagner can you review this? The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})` and I'm not sure what already is expected to fail",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838:140,Modifiability,Adapt,Adapt,140,"@glwagner can you review this? The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})` and I'm not sure what already is expected to fail",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838:146,Modifiability,adapt,adapt,146,"@glwagner can you review this? The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})` and I'm not sure what already is expected to fail",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447:6,Availability,failure,failures,6,"> The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})`. wut. > I'm not sure what already is expected to fail. Nothing is expected to fail. Where does `Fix1` come from?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447:111,Energy Efficiency,Adapt,Adapt,111,"> The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})`. wut. > I'm not sure what already is expected to fail. Nothing is expected to fail. Where does `Fix1` come from?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447:117,Energy Efficiency,adapt,adapt,117,"> The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})`. wut. > I'm not sure what already is expected to fail. Nothing is expected to fail. Where does `Fix1` come from?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447:111,Modifiability,Adapt,Adapt,111,"> The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})`. wut. > I'm not sure what already is expected to fail. Nothing is expected to fail. Where does `Fix1` come from?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447:117,Modifiability,adapt,adapt,117,"> The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})`. wut. > I'm not sure what already is expected to fail. Nothing is expected to fail. Where does `Fix1` come from?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:34,Availability,error,error,34,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:288,Deployability,update,update,288,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:128,Energy Efficiency,Adapt,Adapt,128,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:134,Energy Efficiency,adapt,adapt,134,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:219,Energy Efficiency,adapt,adapt,219,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:306,Energy Efficiency,Adapt,Adapt,306,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:128,Modifiability,Adapt,Adapt,128,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:134,Modifiability,adapt,adapt,134,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:219,Modifiability,adapt,adapt,219,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:306,Modifiability,Adapt,Adapt,306,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041
https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201:52,Deployability,release,release,52,"global tracer conservation for the hydrostatic lock-release configuration in `validation/moving_coordinate/z_star_lock_release.jl`. Better than the z-coordinate but still not machine-precision conserving. <img width=""289"" alt=""Screenshot 2023-12-21 at 11 00 02 AM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/33547697/e7f913c5-07e6-47ab-a391-24af71ea65a5"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201
https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201:60,Deployability,configurat,configuration,60,"global tracer conservation for the hydrostatic lock-release configuration in `validation/moving_coordinate/z_star_lock_release.jl`. Better than the z-coordinate but still not machine-precision conserving. <img width=""289"" alt=""Screenshot 2023-12-21 at 11 00 02 AM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/33547697/e7f913c5-07e6-47ab-a391-24af71ea65a5"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201
https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201:60,Modifiability,config,configuration,60,"global tracer conservation for the hydrostatic lock-release configuration in `validation/moving_coordinate/z_star_lock_release.jl`. Better than the z-coordinate but still not machine-precision conserving. <img width=""289"" alt=""Screenshot 2023-12-21 at 11 00 02 AM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/33547697/e7f913c5-07e6-47ab-a391-24af71ea65a5"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201
https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201:78,Security,validat,validation,78,"global tracer conservation for the hydrostatic lock-release configuration in `validation/moving_coordinate/z_star_lock_release.jl`. Better than the z-coordinate but still not machine-precision conserving. <img width=""289"" alt=""Screenshot 2023-12-21 at 11 00 02 AM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/33547697/e7f913c5-07e6-47ab-a391-24af71ea65a5"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201
https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677:689,Deployability,update,update,689,"There are two things at play here. First, there is a refactoring of the equation set to allow for a generalized vertical coordinate. This actually involves rewriting the equations. To merge that generalization, I think we would also like to see the new equations that are being solved written up in the docs. When the equations are generalized, this would also involve implementing a new abstraction for the vertical coordinate, along with a `vertical_coordinate = ZVerticalCoordinate()` default, which preserves existing behavior. The second PR should then implement a `ZStarVerticalCoordinate()` (other better names are fine too). So to me this feels like we need two PRs, one with docs update and API design, and then a second with z* implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677
https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677:53,Modifiability,refactor,refactoring,53,"There are two things at play here. First, there is a refactoring of the equation set to allow for a generalized vertical coordinate. This actually involves rewriting the equations. To merge that generalization, I think we would also like to see the new equations that are being solved written up in the docs. When the equations are generalized, this would also involve implementing a new abstraction for the vertical coordinate, along with a `vertical_coordinate = ZVerticalCoordinate()` default, which preserves existing behavior. The second PR should then implement a `ZStarVerticalCoordinate()` (other better names are fine too). So to me this feels like we need two PRs, one with docs update and API design, and then a second with z* implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677
https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009:663,Deployability,update,updated,663,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009
https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009:43,Integrability,interface,interface,43,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009
https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009:564,Usability,clear,clear,564,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009
https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1866992025:181,Deployability,update,update,181,"Do you want to fix it? Then you get full credit for it 😄 Note that your ""y'all"" includes _you_! We're all developing this... PS this is a syntax change in Oceananigans, not a Julia update. We made it so that `Flat` directions are always omitted from background fields, forcing, initial conditions, etc (though there is still a bit of work to do with particles).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1866992025
https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1927121355:157,Testability,log,loganpknudsen,157,> I tend to believe that this issue is again related with using a previous version of Oceananigans than the one used by the Docs. Hmm I think you're right. @loganpknudsen can you confirm that your problem goes away if you run the example with the latest version of Oceananigans? PS who are these mysterious colleagues? If they are on github go ahead and tag them here to add them to the discussion.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1927121355
https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1979514042:20,Deployability,update,update,20,"@loganpknudsen, any update on the status of this issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1979514042
https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1979514042:1,Testability,log,loganpknudsen,1,"@loganpknudsen, any update on the status of this issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1979514042
https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1989008367:19,Testability,log,loganpknudsen,19,I'm closing this; @loganpknudsen please re-open if you still think there is an issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412#issuecomment-1989008367
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867019151:40,Performance,queue,queue,40,"Possibly, we should start using a merge queue that would disallow PRs from being merged unless tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867019151
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867019151:95,Testability,test,tests,95,"Possibly, we should start using a merge queue that would disallow PRs from being merged unless tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867019151
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1546,Availability,error,errors,1546,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:27,Energy Efficiency,adapt,adapt,27,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:53,Energy Efficiency,Adapt,Adapt,53,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:59,Energy Efficiency,adapt,adapt,59,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:66,Energy Efficiency,adapt,adapt,66,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:80,Energy Efficiency,Adapt,Adapt,80,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:128,Energy Efficiency,adapt,adaptions,128,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:302,Energy Efficiency,adapt,adapt,302,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:381,Energy Efficiency,adapt,adaptor,381,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:579,Energy Efficiency,Adapt,Adapt,579,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:652,Energy Efficiency,adapt,adapt,652,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:748,Energy Efficiency,adapt,adapt,748,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:934,Energy Efficiency,Adapt,Adapt,934,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:992,Energy Efficiency,adapt,adapt,992,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1018,Energy Efficiency,adapt,adapt,1018,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1263,Energy Efficiency,adapt,adapt,1263,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1297,Energy Efficiency,adapt,adapts,1297,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1349,Energy Efficiency,adapt,adaptions,1349,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1477,Energy Efficiency,adapt,adapt,1477,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:27,Modifiability,adapt,adapt,27,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:53,Modifiability,Adapt,Adapt,53,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:59,Modifiability,adapt,adapt,59,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:66,Modifiability,adapt,adapt,66,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:80,Modifiability,Adapt,Adapt,80,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:128,Modifiability,adapt,adaptions,128,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:302,Modifiability,adapt,adapt,302,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:381,Modifiability,adapt,adaptor,381,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:579,Modifiability,Adapt,Adapt,579,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:652,Modifiability,adapt,adapt,652,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:748,Modifiability,adapt,adapt,748,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:867,Modifiability,extend,extend,867,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:934,Modifiability,Adapt,Adapt,934,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:992,Modifiability,adapt,adapt,992,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1018,Modifiability,adapt,adapt,1018,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1263,Modifiability,adapt,adapt,1263,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1297,Modifiability,adapt,adapts,1297,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1349,Modifiability,adapt,adaptions,1349,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:1477,Modifiability,adapt,adapt,1477,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:21,Energy Efficiency,Adapt,Adapt,21,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:27,Energy Efficiency,adapt,adapt,27,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:57,Energy Efficiency,adapt,adapt,57,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:142,Energy Efficiency,adapt,adapt,142,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:21,Modifiability,Adapt,Adapt,21,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:27,Modifiability,adapt,adapt,27,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:57,Modifiability,adapt,adapt,57,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:142,Modifiability,adapt,adapt,142,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028:0,Energy Efficiency,Adapt,Adapt,0,"Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh. We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028:154,Energy Efficiency,Adapt,Adapt,154,"Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh. We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028:0,Modifiability,Adapt,Adapt,0,"Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh. We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028:154,Modifiability,Adapt,Adapt,154,"Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh. We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:2,Energy Efficiency,Adapt,Adapt,2,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:163,Energy Efficiency,Adapt,Adapt,163,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:218,Energy Efficiency,Adapt,Adapt,218,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:394,Energy Efficiency,adapt,adapting,394,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:455,Energy Efficiency,adapt,adapt,455,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:489,Energy Efficiency,adapt,adapting,489,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:523,Energy Efficiency,adapt,adapted,523,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:2,Modifiability,Adapt,Adapt,2,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:163,Modifiability,Adapt,Adapt,163,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:218,Modifiability,Adapt,Adapt,218,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:394,Modifiability,adapt,adapting,394,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:455,Modifiability,adapt,adapt,455,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:489,Modifiability,adapt,adapting,489,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:523,Modifiability,adapt,adapted,523,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:2,Energy Efficiency,Adapt,Adapt,2,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:163,Energy Efficiency,Adapt,Adapt,163,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:215,Energy Efficiency,adapt,adapt,215,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:263,Energy Efficiency,adapt,adapt,263,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:278,Energy Efficiency,adapt,adapt,278,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:284,Energy Efficiency,Adapt,Adapt,284,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:313,Energy Efficiency,adapt,adapt,313,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:327,Energy Efficiency,Adapt,Adapt,327,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:375,Energy Efficiency,adapt,adaptions,375,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:549,Energy Efficiency,adapt,adapt,549,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:628,Energy Efficiency,adapt,adaptor,628,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:826,Energy Efficiency,Adapt,Adapt,826,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:899,Energy Efficiency,adapt,adapt,899,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:995,Energy Efficiency,adapt,adapt,995,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1181,Energy Efficiency,Adapt,Adapt,1181,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1239,Energy Efficiency,adapt,adapt,1239,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1265,Energy Efficiency,adapt,adapt,1265,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1510,Energy Efficiency,adapt,adapt,1510,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1544,Energy Efficiency,adapt,adapts,1544,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1596,Energy Efficiency,adapt,adaptions,1596,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:2,Modifiability,Adapt,Adapt,2,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:163,Modifiability,Adapt,Adapt,163,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:215,Modifiability,adapt,adapt,215,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:263,Modifiability,adapt,adapt,263,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:278,Modifiability,adapt,adapt,278,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:284,Modifiability,Adapt,Adapt,284,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:313,Modifiability,adapt,adapt,313,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:327,Modifiability,Adapt,Adapt,327,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:375,Modifiability,adapt,adaptions,375,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:549,Modifiability,adapt,adapt,549,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:628,Modifiability,adapt,adaptor,628,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:826,Modifiability,Adapt,Adapt,826,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:899,Modifiability,adapt,adapt,899,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:995,Modifiability,adapt,adapt,995,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1114,Modifiability,extend,extend,1114,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1181,Modifiability,Adapt,Adapt,1181,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1239,Modifiability,adapt,adapt,1239,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1265,Modifiability,adapt,adapt,1265,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1510,Modifiability,adapt,adapt,1510,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1544,Modifiability,adapt,adapts,1544,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:1596,Modifiability,adapt,adaptions,1596,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867965270:12,Testability,test,tests,12,Why are the tests being run twice? It's confusing to interpret the test results.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867965270
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867965270:67,Testability,test,test,67,Why are the tests being run twice? It's confusing to interpret the test results.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867965270
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867988334:14,Testability,test,tests,14,> Why are the tests being run twice? It's confusing to interpret the test results. I know! I’m confused. Perhaps yet some other buildkite setting? I’ll try to figure it out…..,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867988334
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867988334:69,Testability,test,test,69,> Why are the tests being run twice? It's confusing to interpret the test results. I know! I’m confused. Perhaps yet some other buildkite setting? I’ll try to figure it out…..,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867988334
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867997015:6,Testability,test,tests,6,These tests still fail: https://buildkite.com/clima/oceananigans/builds/13791#018c8e8a-a41b-43de-a387-49157d3ccc32/6-46,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867997015
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868223245:300,Testability,test,test,300,Is . https://github.com/CliMA/Oceananigans.jl/blob/c5b030908793d9b49faba6648980abb1932638fc/src/TurbulenceClosures/discrete_diffusion_function.jl#L102. correct?. If it should be `DiscreteBoundaryFunction` then we need to import it. Or should this be `DiscreteDiffusionFunction`? The latter makes the test pass.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868223245
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868239088:5,Deployability,patch,patch,5,Bump patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868239088
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868239088:11,Deployability,release,release,11,Bump patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868239088
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224:42,Performance,queue,queue,42,"> Possibly, we should start using a merge queue that would disallow PRs from being merged unless tests pass. Yeap. I added these in https://github.com/CliMA/Oceananigans.jl/settings/branches. <img width=""905"" alt=""Screenshot 2023-12-23 at 1 10 26 pm"" src=""https://github.com/CliMA/Oceananigans.jl/assets/7112768/3137d7ef-2f34-4f05-86fa-c759177ac164"">. How does this sound?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224:97,Testability,test,tests,97,"> Possibly, we should start using a merge queue that would disallow PRs from being merged unless tests pass. Yeap. I added these in https://github.com/CliMA/Oceananigans.jl/settings/branches. <img width=""905"" alt=""Screenshot 2023-12-23 at 1 10 26 pm"" src=""https://github.com/CliMA/Oceananigans.jl/assets/7112768/3137d7ef-2f34-4f05-86fa-c759177ac164"">. How does this sound?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988:27,Energy Efficiency,adapt,adapt,27,> @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. Sorry! I hadn't realised they could be merged without the tests passing so when I saw the PR approved just hit merge. Sorry for all the problems!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988:27,Modifiability,adapt,adapt,27,> @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. Sorry! I hadn't realised they could be merged without the tests passing so when I saw the PR approved just hit merge. Sorry for all the problems!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988:98,Testability,test,tests,98,> @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. Sorry! I hadn't realised they could be merged without the tests passing so when I saw the PR approved just hit merge. Sorry for all the problems!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988
https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988:204,Testability,test,tests,204,> @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. Sorry! I hadn't realised they could be merged without the tests passing so when I saw the PR approved just hit merge. Sorry for all the problems!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988
https://github.com/CliMA/Oceananigans.jl/pull/3414#issuecomment-1872473253:187,Availability,down,down,187,"https://github.com/CliMA/Oceananigans.jl/blob/6a78d74065bd74d80f6d98cb022e5db97d3a2e0b/src/BuoyancyModels/buoyancy.jl#L47-L53. So, I'm a bit confused. Where is ĝ supposed to point, up or down for non-tilted? @tomchor?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3414#issuecomment-1872473253
https://github.com/CliMA/Oceananigans.jl/issues/3415#issuecomment-1875733999:213,Testability,test,test,213,"> This seems correct for Periodic topologies but wouldn't it be the case for Bounded too. Do particles get bounced if you put them just to the right of the N'th face in a Bounded direction?. I've put up a similar test script in the PR:; https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332. Let me know if you think that is the expected behaviour, and what else should I test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415#issuecomment-1875733999
https://github.com/CliMA/Oceananigans.jl/issues/3415#issuecomment-1875733999:393,Testability,test,test,393,"> This seems correct for Periodic topologies but wouldn't it be the case for Bounded too. Do particles get bounced if you put them just to the right of the N'th face in a Bounded direction?. I've put up a similar test script in the PR:; https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332. Let me know if you think that is the expected behaviour, and what else should I test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415#issuecomment-1875733999
https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332:9,Testability,test,test,9,"Here's a test script:; ```julia; using Oceananigans; using Oceananigans.Units; using StructArrays; using Printf; using Random; using Statistics. Random.seed!(123). grid = RectilinearGrid(CPU(), Float64,; size = (2, 2, 2),; halo = (5, 5, 5),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Bounded, Bounded)). #%%; struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. x_particle = collect(0:0.25:1.5); y_particle = collect(0:0.25:1.5); z_particle = collect(fill(-0.5, length(x_particle))). particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). #%%; model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1seconds, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```; In the test script, the domain is initialized to be `Periodic, Bounded, Bounded`, so particles should be shifted if $x \geq 1$, bounced if $y > 1$, $z<-1$. Here's the output of the script:; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 5.450 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332
https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332:1657,Testability,test,test,1657,"a3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1seconds, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```; In the test script, the domain is initialized to be `Periodic, Bounded, Bounded`, so particles should be shifted if $x \geq 1$, bounced if $y > 1$, $z<-1$. Here's the output of the script:; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 5.450 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: ... simulation initialization complete (3.384 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (7.395 seconds).; i: 1, t: 100 ms, wall time: 7.414 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0, 0.25, 0.5], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0, 0.75, 0.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: Simulation is stopping after running for 10.934 seconds.; [ Info: Model iteration 2 equals or exceeds stop ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332
https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332:336,Usability,Simpl,SimpleParticle,336,"Here's a test script:; ```julia; using Oceananigans; using Oceananigans.Units; using StructArrays; using Printf; using Random; using Statistics. Random.seed!(123). grid = RectilinearGrid(CPU(), Float64,; size = (2, 2, 2),; halo = (5, 5, 5),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Bounded, Bounded)). #%%; struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. x_particle = collect(0:0.25:1.5); y_particle = collect(0:0.25:1.5); z_particle = collect(fill(-0.5, length(x_particle))). particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). #%%; model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1seconds, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```; In the test script, the domain is initialized to be `Periodic, Bounded, Bounded`, so particles should be shifted if $x \geq 1$, bounced if $y > 1$, $z<-1$. Here's the output of the script:; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 5.450 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332
https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332:530,Usability,Simpl,SimpleParticle,530,"Here's a test script:; ```julia; using Oceananigans; using Oceananigans.Units; using StructArrays; using Printf; using Random; using Statistics. Random.seed!(123). grid = RectilinearGrid(CPU(), Float64,; size = (2, 2, 2),; halo = (5, 5, 5),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Bounded, Bounded)). #%%; struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. x_particle = collect(0:0.25:1.5); y_particle = collect(0:0.25:1.5); z_particle = collect(fill(-0.5, length(x_particle))). particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). #%%; model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1seconds, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```; In the test script, the domain is initialized to be `Periodic, Bounded, Bounded`, so particles should be shifted if $x \geq 1$, bounced if $y > 1$, $z<-1$. Here's the output of the script:; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 5.450 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-1875732332
https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-2179422966:307,Usability,Simpl,SimpleParticle,307,"This resolves issue https://github.com/CliMA/Oceananigans.jl/issues/3415. See this script:. ```julia; using Oceananigans; using StructArrays; using Printf. grid = RectilinearGrid(CPU(), Float64,; size = (10, 10),; halo = (5, 5),; x = (0, 1),; y = (0, 1),; topology = (Bounded, Periodic, Flat)). #%%; struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. x_particle = collect(0:0.25:1.5); y_particle = collect(0:0.25:1.5); z_particle = collect(fill(-0.5, length(x_particle))). particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). #%%; model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which outputs . ```julia; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 4.726 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: ... simulation initialization comple",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-2179422966
https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-2179422966:501,Usability,Simpl,SimpleParticle,501,"This resolves issue https://github.com/CliMA/Oceananigans.jl/issues/3415. See this script:. ```julia; using Oceananigans; using StructArrays; using Printf. grid = RectilinearGrid(CPU(), Float64,; size = (10, 10),; halo = (5, 5),; x = (0, 1),; y = (0, 1),; topology = (Bounded, Periodic, Flat)). #%%; struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. x_particle = collect(0:0.25:1.5); y_particle = collect(0:0.25:1.5); z_particle = collect(fill(-0.5, length(x_particle))). particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). #%%; model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which outputs . ```julia; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 4.726 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: ... simulation initialization comple",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-2179422966
https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-2179816144:91,Usability,clear,clear,91,Can you change the first post so merging this issue closes #3415 (and makes the connection clear),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-2179816144
https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1880742060:11,Safety,safe,safer,11,Is it also safer to infer `FT` from `grid`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1880742060
https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1883486297:13,Safety,safe,safer,13,> Is it also safer to infer `FT` from `grid`?. There is no safety difference but it is preferred to use `eltype(grid)`. This also conforms to YASGuide.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1883486297
https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1883486297:59,Safety,safe,safety,59,> Is it also safer to infer `FT` from `grid`?. There is no safety difference but it is preferred to use `eltype(grid)`. This also conforms to YASGuide.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1883486297
https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292:1062,Availability,down,downwelling,1062,"Looks good to me. My only question is about the derivation of ``wˢ``, which results from a vertical integration of the analytical functions. Currently this integral is performed under the assumption that ``wˢ`` is zero at large depths, which I clarified in the code:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L213-L215. **Is this the correct assumption here?** It effectively means that ``wˢ`` and its gradients are a maximum at the surface under a depth-decaying Stokes drift, so any horizontal convergence/divergence of Stokes drift manifests a local change in sea surface height:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L248-L250. An alternative would be to set ``wˢ`` to zero at the surface, which would cause ``wˢ`` and its horizontal gradients to reach a maximum at large depths, as the occurrences of ``ûˢ(z)`` above would become ``( ûˢ(z) - ûˢ(0) )``. Essentially, horizontal convergence/divergence would manifest as downwelling/upwelling (rather than SSH changes in the current case). I feel like this approach makes sense for LES setups, but it could cause problems for simulations of the full water column where you don't want direct Stokes drift effects deep in the ocean interior. I'm happy to go forward with this example as is, but the above would be a useful question to answer in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292
https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292:100,Deployability,integrat,integration,100,"Looks good to me. My only question is about the derivation of ``wˢ``, which results from a vertical integration of the analytical functions. Currently this integral is performed under the assumption that ``wˢ`` is zero at large depths, which I clarified in the code:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L213-L215. **Is this the correct assumption here?** It effectively means that ``wˢ`` and its gradients are a maximum at the surface under a depth-decaying Stokes drift, so any horizontal convergence/divergence of Stokes drift manifests a local change in sea surface height:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L248-L250. An alternative would be to set ``wˢ`` to zero at the surface, which would cause ``wˢ`` and its horizontal gradients to reach a maximum at large depths, as the occurrences of ``ûˢ(z)`` above would become ``( ûˢ(z) - ûˢ(0) )``. Essentially, horizontal convergence/divergence would manifest as downwelling/upwelling (rather than SSH changes in the current case). I feel like this approach makes sense for LES setups, but it could cause problems for simulations of the full water column where you don't want direct Stokes drift effects deep in the ocean interior. I'm happy to go forward with this example as is, but the above would be a useful question to answer in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292
https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292:100,Integrability,integrat,integration,100,"Looks good to me. My only question is about the derivation of ``wˢ``, which results from a vertical integration of the analytical functions. Currently this integral is performed under the assumption that ``wˢ`` is zero at large depths, which I clarified in the code:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L213-L215. **Is this the correct assumption here?** It effectively means that ``wˢ`` and its gradients are a maximum at the surface under a depth-decaying Stokes drift, so any horizontal convergence/divergence of Stokes drift manifests a local change in sea surface height:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L248-L250. An alternative would be to set ``wˢ`` to zero at the surface, which would cause ``wˢ`` and its horizontal gradients to reach a maximum at large depths, as the occurrences of ``ûˢ(z)`` above would become ``( ûˢ(z) - ûˢ(0) )``. Essentially, horizontal convergence/divergence would manifest as downwelling/upwelling (rather than SSH changes in the current case). I feel like this approach makes sense for LES setups, but it could cause problems for simulations of the full water column where you don't want direct Stokes drift effects deep in the ocean interior. I'm happy to go forward with this example as is, but the above would be a useful question to answer in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292
https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292:168,Performance,perform,performed,168,"Looks good to me. My only question is about the derivation of ``wˢ``, which results from a vertical integration of the analytical functions. Currently this integral is performed under the assumption that ``wˢ`` is zero at large depths, which I clarified in the code:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L213-L215. **Is this the correct assumption here?** It effectively means that ``wˢ`` and its gradients are a maximum at the surface under a depth-decaying Stokes drift, so any horizontal convergence/divergence of Stokes drift manifests a local change in sea surface height:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L248-L250. An alternative would be to set ``wˢ`` to zero at the surface, which would cause ``wˢ`` and its horizontal gradients to reach a maximum at large depths, as the occurrences of ``ûˢ(z)`` above would become ``( ûˢ(z) - ûˢ(0) )``. Essentially, horizontal convergence/divergence would manifest as downwelling/upwelling (rather than SSH changes in the current case). I feel like this approach makes sense for LES setups, but it could cause problems for simulations of the full water column where you don't want direct Stokes drift effects deep in the ocean interior. I'm happy to go forward with this example as is, but the above would be a useful question to answer in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292
https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1894586818:371,Availability,down,down,371,"Yes, w^S must vanish with depth in this deep water case, because the motions directly associated with the primary surface wave also vanish with depth. It's an interesting point that there is a non-zero surface expression for w^S. There is also a mean/slow wave-averaged surface displacement associated with this surface expression (usually referred to as wave set-up/set-down). We don't capture the surface displacement in this rigid lid model, so I wonder if we get the total mean circulation right or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1894586818
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:46,Availability,error,error,46,"While using `main` indeed I can reproduce the error above... ```Julia; navidcy:Oceananigans.jl/ |main ✓|$ julia-1.10 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.10.0 (2023-12-25); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; └ @ ~/Oceananigans.jl/Manifest.toml:0; ┌ Warning: The project dependencies or compat requirements have changed since the manifest was last resolved.; │ It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.; └ @ Pkg.API ~/julia-1.10/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:1800; Precompiling Oceananigans; 1 dependency successfully precompiled in 21 seconds. 143 already precompiled.; [ Info: Oceananigans will use 48 threads. julia> grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Ce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:2244,Availability,ERROR,ERROR,2244,"1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Center, Face, Center} on RectilinearGrid on GPU; └── w: 16×16×17 Field{Center, Center, Face} on RectilinearGrid on GPU. julia> maximum(u); 0.0. julia> maximum(w); 0.0. julia> maximum(v); 0.0. julia> maximum(abs, u); 0.0. julia> maximum(abs, w); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/nbRJk/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#867#868""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#867#868""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:2256,Availability,error,error,2256,"1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Center, Face, Center} on RectilinearGrid on GPU; └── w: 16×16×17 Field{Center, Center, Face} on RectilinearGrid on GPU. julia> maximum(u); 0.0. julia> maximum(w); 0.0. julia> maximum(v); 0.0. julia> maximum(abs, u); 0.0. julia> maximum(abs, w); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/nbRJk/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#867#868""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#867#868""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:5321,Availability,mask,mask,5321,":Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[9]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types. julia> maximum(abs, v); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/nbRJk/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#867#868""{Bool, Int64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:5481,Availability,mask,mask,5481,"sion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[9]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types. julia> maximum(abs, v); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/nbRJk/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#867#868""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/exe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:5898,Availability,ERROR,ERROR,5898,"ducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[9]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types. julia> maximum(abs, v); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/nbRJk/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#867#868""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#867#868""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:5910,Availability,error,error,5910,"ducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[9]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types. julia> maximum(abs, v); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/nbRJk/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#867#868""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#867#868""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:8975,Availability,mask,mask,8975,"nigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #3403 is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:9135,Availability,mask,mask,9135,"nigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #3403 is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:742,Deployability,update,update,742,"While using `main` indeed I can reproduce the error above... ```Julia; navidcy:Oceananigans.jl/ |main ✓|$ julia-1.10 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.10.0 (2023-12-25); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; └ @ ~/Oceananigans.jl/Manifest.toml:0; ┌ Warning: The project dependencies or compat requirements have changed since the manifest was last resolved.; │ It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.; └ @ Pkg.API ~/julia-1.10/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:1800; Precompiling Oceananigans; 1 dependency successfully precompiled in 21 seconds. 143 already precompiled.; [ Info: Oceananigans will use 48 threads. julia> grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Ce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:5172,Energy Efficiency,reduce,reducedim,5172,"{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[9]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types. julia> maximum(abs, v); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:8826,Energy Efficiency,reduce,reducedim,8826,"{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #340",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:432,Integrability,depend,dependencies,432,"While using `main` indeed I can reproduce the error above... ```Julia; navidcy:Oceananigans.jl/ |main ✓|$ julia-1.10 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.10.0 (2023-12-25); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; └ @ ~/Oceananigans.jl/Manifest.toml:0; ┌ Warning: The project dependencies or compat requirements have changed since the manifest was last resolved.; │ It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.; └ @ Pkg.API ~/julia-1.10/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:1800; Precompiling Oceananigans; 1 dependency successfully precompiled in 21 seconds. 143 already precompiled.; [ Info: Oceananigans will use 48 threads. julia> grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Ce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:598,Integrability,depend,dependencies,598,"While using `main` indeed I can reproduce the error above... ```Julia; navidcy:Oceananigans.jl/ |main ✓|$ julia-1.10 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.10.0 (2023-12-25); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; └ @ ~/Oceananigans.jl/Manifest.toml:0; ┌ Warning: The project dependencies or compat requirements have changed since the manifest was last resolved.; │ It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.; └ @ Pkg.API ~/julia-1.10/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:1800; Precompiling Oceananigans; 1 dependency successfully precompiled in 21 seconds. 143 already precompiled.; [ Info: Oceananigans will use 48 threads. julia> grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Ce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:871,Integrability,depend,dependency,871,"While using `main` indeed I can reproduce the error above... ```Julia; navidcy:Oceananigans.jl/ |main ✓|$ julia-1.10 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.10.0 (2023-12-25); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; └ @ ~/Oceananigans.jl/Manifest.toml:0; ┌ Warning: The project dependencies or compat requirements have changed since the manifest was last resolved.; │ It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.; └ @ Pkg.API ~/julia-1.10/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:1800; Precompiling Oceananigans; 1 dependency successfully precompiled in 21 seconds. 143 already precompiled.; [ Info: Oceananigans will use 48 threads. julia> grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Ce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:9579,Integrability,depend,dependencies,9579,"nigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #3403 is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:9685,Integrability,depend,dependencies,9685,"nigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #3403 is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1894889482:17,Integrability,depend,dependence,17,"I think the size dependence has to do with how `mapreduce` works; it breaks the reduction into chunks and (10, 10, 10) might be just one chunk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1894889482
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103:80,Availability,error,error,80,"I also had this issue, as new into GPU running, I was super confused about this error. It will be helpful if this issue is not fixable, to at least point out in the documentation. . I encountered this error by running a simulation based on the tutorial ([Langmuir turbulence](https://clima.github.io/OceananigansDocumentation/stable/generated/langmuir_turbulence/#Langmuir-turbulence-example)) in GPUs. Note that the print function prints the `maximum(abs, u), maximum(abs, v), maximum(abs, w)`:; ```; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.Δt),; maximum(abs, u), maximum(abs, v), maximum(abs, w),; prettytime(simulation.run_wall_time)); ```; thus resulting in the error:; ```; LoadError: CUDA error: too many resources requested for launch; ```; For reference, the code works once the `maximum` functions are removed:; ```; msg = @sprintf(""i: %04d, t: %s, �~Tt: %s, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.�~Tt),; prettytime(simulation.run_wall_time)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103:201,Availability,error,error,201,"I also had this issue, as new into GPU running, I was super confused about this error. It will be helpful if this issue is not fixable, to at least point out in the documentation. . I encountered this error by running a simulation based on the tutorial ([Langmuir turbulence](https://clima.github.io/OceananigansDocumentation/stable/generated/langmuir_turbulence/#Langmuir-turbulence-example)) in GPUs. Note that the print function prints the `maximum(abs, u), maximum(abs, v), maximum(abs, w)`:; ```; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.Δt),; maximum(abs, u), maximum(abs, v), maximum(abs, w),; prettytime(simulation.run_wall_time)); ```; thus resulting in the error:; ```; LoadError: CUDA error: too many resources requested for launch; ```; For reference, the code works once the `maximum` functions are removed:; ```; msg = @sprintf(""i: %04d, t: %s, �~Tt: %s, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.�~Tt),; prettytime(simulation.run_wall_time)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103:794,Availability,error,error,794,"I also had this issue, as new into GPU running, I was super confused about this error. It will be helpful if this issue is not fixable, to at least point out in the documentation. . I encountered this error by running a simulation based on the tutorial ([Langmuir turbulence](https://clima.github.io/OceananigansDocumentation/stable/generated/langmuir_turbulence/#Langmuir-turbulence-example)) in GPUs. Note that the print function prints the `maximum(abs, u), maximum(abs, v), maximum(abs, w)`:; ```; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.Δt),; maximum(abs, u), maximum(abs, v), maximum(abs, w),; prettytime(simulation.run_wall_time)); ```; thus resulting in the error:; ```; LoadError: CUDA error: too many resources requested for launch; ```; For reference, the code works once the `maximum` functions are removed:; ```; msg = @sprintf(""i: %04d, t: %s, �~Tt: %s, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.�~Tt),; prettytime(simulation.run_wall_time)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103:823,Availability,error,error,823,"I also had this issue, as new into GPU running, I was super confused about this error. It will be helpful if this issue is not fixable, to at least point out in the documentation. . I encountered this error by running a simulation based on the tutorial ([Langmuir turbulence](https://clima.github.io/OceananigansDocumentation/stable/generated/langmuir_turbulence/#Langmuir-turbulence-example)) in GPUs. Note that the print function prints the `maximum(abs, u), maximum(abs, v), maximum(abs, w)`:; ```; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.Δt),; maximum(abs, u), maximum(abs, v), maximum(abs, w),; prettytime(simulation.run_wall_time)); ```; thus resulting in the error:; ```; LoadError: CUDA error: too many resources requested for launch; ```; For reference, the code works once the `maximum` functions are removed:; ```; msg = @sprintf(""i: %04d, t: %s, �~Tt: %s, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.�~Tt),; prettytime(simulation.run_wall_time)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103:807,Performance,Load,LoadError,807,"I also had this issue, as new into GPU running, I was super confused about this error. It will be helpful if this issue is not fixable, to at least point out in the documentation. . I encountered this error by running a simulation based on the tutorial ([Langmuir turbulence](https://clima.github.io/OceananigansDocumentation/stable/generated/langmuir_turbulence/#Langmuir-turbulence-example)) in GPUs. Note that the print function prints the `maximum(abs, u), maximum(abs, v), maximum(abs, w)`:; ```; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.Δt),; maximum(abs, u), maximum(abs, v), maximum(abs, w),; prettytime(simulation.run_wall_time)); ```; thus resulting in the error:; ```; LoadError: CUDA error: too many resources requested for launch; ```; For reference, the code works once the `maximum` functions are removed:; ```; msg = @sprintf(""i: %04d, t: %s, �~Tt: %s, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.�~Tt),; prettytime(simulation.run_wall_time)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1993831225:178,Testability,test,tested,178,"@simone-silvestri, effectively if I try `maximum` without `abs` the printing function works well. @glwagner is right, any function within the `maximum` creates the same issue (I tested with `sum`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1993831225
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1995001753:161,Testability,log,log,161,Well `sum` definitely won't work (it has to be a simple single-argument transformation) but you could try a function like. ```julia; square(x) = x * x; ```. or `log` if you want to be adventurous,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1995001753
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1995001753:49,Usability,simpl,simple,49,Well `sum` definitely won't work (it has to be a simple single-argument transformation) but you could try a function like. ```julia; square(x) = x * x; ```. or `log` if you want to be adventurous,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1995001753
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026:213,Availability,error,error,213,"Is this still an issue? @xkykai's MWE runs fine for me (I went up to 256x256x256), and I've been doing `maximum(abs, u)` on the GPU for a few versions. Out of curiousity, @josuemtzmo are you able to reproduce the error on the latest versions of Julia, CUDA.jl, and Oceananigans.jl?. ---. I'm using Oceananigans v0.91.7 with. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd4843 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Windows (x86_64-w64-mingw32); CPU: 24 × AMD Ryzen 9 5900X 12-Core Processor; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 24 virtual cores); ```. and. ```; julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.5, artifact installation; CUDA driver 12.5; NVIDIA driver 556.12.0. CUDA libraries:; - CUBLAS: 12.5.3; - CURAND: 10.3.6; - CUFFT: 11.2.3; - CUSOLVER: 11.6.3; - CUSPARSE: 12.5.1; - CUPTI: 2024.2.1 (API 23.0.0); - NVML: 12.0.0+556.12. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. 1 device:; 0: NVIDIA GeForce RTX 3080 (sm_86, 5.794 GiB / 10.000 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026:1211,Availability,avail,available,1211,"Is this still an issue? @xkykai's MWE runs fine for me (I went up to 256x256x256), and I've been doing `maximum(abs, u)` on the GPU for a few versions. Out of curiousity, @josuemtzmo are you able to reproduce the error on the latest versions of Julia, CUDA.jl, and Oceananigans.jl?. ---. I'm using Oceananigans v0.91.7 with. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd4843 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Windows (x86_64-w64-mingw32); CPU: 24 × AMD Ryzen 9 5900X 12-Core Processor; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 24 virtual cores); ```. and. ```; julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.5, artifact installation; CUDA driver 12.5; NVIDIA driver 556.12.0. CUDA libraries:; - CUBLAS: 12.5.3; - CURAND: 10.3.6; - CUFFT: 11.2.3; - CUSOLVER: 11.6.3; - CUSPARSE: 12.5.1; - CUPTI: 2024.2.1 (API 23.0.0); - NVML: 12.0.0+556.12. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. 1 device:; 0: NVIDIA GeForce RTX 3080 (sm_86, 5.794 GiB / 10.000 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026:461,Deployability,release,release,461,"Is this still an issue? @xkykai's MWE runs fine for me (I went up to 256x256x256), and I've been doing `maximum(abs, u)` on the GPU for a few versions. Out of curiousity, @josuemtzmo are you able to reproduce the error on the latest versions of Julia, CUDA.jl, and Oceananigans.jl?. ---. I'm using Oceananigans v0.91.7 with. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd4843 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Windows (x86_64-w64-mingw32); CPU: 24 × AMD Ryzen 9 5900X 12-Core Processor; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 24 virtual cores); ```. and. ```; julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.5, artifact installation; CUDA driver 12.5; NVIDIA driver 556.12.0. CUDA libraries:; - CUBLAS: 12.5.3; - CURAND: 10.3.6; - CUFFT: 11.2.3; - CUSOLVER: 11.6.3; - CUSPARSE: 12.5.1; - CUPTI: 2024.2.1 (API 23.0.0); - NVML: 12.0.0+556.12. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. 1 device:; 0: NVIDIA GeForce RTX 3080 (sm_86, 5.794 GiB / 10.000 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026:786,Deployability,install,installation,786,"Is this still an issue? @xkykai's MWE runs fine for me (I went up to 256x256x256), and I've been doing `maximum(abs, u)` on the GPU for a few versions. Out of curiousity, @josuemtzmo are you able to reproduce the error on the latest versions of Julia, CUDA.jl, and Oceananigans.jl?. ---. I'm using Oceananigans v0.91.7 with. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd4843 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Windows (x86_64-w64-mingw32); CPU: 24 × AMD Ryzen 9 5900X 12-Core Processor; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 24 virtual cores); ```. and. ```; julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.5, artifact installation; CUDA driver 12.5; NVIDIA driver 556.12.0. CUDA libraries:; - CUBLAS: 12.5.3; - CURAND: 10.3.6; - CUFFT: 11.2.3; - CUSOLVER: 11.6.3; - CUSPARSE: 12.5.1; - CUPTI: 2024.2.1 (API 23.0.0); - NVML: 12.0.0+556.12. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. 1 device:; 0: NVIDIA GeForce RTX 3080 (sm_86, 5.794 GiB / 10.000 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471:1077,Availability,avail,available,1077,"Hello, . I've tested it in `Oceananigans v0.91.8` with:. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 64 × Intel(R) Xeon(R) Gold 6130 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, skylake-avx512); Threads: 1 default, 0 interactive, 1 GC (on 64 virtual cores); Environment:; JULIA_CUDA_MEMORY_POOL = none. julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.1, artifact installation; CUDA driver 12.1; NVIDIA driver 530.30.2. CUDA libraries:; - CUBLAS: 12.1.3; - CURAND: 10.3.2; - CUFFT: 11.0.2; - CUSOLVER: 11.4.5; - CUSPARSE: 12.1.0; - CUPTI: 2023.1.1 (API 18.0.0); - NVML: 12.0.0+530.30.2. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. Environment:; - JULIA_CUDA_MEMORY_POOL: none. Preferences:; - CUDA_Runtime_jll.version: 12.1. 1 device:; 0: Tesla V100-PCIE-32GB (sm_70, 30.884 GiB / 32.000 GiB available); ```; and the issue seems solved. ; I agree with @ali-ramadhan, it seems that this issue was fixed at some point, although I haven't managed to pinpoint the version, I think I had the issue when I was using `CUDA v5.1.2`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471:194,Deployability,release,release,194,"Hello, . I've tested it in `Oceananigans v0.91.8` with:. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 64 × Intel(R) Xeon(R) Gold 6130 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, skylake-avx512); Threads: 1 default, 0 interactive, 1 GC (on 64 virtual cores); Environment:; JULIA_CUDA_MEMORY_POOL = none. julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.1, artifact installation; CUDA driver 12.1; NVIDIA driver 530.30.2. CUDA libraries:; - CUBLAS: 12.1.3; - CURAND: 10.3.2; - CUFFT: 11.0.2; - CUSOLVER: 11.4.5; - CUSPARSE: 12.1.0; - CUPTI: 2023.1.1 (API 18.0.0); - NVML: 12.0.0+530.30.2. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. Environment:; - JULIA_CUDA_MEMORY_POOL: none. Preferences:; - CUDA_Runtime_jll.version: 12.1. 1 device:; 0: Tesla V100-PCIE-32GB (sm_70, 30.884 GiB / 32.000 GiB available); ```; and the issue seems solved. ; I agree with @ali-ramadhan, it seems that this issue was fixed at some point, although I haven't managed to pinpoint the version, I think I had the issue when I was using `CUDA v5.1.2`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471:558,Deployability,install,installation,558,"Hello, . I've tested it in `Oceananigans v0.91.8` with:. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 64 × Intel(R) Xeon(R) Gold 6130 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, skylake-avx512); Threads: 1 default, 0 interactive, 1 GC (on 64 virtual cores); Environment:; JULIA_CUDA_MEMORY_POOL = none. julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.1, artifact installation; CUDA driver 12.1; NVIDIA driver 530.30.2. CUDA libraries:; - CUBLAS: 12.1.3; - CURAND: 10.3.2; - CUFFT: 11.0.2; - CUSOLVER: 11.4.5; - CUSPARSE: 12.1.0; - CUPTI: 2023.1.1 (API 18.0.0); - NVML: 12.0.0+530.30.2. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. Environment:; - JULIA_CUDA_MEMORY_POOL: none. Preferences:; - CUDA_Runtime_jll.version: 12.1. 1 device:; 0: Tesla V100-PCIE-32GB (sm_70, 30.884 GiB / 32.000 GiB available); ```; and the issue seems solved. ; I agree with @ali-ramadhan, it seems that this issue was fixed at some point, although I haven't managed to pinpoint the version, I think I had the issue when I was using `CUDA v5.1.2`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471
https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471:14,Testability,test,tested,14,"Hello, . I've tested it in `Oceananigans v0.91.8` with:. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 64 × Intel(R) Xeon(R) Gold 6130 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, skylake-avx512); Threads: 1 default, 0 interactive, 1 GC (on 64 virtual cores); Environment:; JULIA_CUDA_MEMORY_POOL = none. julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.1, artifact installation; CUDA driver 12.1; NVIDIA driver 530.30.2. CUDA libraries:; - CUBLAS: 12.1.3; - CURAND: 10.3.2; - CUFFT: 11.0.2; - CUSOLVER: 11.4.5; - CUSPARSE: 12.1.0; - CUPTI: 2023.1.1 (API 18.0.0); - NVML: 12.0.0+530.30.2. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. Environment:; - JULIA_CUDA_MEMORY_POOL: none. Preferences:; - CUDA_Runtime_jll.version: 12.1. 1 device:; 0: Tesla V100-PCIE-32GB (sm_70, 30.884 GiB / 32.000 GiB available); ```; and the issue seems solved. ; I agree with @ali-ramadhan, it seems that this issue was fixed at some point, although I haven't managed to pinpoint the version, I think I had the issue when I was using `CUDA v5.1.2`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124:224,Modifiability,variab,variables,224,"@glwagner and @simone-silvestri . Continuing the discussion.; https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280. It looks like MPI needs to be initialized before accessing its communication variables. Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`. https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22. Should we initialize MPI when importing DistributedComputations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124:196,Security,access,accessing,196,"@glwagner and @simone-silvestri . Continuing the discussion.; https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280. It looks like MPI needs to be initialized before accessing its communication variables. Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`. https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22. Should we initialize MPI when importing DistributedComputations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124:299,Security,access,access,299,"@glwagner and @simone-silvestri . Continuing the discussion.; https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280. It looks like MPI needs to be initialized before accessing its communication variables. Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`. https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22. Should we initialize MPI when importing DistributedComputations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124:454,Security,validat,validation,454,"@glwagner and @simone-silvestri . Continuing the discussion.; https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280. It looks like MPI needs to be initialized before accessing its communication variables. Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`. https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22. Should we initialize MPI when importing DistributedComputations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696:84,Modifiability,variab,variables,84,"in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit. The other option to not use MPI variables is to hardcode the number of processors",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696:148,Modifiability,variab,variables,148,"in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit. The other option to not use MPI variables is to hardcode the number of processors",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:421,Availability,error,error,421,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:449,Availability,Error,Error,449,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:479,Availability,ERROR,ERROR,479,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:486,Availability,ERROR,ERROR,486,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:504,Availability,ERROR,ERROR,504,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:533,Availability,ERROR,ERROR,533,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:227,Performance,optimiz,optimizer,227,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:251,Performance,perform,perform,251,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:493,Performance,Load,LoadError,493,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:511,Performance,Load,LoadError,511,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:522,Performance,Load,LoadError,522,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:540,Performance,Load,LoadError,540,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511:263,Modifiability,variab,variables,263,"> @glwagner and @simone-silvestri; > ; > Continuing the discussion. [#2788 (reply in thread)](https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280); > ; > It looks like MPI needs to be initialized before accessing its communication variables.; > ; > Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22; > ; > Should we initialize MPI when importing DistributedComputations?. Either 1) explicitly invoke `MPI.Init()` or 2) move those lines to after the grid constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511:235,Security,access,accessing,235,"> @glwagner and @simone-silvestri; > ; > Continuing the discussion. [#2788 (reply in thread)](https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280); > ; > It looks like MPI needs to be initialized before accessing its communication variables.; > ; > Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22; > ; > Should we initialize MPI when importing DistributedComputations?. Either 1) explicitly invoke `MPI.Init()` or 2) move those lines to after the grid constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511:345,Security,access,access,345,"> @glwagner and @simone-silvestri; > ; > Continuing the discussion. [#2788 (reply in thread)](https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280); > ; > It looks like MPI needs to be initialized before accessing its communication variables.; > ; > Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22; > ; > Should we initialize MPI when importing DistributedComputations?. Either 1) explicitly invoke `MPI.Init()` or 2) move those lines to after the grid constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511:507,Security,validat,validation,507,"> @glwagner and @simone-silvestri; > ; > Continuing the discussion. [#2788 (reply in thread)](https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280); > ; > It looks like MPI needs to be initialized before accessing its communication variables.; > ; > Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22; > ; > Should we initialize MPI when importing DistributedComputations?. Either 1) explicitly invoke `MPI.Init()` or 2) move those lines to after the grid constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642:86,Modifiability,variab,variables,86,"> in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > ; > The other option to not use MPI variables is to hardcode the number of processors. This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line. I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642:157,Modifiability,variab,variables,157,"> in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > ; > The other option to not use MPI variables is to hardcode the number of processors. This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line. I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894652800:11,Usability,clear,clear,11,"Just to be clear: our goal is to develop an API for distributed simulations that require a ""minimum"" of changes to the same script applied to a non-distributed simulation. The point of this goal is to make it easy to scale simulations from single-process to multi-process.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894652800
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033:140,Availability,error,errors,140,"I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. ; This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`. If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else. If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033:109,Integrability,rout,routines,109,"I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. ; This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`. If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else. If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033:259,Integrability,rout,routines,259,"I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. ; This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`. If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else. If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033:348,Integrability,rout,routines,348,"I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. ; This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`. If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else. If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065:88,Modifiability,variab,variables,88,"> > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > The other option to not use MPI variables is to hardcode the number of processors; > ; > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > ; > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do. Just to clarify, this is already possible, just by doing; ```julia; arch = Distributed(); rank = arch.local_rank; ```; The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065:157,Modifiability,variab,variables,157,"> > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > The other option to not use MPI variables is to hardcode the number of processors; > ; > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > ; > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do. Just to clarify, this is already possible, just by doing; ```julia; arch = Distributed(); rank = arch.local_rank; ```; The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:140,Availability,error,errors,140,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:111,Integrability,rout,routines,111,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:259,Integrability,rout,routines,259,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:354,Integrability,rout,routines,354,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:1187,Usability,clear,clear,1187,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561:435,Availability,error,error,435,"> I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:; > ; > `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`; > ; > Then it returns the following error:; > ; > Error output:; > Any idea what it could be, @simone-silvestri ?. That's related with #3374 and the warning comes from Julia v1.10 (wasn't there with Julia v1.9).; The PR #3403 will deal with these warnings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561:449,Availability,Error,Error,449,"> I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:; > ; > `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`; > ; > Then it returns the following error:; > ; > Error output:; > Any idea what it could be, @simone-silvestri ?. That's related with #3374 and the warning comes from Julia v1.10 (wasn't there with Julia v1.9).; The PR #3403 will deal with these warnings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561:235,Performance,optimiz,optimizer,235,"> I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:; > ; > `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`; > ; > Then it returns the following error:; > ; > Error output:; > Any idea what it could be, @simone-silvestri ?. That's related with #3374 and the warning comes from Julia v1.10 (wasn't there with Julia v1.9).; The PR #3403 will deal with these warnings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561:259,Performance,perform,perform,259,"> I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:; > ; > `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`; > ; > Then it returns the following error:; > ; > Error output:; > Any idea what it could be, @simone-silvestri ?. That's related with #3374 and the warning comes from Julia v1.10 (wasn't there with Julia v1.9).; The PR #3403 will deal with these warnings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613:90,Modifiability,variab,variables,90,"> > > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > > The other option to not use MPI variables is to hardcode the number of processors; > > ; > > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > > ; > > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.; > ; > Just to clarify, this is already possible, just by doing; > ```julia; > arch = Distributed(); > rank = arch.local_rank; > ```; > The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.; > . @iuryt this works already if you don't want to hardcore/import the MPI module. I would leave the validation case like this though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613:161,Modifiability,variab,variables,161,"> > > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > > The other option to not use MPI variables is to hardcode the number of processors; > > ; > > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > > ; > > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.; > ; > Just to clarify, this is already possible, just by doing; > ```julia; > arch = Distributed(); > rank = arch.local_rank; > ```; > The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.; > . @iuryt this works already if you don't want to hardcore/import the MPI module. I would leave the validation case like this though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613:1005,Security,validat,validation,1005,"> > > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > > The other option to not use MPI variables is to hardcode the number of processors; > > ; > > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > > ; > > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.; > ; > Just to clarify, this is already possible, just by doing; > ```julia; > arch = Distributed(); > rank = arch.local_rank; > ```; > The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.; > . @iuryt this works already if you don't want to hardcore/import the MPI module. I would leave the validation case like this though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895864384:71,Modifiability,refactor,refactor,71,Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895864384
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029:73,Modifiability,refactor,refactor,73,"> Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers. Distributed IO is not necessary to solve this problem. We can introduce a convention for filenames whereby the rank number is automatically inserted into the filename for distributed simulations. Similarly the convention can be reversed for `FieldTimeSeries` to make the process seamless for users. There are probably plenty of other possible solutions. The first step is recognizing that a problem or deficiency exists, and having the desire to fix it. Then we can do the fun part, which is to design solutions to an important problem. Note that distributed IO is unlikely to ever be supported for JLD2. So to provide a seamless experience with JLD2, we really do require a filename convention to solve the problem. (For NetCDF, we could envision providing a choice between file splitting or distributed IO.). Filename conventions also seem preferred to me for many cases in a world of GPUs where each rank likely needs to hold a substantial portion of the computation for performance. Splitting files by rank will limit the filesize, which makes it easier to transfer data when the simulations are very large --- which will probably often be the case when doing distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029:1129,Performance,perform,performance,1129,"> Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers. Distributed IO is not necessary to solve this problem. We can introduce a convention for filenames whereby the rank number is automatically inserted into the filename for distributed simulations. Similarly the convention can be reversed for `FieldTimeSeries` to make the process seamless for users. There are probably plenty of other possible solutions. The first step is recognizing that a problem or deficiency exists, and having the desire to fix it. Then we can do the fun part, which is to design solutions to an important problem. Note that distributed IO is unlikely to ever be supported for JLD2. So to provide a seamless experience with JLD2, we really do require a filename convention to solve the problem. (For NetCDF, we could envision providing a choice between file splitting or distributed IO.). Filename conventions also seem preferred to me for many cases in a world of GPUs where each rank likely needs to hold a substantial portion of the computation for performance. Splitting files by rank will limit the filesize, which makes it easier to transfer data when the simulations are very large --- which will probably often be the case when doing distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896032607:183,Usability,simpl,simple,183,"Sure, that is just how we are doing it now (the difference would be just inserting the rank behind the scenes). @iuryt if you want to have a go at it in this PR, that should be quite simple to implement (the rank is held in the architecture in `arch.local_rank`) and make sure that the the correct partitioning is taken into account (x partitioning vs y partitioning vs x-y). This API ""problem"" does not exhaust the IO issue though. The problem I was referring to is having split files. I still believe that distributed IO is necessary to have a fully functioning distributed code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896032607
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896412530:794,Energy Efficiency,efficient,efficient,794,"> Sure, that is just how we are doing it now (the difference would be just inserting the rank behind the scenes). @iuryt if you want to have a go at it in this PR, that should be quite simple to implement (the rank is held in the architecture in `arch.local_rank`) and make sure that the the correct partitioning is taken into account (x partitioning vs y partitioning vs x-y); > ; > This API ""problem"" does not exhaust the IO issue though. The problem I was referring to is having split files. I still believe that distributed IO is necessary to have a fully functioning distributed code. What's the problem with split files?. Combining data into JLD2 files is not always possible is it? It would require the entirety of the output field to fit into the memory of one node. It also may not be efficient. Correct me if you think otherwise, but it seems we will always want to support split output, even if we also support combined output for distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896412530
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896412530:185,Usability,simpl,simple,185,"> Sure, that is just how we are doing it now (the difference would be just inserting the rank behind the scenes). @iuryt if you want to have a go at it in this PR, that should be quite simple to implement (the rank is held in the architecture in `arch.local_rank`) and make sure that the the correct partitioning is taken into account (x partitioning vs y partitioning vs x-y); > ; > This API ""problem"" does not exhaust the IO issue though. The problem I was referring to is having split files. I still believe that distributed IO is necessary to have a fully functioning distributed code. What's the problem with split files?. Combining data into JLD2 files is not always possible is it? It would require the entirety of the output field to fit into the memory of one node. It also may not be efficient. Correct me if you think otherwise, but it seems we will always want to support split output, even if we also support combined output for distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896412530
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896434796:169,Security,access,access,169,Sorry @glwagner ; Maybe I didn't express very well.; I don't see any problem in split files and understand the importance in having that.; What I meant is that we could access the rank id from Distributed output to use it on the output filename so that we don't need to explicitly import MPI.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896434796
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329:501,Integrability,depend,depend,501,"> Sorry @glwagner Maybe I didn't express very well. I don't see any problem in split files and understand the importance in having that. What I meant is that we could access the rank id from Distributed output to use it on the output filename so that we don't need to explicitly import MPI. I was responding to @simone-silvestri !. In terms of user scripts, I certainly do think it's better to access the `rank_id` from the architecture. I think it's easier to read too, and it allows user scripts to depend on one fewer package. However, I think that the output writers should automatically change the filename when the simulation is distributed. This should be pretty easy and just involves adding the suffix `_rank$(rank_id)` to the filename for distributed architectures. We should also have an API for callbacks that are intended to only run on one rank (for example for printing stuff); eg a property `on_rank=0` which is used when `arch isa Distributed`. There's probably other useful things. `FieldTimeSeries` will have to be modified so that it can combine distributed files, for example. Probably, distributed output should also save some kind of ""meta"" file that contains information about the processor layout, to be used by `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329
https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329:167,Security,access,access,167,"> Sorry @glwagner Maybe I didn't express very well. I don't see any problem in split files and understand the importance in having that. What I meant is that we could access the rank id from Distributed output to use it on the output filename so that we don't need to explicitly import MPI. I was responding to @simone-silvestri !. In terms of user scripts, I certainly do think it's better to access the `rank_id` from the architecture. I think it's easier to read too, and it allows user scripts to depend on one fewer package. However, I think that the output writers should automatically change the filename when the simulation is distributed. This should be pretty easy and just involves adding the suffix `_rank$(rank_id)` to the filename for distributed architectures. We should also have an API for callbacks that are intended to only run on one rank (for example for printing stuff); eg a property `on_rank=0` which is used when `arch isa Distributed`. There's probably other useful things. `FieldTimeSeries` will have to be modified so that it can combine distributed files, for example. Probably, distributed output should also save some kind of ""meta"" file that contains information about the processor layout, to be used by `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329
