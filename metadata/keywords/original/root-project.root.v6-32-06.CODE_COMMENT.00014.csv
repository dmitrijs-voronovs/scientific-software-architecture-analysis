id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:11,Modifiability,variab,variables,11,// __block variables might require us to capture a copy-initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:49,Modifiability,variab,variable,49,"// It's currently invalid to ever have a __block variable with an; // array type; should we diagnose that here?; // Regardless, we don't want to ignore array nesting when; // constructing this copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:26,Availability,error,errors,26,/// Determine whether any errors occurred within this function/method/; /// block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:95,Availability,recover,recover,95,"/// Figure out if an expression could be turned into a call.; ///; /// Use this when trying to recover from an error where the programmer may have; /// written just the name of a function instead of actually calling it.; ///; /// \param E - The expression to examine.; /// \param ZeroArgCallReturnTy - If the expression can be turned into a call; /// with no arguments, this parameter is set to the type returned by such a; /// call; otherwise, it is set to an empty QualType.; /// \param OverloadSet - If the expression is an overloaded function; /// name, this parameter is populated with the decls of the various overloads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:111,Availability,error,error,111,"/// Figure out if an expression could be turned into a call.; ///; /// Use this when trying to recover from an error where the programmer may have; /// written just the name of a function instead of actually calling it.; ///; /// \param E - The expression to examine.; /// \param ZeroArgCallReturnTy - If the expression can be turned into a call; /// with no arguments, this parameter is set to the type returned by such a; /// call; otherwise, it is set to an empty QualType.; /// \param OverloadSet - If the expression is an overloaded function; /// name, this parameter is populated with the decls of the various overloads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:95,Safety,recover,recover,95,"/// Figure out if an expression could be turned into a call.; ///; /// Use this when trying to recover from an error where the programmer may have; /// written just the name of a function instead of actually calling it.; ///; /// \param E - The expression to examine.; /// \param ZeroArgCallReturnTy - If the expression can be turned into a call; /// with no arguments, this parameter is set to the type returned by such a; /// call; otherwise, it is set to an empty QualType.; /// \param OverloadSet - If the expression is an overloaded function; /// name, this parameter is populated with the decls of the various overloads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:407,Integrability,rout,routines,407,"//===---- SemaAccess.cpp - C++ Access Control -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ access control semantics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:31,Security,Access,Access,31,"//===---- SemaAccess.cpp - C++ Access Control -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ access control semantics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:424,Security,access,access,424,"//===---- SemaAccess.cpp - C++ Access Control -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ access control semantics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:90,Availability,error,error,90,/// SetMemberAccessSpecifier - Set the access specifier of a member.; /// Returns true on error (when the previous member decl access specifier; /// is different from the new member decl access specifier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:39,Security,access,access,39,/// SetMemberAccessSpecifier - Set the access specifier of a member.; /// Returns true on error (when the previous member decl access specifier; /// is different from the new member decl access specifier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:127,Security,access,access,127,/// SetMemberAccessSpecifier - Set the access specifier of a member.; /// Returns true on error (when the previous member decl access specifier; /// is different from the new member decl access specifier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:187,Security,access,access,187,/// SetMemberAccessSpecifier - Set the access specifier of a member.; /// Returns true on error (when the previous member decl access specifier; /// is different from the new member decl access specifier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:19,Security,access,access,19,// Use the lexical access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:14,Security,access,access,14,// C++ [class.access.spec]p3: When a member is redeclared its access; // specifier must be same as its initial declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:62,Security,access,access,62,// C++ [class.access.spec]p3: When a member is redeclared its access; // specifier must be same as its initial declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:104,Security,access,access,104,"// An implicit deduction guide is semantically in the context enclosing the; // class template, but for access purposes behaves like the constructor; // from which it was produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:25,Usability,guid,guide,25,"// An implicit deduction guide is semantically in the context enclosing the; // class template, but for access purposes behaves like the constructor; // from which it was produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:16,Security,access,access,16,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:88,Security,access,access,88,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:144,Security,access,access,144,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:188,Security,access,access,188,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:236,Security,access,access,236,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:287,Security,access,access,287,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:349,Security,access,access,349,"// C++11 [class.access.nest]p1:; // A nested class is a member and as such has the same access; // rights as any other member.; // C++11 [class.access]p2:; // A member of a class can also access all the names to which; // the class has access. A local class of a member function; // may access the same names that the member function itself; // may access.; // This almost implies that the privileges of nesting are transitive.; // Technically it says nothing about the local classes of non-member; // functions (which can gain privileges through friendship), but we; // take that as an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:65,Usability,simpl,simplicity,65,"// We want to add canonical declarations to the EC lists for; // simplicity of checking, but we need to walk up through the; // actual current DC chain. Otherwise, something like a local; // extern or friend which happens to be the canonical; // declaration will really mess us up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:78,Security,access,access-control,78,"/// Retrieves the innermost ""useful"" context. Can be null if we're; /// doing access-control without privileges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:15,Security,Access,AccessedEntity,15,"/// Like sema::AccessedEntity, but kindly lets us scribble all over; /// it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:134,Integrability,depend,dependence,134,"/// Checks whether one class is derived from another, inclusively.; /// Properly indicates when it couldn't be determined due to; /// dependence.; ///; /// This should probably be donated to AST or at least Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:24,Integrability,depend,dependent,24,"// If the context isn't dependent, it can't be a dependent match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:49,Integrability,depend,dependent,49,"// If the context isn't dependent, it can't be a dependent match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:52,Integrability,depend,dependent,52,"// If the template names don't match, it can't be a dependent; // match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:87,Integrability,depend,dependent,87,"// If the class's context can't instantiate to the friend's; // context, it can't be a dependent match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:21,Integrability,depend,dependent,21,"// Otherwise, it's a dependent match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:13,Security,access,accesses,13,// Whitelist accesses if there's an invalid or unsupported friend; // declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Integrability,depend,dependent,28,// FIXME: declarations with dependent or templated scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:62,Security,access,access,62,/// A helper class for checking for a friend which will grant access; /// to a protected instance member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:13,Availability,down,down,13,/// The path down to the current base class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:4,Performance,Perform,Perform,4,/// Perform a search starting at the given class.; ///; /// PrivateDepth is the index of the last (least derived) class; /// along the current path such that a notional public member of; /// the final class in the path would have access in that class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:230,Security,access,access,230,/// Perform a search starting at the given class.; ///; /// PrivateDepth is the index of the last (least derived) class; /// along the current path such that a notional public member of; /// the final class in the path would have access in that class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:22,Modifiability,inherit,inheritance,22,"// If this is private inheritance, then a public member of the; // base will not have any access in classes derived from Cur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:90,Security,access,access,90,"// If this is private inheritance, then a public member of the; // base will not have any access in classes derived from Cur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:267,Security,access,access,267,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:523,Security,access,access,523,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:592,Security,access,access,592,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:727,Security,access,accessible,727,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:928,Security,access,access,928,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1032,Security,access,access,1032,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1155,Security,access,accessible,1155,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1270,Security,access,accessible,1270,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1336,Security,access,accessible,1336,"/// Search for a class P that EC is a friend of, under the constraint; /// InstanceContext <= P; /// if InstanceContext exists, or else; /// NamingClass <= P; /// and with the additional restriction that a protected member of; /// NamingClass would have some natural access in P, which implicitly; /// imposes the constraint that P <= NamingClass.; ///; /// This isn't quite the condition laid out in the standard.; /// Instead of saying that a notional protected member of NamingClass; /// would have to have some natural access in P, it says the actual; /// target has to have some natural access in P, which opens up the; /// possibility that the target (which is not necessarily a member; /// of NamingClass) might be more accessible along some path not; /// passing through it. That's really a bad idea, though, because it; /// introduces two problems:; /// - Most importantly, it breaks encapsulation because you can; /// access a forbidden base class's members by directly subclassing; /// it elsewhere.; /// - It also makes access substantially harder to compute because it; /// breaks the hill-climbing algorithm: knowing that the target is; /// accessible in some base class would no longer let you change; /// the question solely to whether the base class is accessible,; /// because the original target might have been more accessible; /// because of crazy subclassing.; /// So we don't implement that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:46,Security,access,access,46,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:104,Security,access,access,104,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:256,Security,access,access,256,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:379,Security,access,access,379,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:502,Security,access,accesses,502,"// C++ [class.protected]p1:; // An additional access check beyond those described earlier in; // [class.access] is applied when a non-static data member or; // non-static member function is a protected member of its naming; // class. As described earlier, access to a protected member is; // granted because the reference occurs in a friend or member of; // some class C. If the access is to form a pointer to member,; // the nested-name-specifier shall name C or a class derived from; // C. All other accesses involve a (possibly implicit) object; // expression. In this case, the class of the object expression; // shall be C or a class derived from C.; //; // We interpret this as a restriction on [M3].; // In this part of the code, 'C' is just our context class ECRecord.; // These rules are different if we don't have an instance context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:172,Security,access,access,172,"// Despite the standard's confident wording, there is a case; // where you can have an instance member that's neither in a; // pointer-to-member expression nor in a member access: when; // it names a field in an unevaluated context that can't be an; // implicit member. Pending clarification, we just apply the; // same naming-class restriction here.; // FIXME: we're probably not correctly adding the; // protected-member restriction when we retroactively convert; // an expression to being evaluated.; // We know that ECRecord derives from NamingClass. The; // restriction says to check whether NamingClass derives from; // ECRecord, but that's not really necessary: two distinct; // classes can't be recursively derived from each other. So; // along this path, we just need to check whether the classes; // are equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:73,Security,access,access,73,"// [M3] and [B3] say that, if the target is protected in N, we grant; // access if the access occurs in a friend or member of some class P; // that's a subclass of N and where the target has some natural; // access in P. The 'member' aspect is easy to handle because P; // would necessarily be one of the effective-context records, and we; // address that above. The 'friend' aspect is completely ridiculous; // to implement because there are no restrictions at all on P; // *unless* the [class.protected] restriction applies. If it does,; // however, we should ignore whether the naming class is a friend,; // and instead rely on whether any potential P is a friend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:87,Security,access,access,87,"// [M3] and [B3] say that, if the target is protected in N, we grant; // access if the access occurs in a friend or member of some class P; // that's a subclass of N and where the target has some natural; // access in P. The 'member' aspect is easy to handle because P; // would necessarily be one of the effective-context records, and we; // address that above. The 'friend' aspect is completely ridiculous; // to implement because there are no restrictions at all on P; // *unless* the [class.protected] restriction applies. If it does,; // however, we should ignore whether the naming class is a friend,; // and instead rely on whether any potential P is a friend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:208,Security,access,access,208,"// [M3] and [B3] say that, if the target is protected in N, we grant; // access if the access occurs in a friend or member of some class P; // that's a subclass of N and where the target has some natural; // access in P. The 'member' aspect is easy to handle because P; // would necessarily be one of the effective-context records, and we; // address that above. The 'friend' aspect is completely ridiculous; // to implement because there are no restrictions at all on P; // *unless* the [class.protected] restriction applies. If it does,; // however, we should ignore whether the naming class is a friend,; // and instead rely on whether any potential P is a friend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2680,Integrability,depend,dependent,2680,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1328,Modifiability,inherit,inheritance,1328,"end of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1527,Modifiability,inherit,inheritance,1527,"end of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1711,Modifiability,inherit,inheritance,1711,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:139,Security,access,access,139,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:174,Security,access,accessible,174,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:636,Security,access,accessible,636,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:667,Security,access,accessible,667,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:729,Security,access,access,729,"/// Finds the best path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:773,Security,access,accessible,773,"path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, f",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1238,Security,access,accessible,1238,"path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, f",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1286,Security,access,accessible,1286,"path from the naming class to the declaring class,; /// taking friend declarations into account.; ///; /// C++0x [class.access.base]p5:; /// A member m is accessible at the point R when named in class N if; /// [M1] m as a member of N is public, or; /// [M2] m as a member of N is private, and R occurs in a member or; /// friend of class N, or; /// [M3] m as a member of N is protected, and R occurs in a member or; /// friend of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, f",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1544,Security,access,access,1544,"end of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1578,Security,access,access,1578,"end of class N, or in a member or friend of a class P; /// derived from N, where m as a member of P is public, private,; /// or protected, or; /// [M4] there exists a base class B of N that is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1639,Security,access,accessible,1639,"t is accessible at R, and; /// m is accessible at R when named in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1881,Security,access,access,1881,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1908,Security,access,accessible,1908,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1942,Security,Access,Access,1942,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:1960,Security,access,access,1960,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2109,Security,Access,Accessible,2109,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2147,Security,Access,Accessible,2147,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2204,Security,Access,Accessible,2204,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2273,Security,Access,Accessible,2273,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2348,Security,Access,AccessToBase,2348,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2369,Security,Access,Access,2369,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2413,Security,Access,Accessible,2413,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2429,Security,Access,AccessToBase,2429,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2460,Security,Access,AccessToBase,2460,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2491,Security,access,accessible,2491,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:2572,Security,access,access,2572,"amed in class B.; ///; /// C++0x [class.access.base]p4:; /// A base class B of N is accessible at R, if; /// [B1] an invented public member of B would be a public member of N, or; /// [B2] R occurs in a member or friend of class N, and an invented public; /// member of B would be a private or protected member of N, or; /// [B3] R occurs in a member or friend of a class P derived from N, and an; /// invented public member of B would be a private or protected member; /// of P, or; /// [B4] there exists a class S such that B is a base class of S accessible; /// at R and S is a base class of N accessible at R.; ///; /// Along a single inheritance path we can restate both of these; /// iteratively:; ///; /// First, we note that M1-4 are equivalent to B1-4 if the member is; /// treated as a notional base of its declaring class with inheritance; /// access equivalent to the member's access. Therefore we need only; /// ask whether a class B is accessible from a class N in context R.; ///; /// Let B_1 .. B_n be the inheritance path in question (i.e. where; /// B_1 = N, B_n = B, and for all i, B_{i+1} is a direct base class of; /// B_i). For i in 1..n, we will calculate ACAB(i), the access to the; /// closest accessible base in the path:; /// Access(a, b) = (* access on the base specifier from a to b *); /// Merge(a, forbidden) = forbidden; /// Merge(a, private) = forbidden; /// Merge(a, b) = min(a,b); /// Accessible(c, forbidden) = false; /// Accessible(c, private) = (R is c) || IsFriend(c, R); /// Accessible(c, protected) = (R derived from c) || IsFriend(c, R); /// Accessible(c, public) = true; /// ACAB(n) = public; /// ACAB(i) =; /// let AccessToBase = Merge(Access(B_i, B_{i+1}), ACAB(i+1)) in; /// if Accessible(B_i, AccessToBase) then public else AccessToBase; ///; /// B is an accessible base of N at R iff ACAB(1) = public.; ///; /// \param FinalAccess the access of the ""final step"", or AS_public if; /// there is no final step.; /// \return null if friendship is dependent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:40,Integrability,depend,dependent,40,// FIXME: fail correctly when there are dependent paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:30,Security,access,access,30,// Derive the friend-modified access along each path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:135,Security,access,accessible,135,"// If the declaration is a private member of a base class, there; // is no level of friendship in derived classes that can make it; // accessible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:10,Testability,test,tests,10,// Future tests are not against members and so do not have; // instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:34,Security,Access,Access,34,// Note that we modify the path's Access field to the; // friend-modified access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,Security,access,access,74,// Note that we modify the path's Access field to the; // friend-modified access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,Integrability,depend,dependent,74,"// We didn't find a public path, but at least one path was subject; // to dependent friendship, so delay the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:47,Security,access,access,47,"/// Given that an entity has protected natural access, check whether; /// access might be denied because of the protected member access; /// restriction.; ///; /// \return true if a note was emitted",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,Security,access,access,74,"/// Given that an entity has protected natural access, check whether; /// access might be denied because of the protected member access; /// restriction.; ///; /// \return true if a note was emitted",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:129,Security,access,access,129,"/// Given that an entity has protected natural access, check whether; /// access might be denied because of the protected member access; /// restriction.; ///; /// \return true if a note was emitted",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Security,access,accesses,28,// Only applies to instance accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:131,Security,access,access,131,"// The effective context is a subclass of the declaring class.; // Check whether the [class.protected] restriction is limiting; // access.; // To get this exactly right, this might need to be checked more; // holistically; it's not necessarily the case that gaining; // access here would grant us access overall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:270,Security,access,access,270,"// The effective context is a subclass of the declaring class.; // Check whether the [class.protected] restriction is limiting; // access.; // To get this exactly right, this might need to be checked more; // holistically; it's not necessarily the case that gaining; // access here would grant us access overall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:297,Security,access,access,297,"// The effective context is a subclass of the declaring class.; // Check whether the [class.protected] restriction is limiting; // access.; // To get this exactly right, this might need to be checked more; // holistically; it's not necessarily the case that gaining; // access here would grant us access overall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:83,Availability,error,error,83,"// TODO: it would be great to have a fixit here, since this is; // such an obvious error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:21,Security,access,access,21,/// We are unable to access a given declaration due to its direct; /// access control; diagnose that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:71,Security,access,access,71,/// We are unable to access a given declaration due to its direct; /// access control; diagnose that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Security,Access,AccessSpecDecl,28,// Check whether there's an AccessSpecDecl preceding this in the; // chain of the DeclContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:98,Security,access,access,98,// This basically repeats the main algorithm but keeps some more; // information.; // The natural access so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:25,Security,access,accessible,25,"// If the declaration is accessible when named in its declaring; // class, then we must be constrained by the path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:17,Security,access,accessible,17,"// Is the entity accessible when named in the deriving class, as; // modified by the base specifier?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:10,Security,access,access,10,"// If the access to this base is worse than the access we have to; // the declaration, remember it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:48,Security,access,access,48,"// If the access to this base is worse than the access we have to; // the declaration, remember it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:23,Modifiability,inherit,inheritance,23,"// If this was private inheritance, but we don't have access to; // the deriving class, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:54,Security,access,access,54,"// If this was private inheritance, but we don't have access to; // the deriving class, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:52,Availability,failure,failure,52,"// If we don't have a constraining base, the access failure must be; // due to the original declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:45,Security,access,access,45,"// If we don't have a constraining base, the access failure must be; // due to the original declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:24,Modifiability,inherit,inheritance,24,"// We're constrained by inheritance, but we want to say; // ""declared private here"" if we're diagnosing a hierarchy; // conversion and this is the final step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:260,Availability,error,error,260,"/// MSVC has a bug where if during an using declaration name lookup,; /// the declaration found is unaccessible (private) and that declaration; /// was bring into scope via another using declaration whose target; /// declaration is accessible (public) then no error is generated.; /// Example:; /// class A {; /// public:; /// int f();; /// };; /// class B : public A {; /// private:; /// using A::f;; /// };; /// class C : public B {; /// private:; /// using B::f;; /// };; ///; /// Here, B::f is private so this should fail in Standard C++, but; /// because B::f refers to A::f which is public MSVC accepts it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:232,Security,access,accessible,232,"/// MSVC has a bug where if during an using declaration name lookup,; /// the declaration found is unaccessible (private) and that declaration; /// was bring into scope via another using declaration whose target; /// declaration is accessible (public) then no error is generated.; /// Example:; /// class A {; /// public:; /// int f();; /// };; /// class B : public A {; /// private:; /// using A::f;; /// };; /// class C : public B {; /// private:; /// using B::f;; /// };; ///; /// Here, B::f is private so this should fail in Standard C++, but; /// because B::f refers to A::f which is public MSVC accepts it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:27,Security,access,accessed,27,/// Determines whether the accessed entity is accessible. Public members; /// have been weeded out by this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:46,Security,access,accessible,46,/// Determines whether the accessed entity is accessible. Public members; /// have been weeded out by this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:32,Security,access,access,32,"// Before we try to recalculate access paths, try to white-list; // accesses which just trade in on the final step, i.e. accesses; // which don't require [M4] or [B4]. These are by far the most; // common forms of privileged access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:68,Security,access,accesses,68,"// Before we try to recalculate access paths, try to white-list; // accesses which just trade in on the final step, i.e. accesses; // which don't require [M4] or [B4]. These are by far the most; // common forms of privileged access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:121,Security,access,accesses,121,"// Before we try to recalculate access paths, try to white-list; // accesses which just trade in on the final step, i.e. accesses; // which don't require [M4] or [B4]. These are by far the most; // common forms of privileged access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:225,Security,access,access,225,"// Before we try to recalculate access paths, try to white-list; // accesses which just trade in on the final step, i.e. accesses; // which don't require [M4] or [B4]. These are by far the most; // common forms of privileged access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:241,Integrability,depend,dependently,241,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:118,Security,access,access,118,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:226,Security,access,accessible,226,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:390,Security,access,access,390,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:310,Testability,assert,assertion,310,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:19,Security,access,accesses,19,// We lower member accesses to base accesses by pretending that the; // member is a base class of its declaring class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:36,Security,access,accesses,36,// We lower member accesses to base accesses by pretending that the; // member is a base class of its declaring class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:35,Security,access,accessible,35,// Determine if the declaration is accessible from EC when named; // in its declaring class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:13,Security,access,accessible,13,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:143,Security,access,accessible,143,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:224,Security,access,access,224,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:95,Usability,simpl,simply,95,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Security,access,access,28,// Append the declaration's access if applicable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to an entity from the given effective context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:10,Security,access,access,10,"// If the access path is public, it's accessible everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:38,Security,access,accessible,38,"// If the access path is public, it's accessible everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:70,Security,access,access,70,"// If we're currently parsing a declaration, we may need to delay; // access control checking, because our effective context might be; // different based on what the declaration comes out as.; //; // For example, we might be parsing a declaration with a scope; // specifier, like this:; // A::private_type A::foo() { ... }; //; // Or we might be parsing something that will turn out to be a friend:; // void foo(A::private_type);; // void B::foo(A::private_type);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:3,Security,Access,Access,3,"// Access control for names used in the declarations of functions; // and function templates should normally be evaluated in the context; // of the declaration, just in case it's a friend of something.; // However, this does not apply to local extern declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:4,Performance,Perform,Perform,4,/// Perform access-control checking on a previously-unresolved member; /// access which has now been resolved to a member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:12,Security,access,access-control,12,/// Perform access-control checking on a previously-unresolved member; /// access which has now been resolved to a member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:75,Security,access,access,75,/// Perform access-control checking on a previously-unresolved member; /// access which has now been resolved to a member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:24,Security,access,accessible,24,/// Is the given member accessible for the purposes of deciding whether to; /// define a special member function as deleted?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:67,Security,access,access,67,// There's never a path involved when checking implicit destructor access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:9,Safety,avoid,avoid,9,// TODO: avoid copy,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to a constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to a constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:307,Usability,clear,clear,307,"// Initializing a base sub-object is an instance method call on an; // object of the derived class. Otherwise, we have an instance method; // call on an object of the constructed type.; //; // FIXME: If we have a parent, we're initializing the base class subobject; // in aggregate initialization. It's not clear whether the object class; // should be the base class or the derived class in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:21,Modifiability,inherit,inheriting,21,"// If we're using an inheriting constructor to construct an object,; // the object class is the derived class, not the base class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to an overloaded operator new or delete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to a member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:20,Security,access,access,20,/// Checks implicit access to a member in a structured binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,"/// Checks access to an overloaded member operator, including; /// conversion operators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to the target of a friend declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:72,Modifiability,inherit,inheritance,72,"// Friendship lookup is a redeclaration lookup, so there's never an; // inheritance path modifying access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:99,Security,access,access,99,"// Friendship lookup is a redeclaration lookup, so there's never an; // inheritance path modifying access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:103,Performance,perform,performed,103,/// Checks access for a hierarchy conversion.; ///; /// \param ForceCheck true if this check should be performed even if access; /// control is disabled; some things rely on this for semantics; /// \param ForceUnprivileged true if this check should proceed as if the; /// context had no special privileges,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access for a hierarchy conversion.; ///; /// \param ForceCheck true if this check should be performed even if access; /// control is disabled; some things rely on this for semantics; /// \param ForceUnprivileged true if this check should proceed as if the; /// context had no special privileges,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:121,Security,access,access,121,/// Checks access for a hierarchy conversion.; ///; /// \param ForceCheck true if this check should be performed even if access; /// control is disabled; some things rely on this for semantics; /// \param ForceUnprivileged true if this check should proceed as if the; /// context had no special privileges,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,/// Checks access to all the declarations in the given result set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:434,Integrability,Depend,Depending,434,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,Security,access,access,11,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:70,Security,access,access,70,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:121,Security,access,access,121,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:212,Security,access,accessed,212,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:341,Security,access,access,341,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:413,Security,access,access,413,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:527,Security,access,access,527,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:649,Security,access,access,649,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:780,Security,access,access,780,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:971,Security,access,accessible,971,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:3,Performance,Perform,Perform,3,// Perform the C++ accessibility checks first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:19,Security,access,accessibility,19,// Perform the C++ accessibility checks first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:20,Security,access,access,20,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:78,Security,access,accessed,78,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:114,Security,access,access,114,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:183,Security,access,access,183,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:250,Security,access,access,250,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:41,Security,access,accessible,41,// @public and @package ivars are always accessible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,Integrability,interface,interface,74,"// If we are inside a class or category implementation, determine the; // interface we're in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:22,Integrability,interface,interface,22,"// If we're not in an interface, this ivar is inaccessible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,Integrability,interface,interface,28,"// If we're inside the same interface that owns the ivar, we're fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:109,Energy Efficiency,power,power,109,"// For most of the platforms we support, native and natural are the same.; // With XL, native is the same as power, natural means something else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:49,Energy Efficiency,power,power,49,"// If specified then alignment must be a ""small"" power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:69,Testability,log,logic,69,// FIXME: Use DefaultFunctionArrayLValueConversion() in place of the logic; // that adds implicit casts here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:58,Availability,redundant,redundant,58,// Warn about non-default alignment at #includes (without redundant; // warnings for the same directive in nested includes).; // The warning is delayed until the end of the file to avoid warnings; // for files that don't have any records that are affected by the modified; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:58,Safety,redund,redundant,58,// Warn about non-default alignment at #includes (without redundant; // warnings for the same directive in nested includes).; // The warning is delayed until the end of the file to avoid warnings; // for files that don't have any records that are affected by the modified; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:181,Safety,avoid,avoid,181,// Warn about non-default alignment at #includes (without redundant; // warnings for the same directive in nested includes).; // The warning is delayed until the end of the file to avoid warnings; // for files that don't have any records that are affected by the modified; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:15,Availability,redundant,redundant,15,// Don't add a redundant or conflicting attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:15,Safety,redund,redundant,15,// Don't add a redundant or conflicting attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:136,Modifiability,variab,variable,136,// Check for contradicting match rules. Contradicting match rules are; // either:; // - a top-level rule and one of its sub-rules. E.g. variable and; // variable(is_parameter).; // - a sub-rule and a sibling that's negated. E.g.; // variable(is_thread_local) and variable(unless(is_parameter)),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:153,Modifiability,variab,variable,153,// Check for contradicting match rules. Contradicting match rules are; // either:; // - a top-level rule and one of its sub-rules. E.g. variable and; // variable(is_parameter).; // - a sub-rule and a sibling that's negated. E.g.; // variable(is_thread_local) and variable(unless(is_parameter)),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:233,Modifiability,variab,variable,233,// Check for contradicting match rules. Contradicting match rules are; // either:; // - a top-level rule and one of its sub-rules. E.g. variable and; // variable(is_parameter).; // - a sub-rule and a sibling that's negated. E.g.; // variable(is_thread_local) and variable(unless(is_parameter)),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:263,Modifiability,variab,variable,263,// Check for contradicting match rules. Contradicting match rules are; // either:; // - a top-level rule and one of its sub-rules. E.g. variable and; // variable(is_parameter).; // - a sub-rule and a sibling that's negated. E.g.; // variable(is_thread_local) and variable(unless(is_parameter)),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:129,Modifiability,variab,variables,129,"// Each rule in Rules must be a strict subset of the attribute's; // SubjectMatch rules. I.e. we're allowed to use; // `apply_to=variables(is_global)` on an attrubute with SubjectList<[Var]>,; // but should not allow `apply_to=variables` on an attribute which has; // `SubjectList<[GlobalVar]>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:227,Modifiability,variab,variables,227,"// Each rule in Rules must be a strict subset of the attribute's; // SubjectMatch rules. I.e. we're allowed to use; // `apply_to=variables(is_global)` on an attrubute with SubjectList<[Var]>,; // but should not allow `apply_to=variables` on an attribute which has; // `SubjectList<[GlobalVar]>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:78,Performance,optimiz,optimize,78,"// In the future, check other pragmas if they're implemented (e.g. pragma; // optimize 0 will probably map to this functionality too).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:74,Performance,optimiz,optimizations,74,"// Don't modify the function attributes if it's ""on"". ""on"" resets the; // optimizations to the ones listed on the command line",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:13,Safety,unsafe,unsafe,13,"// For value unsafe context, combining this pragma with eval method; // setting is not recommended. See comment in function FixupInvocation#506.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:14,Availability,error,error,14,"// For better error recovery, eat all pushes inside the namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:20,Availability,recover,recovery,20,"// For better error recovery, eat all pushes inside the namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:20,Safety,recover,recovery,20,"// For better error recovery, eat all pushes inside the namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:6,Usability,simpl,simplify,6,"// To simplify the implementation, never keep around an empty stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:258,Testability,log,logic,258,"// Several attributes carry different semantics than the parsing requires, so; // those are opted out of the common argument checks.; //; // We also bail on unknown and ignored attributes because those are handled; // as part of the target-specific handling logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:32,Availability,Avail,Availability,32,"//===--- SemaAvailability.cpp - Availability attribute handling -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file processes the availability attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:407,Availability,avail,availability,407,"//===--- SemaAvailability.cpp - Availability attribute handling -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file processes the availability attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:14,Availability,Avail,AvailabilityAttr,14,// Check each AvailabilityAttr to find the one for this platform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:241,Availability,avail,availability,241,"/// The diagnostic we should emit for \c D, and the declaration that; /// originated it, or \c AR_Available.; ///; /// \param D The declaration to check.; /// \param Message If non-null, this will be populated with the message from; /// the availability attribute that is selected.; /// \param ClassReceiver If we're checking the method of a class message; /// send, the class. Otherwise nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:166,Integrability,Message,Message,166,"/// The diagnostic we should emit for \c D, and the declaration that; /// originated it, or \c AR_Available.; ///; /// \param D The declaration to check.; /// \param Message If non-null, this will be populated with the message from; /// the availability attribute that is selected.; /// \param ClassReceiver If we're checking the method of a class message; /// send, the class. Otherwise nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:219,Integrability,message,message,219,"/// The diagnostic we should emit for \c D, and the declaration that; /// originated it, or \c AR_Available.; ///; /// \param D The declaration to check.; /// \param Message If non-null, this will be populated with the message from; /// the availability attribute that is selected.; /// \param ClassReceiver If we're checking the method of a class message; /// send, the class. Otherwise nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:348,Integrability,message,message,348,"/// The diagnostic we should emit for \c D, and the declaration that; /// originated it, or \c AR_Available.; ///; /// \param D The declaration to check.; /// \param Message If non-null, this will be populated with the message from; /// the availability attribute that is selected.; /// \param ClassReceiver If we're checking the method of a class message; /// send, the class. Otherwise nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:52,Availability,avail,available,52,"// For typedefs, if the typedef declaration appears available look; // to the underlying type to see if it is more restrictive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:19,Availability,avail,availability,19,"// For +new, infer availability from -init.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:32,Availability,avail,availability,32,// Checks if we should emit the availability diagnostic in the context of C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:197,Security,access,access,197,"// It is perfectly fine to refer to an 'unavailable' Objective-C method; // when it is referenced from within the @implementation itself. In this; // context, we interpret unavailable as a form of access control.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:40,Availability,avail,availability,40,"// An implementation implicitly has the availability of the interface.; // Unless it is ""+load"" method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:60,Integrability,interface,interface,60,"// An implementation implicitly has the availability of the interface.; // Unless it is ""+load"" method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:90,Performance,load,load,90,"// An implementation implicitly has the availability of the interface.; // Unless it is ""+load"" method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:33,Availability,avail,availability,33,// A category implicitly has the availability of the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:53,Integrability,interface,interface,53,// A category implicitly has the availability of the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:17,Availability,avail,availability,17,// Always enable availability diagnostics for shader models.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:40,Availability,avail,availability,40,// New targets should always warn about availability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:147,Availability,avail,availability,147,"// end anonymous namespace; /// Tries to parse a string as ObjC method name.; ///; /// \param Name The string to parse. Expected to originate from availability; /// attribute argument.; /// \param SlotNames The vector that will be populated with slot names. In case; /// of unsuccessful parsing can contain invalid data.; /// \returns A number of method parameters if parsing was successful,; /// std::nullopt otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:21,Availability,avail,availability,21,"/// Actually emit an availability diagnostic for a reference to an unavailable; /// decl.; ///; /// \param Ctx The context that the reference occurred in; /// \param ReferringDecl The exact declaration that was referenced.; /// \param OffendingDecl A related decl to \c ReferringDecl that has an; /// availability attribute corresponding to \c K attached to it. Note that this; /// may not be the same as ReferringDecl, i.e. if an EnumDecl is annotated and; /// we refer to a member EnumConstantDecl, ReferringDecl is the EnumConstantDecl; /// and OffendingDecl is the EnumDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:301,Availability,avail,availability,301,"/// Actually emit an availability diagnostic for a reference to an unavailable; /// decl.; ///; /// \param Ctx The context that the reference occurred in; /// \param ReferringDecl The exact declaration that was referenced.; /// \param OffendingDecl A related decl to \c ReferringDecl that has an; /// availability attribute corresponding to \c K attached to it. Note that this; /// may not be the same as ReferringDecl, i.e. if an EnumDecl is annotated and; /// we refer to a member EnumConstantDecl, ReferringDecl is the EnumConstantDecl; /// and OffendingDecl is the EnumDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:37,Availability,avail,availability,37,"// The declaration can have multiple availability attributes, we are looking; // at one of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:30,Modifiability,inherit,inherited,30,"// If D is a declaration with inherited attributes, the note should; // point to the declaration with actual attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:60,Availability,avail,availability,60,"// We would like to emit the diagnostic even if -Wunguarded-availability is; // not specified for deployment targets >= to iOS 11 or equivalent or; // for declarations that were introduced in iOS 11 (macOS 10.13, ...) or; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:98,Deployability,deploy,deployment,98,"// We would like to emit the diagnostic even if -Wunguarded-availability is; // not specified for deployment targets >= to iOS 11 or equivalent or; // for declarations that were introduced in iOS 11 (macOS 10.13, ...) or; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:45,Availability,avail,availability,45,// Don't offer a fixit for declarations with availability attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:17,Availability,failure,failures,17,// Most of these failures are due to extra restrictions in ARC;; // reflect that in the primary diagnostic when applicable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:38,Availability,avail,availability,38,"/// This class implements -Wunguarded-availability.; ///; /// This is done with a traversal of the AST of a function that makes reference; /// to a partially available declaration. Whenever we encounter an \c if of the; /// form: \c if(@available(...)), we use the version from the condition to visit; /// the then statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:158,Availability,avail,available,158,"/// This class implements -Wunguarded-availability.; ///; /// This is done with a traversal of the AST of a function that makes reference; /// to a partially available declaration. Whenever we encounter an \c if of the; /// form: \c if(@available(...)), we use the version from the condition to visit; /// the then statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:237,Availability,avail,available,237,"/// This class implements -Wunguarded-availability.; ///; /// This is done with a traversal of the AST of a function that makes reference; /// to a partially available declaration. Whenever we encounter an \c if of the; /// form: \c if(@available(...)), we use the version from the condition to visit; /// the then statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:38,Availability,avail,available,38,/// Stack of potentially nested 'if (@available(...))'s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:43,Availability,avail,available,43,"// If the context of this function is less available than D, we should not; // emit a diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:60,Availability,avail,availability,60,"// We would like to emit the diagnostic even if -Wunguarded-availability is; // not specified for deployment targets >= to iOS 11 or equivalent or; // for declarations that were introduced in iOS 11 (macOS 10.13, ...) or; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:98,Deployability,deploy,deployment,98,"// We would like to emit the diagnostic even if -Wunguarded-availability is; // not specified for deployment targets >= to iOS 11 or equivalent or; // for declarations that were introduced in iOS 11 (macOS 10.13, ...) or; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:3,Availability,avail,available,3,/*@available*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:58,Availability,avail,available,58,// Find the statement which should be enclosed in the if @available check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:131,Availability,avail,available,131,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:83,Integrability,wrap,wrap,83,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:113,Modifiability,variab,variables,113,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:164,Safety,avoid,avoid,164,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:56,Availability,redundant,redundant,56,"// If we're using the '*' case here or if this check is redundant, then we; // use the enclosing version to check both branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:56,Safety,redund,redundant,56,"// If we're using the '*' case here or if this check is redundant, then we; // use the enclosing version to check both branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:17,Availability,avail,availability,17,"// This isn't an availability checking 'if', we can just continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:47,Availability,avail,availability,47,"// FIXME: We only examine the pattern decl for availability violations now,; // but we should also examine instantiated templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:75,Availability,avail,availability,75,"// Conservatively search the entire current function scope context for; // availability violations. This ensures we always correctly analyze nested; // classes, blocks, lambdas, etc. that may or may not be inside if(@available); // checks themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:217,Availability,avail,available,217,"// Conservatively search the entire current function scope context for; // availability violations. This ensures we always correctly analyze nested; // classes, blocks, lambdas, etc. that may or may not be inside if(@available); // checks themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:24,Availability,avail,available,24,"// We need to know the @available context in the current function to; // diagnose this use, let DiagnoseUnguardedAvailabilityViolations do that; // when we're done parsing the current function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:32,Integrability,rout,routines,32,// Top-level semantics-checking routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:8,Availability,down,down,8,"// Walk down from the CE to the OrigSrcExpr, and mark all immediate; // ImplicitCastExpr's as being part of ExplicitCastExpr. The original CE; // (which is a ExplicitCastExpr), and the OrigSrcExpr are not touched.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:33,Integrability,wrap,wrap,33,"// If this is an unbridged cast, wrap the result in an implicit; // cast that yields the unbridged-cast placeholder type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:18,Integrability,depend,dependent,18,"// If the type is dependent, we won't do the semantic analysis now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:87,Performance,perform,perform,87,"// In C++20, if the underlying destination type is a RecordType, Clang; // attempts to perform parentesized aggregate initialization if constructor; // overload fails:; //; // C++20 [expr.static.cast]p4:; // An expression E can be explicitly converted to a type T...if overload; // resolution for a direct-initialization...would find at least one viable; // function ([over.match.viable]), or if T is an aggregate type having a; // first element X and there is an implicit conversion sequence from E to; // the type of X.; //; // If that fails, then we'll generate the diagnostics from the failed; // previous constructor overload attempt. Array initialization, however, is; // not done after attempting constructor overloading, so we exit as there; // won't be a failed overload result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:3,Safety,Detect,Detect,3,"// Detect if both types are (ptr to) class, and note any incompleteness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:199,Availability,down,down,199,"// We've unwrapped at least one level. If the resulting T1 is a (possibly; // multidimensional) array type, any qualifier on any matching layer of; // T2 is considered to correspond to T1. Decompose down to the element; // type of T1 so that we can compare properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:173,Availability,down,downcasts,173,/// CheckDynamicCast - Check that a dynamic_cast\<DestType\>(SrcExpr) is valid.; /// Refer to C++ 5.2.7 for details. Dynamic casts are used mostly for runtime-; /// checked downcasts in class hierarchies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:39,Modifiability,polymorphi,polymorphic,39,"// C++ 5.2.7p6: Otherwise, v shall be [polymorphic].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:23,Availability,avail,available,23,"// dynamic_cast is not available with -fno-rtti.; // As an exception, dynamic_cast to void* is available because it doesn't; // use RTTI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:95,Availability,avail,available,95,"// dynamic_cast is not available with -fno-rtti.; // As an exception, dynamic_cast to void* is available because it doesn't; // use RTTI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:85,Availability,down,downcast,85,/// Check that a reinterpret_cast\<DestType\>(SrcExpr) is not used as upcast; /// or downcast between respective pointers or references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:97,Availability,avail,available,97,"// Examining subobjects for records is only possible if the complete and; // valid definition is available. Also, template instantiation is not; // allowed here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:45,Modifiability,variab,variable,45,// In a cast involving function types with a variable argument list only the; // types of initial arguments that are provided are considered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:8,Testability,test,test,8,"// This test is outside everything else because it's the only case where; // a non-lvalue-reference target type does not lead to decay.; // C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Availability,error,error,46,"// if conversion failed, don't report another error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:50,Performance,perform,performed,50,"/// TryStaticCast - Check if a static cast can be performed, and do so if; /// possible. If @p CStyle, ignore access restrictions on hierarchy casting; /// and casting away constness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:110,Security,access,access,110,"/// TryStaticCast - Check if a static cast can be performed, and do so if; /// possible. If @p CStyle, ignore access restrictions on hierarchy casting; /// and casting away constness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:307,Availability,down,downcast,307,"// The order the tests is not entirely arbitrary. There is one conversion; // that can be handled in two different ways. Given:; // struct A {};; // struct B : public A {; // B(); B(const A&);; // };; // const A &a = B();; // the cast static_cast<const B&>(a) could be seen as either a static; // reference downcast, or an explicit invocation of the user-defined; // conversion using B's conversion constructor.; // DR 427 specifies that the downcast is to be applied here.; // C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".; // Done outside this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:442,Availability,down,downcast,442,"// The order the tests is not entirely arbitrary. There is one conversion; // that can be handled in two different ways. Given:; // struct A {};; // struct B : public A {; // B(); B(const A&);; // };; // const A &a = B();; // the cast static_cast<const B&>(a) could be seen as either a static; // reference downcast, or an explicit invocation of the user-defined; // conversion using B's conversion constructor.; // DR 427 specifies that the downcast is to be applied here.; // C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".; // Done outside this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:17,Testability,test,tests,17,"// The order the tests is not entirely arbitrary. There is one conversion; // that can be handled in two different ways. Given:; // struct A {};; // struct B : public A {; // B(); B(const A&);; // };; // const A &a = B();; // the cast static_cast<const B&>(a) could be seen as either a static; // reference downcast, or an explicit invocation of the user-defined; // conversion using B's conversion constructor.; // DR 427 specifies that the downcast is to be applied here.; // C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".; // Done outside this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:26,Availability,down,downcast,26,"// C++ 5.2.9p5, reference downcast.; // See the function for details.; // DR 427 specifies that this is to be applied before paragraph 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:131,Modifiability,inherit,inheritance,131,// Reverse pointer upcast. C++ 4.10p3 specifies pointer upcast.; // C++ 5.2.9p8 additionally disallows a cast path through virtual inheritance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:139,Security,access,access,139,// Reverse member pointer conversion. C++ 4.11 specifies member pointer; // conversion. C++ 5.2.9p9 has additional information.; // DR54's access restrictions apply here also.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:4,Testability,Test,Tests,4,/// Tests whether a conversion according to N2844 is valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:32,Availability,down,downcast,32,"// Because we try the reference downcast before this function, from now on; // this is the only cast possibility, so we issue an error if we fail now.; // FIXME: Should allow casting away constness if CStyle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:129,Availability,error,error,129,"// Because we try the reference downcast before this function, from now on; // this is the only cast possibility, so we issue an error if we fail now.; // FIXME: Should allow casting away constness if CStyle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:4,Testability,Test,Tests,4,/// Tests whether a conversion according to C++ 5.2.9p5 is valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:340,Security,access,accessible,340,"// C++ 5.2.9p5: An lvalue of type ""cv1 B"", where B is a class type, can be; // cast to type ""reference to cv2 D"", where D is a class derived from B,; // if a valid standard conversion from ""pointer to D"" to ""pointer to B""; // exists, cv2 >= cv1, and B is not a virtual base class of D.; // In addition, DR54 clarifies that the base must be accessible in the; // current context. Although the wording of DR54 only applies to the pointer; // variant of this rule, the intent is clearly for it to apply to the this; // conversion as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:476,Usability,clear,clearly,476,"// C++ 5.2.9p5: An lvalue of type ""cv1 B"", where B is a class type, can be; // cast to type ""reference to cv2 D"", where D is a class derived from B,; // if a valid standard conversion from ""pointer to D"" to ""pointer to B""; // exists, cv2 >= cv1, and B is not a virtual base class of D.; // In addition, DR54 clarifies that the base must be accessible in the; // current context. Although the wording of DR54 only applies to the pointer; // variant of this rule, the intent is clearly for it to apply to the this; // conversion as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:4,Testability,Test,Tests,4,/// Tests whether a conversion according to C++ 5.2.9p8 is valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:371,Security,access,accessible,371,"// C++ 5.2.9p8: An rvalue of type ""pointer to cv1 B"", where B is a class; // type, can be converted to an rvalue of type ""pointer to cv2 D"", where D; // is a class derived from B, if a valid standard conversion from ""pointer; // to D"" to ""pointer to B"" exists, cv2 >= cv1, and B is not a virtual base; // class of D.; // In addition, DR54 clarifies that the base must be accessible in the; // current context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:133,Availability,down,downcast,133,/// TryStaticDowncast - Common functionality of TryStaticReferenceDowncast and; /// TryStaticPointerDowncast. Tests whether a static downcast from SrcType to; /// DestType is possible and allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:110,Testability,Test,Tests,110,/// TryStaticDowncast - Common functionality of TryStaticReferenceDowncast and; /// TryStaticPointerDowncast. Tests whether a static downcast from SrcType to; /// DestType is possible and allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:3,Availability,Down,Downcast,3,"// Downcast can only happen in class hierarchies, so we need classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:70,Availability,error,error,70,"// Target type does derive from source type. Now we're serious. If an error; // appears now, it's not ignored.; // This may not be entirely in line with the standard. Take for example:; // struct A {};; // struct B : virtual A {; // B(A&);; // };; //; // void f(); // {; // (void)static_cast<const B&>(*((A*)0));; // }; // As far as the standard is concerned, p5 does not apply (A is virtual), so; // p2 should be used instead - ""const B& t(*((A*)0));"" is perfectly valid.; // However, both GCC and Comeau reject this example, and accepting it would; // mean more complex code if we're to preserve the nice error message.; // FIXME: Being 100% compliant here would be nice to have.; // Must preserve cv, as always, unless we're in C-style mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:607,Availability,error,error,607,"// Target type does derive from source type. Now we're serious. If an error; // appears now, it's not ignored.; // This may not be entirely in line with the standard. Take for example:; // struct A {};; // struct B : virtual A {; // B(A&);; // };; //; // void f(); // {; // (void)static_cast<const B&>(*((A*)0));; // }; // As far as the standard is concerned, p5 does not apply (A is virtual), so; // p2 should be used instead - ""const B& t(*((A*)0));"" is perfectly valid.; // However, both GCC and Comeau reject this example, and accepting it would; // mean more complex code if we're to preserve the nice error message.; // FIXME: Being 100% compliant here would be nice to have.; // Must preserve cv, as always, unless we're in C-style mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:613,Integrability,message,message,613,"// Target type does derive from source type. Now we're serious. If an error; // appears now, it's not ignored.; // This may not be entirely in line with the standard. Take for example:; // struct A {};; // struct B : virtual A {; // B(A&);; // };; //; // void f(); // {; // (void)static_cast<const B&>(*((A*)0));; // }; // As far as the standard is concerned, p5 does not apply (A is virtual), so; // p2 should be used instead - ""const B& t(*((A*)0));"" is perfectly valid.; // However, both GCC and Comeau reject this example, and accepting it would; // mean more complex code if we're to preserve the nice error message.; // FIXME: Being 100% compliant here would be nice to have.; // Must preserve cv, as always, unless we're in C-style mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:228,Availability,error,error,228,"// This code is analoguous to that in CheckDerivedToBaseConversion, except; // that it builds the paths in reverse order.; // To sum up: record all paths to the base and build a nice string from; // them. Use it to spice up the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:234,Integrability,message,message,234,"// This code is analoguous to that in CheckDerivedToBaseConversion, except; // that it builds the paths in reverse order.; // To sum up: record all paths to the base and build a nice string from; // them. Use it to spice up the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:35,Testability,Test,Tests,35,"/// TryStaticMemberPointerUpcast - Tests whether a conversion according to; /// C++ 5.2.9p9 is valid:; ///; /// An rvalue of type ""pointer to member of D of type cv1 T"" can be; /// converted to an rvalue of type ""pointer to member of B of type cv2 T"",; /// where B is a base class of D [...].; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:8,Availability,down,down,8,"// Lock down the inheritance model right now in MS ABI, whether or not the; // pointee types are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:17,Modifiability,inherit,inheritance,17,"// Lock down the inheritance model right now in MS ABI, whether or not the; // pointee types are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:68,Availability,error,error,68,"// B is a base of D. But is it an allowed base? If not, it's a hard error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,Integrability,depend,dependent,46,// Optimistically assume that the delayed and dependent cases; // will work out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:28,Testability,Test,Tests,28,"/// TryStaticImplicitCast - Tests whether a conversion according to C++ 5.2.9p2; /// is valid:; ///; /// An expression e can be explicitly converted to a type T using a; /// @c static_cast if the declaration ""T t(e);"" is well-formed [...].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:87,Performance,perform,perform,87,"/// TryConstCast - See if a const_cast from source to destination is allowed,; /// and perform it if it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:143,Integrability,message,message,143,"// Cannot const_cast non-lvalue to lvalue reference type. But if this; // is C-style, static_cast might find a way, so we simply suggest a; // message and tell the parent to keep searching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:122,Usability,simpl,simply,122,"// Cannot const_cast non-lvalue to lvalue reference type. But if this; // is C-style, static_cast might find a way, so we simply suggest a; // message and tell the parent to keep searching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:23,Usability,clear,clear,23,"// It's not completely clear under the standard whether we can; // const_cast bit-field gl-values. Doing so would not be; // intrinsically complicated, but for now, we say no for; // consistency with other compilers and await the word of the; // committee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:187,Usability,clear,clear,187,"// Cannot cast to non-pointer, non-reference type. Note that, if DestType; // was a reference type, we converted it to a pointer above.; // The status of rvalue references isn't entirely clear, but it looks like; // conversion to them is simply invalid.; // C++ 5.2.11p3: For two pointer types [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:238,Usability,simpl,simply,238,"// Cannot cast to non-pointer, non-reference type. Note that, if DestType; // was a reference type, we converted it to a pointer above.; // The status of rvalue references isn't entirely clear, but it looks like; // conversion to them is simply invalid.; // C++ 5.2.11p3: For two pointer types [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:160,Security,access,accessing,160,// Checks for undefined behavior in reinterpret_cast.; // The cases that is checked for is:; // *reinterpret_cast<T*>(&a); // reinterpret_cast<T&>(a); // where accessing 'a' as type 'T' will result in undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:28,Modifiability,inherit,inheritance,28,// We need to determine the inheritance model that the class will use if; // haven't yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:207,Usability,clear,clear,207,"// C++ 5.2.10p2 has a note that mentions that, subject to all other; // restrictions, a cast to the same type is allowed so long as it does not; // cast away constness. In C++98, the intent was not entirely clear here,; // since all other paragraphs explicitly forbid casts to the same type.; // C++11 clarifies this case with p2.; //; // The only allowed types are: integral, enumeration, pointer, or; // pointer-to-member types. We also won't restrict Obj-C pointers either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:323,Modifiability,config,configurable,323,"// C++0x 5.2.10p8: Converting a pointer to a function into a pointer to; // an object type or vice versa is conditionally-supported.; // Compilers support it in C++03 too, though, because it's necessary for; // casting the return value of dlsym() and GetProcAddress().; // FIXME: Conditionally-supported behavior should be configurable in the; // TargetInfo or similar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:19,Testability,log,logic,19,"// Even though the logic below is general enough and can be applied to; // non-OpenCL mode too, we fast-path above because no other languages; // define overlapping address spaces currently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:87,Testability,test,test,87,"// C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".; // This test is outside everything else because it's the only case where; // a non-lvalue-reference target type does not lead to decay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:18,Integrability,depend,dependent,18,"// If the type is dependent, we won't do any other semantic analysis now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:38,Performance,perform,performed,38,"// C++ [expr.cast]p5: The conversions performed by; // - a const_cast,; // - a static_cast,; // - a static_cast followed by a const_cast,; // - a reinterpret_cast, or; // - a reinterpret_cast followed by a const_cast,; // can be performed using the cast notation of explicit type conversion.; // [...] If a conversion can be interpreted in more than one of the ways; // listed above, the interpretation that appears first in the list is used,; // even if a cast resulting from that interpretation is ill-formed.; // In plain language, this means trying a const_cast ...; // Note that for address space we check compatibility after const_cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:229,Performance,perform,performed,229,"// C++ [expr.cast]p5: The conversions performed by; // - a const_cast,; // - a static_cast,; // - a static_cast followed by a const_cast,; // - a reinterpret_cast, or; // - a reinterpret_cast followed by a const_cast,; // can be performed using the cast notation of explicit type conversion.; // [...] If a conversion can be interpreted in more than one of the ways; // listed above, the interpretation that appears first in the list is used,; // even if a cast resulting from that interpretation is ill-formed.; // In plain language, this means trying a const_cast ...; // Note that for address space we check compatibility after const_cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:190,Availability,failure,failure,190,"// If DestType is a function type (not to be confused with the function; // pointer type), it will be possible to resolve the function address,; // but the type cast should be considered as failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:18,Integrability,depend,dependent,18,"// If the type is dependent, we won't do any other semantic analysis now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:180,Availability,error,error,180,/// Checks that a call expression's argument count is at least the desired; /// number. This is useful when doing custom type-checking on a variadic; /// function. Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:179,Availability,error,error,179,/// Checks that a call expression's argument count is at most the desired; /// number. This is useful when doing custom type-checking on a variadic; /// function. Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:173,Availability,error,error,173,/// Checks that a call expression's argument count is in the desired range. This; /// is useful when doing custom type-checking on a variadic function. Returns; /// true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:143,Availability,error,error,143,/// Checks that a call expression's argument count is the desired number.; /// This is useful when doing custom type-checking. Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:108,Availability,down,down,108,"/// Check that the value argument for __builtin_is_aligned(value, alignment) and; /// __builtin_aligned_{up,down}(value, alignment) is an integer or a pointer; /// type (but not a function pointer) and that the alignment is a power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:226,Energy Efficiency,power,power-of-two,226,"/// Check that the value argument for __builtin_is_aligned(value, alignment) and; /// __builtin_aligned_{up,down}(value, alignment) is an integer or a pointer; /// type (but not a function pointer) and that the alignment is a power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:38,Availability,error,error,38,"// FIXME: this is not quite the right error message since we don't allow; // floating point types, or member pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:44,Integrability,message,message,44,"// FIXME: this is not quite the right error message since we don't allow; // floating point types, or member pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:55,Integrability,depend,dependent,55,// We can't check validity of alignment if it is value dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Integrability,Wrap,Wrap,3,// Wrap the literal in parentheses to attach a source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:40,Performance,perform,performing,40,// Register a note to explain why we're performing the call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,Availability,error,errors,29,"// Bail out if we've hit any errors, even if we managed to build the; // call. We don't want to produce more than one error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:118,Availability,error,error,118,"// Bail out if we've hit any errors, even if we managed to build the; // call. We don't want to produce more than one error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Integrability,Wrap,Wrap,3,// Wrap double-quotes around a '%s' specifier and limit its maximum; // length. Ideally we'd also somehow escape special characters in the; // contents but printf doesn't support that.; // FIXME: '%s' formatting is not safe in general.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:219,Safety,safe,safe,219,// Wrap double-quotes around a '%s' specifier and limit its maximum; // length. Ideally we'd also somehow escape special characters in the; // contents but printf doesn't support that.; // FIXME: '%s' formatting is not safe in general.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:68,Security,access,access,68,"// Try to instantiate the class template as appropriate; otherwise, access to; // its data() may lead to a crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:53,Security,validat,validate,53,"// Second argument is a callable, but we can't fully validate it until we try; // calling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Integrability,Wrap,Wrap,3,"// Wrap parentheses around the given pointer. This is not necessary for; // correct code generation, but it means that when we pretty-print the call; // arguments in our diagnostics we will produce '(&s)->n' instead of the; // incorrect '&s->n'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:36,Integrability,depend,depends,36,"// Whether these functions overflow depends on the runtime strlen of the; // string, not just the buffer size, so emitting the ""always overflow""; // diagnostic isn't quite right. We should still diagnose passing a buffer; // size larger than the destination buffer though; this is a runtime abort; // in _FORTIFY_SOURCE mode, and is quite suspicious otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:291,Safety,abort,abort,291,"// Whether these functions overflow depends on the runtime strlen of the; // string, not just the buffer size, so emitting the ""always overflow""; // diagnostic isn't quite right. We should still diagnose passing a buffer; // size larger than the destination buffer though; this is a runtime abort; // in _FORTIFY_SOURCE mode, and is quite suspicious otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:17,Availability,avail,available,17,"// Scopes aren't available during instantiation. Fortunately, builtin; // functions cannot be template args so they cannot be formed through template; // instantiation. Therefore checking once during the parse is sufficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:27,Availability,error,error,27,"// Get the location of the error. If a block literal has been passed; // (BlockExpr) then we can point straight to the offending argument,; // else we just point to the variable reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:169,Modifiability,variab,variable,169,"// Get the location of the error. If a block literal has been passed; // (BlockExpr) then we can point straight to the offending argument,; // else we just point to the variable reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:162,Performance,queue,queue,162,"/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different; /// overload formats specified in Table 6.13.17.1.; /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(local void*, ...),; /// uint size0, ...); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(local void*, ...),; /// uint size0, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:292,Performance,queue,queue,292,"/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different; /// overload formats specified in Table 6.13.17.1.; /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(local void*, ...),; /// uint size0, ...); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(local void*, ...),; /// uint size0, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:521,Performance,queue,queue,521,"/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different; /// overload formats specified in Table 6.13.17.1.; /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(local void*, ...),; /// uint size0, ...); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(local void*, ...),; /// uint size0, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:685,Performance,queue,queue,685,"/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different; /// overload formats specified in Table 6.13.17.1.; /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(local void*, ...),; /// uint size0, ...); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(local void*, ...),; /// uint size0, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:106,Modifiability,variab,variable,106,"// With four arguments, there is only one form that the function could be; // called in: no events and no variable arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:61,Availability,error,error,61,"// None of the specific case has been detected, give generic error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:38,Safety,detect,detected,38,"// None of the specific case has been detected, give generic error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:19,Security,access,access,19,/// Returns OpenCL access qual.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Security,Validat,Validates,3,"// Validates the access qualifier is compatible with the call.; // OpenCL v2.0 s6.13.16 - The access qualifiers for pipe should only be; // read_only and write_only, and assumed to be read_only if no qualifier is; // specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:17,Security,access,access,17,"// Validates the access qualifier is compatible with the call.; // OpenCL v2.0 s6.13.16 - The access qualifiers for pipe should only be; // read_only and write_only, and assumed to be read_only if no qualifier is; // specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:94,Security,access,access,94,"// Validates the access qualifier is compatible with the call.; // OpenCL v2.0 s6.13.16 - The access qualifiers for pipe should only be; // read_only and write_only, and assumed to be read_only if no qualifier is; // specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:187,Availability,error,error,187,"// Performs semantic analysis for the read/write_pipe call.; // \param S Reference to the semantic analyzer.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Performs,3,"// Performs semantic analysis for the read/write_pipe call.; // \param S Reference to the semantic analyzer.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:241,Availability,error,error,241,"// Performs a semantic analysis on the {work_group_/sub_group_; // /_}reserve_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Performs,3,"// Performs a semantic analysis on the {work_group_/sub_group_; // /_}reserve_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:236,Availability,error,error,236,"// Performs a semantic analysis on {work_group_/sub_group_; // /_}commit_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Performs,3,"// Performs a semantic analysis on {work_group_/sub_group_; // /_}commit_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:227,Availability,error,error,227,"// Performs a semantic analysis on the call to built-in Pipe; // Query Functions.; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Performs,3,"// Performs a semantic analysis on the call to built-in Pipe; // Query Functions.; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:305,Availability,error,error,305,"// OpenCL v2.0 s6.13.9 - Address space qualifier functions.; // Performs semantic analysis for the to_global/local/private call.; // \param S Reference to the semantic analyzer.; // \param BuiltinID ID of the builtin function.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:64,Performance,Perform,Performs,64,"// OpenCL v2.0 s6.13.9 - Address space qualifier functions.; // Performs semantic analysis for the to_global/local/private call.; // \param S Reference to the semantic analyzer.; // \param BuiltinID ID of the builtin function.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:11,Availability,error,error,11,// Emit an error and return true if the current object format type is in the; // list of unsupported types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:11,Availability,error,error,11,// Emit an error and return true if the current architecture is not in the list; // of supported architectures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:108,Availability,error,error,108,"// Check if \p Ty is a valid type for the elementwise math builtins. If it is; // not a valid type, emit an error message and return true. Otherwise return; // false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:114,Integrability,message,message,114,"// Check if \p Ty is a valid type for the elementwise math builtins. If it is; // not a valid type, emit an error message and return true. Otherwise return; // false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:39,Availability,error,errors,39,"// Don't diagnose previously diagnosed errors.; // If any arguments are required to be ICE's, check and diagnose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:16,Deployability,release,release,16,"// The acquire, release, and no fence variants are ARM and AArch64 only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:130,Deployability,release,release,130,"// TheCall will be freed by the smart pointer here, but that's fine, since; // SemaBuiltinShuffleVector guts it, but then doesn't release it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:111,Integrability,depend,dependent,111,// We warn about copying to or from `nullptr` pointers when `size` is; // greater than 0. When `size` is value dependent we cannot evaluate its; // value so we bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:103,Integrability,depend,dependent,103,// We warn about filling to `nullptr` pointers when `size` is greater than; // 0. When `size` is value dependent we cannot evaluate its value so we bail; // out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:185,Performance,load,load,185,/// getNeonEltType - Return the QualType corresponding to the elements of; /// the vector type specified by the NeonTypeFlags. This is used to check; /// the pointer arguments for Neon load/store intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Perform,3,// Perform all the immediate checks for this builtin call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,Availability,avail,available,29,// Check intrinsics that are available in [sve2p1 or sme/sme2].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:68,Security,validat,validate,68,"// For NEON intrinsics which are overloaded on vector element type, validate; // the immediate which specifies which variant to emit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:56,Performance,load,loaded,56,"// In general, we allow ints, floats and pointers to be loaded and stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:136,Availability,error,error,136,"// For intrinsics which take an immediate value as part of the instruction,; // range check them here.; // FIXME: VFP Intrinsics should error if VFP not present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:49,Security,access,access,49,"// The first argument needs to be a record field access.; // If it is an array element access, we delay decision; // to BPF backend to check whether the access is a; // field access or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:87,Security,access,access,87,"// The first argument needs to be a record field access.; // If it is an array element access, we delay decision; // to BPF backend to check whether the access is a; // field access or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:153,Security,access,access,153,"// The first argument needs to be a record field access.; // If it is an array element access, we delay decision; // to BPF backend to check whether the access is a; // field access or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:175,Security,access,access,175,"// The first argument needs to be a record field access.; // If it is an array element access, we delay decision; // to BPF backend to check whether the access is a; // field access or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:314,Testability,test,tests,314,"// CheckMipsBuiltinArgument - Checks the constant value passed to the; // intrinsic is correct. The switch statement is ordered by DSP, MSA. The; // ordering for DSP is unspecified. MSA is ordered by the data format used; // by the underlying instruction i.e., df/m, df/n and then by size.; //; // FIXME: The size tests here should instead be tablegen'd along with the; // definitions from include/clang/Basic/BuiltinsMips.def.; // FIXME: GCC is strict on signedness for some of these intrinsics, we should; // be too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:32,Performance,load,loads,32,// Memory offsets and immediate loads.; // These intrinsics take a signed 10 bit immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:264,Availability,Mask,Mask,264,"/// DecodePPCMMATypeFromStr - This decodes one PPC MMA type descriptor from Str,; /// advancing the pointer over the consumed characters. The decoded type is; /// returned. If the decoded type represents a constant integer with a; /// constraint on its value then Mask is set to that value. The type descriptors; /// used in Str are specific to PPC MMA builtins and are documented in the file; /// defining the PPC builtins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:135,Integrability,wrap,wrap,135,"/// Returns true if the argument consists of one contiguous run of 1s with any; /// number of 0s on either side. The 1s are allowed to wrap from LSB to MSB, so; /// 0x000FFF0, 0x0000FFFF, 0xFF0000FF, 0x0 are all runs. 0x0F0F0000 is not,; /// since all 1s are not contiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:54,Availability,Avail,Available,54,"// According to GCC 'Basic PowerPC Built-in Functions Available on ISA 2.05',; // __builtin_(un)pack_longdouble are available only if long double uses IBM; // extended double representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Availability,avail,available,116,"// According to GCC 'Basic PowerPC Built-in Functions Available on ISA 2.05',; // __builtin_(un)pack_longdouble are available only if long double uses IBM; // extended double representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:27,Energy Efficiency,Power,PowerPC,27,"// According to GCC 'Basic PowerPC Built-in Functions Available on ISA 2.05',; // __builtin_(un)pack_longdouble are available only if long double uses IBM; // extended double representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:159,Modifiability,extend,extended,159,"// According to GCC 'Basic PowerPC Built-in Functions Available on ISA 2.05',; // __builtin_(un)pack_longdouble are available only if long double uses IBM; // extended double representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:58,Availability,mask,mask,58,"// For __rlwnm, __rlwimi and __rldimi, the last parameter mask must; // be a constant that represents a contiguous bit field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:65,Availability,error,error,65,"// CodeGenFunction can also detect this, but this gives a better error; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:75,Integrability,message,message,75,"// CodeGenFunction can also detect this, but this gives a better error; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:28,Safety,detect,detect,28,"// CodeGenFunction can also detect this, but this gives a better error; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Availability,Error,Error,3,// Error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:9,Integrability,message,message,9,// Error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:148,Availability,error,error,148,"// Given that caller already checked isRVVType() before calling this function,; // if we don't have at least zve32x supported, then we need to emit error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:35,Availability,error,error,35,"// Note that we don't force a hard error on the range check here, allowing; // template-generated or macro-generated dead code to potentially have out-of-; // range values. These need to code generate, but don't need to necessarily; // make any sense. We use a warning that defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:289,Availability,error,error,289,"// Note that we don't force a hard error on the range check here, allowing; // template-generated or macro-generated dead code to potentially have out-of-; // range values. These need to code generate, but don't need to necessarily; // make any sense. We use a warning that defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:169,Safety,safe,safe,169,"// 16 byte ByVal alignment not due to a vector member is not honoured by XL; // on AIX. Emit a warning here that users are generating binary incompatible; // code to be safe.; // Here we try to get information about the alignment of the struct member; // from the struct passed to the caller function. We only warn when the struct; // is passed byval, hence the series of checks and early returns if we are a not; // passing a struct byval.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:8,Safety,safe,safety,8,// Type safety checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:137,Availability,avail,available,137,"// If the callee has an AArch64 SME attribute to indicate that it is an; // __arm_streaming function, then the caller requires SME to be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:72,Safety,safe,safety,72,/// CheckConstructorCall - Check a constructor call for correctness and safety; /// properties not enforced by the C type system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:86,Safety,safe,safety,86,/// CheckFunctionCall - Check a direct function call for various correctness; /// and safety properties not strictly enforced by the C type system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:45,Integrability,depend,depending,45,"// ImplicitThis may or may not be a pointer, depending on whether . or -> is; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:73,Usability,simpl,simple,73,"// None of the checks below are needed for functions that don't have; // simple names (e.g., C++ conversion functions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:68,Availability,avail,available,68,"/// Checks function calls when a FunctionDecl or a NamedDecl is not available,; /// such as function pointers returned from functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:145,Integrability,synchroniz,synchronization,145,// All the non-OpenCL operations take one of the following forms.; // The OpenCL operations take the __c11 forms with one extra argument for; // synchronization scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:7,Availability,mask,mask,7,// Bit mask for extra allowed value types other than integers for atomic; // arithmetic operations. Add/sub allow pointer and floating point. Min/max; // allow floating point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:94,Availability,error,errors,94,"// GCC does not enforce these rules for GNU atomics, but we do to help catch; // trivial type errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:142,Integrability,inject,inject,142,// All atomic operations have an overload which takes a pointer to a volatile; // 'A'. We shouldn't let the volatile-ness of the pointee-type inject itself; // into the result or the other operands. Similarly atomic_load takes a; // pointer to a const 'A'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:142,Security,inject,inject,142,// All atomic operations have an overload which takes a pointer to a volatile; // 'A'. We shouldn't let the volatile-ness of the pointee-type inject itself; // into the result or the other operands. Similarly atomic_load takes a; // pointer to a const 'A'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:2,Availability,failure,failure,2,/*failure=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:317,Availability,error,error,317,"/// checkBuiltinArgument - Given a call to a builtin function, perform; /// normal type-checking on the given argument, updating the call in; /// place. This is useful when a builtin function requires custom; /// type-checking for some of its arguments but not necessarily all of; /// them.; ///; /// Returns true on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,Performance,perform,perform,63,"/// checkBuiltinArgument - Given a call to a builtin function, perform; /// normal type-checking on the given argument, updating the call in; /// place. This is useful when a builtin function requires custom; /// type-checking for some of its arguments but not necessarily all of; /// them.; ///; /// Returns true on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:174,Integrability,rout,routines,174,"/// We have a call to a function like __sync_fetch_and_add, which is an; /// overloaded function based on the pointer type of its first argument.; /// The main BuildCallExpr routines have already promoted the types of; /// arguments because all of these calls are prototyped as void(...).; ///; /// This function goes through and does final semantic checking for these; /// builtins, as well as generating any warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Perform,3,// Perform builtin lookup to avoid redeclaring it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,Safety,avoid,avoid,29,// Perform builtin lookup to avoid redeclaring it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:132,Availability,error,error,132,"// GCC does an implicit conversion to the pointer or integer ValType. This; // can fail in some cases (1i -> int**), check for this error case now.; // Initialize the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:142,Security,access,access,142,"// Inspect the last argument of the nontemporal builtin. This should always; // be a pointer type, from which we imply the type of the memory access.; // Because it is a pointer type, we don't have to worry about any implicit; // casts here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:180,Usability,simpl,simplify,180,/// CheckObjCString - Checks that the argument to the builtin; /// CFString constructor is correct; /// Note: It might also make sense to do the UTF-16 conversion here (would; /// simplify the backend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:24,Availability,failure,failure,24,// Check for conversion failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:102,Availability,error,error,102,/// Check the arguments to '__builtin_va_start' or '__builtin_ms_va_start'; /// for validity. Emit an error and return true on failure; return false; /// on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:127,Availability,failure,failure,127,/// Check the arguments to '__builtin_va_start' or '__builtin_ms_va_start'; /// for validity. Emit an error and return true on failure; return false; /// on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:34,Security,validat,validate,34,// __va_start on Windows does not validate the parameter qualifiers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:77,Safety,safe,safe,77,"// Make sure any conversions are pushed back into the call; this is; // type safe since unordered compare builtins are declared as ""_Bool; // foo(...)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,Availability,mask,mask,63,"// __builtin_isfpclass has integer parameter that specify test mask. It is; // passed in (...), so it should be analyzed completely here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:58,Testability,test,test,58,"// __builtin_isfpclass has integer parameter that specify test mask. It is; // passed in (...), so it should be analyzed completely here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:4,Performance,Perform,Perform,4,/// Perform semantic analysis for a call to __builtin_complex.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:96,Availability,mask,mask,96,"// Determine which of the following types of shufflevector we're checking:; // 1) unary, vector mask: (lhs, mask); // 2) binary, scalar mask: (lhs, rhs, index, ..., index)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:108,Availability,mask,mask,108,"// Determine which of the following types of shufflevector we're checking:; // 1) unary, vector mask: (lhs, mask); // 2) binary, scalar mask: (lhs, rhs, index, ..., index)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:136,Availability,mask,mask,136,"// Determine which of the following types of shufflevector we're checking:; // 1) unary, vector mask: (lhs, mask); // 2) binary, scalar mask: (lhs, rhs, index, ..., index)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:86,Availability,mask,mask,86,"// Check to see if we have a call with 2 vector arguments, the unary shuffle; // with mask. If so, verify that RHS is an integer vector type with the; // same number of elts as lhs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Energy Efficiency,power,power,116,"/// Handle __builtin_alloca_with_align. This is declared; /// as (size_t, size_t) where the second size_t must be a power of 2 greater; /// than 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:89,Safety,avoid,avoid,89,// Check formatting specifiers. NOTE: We're only doing this for the non-size; // call to avoid duplicate diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Energy Efficiency,power,power,116,/// SemaBuiltinConstantArgPower2 - Check if argument ArgNum of TheCall is a; /// constant expression representing a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:31,Energy Efficiency,power,power,31,"// Bit-twiddling to test for a power of 2: for x > 0, x & (x-1) is zero if; // and only if x is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:98,Energy Efficiency,power,power,98,"// Bit-twiddling to test for a power of 2: for x > 0, x & (x-1) is zero if; // and only if x is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:20,Testability,test,test,20,"// Bit-twiddling to test for a power of 2: for x > 0, x & (x-1) is zero if; // and only if x is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:48,Availability,down,down,48,"// Check if it's a shifted byte, by shifting it down",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:33,Integrability,depend,dependent,33,// We can't check the value of a dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:13,Security,validat,validates,13,// This code validates writes to PSTATE registers.; // Not a write.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:31,Security,access,accesses,31,// The 128-bit system register accesses do not touch PSTATE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:30,Security,access,accesses,30,"// These are the named PSTATE accesses using ""MSR (immediate)"" instructions,; // along with the upper limit on the immediates allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:56,Security,validat,validating,56,"// If this is not a named PSTATE, just continue without validating, as this; // will be lowered to an ""MSR (register)"" instruction directly",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:91,Availability,error,error,91,/// SemaBuiltinPPCMMACall - Check the call to a PPC MMA builtin for validity.; /// Emit an error and return true on failure; return false on success.; /// TypeStr is a string containing the type descriptor of the value returned by; /// the builtin and the descriptors of the expected type of the arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Availability,failure,failure,116,/// SemaBuiltinPPCMMACall - Check the call to a PPC MMA builtin for validity.; /// Emit an error and return true on failure; return false on success.; /// TypeStr is a string containing the type descriptor of the value returned by; /// the builtin and the descriptors of the expected type of the arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:23,Availability,Mask,Mask,23,"// If the value of the Mask is not 0, we have a constraint in the size of; // the integer argument so here we ensure the argument is a constant that; // is in the valid range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:241,Availability,error,error,241,"// In case we exited early from the previous loop, there are other types to; // read from TypeStr. So we need to read them all to ensure we have the right; // number of arguments in TheCall and if it is not the case, to display a; // better error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:247,Integrability,message,message,247,"// In case we exited early from the previous loop, there are other types to; // read from TypeStr. So we need to read them all to ensure we have the right; // number of arguments in TheCall and if it is not the case, to display a; // better error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:58,Usability,clear,clear,58,"// A string has been found with all arguments covered, so clear out; // the diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:9,Deployability,update,update,9,// Don't update if a previous string covers all arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:13,Integrability,wrap,wrapper,13,// This is a wrapper class around StringLiteral to support offsetted string; // literals as format strings. It takes the offset into account when returning; // the string and its length or the source locations to display notes correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:140,Integrability,depend,dependent,140,// Technically -Wformat-nonliteral does not warn about this case.; // The behavior of printf and friends in this case is implementation; // dependent. Ideally if the format string cannot be null then; // it should have a 'nonnull' attribute in the function prototype.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:123,Security,secur,security,123,"// While __func__, etc., are technically not string literals, they; // cannot contain format specifiers and thus are not a security; // liability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:32,Availability,error,errors,32,"// As an exception, do not flag errors for variables binding to; // const string literals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:43,Modifiability,variab,variables,43,"// As an exception, do not flag errors for variables binding to; // const string literals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:441,Testability,log,logmessage,441,"// When the format argument is an argument of this function, and this; // function also has the format attribute, there are several interactions; // for which there shouldn't be a warning. For instance, when calling; // v*printf from a function that has the printf format attribute, we; // should not emit a warning about using `fmt`, even though it's not; // constant, because the arguments have already been checked for the; // caller of `logmessage`:; //; // __attribute__((format(printf, 1, 2))); // void logmessage(char const *fmt, ...) {; // va_list ap;; // va_start(ap, fmt);; // vprintf(fmt, ap); /* do not emit a warning about ""fmt"" */; // ...; // }; //; // Another interaction that we need to support is calling a variadic; // format function from a format function that has fixed arguments. For; // instance:; //; // __attribute__((format(printf, 1, 2))); // void logstring(char const *fmt, char const *str) {; // printf(fmt, str); /* do not emit a warning about ""fmt"" */; // }; //; // Same (and perhaps more relatably) for the variadic template case:; //; // template<typename... Args>; // __attribute__((format(printf, 1, 2))); // void log(const char *fmt, Args&&... args) {; // printf(fmt, forward<Args>(args)...);; // /* do not emit a warning about ""fmt"" */; // }; //; // Due to implementation difficulty, we only check the format, not the; // format arguments, in all cases.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:509,Testability,log,logmessage,509,"// When the format argument is an argument of this function, and this; // function also has the format attribute, there are several interactions; // for which there shouldn't be a warning. For instance, when calling; // v*printf from a function that has the printf format attribute, we; // should not emit a warning about using `fmt`, even though it's not; // constant, because the arguments have already been checked for the; // caller of `logmessage`:; //; // __attribute__((format(printf, 1, 2))); // void logmessage(char const *fmt, ...) {; // va_list ap;; // va_start(ap, fmt);; // vprintf(fmt, ap); /* do not emit a warning about ""fmt"" */; // ...; // }; //; // Another interaction that we need to support is calling a variadic; // format function from a format function that has fixed arguments. For; // instance:; //; // __attribute__((format(printf, 1, 2))); // void logstring(char const *fmt, char const *str) {; // printf(fmt, str); /* do not emit a warning about ""fmt"" */; // }; //; // Same (and perhaps more relatably) for the variadic template case:; //; // template<typename... Args>; // __attribute__((format(printf, 1, 2))); // void log(const char *fmt, Args&&... args) {; // printf(fmt, forward<Args>(args)...);; // /* do not emit a warning about ""fmt"" */; // }; //; // Due to implementation difficulty, we only check the format, not the; // format arguments, in all cases.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:875,Testability,log,logstring,875,"// When the format argument is an argument of this function, and this; // function also has the format attribute, there are several interactions; // for which there shouldn't be a warning. For instance, when calling; // v*printf from a function that has the printf format attribute, we; // should not emit a warning about using `fmt`, even though it's not; // constant, because the arguments have already been checked for the; // caller of `logmessage`:; //; // __attribute__((format(printf, 1, 2))); // void logmessage(char const *fmt, ...) {; // va_list ap;; // va_start(ap, fmt);; // vprintf(fmt, ap); /* do not emit a warning about ""fmt"" */; // ...; // }; //; // Another interaction that we need to support is calling a variadic; // format function from a format function that has fixed arguments. For; // instance:; //; // __attribute__((format(printf, 1, 2))); // void logstring(char const *fmt, char const *str) {; // printf(fmt, str); /* do not emit a warning about ""fmt"" */; // }; //; // Same (and perhaps more relatably) for the variadic template case:; //; // template<typename... Args>; // __attribute__((format(printf, 1, 2))); // void log(const char *fmt, Args&&... args) {; // printf(fmt, forward<Args>(args)...);; // /* do not emit a warning about ""fmt"" */; // }; //; // Due to implementation difficulty, we only check the format, not the; // format arguments, in all cases.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:1149,Testability,log,log,1149,"// When the format argument is an argument of this function, and this; // function also has the format attribute, there are several interactions; // for which there shouldn't be a warning. For instance, when calling; // v*printf from a function that has the printf format attribute, we; // should not emit a warning about using `fmt`, even though it's not; // constant, because the arguments have already been checked for the; // caller of `logmessage`:; //; // __attribute__((format(printf, 1, 2))); // void logmessage(char const *fmt, ...) {; // va_list ap;; // va_start(ap, fmt);; // vprintf(fmt, ap); /* do not emit a warning about ""fmt"" */; // ...; // }; //; // Another interaction that we need to support is calling a variadic; // format function from a format function that has fixed arguments. For; // instance:; //; // __attribute__((format(printf, 1, 2))); // void logstring(char const *fmt, char const *str) {; // printf(fmt, str); /* do not emit a warning about ""fmt"" */; // }; //; // Same (and perhaps more relatably) for the variadic template case:; //; // template<typename... Args>; // __attribute__((format(printf, 1, 2))); // void log(const char *fmt, Args&&... args) {; // printf(fmt, forward<Args>(args)...);; // /* do not emit a warning about ""fmt"" */; // }; //; // Due to implementation difficulty, we only check the format, not the; // format arguments, in all cases.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:550,Testability,log,logic,550,"// CHECK: format string is not a string literal.; //; // Dynamically generated format strings are difficult to; // automatically vet at compile time. Requiring that format strings; // are string literals: (1) permits the checking of format strings by; // the compiler and thereby (2) can practically remove the source of; // many format string exploits.; // Format string can be either ObjC string (e.g. @""%d"") or; // C string (e.g. ""%d""); // ObjC string uses the same format specifiers as C string, so we can use; // the same format string checking logic for both ObjC and C strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:56,Safety,detect,detected,56,// Generate a diagnostic where an uncovered argument is detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:83,Safety,safe,safe,83,"// Strftime is particular as it always uses a single 'time' argument,; // so it is safe to pass a non-literal string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:59,Security,secur,security,59,"// If there are no arguments specified, warn with -Wformat-security, otherwise; // warn only with -Wformat-nonliteral.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:49,Availability,error,error,49,// The presence of a null character is likely an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:50,Availability,error,error,50,// Note that this may return NULL if there was an error parsing or building; // one of the argument expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:130,Integrability,message,messages,130,"/// If the format string is not within the function call, emit a note; /// so that the function call and string are in diagnostic messages.; ///; /// \param InFunctionCall if true, the format string is within the function; /// call and only one diagnostic message will be produced. Otherwise, an; /// extra note will be emitted pointing to location of the format string.; ///; /// \param ArgumentExpr the expression that is passed as the format string; /// argument in the function call. Used for getting locations when two; /// diagnostics are emitted.; ///; /// \param PDiag the callee should already have provided any strings for the; /// diagnostic message. This function only adds locations and fixits; /// to diagnostics.; ///; /// \param Loc primary location for diagnostic. If two diagnostics are; /// required, one will be at Loc and a new SourceLocation will be created for; /// the other one.; ///; /// \param IsStringLocation if true, Loc points to the format string should be; /// used for the note. Otherwise, Loc points to the argument list and will; /// be used with PDiag.; ///; /// \param StringRange some or all of the string to highlight. This is; /// templated so it can accept either a CharSourceRange or a SourceRange.; ///; /// \param FixIt optional fix it hint for the format string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:256,Integrability,message,message,256,"/// If the format string is not within the function call, emit a note; /// so that the function call and string are in diagnostic messages.; ///; /// \param InFunctionCall if true, the format string is within the function; /// call and only one diagnostic message will be produced. Otherwise, an; /// extra note will be emitted pointing to location of the format string.; ///; /// \param ArgumentExpr the expression that is passed as the format string; /// argument in the function call. Used for getting locations when two; /// diagnostics are emitted.; ///; /// \param PDiag the callee should already have provided any strings for the; /// diagnostic message. This function only adds locations and fixits; /// to diagnostics.; ///; /// \param Loc primary location for diagnostic. If two diagnostics are; /// required, one will be at Loc and a new SourceLocation will be created for; /// the other one.; ///; /// \param IsStringLocation if true, Loc points to the format string should be; /// used for the note. Otherwise, Loc points to the argument list and will; /// be used with PDiag.; ///; /// \param StringRange some or all of the string to highlight. This is; /// templated so it can accept either a CharSourceRange or a SourceRange.; ///; /// \param FixIt optional fix it hint for the format string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:653,Integrability,message,message,653,"/// If the format string is not within the function call, emit a note; /// so that the function call and string are in diagnostic messages.; ///; /// \param InFunctionCall if true, the format string is within the function; /// call and only one diagnostic message will be produced. Otherwise, an; /// extra note will be emitted pointing to location of the format string.; ///; /// \param ArgumentExpr the expression that is passed as the format string; /// argument in the function call. Used for getting locations when two; /// diagnostics are emitted.; ///; /// \param PDiag the callee should already have provided any strings for the; /// diagnostic message. This function only adds locations and fixits; /// to diagnostics.; ///; /// \param Loc primary location for diagnostic. If two diagnostics are; /// required, one will be at Loc and a new SourceLocation will be created for; /// the other one.; ///; /// \param IsStringLocation if true, Loc points to the format string should be; /// used for the note. Otherwise, Loc points to the argument list and will; /// be used with PDiag.; ///; /// \param StringRange some or all of the string to highlight. This is; /// templated so it can accept either a CharSourceRange or a SourceRange.; ///; /// \param FixIt optional fix it hint for the format string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:62,Availability,error,errors,62,// Don't do any more checking. We will just emit; // spurious errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:177,Safety,safe,safe,177,"// Type check the data argument. It should be an 'int'.; // Although not in conformance with C99, we also allow the argument to be; // an 'unsigned int' as that is a reasonably safe case. GCC also; // doesn't emit a warning for that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:62,Availability,error,errors,62,// Don't do any more checking. We will just emit; // spurious errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:162,Availability,error,error,162,// The check to see if the argIndex is valid will come later.; // We set the bit here because we may exit early from this; // function if we encounter some other error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:24,Integrability,depend,depend,24,// The remaining checks depend on the data arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,Modifiability,layers,layers,29,// Use a 'while' to peel off layers of typedefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:44,Availability,error,error,44,"// Look through argument promotions for our error message's reported type.; // This includes the integral and floating promotions, but excludes array; // and function pointer decay (seeing that an argument intended to be a; // string has type 'char [6]' is probably more confusing than 'char *') and; // certain bitfield promotions (bitfields can be 'demoted' to a lesser type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:50,Integrability,message,message,50,"// Look through argument promotions for our error message's reported type.; // This includes the integral and floating promotions, but excludes array; // and function pointer decay (seeing that an argument intended to be a; // string has type 'char [6]' is probably more confusing than 'char *') and; // certain bitfield promotions (bitfields can be 'demoted' to a lesser type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:199,Integrability,message,message,199,"// In this case, the expression could be printed using a different; // specifier, but we've decided that the specifier is probably correct; // and we should cast instead. Just use the normal warning message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:162,Availability,error,error,162,// The check to see if the argIndex is valid will come later.; // We set the bit here because we may exit early from this; // function if we encounter some other error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:24,Integrability,depend,depend,24,// The remaining checks depend on the data arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:4,Safety,Detect,Detect,4,/// Detect if \c SizeofExpr is likely to calculate the sizeof an object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:67,Availability,error,error,67,"// If we're memsetting or bzeroing 0 bytes, then this is likely an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:109,Availability,error,error,109,"// If the second argument to a memset is a sizeof expression and the third; // isn't, this is also likely an error. This should catch; // 'memset(buf, sizeof(buf), 0xff)'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:114,Safety,abort,abort,114,"// It is possible to have a non-standard definition of memset. Validate; // we have enough arguments, and if not, abort further checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,Security,Validat,Validate,63,"// It is possible to have a non-standard definition of memset. Validate; // we have enough arguments, and if not, abort further checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:74,Performance,cache,cache,74,"// We only compute IDs for expressions if the warning is enabled, and; // cache the sizeof arg's ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:19,Integrability,rout,routine,19,// A little helper routine: ignore addition and subtraction of integer literals.; // This intentionally does not ignore all integer constant expressions because; // we don't want to remove sizeof().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:47,Modifiability,flexible,flexible,47,"// Only handle constant-sized or VLAs, but not flexible members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:109,Modifiability,enhance,enhanced,109,"// Output a FIXIT hint if the destination is an array (rather than a; // pointer to an array). This could be enhanced to handle some; // pointers if we know the actual size, like if DstArg is 'array+2'; // we could say 'sizeof(array)-2'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,Usability,simpl,simpler,63,// Prefer something that doesn't involve a cast to make things simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:273,Availability,failure,failure,273,"// C++11 [basic.stc.dynamic.allocation]p4:; // If an allocation function declared with a non-throwing; // exception-specification fails to allocate storage, it shall return; // a null pointer. Any other allocation function that fails to allocate; // storage shall indicate failure only by throwing an exception [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:139,Energy Efficiency,allocate,allocate,139,"// C++11 [basic.stc.dynamic.allocation]p4:; // If an allocation function declared with a non-throwing; // exception-specification fails to allocate storage, it shall return; // a null pointer. Any other allocation function that fails to allocate; // storage shall indicate failure only by throwing an exception [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:237,Energy Efficiency,allocate,allocate,237,"// C++11 [basic.stc.dynamic.allocation]p4:; // If an allocation function declared with a non-throwing; // exception-specification fails to allocate storage, it shall return; // a null pointer. Any other allocation function that fails to allocate; // storage shall indicate failure only by throwing an exception [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:245,Modifiability,variab,variable,245,"// Special case: check for comparisons against literals that can be exactly; // represented by APFloat. In such cases, do not emit a warning. This; // is a heuristic: often comparison against such literals are used to; // detect if a value in a variable has not changed. This clearly can; // lead to false negatives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:222,Safety,detect,detect,222,"// Special case: check for comparisons against literals that can be exactly; // represented by APFloat. In such cases, do not emit a warning. This; // is a heuristic: often comparison against such literals are used to; // detect if a value in a variable has not changed. This clearly can; // lead to false negatives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:276,Usability,clear,clearly,276,"// Special case: check for comparisons against literals that can be exactly; // represented by APFloat. In such cases, do not emit a warning. This; // is a heuristic: often comparison against such literals are used to; // detect if a value in a variable has not changed. This clearly can; // lead to false negatives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:82,Energy Efficiency,reduce,reduced,82,// We need a 1-bit-wider range if:; // 1) LHS can be negative: least value can be reduced.; // 2) RHS can be negative: greatest value can be increased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Usability,Simpl,Simple,3,"// Simple assignments just pass through the RHS, which will have; // been coerced to the LHS type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:52,Testability,log,logically,52,// ...except that we want to treat '1 << (blah)' as logically; // positive. It's an important idiom.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:76,Performance,perform,performed,76,"// Combine the two ranges, but limit the result to the type in which we; // performed the computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:36,Performance,perform,performed,36,// The type the comparison is being performed in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:23,Integrability,depend,dependent,23,// Don't analyze value-dependent comparisons directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Safety,Avoid,Avoid,3,// Avoid warning about comparison of integers with different signs when; // RHS/LHS has a `typeof(E)` type whose sign is different from the sign of; // the type of `E`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:25,Integrability,depend,dependent,25,// Ignore value- or type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:66,Energy Efficiency,reduce,reduce,66,"// In C, the macro 'true' from stdbool.h will evaluate to '1'; To reduce; // false positives where the user is demonstrating they intend to use the; // bit-field as a Boolean, check to see if the value is 1 and we're assigning; // to a one-bit bit-field to see if the value came from a macro named 'true'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:22,Usability,simpl,simple,22,/// Analyze the given simple or compound assignment for warning-worthy; /// operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:50,Availability,down,down,50,"// FIXME: Force the precision of the source value down so we don't print; // digits which are usually useless (we don't really care here if we; // truncate a digit by accident in edge cases). Ideally, APFloat::toString; // would automatically print the shortest representation, but it's a bit; // tricky to implement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:30,Safety,safe,safe,30,// Return if target type is a safe conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:21,Integrability,wrap,wrapped,21,// __null is usually wrapped in a macro. Go up a macro if that is the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:272,Safety,detect,detect,272,"// If the conversion context location is invalid don't complain. We also; // don't want to emit a warning if the issue occurs from the expansion of; // a system macro. The problem is that 'getSpellingLoc()' is slow, so we; // delay this check as long as possible. Once we detect we are in that; // scenario, we just return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:121,Availability,error,error,121,"// Warn on string literal to bool. Checks for string literals in logical; // and expressions, for instance, assert(0 && ""error here""), are; // prevented by a check in AnalyzeImplicitConversions().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:65,Testability,log,logical,65,"// Warn on string literal to bool. Checks for string literals in logical; // and expressions, for instance, assert(0 && ""error here""), are; // prevented by a check in AnalyzeImplicitConversions().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:108,Testability,assert,assert,108,"// Warn on string literal to bool. Checks for string literals in logical; // and expressions, for instance, assert(0 && ""error here""), are; // prevented by a check in AnalyzeImplicitConversions().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:26,Performance,scalab,scalable,26,// Handle conversion from scalable to fixed when msve-vector-bits is; // specified,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Safety,Detect,Detect,3,"// Detect the case where a call result is converted from floating-point to; // to bool, and the final argument to the call is converted from bool, to; // discover this typo:; //; // bool b = fabs(x < 1.0); // should be ""bool b = fabs(x) < 1.0;""; //; // FIXME: This is an incredibly special case; is there some more general; // way to detect this class of misplaced-parentheses bug?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:334,Safety,detect,detect,334,"// Detect the case where a call result is converted from floating-point to; // to bool, and the final argument to the call is converted from bool, to; // discover this typo:; //; // bool b = fabs(x < 1.0); // should be ""bool b = fabs(x) < 1.0;""; //; // FIXME: This is an incredibly special case; is there some more general; // way to detect this class of misplaced-parentheses bug?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:113,Energy Efficiency,reduce,reduced,113,"// TODO: remove this early return once the false positives for constant->bool; // in templates, macros, etc, are reduced or removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:80,Testability,log,logical,80,/// Check conversion of given expression to boolean.; /// Input argument E is a logical expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:113,Performance,optimiz,optimization,113,// Go ahead and check any implicit conversions we might have skipped.; // The non-canonical typecheck is just an optimization;; // CheckImplicitConversion will filter out dead implicit conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:12,Usability,simpl,simple,12,// And with simple assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:47,Testability,log,logical,47,// Ignore checking string literals that are in logical and operators.; // This is a common pattern for asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:103,Testability,assert,asserts,103,// Ignore checking string literals that are in logical and operators.; // This is a common pattern for asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:37,Integrability,depend,dependent,37,// Don't diagnose for value- or type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:192,Modifiability,variab,variable,192,"// Check for array bounds violations in cases where the check isn't triggered; // elsewhere for other Expr types (like BinaryOperators), e.g. when an; // ArraySubscriptExpr is on the RHS of a variable initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:41,Modifiability,variab,variable,41,// This is not the right CC for (e.g.) a variable initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:106,Testability,log,logical,106,/// CheckBoolLikeConversion - Check conversion of given expression to boolean.; /// Input argument E is a logical expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Performance,Perform,Perform,3,// Perform path compression as we go.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:59,Energy Efficiency,reduce,reduce,59,/// Expressions to check later. We defer checking these to reduce; /// stack usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:241,Availability,down,downgrade,241,"/// RAII object wrapping the visitation of a sequenced subexpression of an; /// expression. At the end of this process, the side-effects of the evaluation; /// become sequenced with respect to the value computation of the result, so; /// we downgrade any UK_ModAsSideEffect within the evaluation to; /// UK_ModAsValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:16,Integrability,wrap,wrapping,16,"/// RAII object wrapping the visitation of a sequenced subexpression of an; /// expression. At the end of this process, the side-effects of the evaluation; /// become sequenced with respect to the value computation of the result, so; /// we downgrade any UK_ModAsSideEffect within the evaluation to; /// UK_ModAsValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:120,Usability,clear,clearing,120,"// Add a new usage with usage kind UK_ModAsValue, and then restore; // the previous usage with UK_ModAsSideEffect (thus clearing it if; // the previous one was empty).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:16,Integrability,wrap,wrapping,16,"/// RAII object wrapping the visitation of a subexpression which we might; /// choose to evaluate as a constant. If any subexpression is evaluated and; /// found to be non-constant, this allows us to suppress the evaluation of; /// the outer expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:1223,Availability,down,downgrade,1223,"// A note on note{Pre, Post}{Use, Mod}:; //; // (It helps to follow the algorithm with an expression such as; // ""((++k)++, k) = k"" or ""k = (k++, k++)"". Both contain unsequenced; // operations before C++17 and both are well-defined in C++17).; //; // When visiting a node which uses/modify an object we first call notePreUse; // or notePreMod before visiting its sub-expression(s). At this point the; // children of the current node have not yet been visited and so the eventual; // uses/modifications resulting from the children of the current node have not; // been recorded yet.; //; // We then visit the children of the current node. After that notePostUse or; // notePostMod is called. These will 1) detect an unsequenced modification; // as side effect (as in ""k++ + k"") and 2) add a new usage with the; // appropriate usage kind.; //; // We also have to be careful that some operation sequences modification as; // side effect as well (for example: || or ,). To account for this we wrap; // the visitation of such a sub-expression (for example: the LHS of || or ,); // with SequencedSubexpression. SequencedSubexpression is an RAII object; // which record usages which are modifications as side effect, and then; // downgrade them (or more accurately restore the previous usage which was a; // modification as side effect) when exiting the scope of the sequenced; // subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:989,Integrability,wrap,wrap,989,"// A note on note{Pre, Post}{Use, Mod}:; //; // (It helps to follow the algorithm with an expression such as; // ""((++k)++, k) = k"" or ""k = (k++, k++)"". Both contain unsequenced; // operations before C++17 and both are well-defined in C++17).; //; // When visiting a node which uses/modify an object we first call notePreUse; // or notePreMod before visiting its sub-expression(s). At this point the; // children of the current node have not yet been visited and so the eventual; // uses/modifications resulting from the children of the current node have not; // been recorded yet.; //; // We then visit the children of the current node. After that notePostUse or; // notePostMod is called. These will 1) detect an unsequenced modification; // as side effect (as in ""k++ + k"") and 2) add a new usage with the; // appropriate usage kind.; //; // We also have to be careful that some operation sequences modification as; // side effect as well (for example: || or ,). To account for this we wrap; // the visitation of such a sub-expression (for example: the LHS of || or ,); // with SequencedSubexpression. SequencedSubexpression is an RAII object; // which record usages which are modifications as side effect, and then; // downgrade them (or more accurately restore the previous usage which was a; // modification as side effect) when exiting the scope of the sequenced; // subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:705,Safety,detect,detect,705,"// A note on note{Pre, Post}{Use, Mod}:; //; // (It helps to follow the algorithm with an expression such as; // ""((++k)++, k) = k"" or ""k = (k++, k++)"". Both contain unsequenced; // operations before C++17 and both are well-defined in C++17).; //; // When visiting a node which uses/modify an object we first call notePreUse; // or notePreMod before visiting its sub-expression(s). At this point the; // children of the current node have not yet been visited and so the eventual; // uses/modifications resulting from the children of the current node have not; // been recorded yet.; //; // We then visit the children of the current node. After that notePostUse or; // notePostMod is called. These will 1) detect an unsequenced modification; // as side effect (as in ""k++ + k"") and 2) add a new usage with the; // appropriate usage kind.; //; // We also have to be careful that some operation sequences modification as; // side effect as well (for example: || or ,). To account for this we wrap; // the visitation of such a sub-expression (for example: the LHS of || or ,); // with SequencedSubexpression. SequencedSubexpression is an RAII object; // which record usages which are modifications as side effect, and then; // downgrade them (or more accurately restore the previous usage which was a; // modification as side effect) when exiting the scope of the sequenced; // subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:186,Deployability,update,update,186,"// C++11 [expr.ass]p1:; // [...] the assignment is sequenced after the value computation; // of the right and left operands, [...]; //; // so check it before inspecting the operands and update the; // map afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:15,Testability,log,log,15,"// C++11 [expr.log.or]p2:; // If the second expression is evaluated, every value computation and; // side effect associated with the first expression is sequenced before; // every value computation and side effect associated with the; // second expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:15,Testability,log,log,15,// C++11 [expr.log.or]p1:; // [...] the second operand is not evaluated if the first operand; // evaluates to true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:15,Testability,log,log,15,"// C++11 [expr.log.and]p2:; // If the second expression is evaluated, every value computation and; // side effect associated with the first expression is sequenced before; // every value computation and side effect associated with the; // second expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:15,Testability,log,log,15,// C++11 [expr.log.and]p1:; // [...] the second operand is not evaluated if the first operand is false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:581,Availability,down,downgrade,581,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:471,Integrability,wrap,wrap,471,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:192,Safety,avoid,avoid,192,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:383,Safety,detect,detect,383,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:184,Performance,perform,performed,184,"/// CheckParmsForFunctionDef - Check that the parameters of the given; /// function are appropriate for the definition of a function. This; /// takes care of any checks that cannot be performed on the; /// declaration itself, e.g., that the types of each of the function; /// parameters are complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:228,Modifiability,variab,variable,228,"// C99 6.7.5.3p12:; // If the function declarator is not part of a definition of that; // function, parameters may have incomplete type and may use the [*]; // notation in their sequences of declarator specifiers to specify; // variable length array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:179,Performance,perform,perform,179,"// If the parameter is a c++ class type and it has to be destructed in the; // callee function, declare the destructor so that it can be called by the; // callee function. Do not perform any direct access check on the dtor here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:198,Security,access,access,198,"// If the parameter is a c++ class type and it has to be destructed in the; // callee function, declare the destructor so that it can be called by the; // callee function. Do not perform any direct access check on the dtor here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:62,Modifiability,variab,variable,62,"// FIXME: If VD is captured by copy or is an escaping __block variable,; // use the alignment of VD's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Integrability,Depend,Dependent,3,// Dependent alignment cannot be resolved -> bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:10,Integrability,depend,dependent,10,// Ignore dependent types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:94,Integrability,message,message,94,"// Need to compute max possible elements in address space, since that; // is included in diag message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:8,Integrability,message,message,8,"// Diag message shows element size in bits and in ""bytes"" (platform-; // dependent CharUnits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:73,Integrability,depend,dependent,73,"// Diag message shows element size in bits and in ""bytes"" (platform-; // dependent CharUnits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:279,Security,access,access,279,"// It is possible that the type of the base expression after; // IgnoreParenCasts is incomplete, even though the type of the base; // expression before IgnoreParenCasts is complete (see PR39746 for an; // example). In this case we have no information about whether the array; // access exceeds the array bounds. However we can still diagnose an array; // access which precedes the array bounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:355,Security,access,access,355,"// It is possible that the type of the base expression after; // IgnoreParenCasts is incomplete, even though the type of the base; // expression before IgnoreParenCasts is complete (see PR39746 for an; // example). In this case we have no information about whether the array; // access exceeds the array bounds. However we can still diagnose an array; // access which precedes the array bounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:55,Modifiability,variab,variable,55,// namespace; /// Consider whether capturing the given variable can possibly lead to; /// a retain cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:42,Modifiability,variab,variable,42,"// In ARC, it's captured strongly iff the variable has __strong; // lifetime. In MRR, it's captured strongly if the variable is; // __block and has an appropriate type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,Modifiability,variab,variable,116,"// In ARC, it's captured strongly iff the variable has __strong; // lifetime. In MRR, it's captured strongly if the variable is; // __block and has an appropriate type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:84,Modifiability,variab,variable,84,// namespace; /// Check whether the given argument is a block which captures a; /// variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:12,Integrability,message,message,12,/// Check a message send to see if it's likely to cause a retain cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:17,Modifiability,variab,variable,17,// Try to find a variable that the receiver is strongly owned by.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:47,Modifiability,variab,variable,47,"// Because we don't have an expression for the variable, we have to set the; // location explicitly here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:10,Modifiability,variab,variables,10,// Member variables require a different approach to check for self moves.; // MemberExpr's are the same if every nested MemberExpr refers to the same; // Decl and that the base Expr's are DeclRefExpr's with the same Decl or; // the base Expr's are CXXThisExpr's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:412,Performance,perform,performed,412,"//===--- CHECK: pointer_with_type_tag attribute: datatypes should match ----//; /// Given a type tag expression find the type tag itself.; ///; /// \param TypeExpr Type tag expression, as it appears in user's code.; ///; /// \param VD Declaration of an identifier that appears in a type tag.; ///; /// \param MagicValue Type tag magic value.; ///; /// \param isConstantEvaluated whether the evalaution should be performed in; /// constant context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:413,Performance,perform,performed,413,"/// Retrieve the C type corresponding to type tag TypeExpr.; ///; /// \param TypeExpr Expression that specifies a type tag.; ///; /// \param MagicValues Registered magic values.; ///; /// \param FoundWrongKind Set to true if a type tag was found, but of a wrong; /// kind.; ///; /// \param TypeInfo Information about the corresponding C type.; ///; /// \param isConstantEvaluated whether the evalaution should be performed in; /// constant context.; ///; /// \returns true if the corresponding C type was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Modifiability,Variab,Variable,3,// Variable declaration that has type_tag_for_datatype attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:194,Integrability,depend,depending,194,"// C++11 [basic.fundamental] p1:; // Plain char, signed char, and unsigned char are three distinct types.; //; // But we treat plain `char' as equivalent to `signed char' or `unsigned; // char' depending on the current char signedness mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:34,Security,access,access,34,// Synthesize offset of the whole access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:268,Energy Efficiency,reduce,reduced,268,"// If this happens, we want to determine a sensible culprit of this.; // Intuitively, watching the chain of member expressions from right to; // left, we start with the required alignment (as required by the field; // type) but some packed attribute in that chain has reduced the alignment.; // It may happen that another packed structure increases it again. But if; // we are here such increase has not been enough. So pointing the first; // FieldDecl that either is packed or else its RecordDecl is,; // seems reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:73,Usability,Intuit,Intuitively,73,"// If this happens, we want to determine a sensible culprit of this.; // Intuitively, watching the chain of member expressions from right to; // left, we start with the required alignment (as required by the field; // type) but some packed attribute in that chain has reduced the alignment.; // It may happen that another packed structure increases it again. But if; // we are here such increase has not been enough. So pointing the first; // FieldDecl that either is packed or else its RecordDecl is,; // seems reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Deployability,Update,Update,3,// Update call argument to use the possibly converted matrix argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:80,Integrability,Depend,DependentTy,80,"// If any part of the result matrix type is still pending, just use; // Context.DependentTy, until all parts are resolved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:84,Integrability,rout,routines,84,"/// The type of a name-lookup filter, which can be provided to the; /// name-lookup routines to specify which declarations should be included in; /// the result set (when it returns true) and which declarations should be; /// filtered out (returns false).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:41,Performance,optimiz,optimized,41,"/// An entry in the shadow map, which is optimized to store; /// a single (declaration, index) mapping (the common case) but; /// can also store a list of (declaration, index) mappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:26,Energy Efficiency,allocate,allocate,26,/// The allocator used to allocate new code-completion strings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:101,Modifiability,inherit,inheritance,101,"/// A list of shadow maps, which is used to model name hiding at; /// different levels of, e.g., the inheritance hierarchy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:213,Availability,avail,available,213,"/// Set the cv-qualifiers on the object type, for us in filtering; /// calls to member functions.; ///; /// When there are qualifiers in this set, they will be used to filter; /// out member functions that aren't available (because there will be a; /// cv-qualifier mismatch) or prefer functions with an exact qualifier; /// match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:35,Energy Efficiency,allocate,allocate,35,/// Retrieve the allocator used to allocate code completion strings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:168,Security,access,access,168,"/// Decide whether or not a use of function Decl can be a call.; ///; /// \param ND the function declaration.; ///; /// \param BaseExprType the object type in a member access expression,; /// if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:179,Security,access,access,179,"/// Decide whether or not a use of member function Decl can be a call.; ///; /// \param Method the function declaration.; ///; /// \param BaseExprType the object type in a member access expression,; /// if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:500,Security,access,access,500,"/// Add a new result to this result set, where we already know; /// the hiding declaration (if any).; ///; /// \param R the result to add (if it is unique).; ///; /// \param CurContext the context in which this result will be named.; ///; /// \param Hiding the declaration that hides the result.; ///; /// \param InBaseClass whether the result was found in a base; /// class of the searched context.; ///; /// \param BaseExprType the type of expression that precedes the ""."" or ""->""; /// in a member access expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Testability,Log,Logical,3,"// Logical operators, assume we want bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:55,Testability,assert,assertion,55,"// FIXME(ibiryukov): handle the missing op, re-add the assertion.; // assert(false && ""unhandled binary op"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:70,Testability,assert,assert,70,"// FIXME(ibiryukov): handle the missing op, re-add the assertion.; // assert(false && ""unhandled binary op"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:32,Deployability,update,update,32,"// Keep the expected type, only update the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:6,Usability,simpl,simplified,6,"/// A simplified classification of types used to determine whether two; /// types are ""similar enough"" when adjusting priorities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:76,Availability,down,down,76,"// Dig through references, function pointers, and block pointers to; // get down to the likely type of an expression when the entity is; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:83,Integrability,message,message,83,"// Use CCP_Type for type declarations unless we're in a statement, Objective-C; // message receiver, or parenthesized expression context. There, it's as; // likely that the user will want to write a type as other declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Integrability,Protocol,Protocols,3,// Protocols are in distinct namespaces from everything else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:213,Integrability,depend,depending,213,"// Will Candidate ever be called on the object, when overloaded with Incumbent?; // Returns Dominates if Candidate is always called, Dominated if Incumbent is; // always called, BothViable if either may be called depending on arguments.; // Precondition: must actually be overloads!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:92,Security,access,access,92,"// We apply heuristics only to CCC_Symbol:; // * CCC_{Arrow,Dot}MemberAccess reflect member access expressions:; // f.method() and f->method(). These are always calls.; // * A qualified name to a member function may *not* be a call. We have to; // subdivide the cases: For example, f.Base::method(), which is regarded as; // CCC_Symbol, should be a call.; // * Non-member functions and static member functions are always considered; // calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Safety,Detect,Detect,3,// Detect cases where a ref-qualified method cannot be invoked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:15,Integrability,interface,interfaces,15,// Objective-C interfaces names are not filtered by this method because they; // can be used in a class property expression. We can still filter out; // @class declarations though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:31,Integrability,interface,interfaces,31,"// For purposes of this check, interfaces match too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Performance,perform,perform,19,"// FIXME: We could perform more analysis here to determine whether a; // particular class type has any conversions to Objective-C types. For now,; // just accept all class types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:77,Modifiability,variab,variable,77,/// Determines whether the given declaration is an Objective-C; /// instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:41,Security,access,access-checking,41,// NamingClass and BaseType are used for access-checking. See; // Sema::IsSimplyAccessible for details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,Security,access,access,27,"// Naming class to use for access check. In most cases it was provided; // explicitly (e.g. member access (lhs.foo) or qualified lookup (X::)),; // for unqualified lookup we fallback to the \p Ctx in which we found the; // member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:99,Security,access,access,99,"// Naming class to use for access check. In most cases it was provided; // explicitly (e.g. member access (lhs.foo) or qualified lookup (X::)),; // for unqualified lookup we fallback to the \p Ctx in which we found the; // member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:130,Safety,avoid,avoid,130,"// When we emulate implicit 'this->' in an unqualified lookup, we might; // end up with an invalid naming class. In that case, we avoid emulating; // 'this->' qualifier to satisfy preconditions of the access checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:201,Security,access,access,201,"// When we emulate implicit 'this->' in an unqualified lookup, we might; // end up with an invalid naming class. In that case, we avoid emulating; // 'this->' qualifier to satisfy preconditions of the access checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:58,Security,access,access,58,"// The decl was found outside the C++ class, so only ObjC access checks; // apply. Those do not rely on NamingClass and BaseType, so we clear them; // out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:136,Usability,clear,clear,136,"// The decl was found outside the C++ class, so only ObjC access checks; // apply. Those do not rely on NamingClass and BaseType, so we clear them; // out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:144,Integrability,rout,routine,144,/// Retrieve the string representation of the given type as a string; /// that has the appropriate lifetime for code completion.; ///; /// This routine provides a fast path where we provide constant strings for; /// common type names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:45,Integrability,depend,dependent,45,// using typename qualifier::name (only in a dependent context),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:40,Integrability,depend,depending,40,"// ""return expression ;"" or ""return ;"", depending on the return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:7,Integrability,interface,interface,7,// The interface can be NULL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:144,Availability,avail,available,144,"// Params are unavailable in FunctionTypeLoc if the FunctionType is invalid.; // It would be better to pass in the param Type, which is usually available.; // But this case is rare, so just pretend we fell back to int as elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:22,Integrability,depend,dependent,22,// The argument for a dependent or non-block parameter is a placeholder; // containing that parameter's type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,Usability,simpl,simple,27,// Non-variadic macros are simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:118,Energy Efficiency,allocate,allocated,118,"/// If possible, create a new code completion string for the given; /// result.; ///; /// \returns Either a new, heap-allocated code completion string describing; /// how to use this result, or NULL to indicate that the string or name of the; /// result is all that is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Safety,Avoid,Avoid,3,// Avoid running it if this is not a call: We should emit *all* template; // parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:338,Safety,Detect,Detect,338,"// Some of the function template arguments cannot be deduced from a; // function call, so we introduce an explicit template argument list; // containing all of the arguments up to the first deducible argument.; //; // Or, if this isn't a call, emit all the template arguments; // to disambiguate the (potential) overloads.; //; // FIXME: Detect cases where the function parameters can be deduced from; // the surrounding context, as per [temp.deduct.funcaddr].; // e.g.,; // template <class T> void foo(T);; // void (*f)(int) = foo;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:162,Safety,avoid,avoids,162,"// Show signatures of constructors as they are declared:; // vector(int n) rather than vector<string>(int n); // This is less noisy without being less clear, and avoids tricky cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:151,Usability,clear,clear,151,"// Show signatures of constructors as they are declared:; // vector(int n) rather than vector<string>(int n); // This is less noisy without being less clear, and avoids tricky cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:24,Availability,avail,availability,24,"// FIXME: Set priority, availability appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Performance,Load,Load,3,// Load the named module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:182,Integrability,message,message,182,"// If we're in a context where we might have an expression (rather than a; // declaration), and what we've seen so far is an Objective-C type that could; // be a receiver of a class message, this may be a class message send with; // the initial opening bracket '[' missing. Add appropriate completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:211,Integrability,message,message,211,"// If we're in a context where we might have an expression (rather than a; // declaration), and what we've seen so far is an Objective-C type that could; // be a receiver of a class message, this may be a class message send with; // the initial opening bracket '[' missing. Add appropriate completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:48,Availability,redundant,redundant,48,/// Information that allows to avoid completing redundant enumerators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:31,Safety,avoid,avoid,31,/// Information that allows to avoid completing redundant enumerators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:48,Safety,redund,redundant,48,/// Information that allows to avoid completing redundant enumerators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Performance,Perform,Perform,4,/// Perform code-completion in an expression context when we know what; /// type we're looking for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:32,Integrability,protocol,protocols,32,// Add properties in referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:24,Performance,perform,performing,24,"// Indicate that we are performing a member access, and the cv-qualifiers; // for the base object type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:44,Security,access,access,44,"// Indicate that we are performing a member access, and the cv-qualifiers; // for the base object type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Security,Access,Access,3,"// Access to a C/C++ class, struct, or union.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:143,Integrability,depend,dependent,143,"// The ""template"" keyword can follow ""->"" or ""."" in the grammar.; // However, we only want to suggest the template keyword if something; // is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:194,Integrability,depend,dependent,194,"// Returns the RecordDecl inside the BaseType, falling back to primary template; // in case of specializations. Since we might not have a decl for the; // instantiation/specialization yet, e.g. dependent code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:201,Availability,down,down,201,"// Collects completion-relevant information about a concept-constrainted type T.; // In particular, examines the constraint expressions to find members of T.; //; // The design is very simple: we walk down each constraint looking for; // expressions of the form T.foo().; // If we're extra lucky, the return type is specified.; // We don't do any clever handling of && or || in constraint expressions, we; // take members from both branches.; //; // For example, given:; // template <class T> concept X = requires (T t, string& s) { t.print(s); };; // template <X U> void foo(U u) { u.^ }; // We want to suggest the inferred member function 'print(string)'.; // We see that u has type U, so X<U> holds.; // X<U> requires t.print(s) to be valid, where t has type U (substituted for T).; // By looking at the CallExpr we find the signature of print().; //; // While we tend to know in advance which kind of members (access via . -> ::); // we want, it's simpler just to gather them all and post-filter.; //; // FIXME: some of this machinery could be used for non-concept type-parms too,; // enabling completion for type parameters based on other uses of that param.; //; // FIXME: there are other cases where a type can be constrained by a concept,; // e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:914,Security,access,access,914,"// Collects completion-relevant information about a concept-constrainted type T.; // In particular, examines the constraint expressions to find members of T.; //; // The design is very simple: we walk down each constraint looking for; // expressions of the form T.foo().; // If we're extra lucky, the return type is specified.; // We don't do any clever handling of && or || in constraint expressions, we; // take members from both branches.; //; // For example, given:; // template <class T> concept X = requires (T t, string& s) { t.print(s); };; // template <X U> void foo(U u) { u.^ }; // We want to suggest the inferred member function 'print(string)'.; // We see that u has type U, so X<U> holds.; // X<U> requires t.print(s) to be valid, where t has type U (substituted for T).; // By looking at the CallExpr we find the signature of print().; //; // While we tend to know in advance which kind of members (access via . -> ::); // we want, it's simpler just to gather them all and post-filter.; //; // FIXME: some of this machinery could be used for non-concept type-parms too,; // enabling completion for type parameters based on other uses of that param.; //; // FIXME: there are other cases where a type can be constrained by a concept,; // e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:185,Usability,simpl,simple,185,"// Collects completion-relevant information about a concept-constrainted type T.; // In particular, examines the constraint expressions to find members of T.; //; // The design is very simple: we walk down each constraint looking for; // expressions of the form T.foo().; // If we're extra lucky, the return type is specified.; // We don't do any clever handling of && or || in constraint expressions, we; // take members from both branches.; //; // For example, given:; // template <class T> concept X = requires (T t, string& s) { t.print(s); };; // template <X U> void foo(U u) { u.^ }; // We want to suggest the inferred member function 'print(string)'.; // We see that u has type U, so X<U> holds.; // X<U> requires t.print(s) to be valid, where t has type U (substituted for T).; // By looking at the CallExpr we find the signature of print().; //; // While we tend to know in advance which kind of members (access via . -> ::); // we want, it's simpler just to gather them all and post-filter.; //; // FIXME: some of this machinery could be used for non-concept type-parms too,; // enabling completion for type parameters based on other uses of that param.; //; // FIXME: there are other cases where a type can be constrained by a concept,; // e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:952,Usability,simpl,simpler,952,"// Collects completion-relevant information about a concept-constrainted type T.; // In particular, examines the constraint expressions to find members of T.; //; // The design is very simple: we walk down each constraint looking for; // expressions of the form T.foo().; // If we're extra lucky, the return type is specified.; // We don't do any clever handling of && or || in constraint expressions, we; // take members from both branches.; //; // For example, given:; // template <class T> concept X = requires (T t, string& s) { t.print(s); };; // template <X U> void foo(U u) { u.^ }; // We want to suggest the inferred member function 'print(string)'.; // We see that u has type U, so X<U> holds.; // X<U> requires t.print(s) to be valid, where t has type U (substituted for T).; // By looking at the CallExpr we find the signature of print().; //; // While we tend to know in advance which kind of members (access via . -> ::); // we want, it's simpler just to gather them all and post-filter.; //; // FIXME: some of this machinery could be used for non-concept type-parms too,; // enabling completion for type parameters based on other uses of that param.; //; // FIXME: there are other cases where a type can be constrained by a concept,; // e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Security,access,accessed,19,"// Whether this is accessed as T.member, T->member, or T::member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:36,Modifiability,variab,variable,36,// What's known about the type of a variable or return type of a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:53,Modifiability,variab,variable,53,"// FIXME: also track:; // - kind of entity (function/variable/type), to expose structured results; // - template args kinds/types, as a proxy for template params; // For now we simply return these results as ""pattern"" strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:72,Security,expose,expose,72,"// FIXME: also track:; // - kind of entity (function/variable/type), to expose structured results; // - template args kinds/types, as a proxy for template params; // For now we simply return these results as ""pattern"" strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:177,Usability,simpl,simply,177,"// FIXME: also track:; // - kind of entity (function/variable/type), to expose structured results; // - template args kinds/types, as a proxy for template params; // For now we simply return these results as ""pattern"" strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:73,Security,access,accessible,73,"// BaseType is the type parameter T to infer members from.; // T must be accessible within S, as we use it to find the template entity; // that T is attached to in order to gather the relevant constraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:52,Integrability,depend,dependent,52,"// Infer members of T, given that the expression E (dependent on T) is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:270,Usability,simpl,simplicity,270,"// If the concept is; // template <class A, class B> concept CD = f<A, B>();; // And the concept specialization is; // CD<int, T>; // Then we're substituting T for B, so we want to make f<A, B>() true; // by adding members to B - i.e. believe(f<A, B>(), B);; //; // For simplicity:; // - we don't attempt to substitute int for A; // - when T is used in other ways (like CD<T*>) we ignore it",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:69,Availability,error,error,69,// Can't tell us anything about T.; // Now Req cannot a substitution-error: those aren't dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:89,Integrability,depend,dependent,89,// Can't tell us anything about T.; // Now Req cannot a substitution-error: those aren't dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:50,Modifiability,variab,variable,50,"// In T.foo or T->foo, `foo` is a member function/variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:48,Modifiability,variab,variable,48,"// In T::foo, `foo` is a static member function/variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:111,Modifiability,variab,variable,111,"// If this is the callee of an immediately-enclosing CallExpr, then; // treat it as a method, otherwise it's a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:77,Modifiability,variab,variables,77,// Gets all the type constraint expressions that might apply to the type; // variables associated with DC (as returned by getTemplatedEntity()).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:107,Integrability,Depend,DependentTy,107,"// Returns a type for E that yields acceptable member completions.; // In particular, when E->getType() is DependentTy, try to guess a likely type.; // We accept some lossiness (like dropping parameters).; // We only try to handle common expressions on the LHS of MemberExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Integrability,Depend,DependentTy,19,"// We only resolve DependentTy, or undeduced autos (including auto* etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:5,Integrability,depend,dependent,5,"// A dependent member: approximate-resolve the base, then lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:28,Modifiability,variab,variable,28,// A reference to an `auto` variable: approximate-resolve its initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:49,Performance,perform,performing,49,"// Objective-C property reference. Bail if we're performing fix-it code; // completion since Objective-C properties are normally backed by ivars,; // most Objective-C fix-its here would have little value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:37,Integrability,interface,interface,37,// Add property results based on our interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,Integrability,protocol,protocols,27,// Add properties from the protocols in a qualified interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:52,Integrability,interface,interface,52,// Add properties from the protocols in a qualified interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:24,Modifiability,variab,variable,24,"// Objective-C instance variable access. Bail if we're performing fix-it; // code completion since Objective-C properties are normally backed by; // ivars, most Objective-C fix-its here would have little value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:55,Performance,perform,performing,55,"// Objective-C instance variable access. Bail if we're performing fix-it; // code completion since Objective-C properties are normally backed by; // ivars, most Objective-C fix-its here would have little value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:33,Security,access,access,33,"// Objective-C instance variable access. Bail if we're performing fix-it; // code completion since Objective-C properties are normally backed by; // ivars, most Objective-C fix-its here would have little value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:378,Integrability,depend,dependent,378,"// We look into the AST of the case statement to determine which; // enumerator was named. Alternatively, we could compute the value of; // the integral constant expression, then compare it against the; // values of each enumerator. However, value-based approach would not; // work as well with C++ templates where enumerators declared within a; // template are type- and value-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:173,Availability,recover,recover,173,"// Given a callee expression `Fn`, if the call is through a function pointer,; // try to find the declaration of the corresponding function pointer type,; // so that we can recover argument names from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:173,Safety,recover,recover,173,"// Given a callee expression `Fn`, if the call is through a function pointer,; // try to find the declaration of the corresponding function pointer type,; // so that we can recover argument names from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:28,Integrability,wrap,wrapping,28,// Unwrap types that may be wrapping the function type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:75,Integrability,depend,dependent,75,// FIXME: Provide support for variadic template functions.; // Ignore type-dependent call expressions entirely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:18,Integrability,depend,dependent,18,// In presence of dependent args we surface all possible signatures using the; // non-dependent args in the prefix. Afterwards we do a post filtering to make; // sure provided candidates satisfy parameter count restrictions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:86,Integrability,depend,dependent,86,// In presence of dependent args we surface all possible signatures using the; // non-dependent args in the prefix. Afterwards we do a post filtering to make; // sure provided candidates satisfy parameter count restrictions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:37,Modifiability,variab,variable,37,"// Ignore VD to avoid completing the variable itself, e.g. in 'int foo = ^'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Safety,avoid,avoid,16,"// Ignore VD to avoid completing the variable itself, e.g. in 'int foo = ^'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:39,Security,access,accessible,39,"// As SS is invalid, we try to collect accessible contexts from the current; // scope with a dummy lookup so that the completion consumer can try to; // guess what the specified scope is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:2,Performance,Load,LoadExternal,2,/*LoadExternal=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:54,Integrability,depend,dependent,54,// Always pretend to enter a context to ensure that a dependent type; // resolves to a dependent record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:87,Integrability,depend,dependent,87,// Always pretend to enter a context to ensure that a dependent type; // resolves to a dependent record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:30,Integrability,depend,dependent,30,// Try to instantiate any non-dependent declaration contexts before; // we look in them. Bail out if we fail.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:127,Integrability,depend,dependent,127,"// The ""template"" keyword can follow ""::"" in the grammar, but only; // put it into the grammar if the nested-name-specifier is dependent.; // FIXME: results is always empty, this appears to be dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:146,Modifiability,extend,extended,146,"// We only want to see those namespaces that have already been defined; // within this scope, because its likely that the user is creating an; // extended namespace declaration. Keep track of the most recent; // definition of each namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:38,Modifiability,extend,extended,38,// Add the most recent definition (or extended definition) of each; // namespace to the list of results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:29,Modifiability,variab,variables,29,// Look for other capturable variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:92,Integrability,depend,depending,92,"/// Macro that optionally prepends an ""@"" to the string literal passed in via; /// Keyword, depending on whether NeedAt is true or false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,interface,interface,20,"// Since we have an interface or protocol, we can end it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:33,Integrability,protocol,protocol,33,"// Since we have an interface or protocol, we can end it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Integrability,interface,interface,4,"// @interface name; // FIXME: Could introduce the whole pattern, including superclasses and; // such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Integrability,protocol,protocol,4,// @protocol name,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Integrability,protocol,protocol,4,// @protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:15,Integrability,protocol,protocol-name,15,// @protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Integrability,synchroniz,synchronized,4,// @synchronized ( expression ) { statements },MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:41,Safety,avoid,avoid,41,"/// A set of selectors, which is used to avoid introducing multiple; /// completions with the same selector into the result set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:143,Integrability,protocol,protocol,143,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:318,Integrability,protocol,protocols,318,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:530,Integrability,rout,routine,530,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:626,Performance,perform,performing,626,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:49,Integrability,message,messaged,49,// The instance methods on the root class can be messaged via the; // metaclass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:13,Integrability,protocol,protocols,13,// Visit the protocols of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:26,Integrability,protocol,protocols,26,// Visit the protocols of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:18,Integrability,protocol,protocols,18,// Add methods in protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,protocol,protocol,20,// Add a categories protocol methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Safety,Avoid,Avoid,34,// Add methods in superclass.; // Avoid passing in IsRootClass since root classes won't have super classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Integrability,interface,interface,19,// Try to find the interface where getters might live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Integrability,interface,interface,19,// Try to find the interface where setters might live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:168,Integrability,rout,routine,168,"/// When we have an expression with type ""id"", we may assume; /// that it has some more-specific class type based on knowledge of; /// common uses of Objective-C. This routine returns that class type,; /// or NULL if no better result could be determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:46,Integrability,message,message,46,// Determine the class that we're sending the message to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Integrability,message,message,34,"// Add a special completion for a message send to ""super"", which fills in the; // most likely case of forwarding all of our arguments to the superclass; // function.; ///; /// \param S The semantic analysis object.; ///; /// \param NeedSuperKeyword Whether we need to prefix this completion with; /// the ""super"" keyword. Otherwise, we just need to provide the arguments.; ///; /// \param SelIdents The identifiers in the selector that have already been; /// provided as arguments for a send to ""super"".; ///; /// \param Results The set of results to augment.; ///; /// \returns the Objective-C method declaration that would be invoked by; /// this ""super"" completion. If NULL, no completion was added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,interface,interface,20,// Figure out which interface we're in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:58,Integrability,message,message,58,"// We are inside an instance method, which means that the message; // send [super ...] is actually calling an instance method on the; // current object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:40,Modifiability,variab,variable,40,"// ""super"" may be the name of a type or variable. Figure out which; // it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,interface,interface,20,"// ""super"" names an interface. Use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:65,Integrability,message,message,65,"/// Given a set of code-completion results for the argument of a message; /// send, determine the preferred type (if any) for that argument expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Integrability,interface,interface,34,"// If the given name refers to an interface type, retrieve the; // corresponding declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:65,Integrability,protocol,protocols,65,"// Add all of the factory methods in this Objective-C class, its protocols,; // superclasses, categories, implementation, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:105,Performance,load,load,105,"// We're messaging ""id"" as a type; provide all class/factory methods.; // If we have an external source, load the entire class method; // pool from the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:104,Performance,perform,performing,104,"// If we're actually at the argument expression (rather than prior to the; // selector), we're actually performing code completion for an expression.; // Determine whether we have a single, best method. If so, we can; // code-complete the expression using the corresponding parameter type as; // our preferred type, improving completion results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,message,messages,10,"// Handle messages to Class. This really isn't a message to an instance; // method, so we treat it the same way we would treat a message send to a; // class method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:49,Integrability,message,message,49,"// Handle messages to Class. This really isn't a message to an instance; // method, so we treat it the same way we would treat a message send to a; // class method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:129,Integrability,message,message,129,"// Handle messages to Class. This really isn't a message to an instance; // method, so we treat it the same way we would treat a message send to a; // class method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,message,messages,10,"// Handle messages to a qualified ID (""id<foo>"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,protocol,protocols,10,// Search protocols for instance methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,message,messages,10,// Handle messages to a pointer to interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:35,Integrability,interface,interface,35,// Handle messages to a pointer to interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,protocol,protocols,10,// Search protocols for instance methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,Integrability,message,messages,10,"// Handle messages to ""id"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:138,Performance,load,load,138,"// We're messaging ""id"", so provide all instance methods we know; // about as code-completion results.; // If we have an external source, load the entire class method; // pool from the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:104,Performance,perform,performing,104,"// If we're actually at the argument expression (rather than prior to the; // selector), we're actually performing code completion for an expression.; // Determine whether we have a single, best method. If so, we can; // code-complete the expression using the corresponding parameter type as; // our preferred type, improving completion results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Performance,load,load,34,"// If we have an external source, load the entire class method; // pool from the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Integrability,protocol,protocol,19,/// Add all of the protocol declarations that we find in the given; /// (translation unit) context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:14,Integrability,protocol,protocols,14,// Record any protocols we find.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:44,Integrability,protocol,protocols,44,// Tell the result set to ignore all of the protocols we have; // already seen.; // FIXME: This doesn't work when caching code-completion results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:11,Integrability,protocol,protocols,11,// Add all protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:11,Integrability,protocol,protocols,11,// Add all protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:31,Integrability,interface,interface,31,/// Add all of the Objective-C interface declarations that we find in; /// the given (translation unit) context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:14,Integrability,interface,interfaces,14,// Record any interfaces we find.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:80,Integrability,interface,interface,80,// Ignore any categories we find that have already been implemented by this; // interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:26,Integrability,interface,interface,26,"// Find the corresponding interface. If we couldn't find the interface, the; // program itself is ill-formed. However, we'll try to be helpful still by; // providing the list of all of the categories we know about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:61,Integrability,interface,interface,61,"// Find the corresponding interface. If we couldn't find the interface, the; // program itself is ill-formed. However, we'll try to be helpful still by; // providing the list of all of the categories we know about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:53,Integrability,interface,interface,53,"// Add all of the categories that have corresponding interface; // declarations in this class and any of its superclasses, except for; // already-implemented categories in the class itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,Integrability,interface,interface,20,// Figure out which interface we're looking into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,Modifiability,variab,variables,27,// Add all of the instance variables in this class and its superclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Energy Efficiency,Reduce,Reduce,3,"// Reduce the priority of this result by one, to give it a slight; // advantage over other results whose names don't match so closely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:91,Integrability,protocol,protocols,91,"/// Find all of the methods that reside in the given container; /// (and its superclasses, protocols, etc.) that meet the given; /// criteria. Insert those methods into the map of known methods,; /// indexed by selector so they can be easily found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Integrability,protocol,protocols,16,// Recurse into protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:55,Integrability,interface,interface,55,"// If this category is the original class, jump to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,Integrability,protocol,protocols,16,// Recurse into protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:44,Modifiability,inherit,inherits,44,/// Determine whether the given class is or inherits from a class by; /// the given name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:18,Security,access,accessor,18,// Add the normal accessor -(type)key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:121,Security,access,accessor,121,"// If we have an integral or boolean property (or the user has provided; // an integral or boolean return type), add the accessor -(type)isKey.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:25,Security,access,accessors,25,// Indexed and unordered accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:11,Integrability,interface,interface,11,"// If this interface type is not provably derived from a known; // collection, penalize the corresponding completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,Security,access,accessors,19,// Mutable indexed accessors; // - (void)insertObject:(type *)object inKeyAtIndex:(NSUInteger)index,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:21,Security,access,accessors,21,// Mutable unordered accessors; // - (void)addKeyObject:(type *)object,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:48,Security,access,accessor,48,// Add Key-Value-Coding and Key-Value-Observing accessor methods for all of; // the properties in this class and its categories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Performance,load,load,34,"// If we have an external source, load the entire class method; // pool from the AST file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Availability,error,error,4,// #error <message>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:11,Integrability,message,message,11,// #error <message>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:13,Integrability,message,message,13,// #warning <message>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:233,Testability,assert,assert,233,"// Note: #ident and #sccs are such crazy anachronisms that we don't provide; // completions for them. And __include_macros is a Clang-internal extension; // that we don't want to encourage anyone to use.; // FIXME: we don't support #assert or #unassert, so don't suggest them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:17,Safety,detect,detect,17,// FIXME: Can we detect when the user just wrote an include guard above?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:108,Usability,simpl,simplicity,108,"// RelDir should use /, but unescaped \ is possible on windows!; // Our completions will normalize to / for simplicity, this case is rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Safety,Avoid,Avoid,3,// Avoid dangling StringRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:496,Availability,error,error,496,"// We have the following case:; // template<typename> requires func(0) struct S { };; // The user probably isn't aware of the parentheses required around; // the function call, and we're only going to parse 'func' as the; // primary-expression, and complain that it is of non-bool type.; //; // However, if we're in a lambda, this might also be:; // []<typename> requires var () {};; // Which also looks like a function call due to the lambda parentheses,; // but unlike the first case, isn't an error, so this check is skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:71,Availability,Recover,RecoveryExpr,71,"// We don't have the ability to evaluate this, since it contains a; // RecoveryExpr, so we want to fail overload resolution. Otherwise,; // we'd potentially pick up a different overload, and cause confusing; // diagnostics. SO, add a failure detail that will cause us to make this; // overload set not viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:234,Availability,failure,failure,234,"// We don't have the ability to evaluate this, since it contains a; // RecoveryExpr, so we want to fail overload resolution. Otherwise,; // we'd potentially pick up a different overload, and cause confusing; // diagnostics. SO, add a failure detail that will cause us to make this; // overload set not viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:71,Safety,Recover,RecoveryExpr,71,"// We don't have the ability to evaluate this, since it contains a; // RecoveryExpr, so we want to fail overload resolution. Otherwise,; // we'd potentially pick up a different overload, and cause confusing; // diagnostics. SO, add a failure detail that will cause us to make this; // overload set not viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:222,Availability,recover,recovery,222,"// Note that we have to do this with our own collection, because there are; // times where a constraint-expression check can cause us to need to evaluate; // other constriants that are unrelated, such as when evaluating a recovery; // expression, or when trying to determine the constexpr-ness of special; // members. Otherwise we could just use the; // Sema::InstantiatingTemplate::isAlreadyBeingInstantiated function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:222,Safety,recover,recovery,222,"// Note that we have to do this with our own collection, because there are; // times where a constraint-expression check can cause us to need to evaluate; // other constriants that are unrelated, such as when evaluating a recovery; // expression, or when trying to determine the constexpr-ness of special; // members. Otherwise we could just use the; // Sema::InstantiatingTemplate::isAlreadyBeingInstantiated function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:18,Availability,error,error,18,// We do not want error diagnostics escaping here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:16,Availability,error,error,16,// A non-SFINAE error has occurred as a result of this; // substitution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:517,Modifiability,extend,extend,517,"// [temp.constr.atomic]p3: To determine if an atomic constraint is; // satisfied, the parameter mapping and template arguments are first; // substituted into its expression. If substitution results in an; // invalid type or expression, the constraint is not satisfied.; // Otherwise, the lvalue-to-rvalue conversion is performed if necessary,; // and E shall be a constant expression of type bool.; //; // Perform the L to R Value conversion if necessary. We do so for all; // non-PRValue categories, else we fail to extend the lifetime of; // temporaries, and that fails the constant expression check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:319,Performance,perform,performed,319,"// [temp.constr.atomic]p3: To determine if an atomic constraint is; // satisfied, the parameter mapping and template arguments are first; // substituted into its expression. If substitution results in an; // invalid type or expression, the constraint is not satisfied.; // Otherwise, the lvalue-to-rvalue conversion is performed if necessary,; // and E shall be a constant expression of type bool.; //; // Perform the L to R Value conversion if necessary. We do so for all; // non-PRValue categories, else we fail to extend the lifetime of; // temporaries, and that fails the constant expression check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:406,Performance,Perform,Perform,406,"// [temp.constr.atomic]p3: To determine if an atomic constraint is; // satisfied, the parameter mapping and template arguments are first; // substituted into its expression. If substitution results in an; // invalid type or expression, the constraint is not satisfied.; // Otherwise, the lvalue-to-rvalue conversion is performed if necessary,; // and E shall be a constant expression of type bool.; //; // Perform the L to R Value conversion if necessary. We do so for all; // non-PRValue categories, else we fail to extend the lifetime of; // temporaries, and that fails the constant expression check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:37,Integrability,depend,dependent,37,// No need to check satisfaction for dependent constraint expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:55,Safety,predict,predictible,55,"// A list of the template argument list flattened in a predictible manner for; // the purposes of caching. The ConstraintSatisfaction type is in AST so it; // has no access to the MultiLevelTemplateArgumentList, so this has to happen; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:166,Security,access,access,166,"// A list of the template argument list flattened in a predictible manner for; // the purposes of caching. The ConstraintSatisfaction type is in AST so it; // has no access to the MultiLevelTemplateArgumentList, so this has to happen; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:150,Availability,Recover,RecoveryExpr,150,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:234,Performance,cache,cached,234,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:473,Performance,cache,cached,473,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:150,Safety,Recover,RecoveryExpr,150,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:15,Usability,simpl,simply,15,// Else we can simply add this satisfaction to the list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:46,Integrability,depend,dependent,46,"// Don't check constraints if the function is dependent. Also don't check if; // this is a function template specialization, as the call to; // CheckinstantiatedFunctionTemplateConstraints after this will check it; // better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:2,Security,Access,AccessCheckingSFINAE,2,/*AccessCheckingSFINAE=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:112,Integrability,Depend,DependsOnEnclosingTemplate,112,"// The logic for non-templates is handled in ASTContext::isSameEntity, so we; // don't have to bother checking 'DependsOnEnclosingTemplate' for a; // non-function-template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:7,Testability,log,logic,7,"// The logic for non-templates is handled in ASTContext::isSameEntity, so we; // don't have to bother checking 'DependsOnEnclosingTemplate' for a; // non-function-template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:5,Usability,simpl,simple,5,// A simple case - expr type is the type being constrained and the concept; // was not provided arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:156,Availability,down,down,156,"// These two cases will in practice only be reached when using fold; // expressions with || and &&, since otherwise the || and && will have been; // broken down into atomic constraints during satisfaction checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:36,Integrability,depend,dependent,36,// FIXME: RequiresExpr should store dependent diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:100,Safety,avoid,avoid,100,"// In case the ConstrainedDecl comes from modules, it is necessary to use; // the canonical decl to avoid different atomic constraints with the 'same'; // declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:34,Integrability,depend,dependent,34,// We reach this ctor with either dependent types (in which; // IsSatisfied doesn't matter) or with non-dependent type in; // which the existence of the type indicates satisfaction.; /*IsSatisfied=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:104,Integrability,depend,dependent,104,// We reach this ctor with either dependent types (in which; // IsSatisfied doesn't matter) or with non-dependent type in; // which the existence of the type indicates satisfaction.; /*IsSatisfied=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConsumer.cpp:36,Integrability,interface,interface,36,"//===-- SemaConsumer.cpp - Abstract interface for AST semantics -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:73,Usability,resume,resume,73,"// See if return type is coroutine-handle and if so, invoke builtin coro-resume; // on its address. This is to enable the support for coroutine-handle; // returning await_suspend that results in a guaranteed tail call to the target; // coroutine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:394,Deployability,update,update,394,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:550,Integrability,wrap,wrap,550,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:182,Modifiability,variab,variable,182,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:18,Performance,optimiz,optimizations,18,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:387,Security,access,access,387,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:565,Testability,log,logic,565,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:311,Integrability,contract,contract,311,"// Clean up temporary objects so that they don't live across suspension points; // unnecessarily. We choose to clean up before the call to; // __builtin_coro_resume so that the cleanup code are not inserted in-between; // the resume call and return instruction, which would interfere with the; // musttail call contract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:226,Usability,resume,resume,226,"// Clean up temporary objects so that they don't live across suspension points; // unnecessarily. We choose to clean up before the call to; // __builtin_coro_resume so that the cleanup code are not inserted in-between; // the resume call and return instruction, which would interfere with the; // musttail call contract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:27,Performance,perform,performed,27,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:1131,Performance,perform,perform,1131,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:1143,Safety,safe,safety,1143,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:1192,Safety,safe,safe,1192,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:300,Energy Efficiency,power,powerful,300,// The method here to extract the awaiter decl is not precise.; // This is intentional. Since it is hard to perform the analysis in the; // frontend due to the complexity of C++'s type systems.; // And we prefer to perform such analysis in the middle end since it is; // easier to implement and more powerful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:108,Performance,perform,perform,108,// The method here to extract the awaiter decl is not precise.; // This is intentional. Since it is hard to perform the analysis in the; // frontend due to the complexity of C++'s type systems.; // And we prefer to perform such analysis in the middle end since it is; // easier to implement and more powerful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:215,Performance,perform,perform,215,// The method here to extract the awaiter decl is not precise.; // This is intentional. Since it is hard to perform the analysis in the; // frontend due to the complexity of C++'s type systems.; // And we prefer to perform such analysis in the middle end since it is; // easier to implement and more powerful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:368,Availability,toler,tolerant,368,"// This is problematic if the user calls the await_suspend standalone. But on; // the on hand, it is not incorrect semantically since inlining is not part; // of the standard. On the other hand, it is relatively rare to call; // the await_suspend function standalone.; //; // And given we've already had the long-term plan, the current workaround; // looks relatively tolerant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:487,Integrability,wrap,wrapping,487,"/// Build calls to await_ready, await_suspend, and await_resume for a co_await; /// expression.; /// The generated AST tries to clean up temporary objects as early as; /// possible so that they don't live across suspension points if possible.; /// Having temporary objects living across suspension points unnecessarily can; /// lead to large frame size, and also lead to memory corruptions if the; /// coroutine frame is destroyed after coming back from suspension. This is done; /// by wrapping both the await_ready call and the await_suspend call with; /// ExprWithCleanups. In the end of this function, we also need to explicitly; /// set cleanup state so that the CoawaitExpr is also wrapped with an; /// ExprWithCleanups to clean up the awaiter associated with the co_await; /// expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:688,Integrability,wrap,wrapped,688,"/// Build calls to await_ready, await_suspend, and await_resume for a co_await; /// expression.; /// The generated AST tries to clean up temporary objects as early as; /// possible so that they don't live across suspension points if possible.; /// Having temporary objects living across suspension points unnecessarily can; /// lead to large frame size, and also lead to memory corruptions if the; /// coroutine frame is destroyed after coming back from suspension. This is done; /// by wrapping both the await_ready call and the await_suspend call with; /// ExprWithCleanups. In the end of this function, we also need to explicitly; /// set cleanup state so that the CoawaitExpr is also wrapped with an; /// ExprWithCleanups to clean up the awaiter associated with the co_await; /// expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:22,Integrability,wrap,wrap,22,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:116,Integrability,contract,contract,116,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:232,Integrability,wrap,wrapped,232,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:276,Usability,resume,resume,276,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:95,Integrability,wrap,wrapped,95,"// Create an initialization sequence for the promise type using the; // constructor arguments, wrapped in a parenthesized list expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:117,Performance,perform,performed,117,"// [dcl.fct.def.coroutine]5.7; // promise-constructor-arguments is determined as follows: overload; // resolution is performed on a promise constructor call created by; // assembling an argument list q_1 ... q_n . If a viable constructor is; // found ([over.match.viable]), then promise-constructor-arguments is ( q_1; // , ..., q_n ), otherwise promise-constructor-arguments is empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:402,Testability,log,logically,402,"// co_await promise.final_suspend() could end up calling; // __builtin_coro_resume for symmetric transfer if await_suspend(); // returns a handle. In that case, even __builtin_coro_resume is not; // declared as noexcept and may throw, it does not throw _into_ the; // coroutine that just suspended, but rather throws back out from; // whoever called coroutine_handle::resume(), hence we claim that; // logically it does not throw.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:368,Usability,resume,resume,368,"// co_await promise.final_suspend() could end up calling; // __builtin_coro_resume for symmetric transfer if await_suspend(); // returns a handle. In that case, even __builtin_coro_resume is not; // declared as noexcept and may throw, it does not throw _into_ the; // coroutine that just suspended, but rather throws back out from; // whoever called coroutine_handle::resume(), hence we claim that; // logically it does not throw.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:166,Availability,error,error,166,"// [dcl.fct.def.coroutine]p15; // The expression co_await promise.final_suspend() shall not be; // potentially-throwing ([except.spec]).; //; // First time seeing an error, emit the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:182,Availability,error,error,182,"// [dcl.fct.def.coroutine]p15; // The expression co_await promise.final_suspend() shall not be; // potentially-throwing ([except.spec]).; //; // First time seeing an error, emit the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:188,Integrability,message,message,188,"// [dcl.fct.def.coroutine]p15; // The expression co_await promise.final_suspend() shall not be; // potentially-throwing ([except.spec]).; //; // First time seeing an error, emit the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:287,Integrability,message,messages,287,"// We first collect all declarations that should not throw but not declared; // with noexcept. We then sort them based on the location before printing.; // This is to avoid emitting the same note multiple times on the same; // declaration, and also provide a deterministic order for the messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:167,Safety,avoid,avoid,167,"// We first collect all declarations that should not throw but not declared; // with noexcept. We then sort them based on the location before printing.; // This is to avoid emitting the same note multiple times on the same; // declaration, and also provide a deterministic order for the messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:85,Integrability,Depend,DependentCoawaitExpr,85,"// Attempts to resolve and build a CoawaitExpr from ""raw"" inputs, bailing out to; // DependentCoawaitExpr if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:171,Performance,perform,performed,171,"// [dcl.fct.def.coroutine]p12; // The deallocation function's name is looked up by searching for it in the; // scope of the promise type. If nothing is found, a search is performed in; // the global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:39,Availability,reliab,reliably,39,"// The always_inline attribute doesn't reliably apply to a coroutine,; // because the coroutine will be split into pieces and some pieces; // might be called indirectly, as in a virtual call. Even the ramp; // function cannot be inlined at -O0, due to pipeline ordering; // problems (see https://llvm.org/PR53413). Tell the user about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:252,Deployability,pipeline,pipeline,252,"// The always_inline attribute doesn't reliably apply to a coroutine,; // because the coroutine will be split into pieces and some pieces; // might be called indirectly, as in a virtual call. Even the ramp; // function cannot be inlined at -O0, due to pipeline ordering; // problems (see https://llvm.org/PR53413). Tell the user about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:32,Integrability,wrap,wrapper,32,// Build body for the coroutine wrapper statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:105,Integrability,wrap,wrap,105,// The body of the coroutine may be a try statement if it is in; // 'function-try-block' syntax. Here we wrap it into a compound; // statement for consistency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:162,Energy Efficiency,allocate,allocated,162,"// According to [dcl.fct.def.coroutine]p9, Lookup allocation functions using a; // parameter list composed of the requested size of the coroutine state being; // allocated, followed by the coroutine function's arguments. If a matching; // allocation function exists, use it. Otherwise, use an allocation function; // that just takes the requested size.; //; // [dcl.fct.def.coroutine]p9; // An implementation may need to allocate additional storage for a; // coroutine.; // This storage is known as the coroutine state and is obtained by calling a; // non-array allocation function ([basic.stc.dynamic.allocation]). The; // allocation function's name is looked up by searching for it in the scope of; // the promise type.; // - If any declarations are found, overload resolution is performed on a; // function call created by assembling an argument list. The first argument is; // the amount of space requested, and has type std::size_t. The; // lvalues p1 ... pn are the succeeding arguments.; //; // ...where ""p1 ... pn"" are defined earlier as:; //; // [dcl.fct.def.coroutine]p3; // The promise type of a coroutine is `std::coroutine_traits<R, P1, ...,; // Pn>`; // , where R is the return type of the function, and `P1, ..., Pn` are the; // sequence of types of the non-object function parameters, preceded by the; // type of the object parameter ([dcl.fct]) if the coroutine is a non-static; // member function. [dcl.fct.def.coroutine]p4 In the following, p_i is an; // lvalue of type P_i, where p1 denotes the object parameter and p_i+1 denotes; // the i-th non-object function parameter for a non-static member function,; // and p_i denotes the i-th function parameter otherwise. For a non-static; // member function, q_1 is an lvalue that denotes *this; any other q_i is an; // lvalue that denotes the parameter copy corresponding to p_i.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:421,Energy Efficiency,allocate,allocate,421,"// According to [dcl.fct.def.coroutine]p9, Lookup allocation functions using a; // parameter list composed of the requested size of the coroutine state being; // allocated, followed by the coroutine function's arguments. If a matching; // allocation function exists, use it. Otherwise, use an allocation function; // that just takes the requested size.; //; // [dcl.fct.def.coroutine]p9; // An implementation may need to allocate additional storage for a; // coroutine.; // This storage is known as the coroutine state and is obtained by calling a; // non-array allocation function ([basic.stc.dynamic.allocation]). The; // allocation function's name is looked up by searching for it in the scope of; // the promise type.; // - If any declarations are found, overload resolution is performed on a; // function call created by assembling an argument list. The first argument is; // the amount of space requested, and has type std::size_t. The; // lvalues p1 ... pn are the succeeding arguments.; //; // ...where ""p1 ... pn"" are defined earlier as:; //; // [dcl.fct.def.coroutine]p3; // The promise type of a coroutine is `std::coroutine_traits<R, P1, ...,; // Pn>`; // , where R is the return type of the function, and `P1, ..., Pn` are the; // sequence of types of the non-object function parameters, preceded by the; // type of the object parameter ([dcl.fct]) if the coroutine is a non-static; // member function. [dcl.fct.def.coroutine]p4 In the following, p_i is an; // lvalue of type P_i, where p1 denotes the object parameter and p_i+1 denotes; // the i-th non-object function parameter for a non-static member function,; // and p_i denotes the i-th function parameter otherwise. For a non-static; // member function, q_1 is an lvalue that denotes *this; any other q_i is an; // lvalue that denotes the parameter copy corresponding to p_i.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:782,Performance,perform,performed,782,"// According to [dcl.fct.def.coroutine]p9, Lookup allocation functions using a; // parameter list composed of the requested size of the coroutine state being; // allocated, followed by the coroutine function's arguments. If a matching; // allocation function exists, use it. Otherwise, use an allocation function; // that just takes the requested size.; //; // [dcl.fct.def.coroutine]p9; // An implementation may need to allocate additional storage for a; // coroutine.; // This storage is known as the coroutine state and is obtained by calling a; // non-array allocation function ([basic.stc.dynamic.allocation]). The; // allocation function's name is looked up by searching for it in the scope of; // the promise type.; // - If any declarations are found, overload resolution is performed on a; // function call created by assembling an argument list. The first argument is; // the amount of space requested, and has type std::size_t. The; // lvalues p1 ... pn are the succeeding arguments.; //; // ...where ""p1 ... pn"" are defined earlier as:; //; // [dcl.fct.def.coroutine]p3; // The promise type of a coroutine is `std::coroutine_traits<R, P1, ...,; // Pn>`; // , where R is the return type of the function, and `P1, ..., Pn` are the; // sequence of types of the non-object function parameters, preceded by the; // type of the object parameter ([dcl.fct]) if the coroutine is a non-static; // member function. [dcl.fct.def.coroutine]p4 In the following, p_i is an; // lvalue of type P_i, where p1 denotes the object parameter and p_i+1 denotes; // the i-th non-object function parameter for a non-static member function,; // and p_i denotes the i-th function parameter otherwise. For a non-static; // member function, q_1 is an lvalue that denotes *this; any other q_i is an; // lvalue that denotes the parameter copy corresponding to p_i.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:261,Performance,perform,performed,261,"// [dcl.fct.def.coroutine]p9; // The allocation function's name is looked up by searching for it in the; // scope of the promise type.; // - If any declarations are found, ...; // - If no declarations are found in the scope of the promise type, a search; // is performed in the global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:118,Performance,perform,performed,118,"// [dcl.fct.def.coroutine]p9; // If no viable function is found ([over.match.viable]), overload; // resolution; // is performed again on a function call created by passing just the amount; // of space required as an argument of type std::size_t.; //; // Proposed Change of [dcl.fct.def.coroutine]p9 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the requested alignment as; // an argument of type std:align_val_t as the second argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:349,Performance,perform,performed,349,"// [dcl.fct.def.coroutine]p9; // If no viable function is found ([over.match.viable]), overload; // resolution; // is performed again on a function call created by passing just the amount; // of space required as an argument of type std::size_t.; //; // Proposed Change of [dcl.fct.def.coroutine]p9 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the requested alignment as; // an argument of type std:align_val_t as the second argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:848,Modifiability,variab,variable,848,"// Proposed Change of [dcl.fct.def.coroutine]p12 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the lvalues p1 ... pn as the; // succeeding arguments. Otherwise, overload resolution is performed again; // on a function call created by passing just the amount of space required as; // an argument of type std::size_t.; //; // So within the proposed change in P2014RO, the priority order of aligned; // allocation functions wiht promise_type is:; //; // void* operator new( std::size_t, std::align_val_t, placement_args... );; // void* operator new( std::size_t, std::align_val_t);; // void* operator new( std::size_t, placement_args... );; // void* operator new( std::size_t);; // Helper variable to emit warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:99,Performance,perform,performed,99,"// Proposed Change of [dcl.fct.def.coroutine]p12 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the lvalues p1 ... pn as the; // succeeding arguments. Otherwise, overload resolution is performed again; // on a function call created by passing just the amount of space required as; // an argument of type std::size_t.; //; // So within the proposed change in P2014RO, the priority order of aligned; // allocation functions wiht promise_type is:; //; // void* operator new( std::size_t, std::align_val_t, placement_args... );; // void* operator new( std::size_t, std::align_val_t);; // void* operator new( std::size_t, placement_args... );; // void* operator new( std::size_t);; // Helper variable to emit warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:346,Performance,perform,performed,346,"// Proposed Change of [dcl.fct.def.coroutine]p12 in P2014R0:; // Otherwise, overload resolution is performed again on a function call; // created; // by passing the amount of space requested as an argument of type; // std::size_t as the first argument, and the lvalues p1 ... pn as the; // succeeding arguments. Otherwise, overload resolution is performed again; // on a function call created by passing just the amount of space required as; // an argument of type std::size_t.; //; // So within the proposed change in P2014RO, the priority order of aligned; // allocation functions wiht promise_type is:; //; // void* operator new( std::size_t, std::align_val_t, placement_args... );; // void* operator new( std::size_t, std::align_val_t);; // void* operator new( std::size_t, placement_args... );; // void* operator new( std::size_t);; // Helper variable to emit warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:106,Deployability,update,update,106,"// If we found a non-aligned allocation function in the promise_type,; // it indicates the user forgot to update the allocation function. Let's emit; // a warning here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:27,Availability,error,error,27,"// FIXME: We should add an error here. According to:; // [dcl.fct.def.coroutine]p12; // If no usual deallocation function is found, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:43,Integrability,wrap,wrapped,43,"// Since the body of the coroutine will be wrapped in try-catch, it will; // be incompatible with SEH __try if present in a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:240,Integrability,depend,depending,240,"// The call to get_return_object is sequenced before the call to; // initial_suspend and is invoked at most once, but there are caveats; // regarding on whether the prvalue result object may be initialized; // directly/eager or delayed, depending on the types involved.; //; // More info at https://github.com/cplusplus/papers/issues/1414",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:18,Availability,error,error,18,// Trigger a nice error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:24,Integrability,message,message,24,// Trigger a nice error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:12,Modifiability,variab,variable,12,/// Build a variable declaration for move parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:212,Modifiability,variab,variable,212,"// [dcl.fct.def.coroutine]p13; // When a coroutine is invoked, after initializing its parameters; // ([expr.call]), a copy is created for each coroutine parameter. For a; // parameter of type cv T, the copy is a variable of type cv T with; // automatic storage duration that is direct-initialized from an xvalue of; // type T referring to the parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:68,Modifiability,variab,variable,68,/// IdentifyTarget - Determine the CUDA compilation target for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:28,Modifiability,variab,variabless,28,// Only constexpr and const variabless with implicit constant attribute; // are emitted on both sides. Such variables are promoted to device side; // only if they have static constant intializers on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:108,Modifiability,variab,variables,108,// Only constexpr and const variabless with implicit constant attribute; // are emitted on both sides. Such variables are promoted to device side; // only if they have static constant intializers on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:25,Modifiability,variab,variable,25,// Function-scope static variable without explicit device or constant; // attribute are emitted; // - on both sides in host device functions; // - on device side in device or global functions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:27,Integrability,depend,depends,27,// (d) HostDevice behavior depends on compilation mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:41,Modifiability,variab,variable,41,// Check initializer for device/constant variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:32,Modifiability,variab,variable,32,// Check initializer for shared variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:19,Modifiability,variab,variable,19,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:82,Modifiability,variab,variable,82,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:132,Modifiability,variab,variable,132,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:198,Modifiability,variab,variable,198,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:287,Modifiability,variab,variables,287,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:378,Modifiability,variab,variables,378,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:556,Modifiability,variab,variables,556,"// Check whether a variable has an allowed initializer for a CUDA device side; // variable with global storage. \p VD may be a host variable to be checked for; // potential promotion to device side variable.; //; // CUDA/HIP allows only empty constructors as initializers for global; // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all; // __shared__ variables whether they are local or not (they all are implicitly; // static in CUDA). One exception is that CUDA allows constant initializers; // for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:16,Integrability,depend,dependent,16,// Do not check dependent variables since the ctor/dtor/initializer are not; // determined. Do it after instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:26,Modifiability,variab,variables,26,// Do not check dependent variables since the ctor/dtor/initializer are not; // determined. Do it after instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:30,Modifiability,variab,variable,30,// This is a host-side global variable. Check that the initializer is; // callable from the host side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:335,Availability,error,error,335,"// With -fcuda-host-device-constexpr, an unattributed constexpr function is; // treated as implicitly __host__ __device__, unless:; // * it is a variadic function (device-side variadic functions are not; // allowed), or; // * a __device__ function with this signature was already declared, in which; // case in which case we output an error, unless the __device__ decl is in a; // system header, in which case we leave the constexpr function unattributed.; //; // In addition, all function decls are treated as __host__ __device__ when; // ForceCUDAHostDeviceDepth > 0 (corresponding to code within a; // #pragma clang force_cuda_host_device_begin/end; // pair).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:113,Availability,error,error,113,"// We found a __device__ function with the same name and signature as NewD; // (ignoring CUDA attrs). This is an error unless that function is defined; // in a system header, in which case we simply return without making NewD; // host+device.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:192,Usability,simpl,simply,192,"// We found a __device__ function with the same name and signature as NewD; // (ignoring CUDA attrs). This is an error unless that function is defined; // in a system header, in which case we simply return without making NewD; // host+device.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:134,Deployability,pipeline,pipeline,134,// TODO: `__constant__` memory may be a limited resource for certain targets.; // A safeguard may be needed at the end of compilation pipeline if; // `__constant__` memory usage goes beyond limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:84,Safety,safe,safeguard,84,// TODO: `__constant__` memory may be a limited resource for certain targets.; // A safeguard may be needed at the end of compilation pipeline if; // `__constant__` memory usage goes beyond limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:18,Integrability,depend,dependent,18,// Do not promote dependent variables since the cotr/dtor/initializer are; // not determined. Do it after instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:28,Modifiability,variab,variables,28,// Do not promote dependent variables since the cotr/dtor/initializer are; // not determined. Do it after instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:128,Availability,error,errors,128,"// An HD function counts as host code if we're compiling for host, and; // device code if we're compiling for device. Defer any errors in device; // mode until the function is known-emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:128,Availability,error,errors,128,"// An HD function counts as host code if we're compiling for host, and; // device code if we're compiling for device. Defer any errors in device; // mode until the function is known-emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:113,Availability,error,error,113,"// If we know the caller will be emitted, we know this wrong-side call; // will be emitted, so it's an immediate error. Otherwise, defer the; // error until we know the caller is emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:145,Availability,error,error,145,"// If we know the caller will be emitted, we know this wrong-side call; // will be emitted, so it's an immediate error. Otherwise, defer the; // error until we know the caller is emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:23,Availability,error,error,23,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:187,Availability,error,error,187,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:274,Availability,error,error,274,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:3,Safety,Avoid,Avoid,3,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:66,Security,hash,hashtable,66,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:109,Modifiability,variab,variable,109,"// Check the wrong-sided reference capture of lambda for CUDA/HIP.; // A lambda function may capture a stack variable by reference when it is; // defined and uses the capture by reference when the lambda is called. When; // the capture and use happen on different sides, the capture is invalid and; // should be diagnosed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:58,Modifiability,variab,variables,58,"// File-scope lambda can only do init captures for global variables, which; // results in passing by value for these global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:124,Modifiability,variab,variables,124,"// File-scope lambda can only do init captures for global variables, which; // results in passing by value for these global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:104,Security,access,accessible,104,// Capture of this pointer is allowed since this pointer may be pointing to; // managed memory which is accessible on both device and host sides. It only; // results in invalid memory access if this pointer points to memory not; // accessible on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:184,Security,access,access,184,// Capture of this pointer is allowed since this pointer may be pointing to; // managed memory which is accessible on both device and host sides. It only; // results in invalid memory access if this pointer points to memory not; // accessible on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:232,Security,access,accessible,232,// Capture of this pointer is allowed since this pointer may be pointing to; // managed memory which is accessible on both device and host sides. It only; // results in invalid memory access if this pointer points to memory not; // accessible on device side.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:22,Deployability,configurat,configuration,22,// Legacy CUDA kernel configuration call,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:22,Modifiability,config,configuration,22,// Legacy CUDA kernel configuration call,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:302,Integrability,depend,dependent,302,"/// Compute the DeclContext that is associated with the given type.; ///; /// \param T the type for which we are attempting to find a DeclContext.; ///; /// \returns the declaration context represented by the type T,; /// or NULL if the declaration context cannot be computed (e.g., because it is; /// dependent and not the current instantiation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:591,Integrability,depend,dependent,591,"/// Compute the DeclContext that is associated with the given; /// scope specifier.; ///; /// \param SS the C++ scope specifier as it appears in the source; ///; /// \param EnteringContext when true, we will be entering the context of; /// this scope specifier, so we can retrieve the declaration context of a; /// class template or class template partial specialization even if it is; /// not the current instantiation.; ///; /// \returns the declaration context represented by the scope specifier @p SS,; /// or NULL if the declaration context cannot be computed (e.g., because it is; /// dependent and not the current instantiation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:305,Testability,test,tests,305,// FIXME: The fallback on the search of partial; // specialization using ContextType should be eventually removed since; // it doesn't handle the case of constrained template parameters; // correctly. Currently removing this fallback would change the; // diagnostic output for invalid code in a number of tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:82,Availability,recover,recover,82,"// A declaration of the partial specialization must be visible.; // We can always recover here, because this only happens when we're; // entering the context, and that can't happen in a SFINAE context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:82,Safety,recover,recover,82,"// A declaration of the partial specialization must be visible.; // We can always recover here, because this only happens when we're; // entering the context, and that can't happen in a SFINAE context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:67,Integrability,inject,injected,67,"// If the type of the nested name specifier is the same as the; // injected class name of the named class template, we're entering; // into that class template definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:67,Security,inject,injected,67,"// If the type of the nested name specifier is the same as the; // injected class name of the named class template, we're entering; // into that class template definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:206,Integrability,depend,dependent,206,"/// If the given nested name specifier refers to the current; /// instantiation, return the declaration that corresponds to that; /// current instantiation (C++0x [temp.dep.type]p1).; ///; /// \param NNS a dependent nested name specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:97,Integrability,rout,routine,97,"/// Require that the context specified by SS be complete.; ///; /// If SS refers to a type, this routine checks whether the type is; /// complete enough (or can be made complete enough) for name lookup; /// into the DeclContext. A type that is not yet completed can be; /// considered ""complete enough"" if it is a class/struct/union/enum; /// that is currently being defined. Or, if we have a type that names; /// a class template specialization that is not a complete type, we; /// will attempt to instantiate that class template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:16,Integrability,depend,dependent,16,"// If this is a dependent type, then we consider it complete.; // FIXME: This is wrong; we should require a (visible) definition to; // exist in this case too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:55,Performance,load,loaded,55,"// The actual information about the decl may have been loaded via an; // external source that created a new AST node/decl for the definition; // rather than reusing the one we had (DC) like the ASTReader does.; // To avoid the caller to continue using the still incomplete decl, let's; // set it to the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:217,Safety,avoid,avoid,217,"// The actual information about the decl may have been loaded via an; // external source that created a new AST node/decl for the definition; // rather than reusing the one we had (DC) like the ASTReader does.; // To avoid the caller to continue using the still incomplete decl, let's; // set it to the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:34,Availability,error,error,34,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:46,Availability,recover,recover,46,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:46,Safety,recover,recover,46,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:2,Availability,Recover,Recover,2,/*Recover*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:2,Safety,Recover,Recover,2,/*Recover*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:288,Modifiability,variab,variable,288,"/// Determines whether the given declaration is an valid acceptable; /// result for name lookup of a nested-name-specifier.; /// \param SD Declaration checked for nested-name-specifier.; /// \param IsExtension If not null and the declaration is accepted as an; /// extension, the pointed variable is assigned true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:90,Performance,perform,perform,90,"/// If the given nested-name-specifier begins with a bare identifier; /// (e.g., Base::), perform name lookup for that identifier as a; /// nested-name-specifier within the given scope, and return the result of that; /// name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:616,Availability,Error,ErrorRecoveryLookup,616,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:686,Availability,error,error,686,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:692,Availability,recover,recovery,692,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:718,Availability,recover,recovery,718,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1348,Availability,Error,ErrorRecoveryLookup,1348,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1411,Availability,error,error,1411,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1422,Availability,recover,recovery,1422,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1515,Availability,failure,failure,1515,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1061,Integrability,rout,routine,1061,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1652,Integrability,depend,dependent,1652,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1696,Modifiability,extend,extend,1696,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:730,Performance,perform,performed,730,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:692,Safety,recover,recovery,692,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:718,Safety,recover,recovery,718,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1422,Safety,recover,recovery,1422,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:22,Performance,perform,perform,22,// Determine where to perform name lookup,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:49,Security,access,access,49,"// This nested-name-specifier occurs in a member access expression, e.g.,; // x->B::f, and we are looking into the type of the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:3,Performance,Perform,Perform,3,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.; // The declaration context must be complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:130,Security,access,access,130,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.; // The declaration context must be complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:3,Deployability,Update,Update,3,// Update the DeclContext to point to the Tag definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:895,Availability,avail,available,895,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:836,Performance,perform,perform,836,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:962,Performance,perform,performed,962,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:77,Security,access,access,77,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:3,Performance,Perform,Perform,3,// Perform unqualified name lookup in the current scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:33,Integrability,depend,dependent,33,"// If we performed lookup into a dependent context and did not find anything,; // that's fine: just build a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:108,Integrability,depend,dependent,108,"// If we performed lookup into a dependent context and did not find anything,; // that's fine: just build a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:9,Performance,perform,performed,9,"// If we performed lookup into a dependent context and did not find anything,; // that's fine: just build a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:51,Availability,error,error,51,// Don't speculate if we're just trying to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:57,Availability,recover,recovery,57,// Don't speculate if we're just trying to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:57,Safety,recover,recovery,57,// Don't speculate if we're just trying to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:61,Integrability,depend,dependent,61,"// We were not able to compute the declaration context for a dependent; // base object type or prior nested-name-specifier, so this; // nested-name-specifier refers to an unknown specialization. Just build; // a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:212,Integrability,depend,dependent,212,"// We were not able to compute the declaration context for a dependent; // base object type or prior nested-name-specifier, so this; // nested-name-specifier refers to an unknown specialization. Just build; // a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:65,Availability,error,error,65,"// Replacement '::' -> ':' is not allowed, just issue respective error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:44,Availability,recover,recovering,44,"// We haven't found anything, and we're not recovering from a; // different kind of error, so look for typos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:84,Availability,error,error,84,"// We haven't found anything, and we're not recovering from a; // different kind of error, so look for typos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:44,Safety,recover,recovering,44,"// We haven't found anything, and we're not recovering from a; // different kind of error, so look for typos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:485,Availability,redundant,redundant,485,"// C++03 [basic.lookup.classref]p4:; // [...] If the name is found in both contexts, the; // class-name-or-namespace-name shall refer to the same entity.; //; // We already found the name in the scope of the object. Now, look; // into the current scope (the scope of the postfix-expression) to; // see if we can find the same name there. As above, if there is no; // scope, reconstruct the result from the template instantiation itself.; //; // Note that C++11 does *not* perform this redundant lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:472,Performance,perform,perform,472,"// C++03 [basic.lookup.classref]p4:; // [...] If the name is found in both contexts, the; // class-name-or-namespace-name shall refer to the same entity.; //; // We already found the name in the scope of the object. Now, look; // into the current scope (the scope of the postfix-expression) to; // see if we can find the same name there. As above, if there is no; // scope, reconstruct the result from the template instantiation itself.; //; // Note that C++11 does *not* perform this redundant lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:485,Safety,redund,redundant,485,"// C++03 [basic.lookup.classref]p4:; // [...] If the name is found in both contexts, the; // class-name-or-namespace-name shall refer to the same entity.; //; // We already found the name in the scope of the object. Now, look; // into the current scope (the scope of the postfix-expression) to; // see if we can find the same name there. As above, if there is no; // scope, reconstruct the result from the template instantiation itself.; //; // Note that C++11 does *not* perform this redundant lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:44,Availability,error,error-recovery,44,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:79,Modifiability,extend,extend,79,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:17,Performance,perform,performing,17,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:50,Safety,recover,recovery,50,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:25,Availability,error,error,25,"// Otherwise, we have an error case. If we don't want diagnostics, just; // return an error now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:86,Availability,error,error,86,"// Otherwise, we have an error case. If we don't want diagnostics, just; // return an error now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:123,Availability,error,error,123,"// If we didn't find anything during our lookup, try again with; // ordinary name lookup, which can help us produce better error; // messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:133,Integrability,message,messages,133,"// If we didn't find anything during our lookup, try again with; // ordinary name lookup, which can help us produce better error; // messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:324,Integrability,depend,dependent,324,"// In Microsoft mode, if we are within a templated function and we can't; // resolve Identifier, then extend the SS with Identifier. This will have; // the effect of resolving Identifier during template instantiation.; // The goal is to be able to resolve a function call whose; // nested-name-specifier is located inside a dependent base class.; // Example:; //; // class C {; // public:; // static void foo2() { }; // };; // template <class T> class A { public: typedef C D; };; //; // template <class T> class B : public A<T> {; // public:; // void foo() { D::foo2(); }; // };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:102,Modifiability,extend,extend,102,"// In Microsoft mode, if we are within a templated function and we can't; // resolve Identifier, then extend the SS with Identifier. This will have; // the effect of resolving Identifier during template instantiation.; // The goal is to be able to resolve a function call whose; // nested-name-specifier is located inside a dependent base class.; // Example:; //; // class C {; // public:; // static void foo2() { }; // };; // template <class T> class A { public: typedef C D; };; //; // template <class T> class B : public A<T> {; // public:; // void foo() { D::foo2(); }; // };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:56,Availability,error,error,56,"/// IsInvalidUnlessNestedName - This method is used for error recovery; /// purposes to determine whether the specified identifier is only valid as; /// a nested name specifier, for example a namespace name. It is; /// conservatively correct to always return false from this method.; ///; /// The arguments are the same as those passed to ActOnCXXNestedNameSpecifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:62,Availability,recover,recovery,62,"/// IsInvalidUnlessNestedName - This method is used for error recovery; /// purposes to determine whether the specified identifier is only valid as; /// a nested name specifier, for example a namespace name. It is; /// conservatively correct to always return false from this method.; ///; /// The arguments are the same as those passed to ActOnCXXNestedNameSpecifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:62,Safety,recover,recovery,62,"/// IsInvalidUnlessNestedName - This method is used for error recovery; /// purposes to determine whether the specified identifier is only valid as; /// a nested name specifier, for example a namespace name. It is; /// conservatively correct to always return false from this method.; ///; /// The arguments are the same as those passed to ActOnCXXNestedNameSpecifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:12,Integrability,depend,dependent,12,// Handle a dependent template specialization for which we cannot resolve; // the template name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Integrability,depend,depend,24,// TODO: Sema shouldn't depend on Lex,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Integrability,depend,depend,24,// TODO: Sema shouldn't depend on Lex,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:6,Integrability,inject,injected-class-name,6,// An injected-class-name of a class template (specialization) is valid; // as a template or as a non-template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:6,Security,inject,injected-class-name,6,// An injected-class-name of a class template (specialization) is valid; // as a template or as a non-template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,Usability,simpl,simple-type-specifier,74,// end anonymous namespace; /// Determine whether the token kind starts a simple-type-specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:104,Integrability,depend,dependent,104,"// end anonymous namespace; /// Tries to perform unqualified lookup of the type decls in bases for; /// dependent class.; /// \return \a NotFound if no any decls is found, \a FoundNotType if found not a; /// type decl, \a FoundType if only type decls are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Performance,perform,perform,41,"// end anonymous namespace; /// Tries to perform unqualified lookup of the type decls in bases for; /// dependent class.; /// \return \a NotFound if no any decls is found, \a FoundNotType if found not a; /// type decl, \a FoundType if only type decls are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Integrability,depend,dependent,26,// Look for type decls in dependent base classes that have known primary; // templates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Integrability,depend,dependent,26,// Look for type decls in dependent base classes that have known primary; // templates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Availability,Recover,Recover,50,// We found some types in dependent base classes. Recover as if the user; // wrote 'typename MyClass::II' instead of 'II'. We'll fully resolve the; // lookup during template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Integrability,depend,dependent,26,// We found some types in dependent base classes. Recover as if the user; // wrote 'typename MyClass::II' instead of 'II'. We'll fully resolve the; // lookup during template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Safety,Recover,Recover,50,// We found some types in dependent base classes. Recover as if the user; // wrote 'typename MyClass::II' instead of 'II'. We'll fully resolve the; // lookup during template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Usability,simpl,simple-type-specifier,29,/// Build a ParsedType for a simple-type-specifier with a nested-name-specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,Integrability,rout,routine,120,"/// If the identifier refers to a type name within this scope,; /// return the declaration of that type.; ///; /// This routine performs ordinary name lookup of the identifier II; /// within the given scope, with optional C++ scope specifier SS, to; /// determine whether the name refers to a type. If so, returns an; /// opaque pointer (actually a QualType) corresponding to that; /// type. Otherwise, returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Performance,perform,performs,128,"/// If the identifier refers to a type name within this scope,; /// return the declaration of that type.; ///; /// This routine performs ordinary name lookup of the identifier II; /// within the given scope, with optional C++ scope specifier SS, to; /// determine whether the name refers to a type. If so, returns an; /// opaque pointer (actually a QualType) corresponding to that; /// type. Otherwise, returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Performance,perform,perform,27,// Determine where we will perform name lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,Integrability,depend,depends,105,"// C++ [temp.res]p3:; // A qualified-id that refers to a type and in which the; // nested-name-specifier depends on a template-parameter (14.6.2); // shall be prefixed by the keyword typename to indicate that the; // qualified-id denotes a type, forming an; // elaborated-type-specifier (7.1.5.3).; //; // We therefore do not perform any name lookup if the result would; // refer to a member of an unknown specialization.; // In C++2a, in several contexts a 'typename' is not required. Also; // allow this as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:326,Performance,perform,perform,326,"// C++ [temp.res]p3:; // A qualified-id that refers to a type and in which the; // nested-name-specifier depends on a template-parameter (14.6.2); // shall be prefixed by the keyword typename to indicate that the; // qualified-id denotes a type, forming an; // elaborated-type-specifier (7.1.5.3).; //; // We therefore do not perform any name lookup if the result would; // refer to a member of an unknown specialization.; // In C++2a, in several contexts a 'typename' is not required. Also; // allow this as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,Integrability,depend,dependent,76,"// We know from the grammar that this name refers to a type,; // so build a dependent node to describe the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,// Update the DeclContext to point to the Tag definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:130,Security,access,access,130,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform unqualified name lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,Integrability,depend,dependent,74,"// For unqualified lookup in a class template in MSVC mode, look into; // dependent base classes where the primary class template is known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:146,Availability,error,error,146,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:188,Availability,error,error,188,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:255,Availability,error,error,255,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Availability,recover,recovery,29,// Make the selection of the recovery decl deterministic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Safety,recover,recovery,29,// Make the selection of the recovery decl deterministic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:197,Performance,perform,perform,197,"// None of the entities we found is a type, so there is no way; // to even assume that the result is a type. In this case, don't; // complain about the ambiguity. The parser will either try to; // perform this lookup again (e.g., as an object name), which; // will produce the ambiguity, or will complain that it expected; // a type name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:195,Performance,perform,perform,195,"// We found a type within the ambiguous lookup; diagnose the; // ambiguity and then return that type. This might be the right; // answer, or it might not be, but it suppresses any attempt to; // perform the name lookup again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Integrability,inject,injected-class-name,52,"// C++ [class.qual]p2: A lookup that would find the injected-class-name; // instead names the constructors of the class, except when naming a class.; // This is ill-formed when we're not actually forming a ctor or dtor name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Security,inject,injected-class-name,52,"// C++ [class.qual]p2: A lookup that would find the injected-class-name; // instead names the constructors of the class, except when naming a class.; // This is ill-formed when we're not actually forming a ctor or dtor name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover with 'int',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover with 'int',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Integrability,wrap,wrap,9,// Don't wrap in a further UsingType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Integrability,depend,dependent,31,"/// Find the parent class with dependent bases of the innermost enclosing method; /// context. Do not look for enclosing CXXRecordDecls directly, or we will end; /// up allowing unqualified dependent type names at class-level, which MSVC; /// correctly rejects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:190,Integrability,depend,dependent,190,"/// Find the parent class with dependent bases of the innermost enclosing method; /// context. Do not look for enclosing CXXRecordDecls directly, or we will end; /// up allowing unqualified dependent type names at class-level, which MSVC; /// correctly rejects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:309,Availability,error,errors,309,"// If we weren't able to parse a default template argument, delay lookup; // until instantiation time by making a non-dependent DependentTypeName. We; // pretend we saw a NestedNameSpecifier referring to the current scope, and; // lookup is retried.; // FIXME: This hurts our diagnostic quality, since we get errors like ""no; // type named 'Foo' in 'current_namespace'"" when the user didn't write any; // name specifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:118,Integrability,depend,dependent,118,"// If we weren't able to parse a default template argument, delay lookup; // until instantiation time by making a non-dependent DependentTypeName. We; // pretend we saw a NestedNameSpecifier referring to the current scope, and; // lookup is retried.; // FIXME: This hurts our diagnostic quality, since we get errors like ""no; // type named 'Foo' in 'current_namespace'"" when the user didn't write any; // name specifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Integrability,Depend,DependentTypeName,128,"// If we weren't able to parse a default template argument, delay lookup; // until instantiation time by making a non-dependent DependentTypeName. We; // pretend we saw a NestedNameSpecifier referring to the current scope, and; // lookup is retried.; // FIXME: This hurts our diagnostic quality, since we get errors like ""no; // type named 'Foo' in 'current_namespace'"" when the user didn't write any; // name specifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Integrability,Depend,DependentNameType,11,// Build a DependentNameType that will perform lookup into RD at; // instantiation time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Performance,perform,perform,39,// Build a DependentNameType that will perform lookup into RD at; // instantiation time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Availability,recover,recover,42,// This is not a situation that we should recover from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Safety,recover,recover,42,// This is not a situation that we should recover from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Availability,error,error,45,"/// isTagName() - This method is called *for error recovery purposes only*; /// to determine if the specified name is a valid tag name (""struct foo""). If; /// so, this returns the TST for the tag corresponding to it (TST_enum,; /// TST_union, TST_struct, TST_interface, TST_class). This is used to diagnose; /// cases in C where the user forgot to specify the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Availability,recover,recovery,51,"/// isTagName() - This method is called *for error recovery purposes only*; /// to determine if the specified name is a valid tag name (""struct foo""). If; /// so, this returns the TST for the tag corresponding to it (TST_enum,; /// TST_union, TST_struct, TST_interface, TST_class). This is used to diagnose; /// cases in C where the user forgot to specify the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Safety,recover,recovery,51,"/// isTagName() - This method is called *for error recovery purposes only*; /// to determine if the specified name is a valid tag name (""struct foo""). If; /// so, this returns the TST for the tag corresponding to it (TST_enum,; /// TST_union, TST_struct, TST_interface, TST_class). This is used to diagnose; /// cases in C where the user forgot to specify the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Availability,down,downgrade,160,"/// isMicrosoftMissingTypename - In Microsoft mode, within class scope,; /// if a CXXScopeSpec's type is equal to the type of one of the base classes; /// then downgrade the missing typename error to a warning.; /// This is needed for MSVC compatibility; Example:; /// @code; /// template<class T> class A {; /// public:; /// typedef int TYPE;; /// };; /// template<class T> class B : public A<T> {; /// public:; /// A<T>::TYPE a; // no typename required because A<T> is a base class.; /// };; /// @endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:191,Availability,error,error,191,"/// isMicrosoftMissingTypename - In Microsoft mode, within class scope,; /// if a CXXScopeSpec's type is equal to the type of one of the base classes; /// then downgrade the missing typename error to a warning.; /// This is needed for MSVC compatibility; Example:; /// @code; /// template<class T> class A {; /// public:; /// typedef int TYPE;; /// };; /// template<class T> class B : public A<T> {; /// public:; /// A<T>::TYPE a; // no typename required because A<T> is a base class.; /// };; /// @endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Availability,error,errors,25,// Don't report typename errors for editor placeholders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Availability,error,error,18,// FIXME: Support error recovery for the template-name case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Availability,recover,recovery,24,// FIXME: Support error recovery for the template-name case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Safety,recover,recovery,24,// FIXME: Support error recovery for the template-name case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Integrability,interface,interface,38,// We found a similarly-named type or interface; suggest that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Availability,recover,recover,49,"// FIXME: Should we move the logic that tries to recover from a missing tag; // (struct, union, enum) from Parser::ParseImplicitInt here, instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Safety,recover,recover,49,"// FIXME: Should we move the logic that tries to recover from a missing tag; // (struct, union, enum) from Parser::ParseImplicitInt here, instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Testability,log,logic,29,"// FIXME: Should we move the logic that tries to recover from a missing tag; // (struct, union, enum) from Parser::ParseImplicitInt here, instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:70,Integrability,inject,injected-class-name,70,"// Per [class.qual]p2, this names the constructors of SS, not the; // injected-class-name. We don't have a classification for that.; // There's not much point caching this result, since the parser; // will reject it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:70,Security,inject,injected-class-name,70,"// Per [class.qual]p2, this names the constructors of SS, not the; // injected-class-name. We don't have a classification for that.; // There's not much point caching this result, since the parser; // will reject it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,Integrability,depend,dependent,74,"// For unqualified lookup in a class template in MSVC mode, look into; // dependent base classes where the primary class template is known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:43,Modifiability,variab,variables,43,"// Perform lookup for Objective-C instance variables (including automatically; // synthesized instance variables), if we're in an Objective-C method.; // FIXME: This lookup really, really needs to be folded in to the normal; // unqualified lookup mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:103,Modifiability,variab,variables,103,"// Perform lookup for Objective-C instance variables (including automatically; // synthesized instance variables), if we're in an Objective-C method.; // FIXME: This lookup really, really needs to be folded in to the normal; // unqualified lookup mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,"// Perform lookup for Objective-C instance variables (including automatically; // synthesized instance variables), if we're in an Objective-C method.; // FIXME: This lookup really, really needs to be folded in to the normal; // unqualified lookup mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform typo correction to determine if there is another name that is; // close to this name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Testability,Test,Test,34,// FIXME: is this even reachable? Test it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,"// Update the name, so that the caller has the new name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,Deployability,update,update,8,// Also update the LookupResult...; // FIXME: This should probably go away at some point,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Modifiability,variab,variable,39,"// If we found an Objective-C instance variable, let; // LookupInObjCMethod build the appropriate expression to; // reference the ivar.; // FIXME: This is a gross hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Integrability,depend,dependent,79,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:150,Integrability,depend,dependent,150,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:277,Integrability,depend,dependent,277,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:6,Performance,perform,performed,6,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:531,Performance,perform,perform,531,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Integrability,inject,injected-class-name,50,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in an; // ambiguity in certain cases (for example, if it is found in more than; // one base class). If all of the injected-class-names that are found; // refer to specializations of the same class template, and if the name; // is followed by a template-argument-list, the reference refers to the; // class template itself and not a specialization thereof, and is not; // ambiguous.; //; // This filtering can make an ambiguous result into an unambiguous one,; // so try again after filtering out template names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:202,Integrability,inject,injected-class-names,202,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in an; // ambiguity in certain cases (for example, if it is found in more than; // one base class). If all of the injected-class-names that are found; // refer to specializations of the same class template, and if the name; // is followed by a template-argument-list, the reference refers to the; // class template itself and not a specialization thereof, and is not; // ambiguous.; //; // This filtering can make an ambiguous result into an unambiguous one,; // so try again after filtering out template names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Security,inject,injected-class-name,50,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in an; // ambiguity in certain cases (for example, if it is found in more than; // one base class). If all of the injected-class-names that are found; // refer to specializations of the same class template, and if the name; // is followed by a template-argument-list, the reference refers to the; // class template itself and not a specialization thereof, and is not; // ambiguous.; //; // This filtering can make an ambiguous result into an unambiguous one,; // so try again after filtering out template names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:202,Security,inject,injected-class-names,202,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in an; // ambiguity in certain cases (for example, if it is found in more than; // one base class). If all of the injected-class-names that are found; // refer to specializations of the same class template, and if the name; // is followed by a template-argument-list, the reference refers to the; // class template itself and not a specialization thereof, and is not; // ambiguous.; //; // This filtering can make an ambiguous result into an unambiguous one,; // so try again after filtering out template names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:40,Availability,error,error,40,// Diagnose the ambiguity and return an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Performance,perform,perform,86,"// Function templates always go through overload resolution, at which; // point we'll perform the various checks (e.g., accessibility) we need; // to based on which function we selected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,Security,access,accessibility,120,"// Function templates always go through overload resolution, at which; // point we'll perform the various checks (e.g., accessibility) we need; // to based on which function we selected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Integrability,Interface,Interface,3,"// Interface. <something> is parsed as a property reference expression.; // Just return ""unknown"" as a fall-through for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Security,access,accesses,160,"// If we already know which single declaration is referenced, just annotate; // that declaration directly. Defer resolving even non-overloaded class; // member accesses, as we need to defer certain access checks until we know; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:198,Security,access,access,198,"// If we already know which single declaration is referenced, just annotate; // that declaration directly. Defer resolving even non-overloaded class; // member accesses, as we need to defer certain access checks until we know; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Security,access,access,32,"// For an implicit class member access, transform the result into a member; // access expression if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Security,access,access,79,"// For an implicit class member access, transform the result into a member; // access expression if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:267,Modifiability,variab,variable,267,"// C++0x [basic.lookup.unqual]p13:; // A name used in the definition of a static data member of class; // X (after the qualified-id of the static member) is looked up as; // if the name was used in a member function of X.; // C++0x [basic.lookup.unqual]p14:; // If a variable member of a namespace is defined outside of the; // scope of its namespace then any name used in the definition of; // the variable member (after the declarator-id) is looked up as; // if the definition of the variable member occurred in its; // namespace.; // Both of these imply that we should push a scope whose context; // is the semantic context of the declaration. We can't use; // PushDeclContext here because that context is not necessarily; // lexically contained in the current context. Fortunately,; // the containing scope should have the appropriate information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:399,Modifiability,variab,variable,399,"// C++0x [basic.lookup.unqual]p13:; // A name used in the definition of a static data member of class; // X (after the qualified-id of the static member) is looked up as; // if the name was used in a member function of X.; // C++0x [basic.lookup.unqual]p14:; // If a variable member of a namespace is defined outside of the; // scope of its namespace then any name used in the definition of; // the variable member (after the declarator-id) is looked up as; // if the definition of the variable member occurred in its; // namespace.; // Both of these imply that we should push a scope whose context; // is the semantic context of the declaration. We can't use; // PushDeclContext here because that context is not necessarily; // lexically contained in the current context. Fortunately,; // the containing scope should have the appropriate information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:486,Modifiability,variab,variable,486,"// C++0x [basic.lookup.unqual]p13:; // A name used in the definition of a static data member of class; // X (after the qualified-id of the static member) is looked up as; // if the name was used in a member function of X.; // C++0x [basic.lookup.unqual]p14:; // If a variable member of a namespace is defined outside of the; // scope of its namespace then any name used in the definition of; // the variable member (after the declarator-id) is looked up as; // if the definition of the variable member occurred in its; // namespace.; // Both of these imply that we should push a scope whose context; // is the semantic context of the declaration. We can't use; // PushDeclContext here because that context is not necessarily; // lexically contained in the current context. Fortunately,; // the containing scope should have the appropriate information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:43,Safety,safe,safety,43,// Switch back to the lexical context. The safety of this is; // enforced by an assert in EnterDeclaratorContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Testability,assert,assert,80,// Switch back to the lexical context. The safety of this is; // enforced by an assert in EnterDeclaratorContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:547,Integrability,depend,dependent,547,"// C++20 [temp.local]p7:; // In the definition of a member of a class template that appears outside; // of the class template definition, the name of a member of the class; // template hides the name of a template-parameter of any enclosing class; // templates (but not a template-parameter of the member if the member is a; // class or function template).; // C++20 [temp.local]p9:; // In the definition of a class template or in the definition of a member; // of such a template that appears outside of the template definition, for; // each non-dependent base class (13.8.2.1), if the name of the base class; // or the name of a member of the base class is the same as the name of a; // template-parameter, the base class name or member name hides the; // template-parameter name (6.4.10).; //; // This means that a template parameter scope should be searched immediately; // after searching the DeclContext for which it is a template parameter; // scope. For example, for; // template<typename T> template<typename U> template<typename V>; // void N::A<T>::B<U>::f(...); // we search V then B<U> (and base classes) then U then A<T> (and base; // classes) then T then N then ::.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:145,Integrability,rout,routine,145,"/// Determine whether overloading is allowed for a new function; /// declaration considering prior declarations of the same name.; ///; /// This routine determines whether overloading is possible, not; /// whether a new declaration actually overloads a previous one.; /// It will return true in C++ (where overloads are alway permitted); /// or, as a C extension, when either the new declaration or a; /// previous one is declared with the 'overloadable' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Integrability,interface,interface,11,"// [module.interface]p7:; // A declaration is attached to a module as follows:; // - If the declaration is a non-dependent friend declaration that nominates a; // function with a declarator-id that is a qualified-id or template-id or that; // nominates a class other than with an elaborated-type-specifier with neither; // a nested-name-specifier nor a simple-template-id, it is attached to the; // module to which the friend is attached ([basic.link]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:113,Integrability,depend,dependent,113,"// [module.interface]p7:; // A declaration is attached to a module as follows:; // - If the declaration is a non-dependent friend declaration that nominates a; // function with a declarator-id that is a qualified-id or template-id or that; // nominates a class other than with an elaborated-type-specifier with neither; // a nested-name-specifier nor a simple-template-id, it is attached to the; // module to which the friend is attached ([basic.link]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:353,Usability,simpl,simple-template-id,353,"// [module.interface]p7:; // A declaration is attached to a module as follows:; // - If the declaration is a non-dependent friend declaration that nominates a; // function with a declarator-id that is a qualified-id or template-id or that; // nominates a class other than with an elaborated-type-specifier with neither; // a nested-name-specifier nor a simple-template-id, it is attached to the; // module to which the friend is attached ([basic.link]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:91,Integrability,interface,interface,91,// A module implementation unit has visibility of the decls in its; // implicitly imported interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Integrability,interface,interface,11,// [module.interface]p6:; // A redeclaration of an entity X is implicitly exported if X was introduced by; // an exported declaration; otherwise it shall not be exported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Integrability,interface,interface,11,// [module.interface]p1:; // An export-declaration shall inhabit a namespace scope.; //; // So it is meaningless to talk about redeclaration which is not at namespace; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:5,Integrability,wrap,wrapper,5,// A wrapper function for checking the semantic restrictions of; // a redeclaration within a module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:202,Modifiability,variab,variable,202,"// Check the redefinition in C++20 Modules.; //; // [basic.def.odr]p14:; // For any definable item D with definitions in multiple translation units,; // - if D is a non-inline non-templated function or variable, or; // - if the definitions in different translation units do not satisfy the; // following requirements,; // the program is ill-formed; a diagnostic is required only if the definable; // item is attached to a named module and a prior definition is reachable at; // the point where a later definition occurs.; // - Each such definition shall not be attached to a named module; // ([module.unit]).; // - Each such definition shall consist of the same sequence of tokens, ...; // ...; //; // Return true if the redefinition is not allowed. Return false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:686,Safety,detect,detect,686,"// We only checks for named modules here. The header like modules is skipped.; // FIXME: This is not right if we import the header like modules in the module; // purview.; //; // For example, assuming ""header.h"" provides definition for `D`.; // ```C++; // //--- M.cppm; // export module M;; // import ""header.h""; // or #include ""header.h"" but import it by clang modules; // actually.; //; // //--- Use.cpp; // import M;; // import ""header.h""; // or uses clang modules.; // ```; //; // In this case, `D` has multiple definitions in multiple TU (M.cppm and; // Use.cpp) and `D` is attached to a named module `M`. The compiler should; // reject it. But the current implementation couldn't detect the case since we; // don't record the information about the importee modules.; //; // But this might not be painful in practice. Since the design of C++20 Named; // Modules suggests us to use headers in global module fragment instead of; // module purview.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Security,access,access,35,// FIXME: Should check for private access too but access is set after we get; // the decl here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Security,access,access,50,// FIXME: Should check for private access too but access is set after we get; // the decl here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Modifiability,refactor,refactored,27,// FIXME: This needs to be refactored; some other isInMainFile users want; // these semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Modifiability,variab,variables,25,"// Constants and utility variables are defined in headers with internal; // linkage; don't warn. (Unlike functions, there isn't a convenient marker; // like ""inline"".)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:103,Modifiability,variab,variable,103,"// For a decomposition declaration, warn if none of the bindings are; // referenced, instead of if the variable itself is referenced (which; // it is, by the bindings' expressions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Integrability,depend,dependent,7,"// For dependent types, the diagnostic is deferred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Modifiability,variab,variable,42,// White-list anything that isn't a local variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Modifiability,variab,variables,24,"// Types of valid local variables should be complete, so this should succeed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Modifiability,variab,variables,22,// Warn for reference variables whose initializtion performs lifetime; // extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Performance,perform,performs,52,// Warn for reference variables whose initializtion performs lifetime; // extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,Integrability,depend,dependent,76,"// If we failed to complete the type for some reason, or if the type is; // dependent, don't diagnose the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Modifiability,variab,variable,106,"// If we failed to complete the type for some reason, or if the type is; // dependent, don't diagnose the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:87,Integrability,depend,dependent,87,// Suppress the warning if the constructor is unresolved because; // its arguments are dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Modifiability,variab,variables,15,"// In C++, `_` variables behave as if they were maybe_unused",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Modifiability,variab,variables,48,"// Don't warn about __block Objective-C pointer variables, as they might; // be assigned in the block but not used elsewhere for the purpose of lifetime; // extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:118,Deployability,release,releases,118,"// Don't warn about Objective-C pointer variables with precise lifetime; // semantics; they can be used to ensure ARC releases the object at a known; // time, which may mean assignment but no other references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:40,Modifiability,variab,variables,40,"// Don't warn about Objective-C pointer variables with precise lifetime; // semantics; they can be used to ensure ARC releases the object at a known; // time, which may mean assignment but no other references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Modifiability,variab,variables,19,// Diagnose unused variables in this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:188,Deployability,update,updated,188,"/// Look for an Objective-C class in the translation unit.; ///; /// \param Id The name of the Objective-C class we're looking for. If; /// typo-correction fixes this name, the Id will be updated; /// to the fixed name.; ///; /// \param IdLoc The location of the name in the translation unit.; ///; /// \param DoTypoCorrection If true, this routine will attempt typo correction; /// if there is no class with the given name.; ///; /// \returns The declaration of the named Objective-C class, or NULL if the; /// class could not be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:341,Integrability,rout,routine,341,"/// Look for an Objective-C class in the translation unit.; ///; /// \param Id The name of the Objective-C class we're looking for. If; /// typo-correction fixes this name, the Id will be updated; /// to the fixed name.; ///; /// \param IdLoc The location of the name in the translation unit.; ///; /// \param DoTypoCorrection If true, this routine will attempt typo correction; /// if there is no class with the given name.; ///; /// \returns The declaration of the named Objective-C class, or NULL if the; /// class could not be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,"// Perform typo correction at the given location, but only if we; // find an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,Integrability,rout,routine,8,"// This routine must always return a class definition, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:122,Integrability,rout,routine,122,"/// getNonFieldDeclScope - Retrieves the innermost scope, starting; /// from S, where a non-field would be declared. This routine copes; /// with the difference between C and C++ scoping rules in structs and; /// unions. For example, the following code is well-formed in C but; /// ill-formed in C++:; /// @code; /// struct S6 {; /// enum { BAR } e;; /// };; ///; /// void test_S6() {; /// struct S6 a;; /// a.e = BAR;; /// }; /// @endcode; /// For the declaration of BAR, this routine will return a different; /// scope. The scope S will be the scope of the unnamed enumeration; /// within S6. In C++, this routine will return the scope associated; /// with S6, because the enumeration's scope is a transparent; /// context but structures can contain non-field names. In C, this; /// routine will return the translation unit scope, since the; /// enumeration's scope is a transparent context and structures cannot; /// contain non-field names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:478,Integrability,rout,routine,478,"/// getNonFieldDeclScope - Retrieves the innermost scope, starting; /// from S, where a non-field would be declared. This routine copes; /// with the difference between C and C++ scoping rules in structs and; /// unions. For example, the following code is well-formed in C but; /// ill-formed in C++:; /// @code; /// struct S6 {; /// enum { BAR } e;; /// };; ///; /// void test_S6() {; /// struct S6 a;; /// a.e = BAR;; /// }; /// @endcode; /// For the declaration of BAR, this routine will return a different; /// scope. The scope S will be the scope of the unnamed enumeration; /// within S6. In C++, this routine will return the scope associated; /// with S6, because the enumeration's scope is a transparent; /// context but structures can contain non-field names. In C, this; /// routine will return the translation unit scope, since the; /// enumeration's scope is a transparent context and structures cannot; /// contain non-field names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:608,Integrability,rout,routine,608,"/// getNonFieldDeclScope - Retrieves the innermost scope, starting; /// from S, where a non-field would be declared. This routine copes; /// with the difference between C and C++ scoping rules in structs and; /// unions. For example, the following code is well-formed in C but; /// ill-formed in C++:; /// @code; /// struct S6 {; /// enum { BAR } e;; /// };; ///; /// void test_S6() {; /// struct S6 a;; /// a.e = BAR;; /// }; /// @endcode; /// For the declaration of BAR, this routine will return a different; /// scope. The scope S will be the scope of the unnamed enumeration; /// within S6. In C++, this routine will return the scope associated; /// with S6, because the enumeration's scope is a transparent; /// context but structures can contain non-field names. In C, this; /// routine will return the translation unit scope, since the; /// enumeration's scope is a transparent context and structures cannot; /// contain non-field names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:785,Integrability,rout,routine,785,"/// getNonFieldDeclScope - Retrieves the innermost scope, starting; /// from S, where a non-field would be declared. This routine copes; /// with the difference between C and C++ scoping rules in structs and; /// unions. For example, the following code is well-formed in C but; /// ill-formed in C++:; /// @code; /// struct S6 {; /// enum { BAR } e;; /// };; ///; /// void test_S6() {; /// struct S6 a;; /// a.e = BAR;; /// }; /// @endcode; /// For the declaration of BAR, this routine will return a different; /// scope. The scope S will be the scope of the unnamed enumeration; /// within S6. In C++, this routine will return the scope associated; /// with S6, because the enumeration's scope is a transparent; /// context but structures can contain non-field names. In C, this; /// routine will return the translation unit scope, since the; /// enumeration's scope is a transparent context and structures cannot; /// contain non-field names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Modifiability,variab,variably-modified,38,// Must not redefine a typedef with a variably-modified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:252,Availability,error,error,252,"/// MergeTypedefNameDecl - We just parsed a typedef 'New' which has the; /// same name and scope as a previous declaration 'Old'. Figure out; /// how to resolve this situation, merging decls or emitting; /// diagnostics as appropriate. If there was an error, set New to be invalid.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Install,Install,3,"// Install the built-in type for 'id', ignoring the current definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Install,Install,3,"// Install the built-in type for 'Class', ignoring the current definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Install,Install,3,"// Install the built-in type for 'SEL', ignoring the current definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Availability,error,error,106,"// If we have a redefinition of a typedef in C, emit a warning. This warning; // is normally mapped to an error, but can be controlled with; // -Wtypedef-redefinition. If either the original or the redefinition is; // in a system header, don't emit this for compatibility with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Integrability,depend,dependent,51,"// FIXME: We have no way of representing inherited dependent alignments; // in a case like:; // template<int A, int B> struct alignas(A) X;; // template<int A, int B> struct alignas(B) X {};; // For now, we just ignore any alignas attributes which are not on the; // definition in such a case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Modifiability,inherit,inherited,41,"// FIXME: We have no way of representing inherited dependent alignments; // in a case like:; // template<int A, int B> struct alignas(A) X;; // template<int A, int B> struct alignas(B) X {};; // For now, we just ignore any alignas attributes which are not on the; // definition in such a case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:256,Testability,log,logic,256,"// This function copies an attribute Attr from a previous declaration to the; // new declaration D if the new declaration doesn't itself have that attribute; // yet or if that attribute allows duplicates.; // If you're adding a new attribute that requires logic different from; // ""use explicit attribute on decl if present, else use attribute from; // previous decl"", for example if the attribute needs to be consistent; // between redeclarations, you need to call a custom merge function here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Security,validat,validating,42,// regular attr merging will take care of validating this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Modifiability,variab,variables,60,"// Don't warn about applying selectany to implicitly inline variables.; // Older compilers and language modes would require the use of selectany; // to make such variables inline, and it would have no effect if we; // honored it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:162,Modifiability,variab,variables,162,"// Don't warn about applying selectany to implicitly inline variables.; // Older compilers and language modes would require the use of selectany; // to make such variables inline, and it would have no effect if we; // honored it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Availability,error,error,45,"// extern constinit int a;; // int a = 0; // error (missing 'constinit'), accepted as extension",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Availability,error,error,45,// int a = 0;; // constinit extern int a; // error (missing 'constinit'),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:94,Modifiability,variab,variable,94,"// [dcl.constinit]p1:; // If the [constinit] specifier is applied to any declaration of a; // variable, it shall be applied to the initializing declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Modifiability,inherit,inherit,53,"// This is the initializing declaration. If it would inherit 'constinit',; // that's ill-formed. (Note that we do not apply this to the attribute; // form).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Energy Efficiency,allocate,allocated,48,// Ensure that any moving of objects within the allocated map is done before; // we process them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,Availability,avail,availability,33,// Ignore deprecated/unavailable/availability attributes if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Integrability,depend,depend,19,// C++11 [dcl.attr.depend]p2:; // The first declaration of a function shall specify the; // carries_dependency attribute for its declarator-id if any declaration; // of the function specifies the carries_dependency attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Energy Efficiency,allocate,allocated,48,// Ensure that any moving of objects within the allocated map is; // done before we process them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Integrability,depend,dependent,24,// Don't try to compare dependent sized array,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:430,Modifiability,variab,variable,430,"// C++11 [basic.scope.declarative]p4:; // Given a set of declarations in a single declarative region, each of; // which specifies the same unqualified name,; // -- they shall all refer to the same entity, or all refer to functions; // and function templates; or; // -- exactly one declaration shall declare a class name or enumeration; // name that is not a typedef name and the other declarations shall all; // refer to the same variable or enumerator, or all refer to functions; // and function templates; in this case the class name or enumeration; // name is hidden (3.3.10).; // C++11 [namespace.udecl]p14:; // If a function declaration in namespace scope or block scope has the; // same name and the same parameter-type-list as a function introduced; // by a using-declaration, and the declarations do not declare the same; // function, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Deployability,update,update,34,"// The only case where we need to update the DeclContext is when; // redeclaration lookup for a qualified name finds a declaration; // in an inline namespace within the context named by the qualifier:; //; // inline namespace N { int f(); }; // int ::f(); // Sema DC needs adjusting from :: to N::.; //; // For unqualified declarations, the semantic context *can* change; // along the redeclaration chain (for local extern declarations,; // extern ""C"" declarations, and friend declarations in particular).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:512,Availability,error,error,512,"/// MergeFunctionDecl - We just parsed a function 'New' from; /// declarator D which has the same name and scope as a previous; /// declaration 'Old'. Figure out how to resolve this situation,; /// merging decls or emitting diagnostics as appropriate.; ///; /// In C++, New and Old must be declarations that are not; /// overloaded. Use IsOverload to determine whether New and Old are; /// overloaded, and to select the Old declaration that New should be; /// merged with.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Deployability,update,update,102,"// If the old declaration was found in an inline namespace and the new; // declaration was qualified, update the DeclContext to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:343,Testability,test,test,343,"// If a function is first declared with a calling convention, but is later; // declared or defined without one, all following decls assume the calling; // convention of the first.; //; // It's OK if a function is first declared without a calling convention,; // but is later declared or defined with the default calling convention.; //; // To test if either decl has an explicit calling convention, we look for; // AttributedType sugar nodes on the type as written. If they are missing or; // were canonicalized away, we assume the calling convention was implicit.; //; // Note also that we DO NOT return at this point, because we still have; // other tests to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:652,Testability,test,tests,652,"// If a function is first declared with a calling convention, but is later; // declared or defined without one, all following decls assume the calling; // convention of the first.; //; // It's OK if a function is first declared without a calling convention,; // but is later declared or defined with the default calling convention.; //; // To test if either decl has an explicit calling convention, we look for; // AttributedType sugar nodes on the type as written. If they are missing or; // were canonicalized away, we assume the calling convention was implicit.; //; // Note also that we DO NOT return at this point, because we still have; // other tests to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit the CC from the previous declaration if it was specified; // there but not here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:168,Availability,error,error,168,// MSVC allows explicit template specialization at class scope:; // 2 CXXMethodDecls referring to the same function will be injected.; // We don't want a redeclaration error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:124,Integrability,inject,injected,124,// MSVC allows explicit template specialization at class scope:; // 2 CXXMethodDecls referring to the same function will be injected.; // We don't want a redeclaration error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:124,Security,inject,injected,124,// MSVC allows explicit template specialization at class scope:; // 2 CXXMethodDecls referring to the same function will be injected.; // We don't want a redeclaration error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:400,Deployability,update,updates,400,"// C++1z [over.load]p2; // Certain function declarations cannot be overloaded:; // -- Function declarations that differ only in the return type,; // the exception specification, or both cannot be overloaded.; // Check the exception specifications match. This may recompute the type of; // both Old and New if it resolved exception specifications, so grab the; // types again after this. Because this updates the type, we do this before; // any of the other checks below, which may update the ""de facto"" NewQType; // but do not necessarily update the type of New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:481,Deployability,update,update,481,"// C++1z [over.load]p2; // Certain function declarations cannot be overloaded:; // -- Function declarations that differ only in the return type,; // the exception specification, or both cannot be overloaded.; // Check the exception specifications match. This may recompute the type of; // both Old and New if it resolved exception specifications, so grab the; // types again after this. Because this updates the type, we do this before; // any of the other checks below, which may update the ""de facto"" NewQType; // but do not necessarily update the type of New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:539,Deployability,update,update,539,"// C++1z [over.load]p2; // Certain function declarations cannot be overloaded:; // -- Function declarations that differ only in the return type,; // the exception specification, or both cannot be overloaded.; // Check the exception specifications match. This may recompute the type of; // both Old and New if it resolved exception specifications, so grab the; // types again after this. Because this updates the type, we do this before; // any of the other checks below, which may update the ""de facto"" NewQType; // but do not necessarily update the type of New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Performance,load,load,15,"// C++1z [over.load]p2; // Certain function declarations cannot be overloaded:; // -- Function declarations that differ only in the return type,; // the exception specification, or both cannot be overloaded.; // Check the exception specifications match. This may recompute the type of; // both Old and New if it resolved exception specifications, so grab the; // types again after this. Because this updates the type, we do this before; // any of the other checks below, which may update the ""de facto"" NewQType; // but do not necessarily update the type of New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Integrability,depend,depend,19,// C++11 [dcl.attr.depend]p2:; // The first declaration of a function shall specify the; // carries_dependency attribute for its declarator-id if any declaration; // of the function specifies the carries_dependency attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:169,Modifiability,extend,extended,169,// (C++98 8.3.5p3):; // All declarations for a function shall agree exactly in both the; // return type and the parameter-type-list.; // We also want to respect all the extended bits except noreturn.; // noreturn should now match unless the old type info didn't have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Integrability,depend,dependent,38,"// If the types are imprecise (due to dependent constructs in friends or; // local extern declarations), it's OK if they differ. We'll check again; // during instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:537,Integrability,depend,depending,537,"// GNU C permits a K&R definition to follow a prototype declaration; // if the declared types of the parameters in the K&R definition; // match the types in the prototype declaration, even when the; // promoted types of the parameters from the K&R definition differ; // from the types in the prototype. GCC then keeps the types from; // the prototype.; //; // If a variadic prototype is followed by a non-variadic K&R definition,; // the K&R definition becomes variadic. This is sort of an edge case, but; // it's legal per the standard depending on how you read C99 6.7.5.3p15 and; // C99 6.9.1p8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Integrability,rout,routine,106,"/// Completes the merge of two function declarations that are; /// known to be compatible.; ///; /// This routine handles the merging of attributes and other; /// properties of function declarations from the old declaration to; /// the new declaration, once we know that New is in fact a; /// redeclaration of Old.; ///; /// \returns false",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:123,Deployability,update,update,123,"// Merge the function types so the we get the composite types for the return; // and argument types. Per C11 6.2.7/4, only update the type if the old decl; // was visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:36,Modifiability,variab,variable,36,"/// MergeVarDeclTypes - We parsed a variable 'New' which has the same name and; /// scope as a previous declaration 'Old'. Figure out how to merge their types,; /// emitting diagnostics as appropriate.; ///; /// Declarations using the auto type specifier (C++ [decl.spec.auto]) call back; /// to here in AddInitializerToDecl. We can't check them before the initializer; /// is attached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Modifiability,variab,variable,20,"// We are merging a variable declaration New into Old. If it has an array; // bound, and that bound differs from Old's bound, we should diagnose the; // mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:112,Modifiability,inherit,inherit,112,"// FIXME: Check visibility. New is hidden but has a complete type. If New; // has no array bound, it should not inherit one from Old, if Old is not; // visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Integrability,depend,dependent,56,"// It's OK if we couldn't merge types if either type is dependent, for a; // block-scope variable. In other cases (static data members of class; // templates, variable templates, ...), we require the types to be; // equivalent.; // FIXME: The C++ standard doesn't say anything about this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:89,Modifiability,variab,variable,89,"// It's OK if we couldn't merge types if either type is dependent, for a; // block-scope variable. In other cases (static data members of class; // templates, variable templates, ...), we require the types to be; // equivalent.; // FIXME: The C++ standard doesn't say anything about this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:159,Modifiability,variab,variable,159,"// It's OK if we couldn't merge types if either type is dependent, for a; // block-scope variable. In other cases (static data members of class; // templates, variable templates, ...), we require the types to be; // equivalent.; // FIXME: The C++ standard doesn't say anything about this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Integrability,depend,dependent,23,"// If the old type was dependent, we can't merge with it, so the new type; // becomes dependent for now. We'll reproduce the original type when we; // instantiate the TypeSourceInfo for the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Integrability,depend,dependent,86,"// If the old type was dependent, we can't merge with it, so the new type; // becomes dependent for now. We'll reproduce the original type when we; // instantiate the TypeSourceInfo for the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:190,Modifiability,variab,variable,190,"// If the old type was dependent, we can't merge with it, so the new type; // becomes dependent for now. We'll reproduce the original type when we; // instantiate the TypeSourceInfo for the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Deployability,update,update,18,// Don't actually update the type on the new declaration if the old; // declaration was an extern declaration in a different scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:328,Modifiability,variab,variable,328,"// C11 6.2.7p4:; // For an identifier with internal or external linkage declared; // in a scope in which a prior declaration of that identifier is; // visible, if the prior declaration specifies internal or; // external linkage, the type of the identifier at the later; // declaration becomes the composite type.; //; // If the variable isn't visible, we do not merge with its type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:36,Modifiability,variab,variable,36,"/// MergeVarDecl - We just parsed a variable 'New' which has the same name; /// and scope as a previous declaration 'Old'. Figure out how to resolve this; /// situation, merging decls or emitting diagnostics as appropriate.; ///; /// Tentative definition rules (C99 6.9.2p2) are checked by; /// FinalizeDeclaratorGroup. Unfortunately, we can't analyze tentative; /// definitions here, since the initializer hasn't been attached.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Modifiability,variab,variable,34,// Verify the old decl was also a variable or variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Modifiability,variab,variable,46,// Verify the old decl was also a variable or variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Deployability,update,update,102,"// If the old declaration was found in an inline namespace and the new; // declaration was qualified, update the DeclContext to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,variab,variable,31,// Warn if an already-declared variable is made a weak_import in a subsequent; // declaration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,Variab,Variables,3,// Variables with external linkage are analyzed in FinalizeDeclaratorGroup.; // FIXME: The test for external storage here seems wrong? We still; // need to check for mismatches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:91,Testability,test,test,91,// Variables with external linkage are analyzed in FinalizeDeclaratorGroup.; // FIXME: The test for external storage here seems wrong? We still; // need to check for mismatches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:54,Modifiability,variab,variable,54,"// C++1z [dcl.fcn.spec]p4:; // If the definition of a variable appears in a translation unit before; // its first declaration as inline, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Modifiability,variab,variable,35,"// If this redeclaration makes the variable inline, we may need to add it to; // UndefinedButUsed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Modifiability,variab,variable,44,"// Do not allow redeclaration to change the variable between requiring; // static and dynamic initialization.; // FIXME: GCC allows this, but uses the TLS keyword on the first; // declaration to determine the kind. Do we need to be compatible here?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit access appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Security,access,access,11,// Inherit access appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:16,Availability,error,errors,16,"// Redefinition errors with modules are common with non modular mapped; // headers, example: a non-modular header H in module A that also gets; // included directly in a TU. Pointing twice to the same header/definition; // is confusing, try to get better diagnostics when modules is on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,Availability,error,error,105,// Is it the same file and same offset? Provide more information on why; // this leads to a redefinition error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:96,Modifiability,variab,variable,96,/// We've just determined that \p Old and \p New both appear to be definitions; /// of the same variable. Either diagnose or fix the problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:262,Integrability,depend,depending,262,"// The MS ABI changed between VS2013 and VS2015 with regard to numbers used to; // disambiguate entities defined in different scopes.; // While the VS2015 ABI fixes potential miscompiles, it is also breaks; // compatibility.; // We will pick our mangling number depending on which version of MSVC is being; // targeted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:336,Safety,avoid,avoid,336,"// C++ [dcl.typedef]p9: [P1766R1, applied as DR]; // An unnamed class with a typedef name for linkage purposes shall [be; // C-like].; //; // FIXME: Also diagnose if we've already computed the linkage. That ideally; // shouldn't happen, but there are constructs that the language rule doesn't; // disallow for which we can't reasonably avoid computing linkage early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Availability,error,error,22,// We probably had an error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:111,Modifiability,variab,variables,111,// C++0x [dcl.constexpr]p1: constexpr can only be applied to declarations; // and definitions of functions and variables.; // C++2a [dcl.constexpr]p1: The consteval specifier shall be applied only to; // the declaration of a function or function template,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Availability,error,error,34,// Don't emit warnings after this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,Integrability,rout,routines,76,"// If we're dealing with a decl but not a TagDecl, assume that; // whatever routines created it handled the friendship aspect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Availability,error,error,47,// Skip all the checks below if we have a type error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Availability,redundant,redundant,106,"// In C, we allow this as a (popular) extension / bug. Don't bother; // producing further diagnostics for redundant qualifiers after this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Safety,redund,redundant,106,"// In C, we allow this as a (popular) extension / bug. Don't bother; // producing further diagnostics for redundant qualifiers after this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Availability,error,error,139,"// Since mutable is not a viable storage class specifier in C, there is; // no reason to treat it as an extension. Instead, diagnose as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:21,Integrability,inject,inject,21,/// We are trying to inject an anonymous member into the given scope;; /// check if there's an existing declaration that can't be overloaded.; ///; /// \return true if this is a forbidden redeclaration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:21,Security,inject,inject,21,/// We are trying to inject an anonymous member into the given scope;; /// check if there's an existing declaration that can't be overloaded.; ///; /// \return true if this is a forbidden redeclaration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Security,validat,validated,46,// This function can be parsed before we have validated the; // structure as an anonymous struct,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Integrability,Inject,InjectAnonymousStructOrUnionMembers,4,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Integrability,Inject,Inject,42,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:163,Integrability,rout,routine,163,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:365,Integrability,Inject,InjectAnonymousStructOrUnionMembers,365,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:416,Integrability,inject,inject,416,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:497,Integrability,rout,routine,497,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:519,Integrability,inject,injecting,519,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Security,Inject,InjectAnonymousStructOrUnionMembers,4,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Security,Inject,Inject,42,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:365,Security,Inject,InjectAnonymousStructOrUnionMembers,365,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:416,Security,inject,inject,416,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:519,Security,inject,injecting,519,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Security,access,access,44,// That includes picking up the appropriate access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Availability,error,error,102,/// StorageClassSpecToVarDeclStorageClass - Maps a DeclSpec::SCS to; /// a VarDecl::StorageClass. Any error reporting is up to the caller:; /// illegal input values are mapped to SC_None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Availability,error,error,29,// Illegal SCSs map to None: error reporting is up to the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by adding 'static'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by adding 'static'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by removing the storage specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by removing the storage specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Security,access,access,7,// Any access specifier is fine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:379,Availability,error,error,379,"// C++ [dcl.dcl]p3:; // [If there are no declarators], and except for the declaration of an; // unnamed bit-field, the decl-specifier-seq shall introduce one or more; // names into the program; // C++ [class.mem]p2:; // each such member-declaration shall either declare at least one member; // name of the class or declare at least one unnamed bit-field; //; // For C this is an error even for a named struct, and is diagnosed elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Testability,Mock,Mock,3,// Mock up a declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Availability,error,error,78,"// mutable can only appear on non-static class members, so it's always; // an error here",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Modifiability,variab,variable,35,"// Default-initialize the implicit variable. This initialization will be; // trivial in almost all cases, except if a union member has an in-class; // initializer:; // union { int n = 0; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Integrability,Inject,Inject,3,// Inject the members of the anonymous struct/union into the owning; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Security,Inject,Inject,3,// Inject the members of the anonymous struct/union into the owning; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Testability,Mock,Mock,3,// Mock up a declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Integrability,Inject,Inject,3,// Inject the members of the anonymous struct into the current; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Security,Inject,Inject,3,// Inject the members of the anonymous struct into the current; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Usability,guid,guide,20,// C++ [temp.deduct.guide]p3:; // The simple-template-id shall name a class template specialization.; // The template-name shall be the same identifier as the template-name; // of the simple-template-id.; // These together intend to imply that the template-name shall name a; // class template.; // FIXME: template<typename T> struct X {};; // template<typename T> using Y = X<T>;; // Y(int) -> Y<int>;; // satisfies these rules but does not name a class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Usability,simpl,simple-template-id,38,// C++ [temp.deduct.guide]p3:; // The simple-template-id shall name a class template specialization.; // The template-name shall be the same identifier as the template-name; // of the simple-template-id.; // These together intend to imply that the template-name shall name a; // class template.; // FIXME: template<typename T> struct X {};; // template<typename T> using Y = X<T>;; // Y(int) -> Y<int>;; // satisfies these rules but does not name a class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:184,Usability,simpl,simple-template-id,184,// C++ [temp.deduct.guide]p3:; // The simple-template-id shall name a class template specialization.; // The template-name shall be the same identifier as the template-name; // of the simple-template-id.; // These together intend to imply that the template-name shall name a; // class template.; // FIXME: template<typename T> struct X {};; // template<typename T> using Y = X<T>;; // Y(int) -> Y<int>;; // satisfies these rules but does not name a class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,Integrability,inject,injected,120,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:243,Integrability,depend,dependent,243,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:223,Safety,safe,safest,223,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,Security,inject,injected,120,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:85,Integrability,depend,dependent,85,// Make sure there's a type source info. This isn't really much; // of a waste; most dependent types should have type source info; // attached already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Avoid,Avoid,3,"// Avoid warning twice on the same identifier, and don't warn on redeclaration; // of system decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:590,Availability,recover,recover,590,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:608,Availability,error,error,608,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:583,Safety,safe,safely,583,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:590,Safety,recover,recover,590,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:441,Usability,simpl,simple,441,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:240,Availability,redundant,redundant,240,"// If the user provided a superfluous scope specifier that refers back to the; // class in which the entity is already declared, diagnose and ignore it.; //; // class X {; // void X::f();; // };; //; // Note, it was once ill-formed to give redundant qualification in all; // contexts, but that rule was removed by DR482.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:240,Safety,redund,redundant,240,"// If the user provided a superfluous scope specifier that refers back to the; // class in which the entity is already declared, diagnose and ignore it.; //; // class X {; // void X::f();; // };; //; // Note, it was once ill-formed to give redundant qualification in all; // contexts, but that rule was removed by DR482.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:112,Performance,perform,perform,112,"// Check whether the qualifying scope encloses the scope of the original; // declaration. For a template-id, we perform the checks in; // CheckTemplateSpecializationScope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:96,Integrability,depend,dependent,96,"// If we could not compute the declaration context, it's because the; // declaration context is dependent but does not refer to a class,; // class template, or class template partial specialization. Complain; // and return early, to avoid the coming semantic disaster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:233,Safety,avoid,avoid,233,"// If we could not compute the declaration context, it's because the; // declaration context is dependent but does not refer to a class,; // class template, or class template partial specialization. Complain; // and return early, to avoid the coming semantic disaster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Modifiability,variab,variable,38,// See if this is a redefinition of a variable in the same scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Integrability,inject,injected-class-name,47,// Forget that the previous declaration is the injected-class-name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Security,inject,injected-class-name,47,// Forget that the previous declaration is the injected-class-name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:212,Modifiability,variab,variables,212,"// In C++, the previous declaration we find might be a tag type; // (class or enum). In this case, the new declaration will hide the; // tag type. Note that this applies to functions, function templates, and; // variables, but not to typedefs (C++ [dcl.typedef]p4) or variable templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:268,Modifiability,variab,variable,268,"// In C++, the previous declaration we find might be a tag type; // (class or enum). In this case, the new declaration will hide the; // tag type. Note that this applies to functions, function templates, and; // variables, but not to typedefs (C++ [dcl.typedef]p4) or variable templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:125,Availability,error,errors,125,/// Helper method to turn variable array types into constant array; /// types in certain situations which would otherwise be errors (for; /// GCC compatibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Modifiability,variab,variable,26,/// Helper method to turn variable array types into constant array; /// types in certain situations which would otherwise be errors (for; /// GCC compatibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Integrability,depend,depends,160,"// This method tries to turn a variable array into a constant; // array even when the size isn't an ICE. This is necessary; // for compatibility with code that depends on gcc's buggy; // constant expression folding, like struct {char x[(int)(char*)2];}",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,variab,variable,31,"// This method tries to turn a variable array into a constant; // array even when the size isn't an ICE. This is necessary; // for compatibility with code that depends on gcc's buggy; // constant expression folding, like struct {char x[(int)(char*)2];}",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:125,Availability,error,errors,125,/// Helper method to turn variable array types into constant array; /// types in certain situations which would otherwise be errors (for; /// GCC compatibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Modifiability,variab,variable,26,/// Helper method to turn variable array types into constant array; /// types in certain situations which would otherwise be errors (for; /// GCC compatibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Modifiability,variab,variable-sized,22,"/// Attempt to fold a variable-sized type to a constant-sized type, returning; /// true if we were successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:68,Safety,avoid,avoid,68,"// FIXME: We should probably indicate the identifier in question to avoid; // confusion for constructs like ""virtual int a(), b;""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Modifiability,variab,variably,46,// C99 6.7.7p2: If a typedef name specifies a variably modified type; // then it shall have block scope.; // Note that variably modified types must be fixed before merging the decl so; // that redeclarations will match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:119,Modifiability,variab,variably,119,// C99 6.7.7p2: If a typedef name specifies a variably modified type; // then it shall have block scope.; // Note that variably modified types must be fixed before merging the decl so; // that redeclarations will match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Performance,Perform,Perform,27,"/// ActOnTypedefNameDecl - Perform semantic checking for a declaration which; /// declares a typedef-name, either using the 'typedef' type specifier or via; /// a C++0x [dcl.typedef]p2 alias-declaration: 'using T = A;'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Integrability,rout,routine,106,"/// Determines whether the given declaration is an out-of-scope; /// previous declaration.; ///; /// This routine should be invoked when name lookup has found a; /// previous declaration (PrevDecl) that is not in the scope where a; /// new declaration by the same name is being introduced. If the new; /// declaration occurs in a local scope, previous declarations with; /// linkage may still be considered previous declarations (C99; /// 6.2.2p4-5, C++ [basic.link]p6).; ///; /// \param PrevDecl the previous declaration found by name; /// lookup; ///; /// \param DC the context in which the new declaration is being; /// declared.; ///; /// \returns true if PrevDecl is an out-of-scope previous declaration; /// for a new delcaration with the same name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:16,Modifiability,variab,variables,16,// Thread-local variables cannot have lifetime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:138,Modifiability,variab,variable,138,"// OpenCL C v3.0 s6.7.8 - For OpenCL C 2.0 or with the; // __opencl_c_program_scope_global_variables feature, the address space; // for a variable at program scope or a static or extern variable inside; // a function are inferred to be __global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:186,Modifiability,variab,variable,186,"// OpenCL C v3.0 s6.7.8 - For OpenCL C 2.0 or with the; // __opencl_c_program_scope_global_variables feature, the address space; // for a variable at program scope or a static or extern variable inside; // a function are inferred to be __global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:72,Performance,cache,cache,72,// Ensure that an auto decl is deduced otherwise the checks below might cache; // the wrong linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Modifiability,variab,variable,50,// 'selectany' only applies to externally visible variable declarations.; // It does not apply to functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:166,Modifiability,variab,variable,166,"// dll attributes require external linkage. Static locals may have external; // linkage but still cannot be explicitly imported or exported.; // In Microsoft mode, a variable defined in anonymous namespace must have; // external linkage in order to be exported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Modifiability,variab,variable,22,// Don't declare this variable in the second operand of the for-statement;; // GCC miscompiles that by ending its lifetime before evaluating the; // third operand. See gcc.gnu.org/PR86769.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,inherit,inheritable,31,// dllimport and dllexport are inheritable attributes so we have to exclude; // inherited attribute instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Modifiability,inherit,inherited,80,// dllimport and dllexport are inheritable attributes so we have to exclude; // inherited attribute instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:54,Modifiability,variab,variables,54,// Allow with a warning for free functions and global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Modifiability,inherit,inherited,30,// MSVC allows this. Keep the inherited attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:163,Modifiability,inherit,inherits,163,"// A specialization of a class template member function is processed here; // since it's a redeclaration. If the parent class is dllexport, the; // specialization inherits that attribute. This doesn't happen automatically; // since the parent class isn't instantiated until later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:171,Performance,optimiz,optimization,171,"/// Given that we are within the definition of the given function,; /// will that definition behave like C99's 'inline', where the; /// definition is discarded except for optimization purposes?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Safety,avoid,avoid,10,// Try to avoid calling GetGVALinkageForFunction.; // All cases of this require the 'inline' keyword.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Modifiability,variab,variable,24,"/// Determine whether a variable is extern ""C"" prior to attaching; /// an initializer. We can't just call isExternC() here, because that; /// will also compute and cache whether the declaration is externally; /// visible, which might change when we attach the initializer.; ///; /// This can only be used if the declaration is known to not be a; /// redeclaration of an internal linkage declaration.; ///; /// For instance:; ///; /// auto x = []{};; ///; /// Attaching the initializer here makes this declaration not externally; /// visible, because its type has internal linkage.; ///; /// FIXME: This is a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:164,Performance,cache,cache,164,"/// Determine whether a variable is extern ""C"" prior to attaching; /// an initializer. We can't just call isExternC() here, because that; /// will also compute and cache whether the declaration is externally; /// visible, which might change when we attach the initializer.; ///; /// This can only be used if the declaration is known to not be a; /// redeclaration of an internal linkage declaration.; ///; /// For instance:; ///; /// auto x = []{};; ///; /// Attaching the initializer here makes this declaration not externally; /// visible, because its type has internal linkage.; ///; /// FIXME: This is a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Modifiability,variab,variable,48,/// Adjust the \c DeclContext for a function or variable that might be a; /// function-local external declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:185,Integrability,depend,dependent,185,"// If this is a local extern function or variable declared within a function; // template, don't add it into the enclosing namespace scope until it is; // instantiated; it might have a dependent type right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Modifiability,variab,variable,41,"// If this is a local extern function or variable declared within a function; // template, don't add it into the enclosing namespace scope until it is; // instantiated; it might have a dependent type right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:84,Modifiability,variab,variable,84,// OpenCL v1.2 s6.9.r:; // The event type cannot be used to declare a program scope variable.; // OpenCL v2.0 s6.9.q:; // The clk_event_t and reserve_id_t types cannot be declared in program; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Modifiability,variab,variables,42,// OpenCL v1.2 s6.1.1.1: reject declaring variables of the half and; // half array type (unless the cl_khr_fp16 extension is enabled).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:141,Modifiability,variab,variable,141,// This function emits warning and a corresponding note based on the; // ReadOnlyPlacementAttr attribute. The warning checks that all global variable; // declarations of an annotated type must be const qualified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:217,Deployability,patch,patch,217,// Ignore local declarations (for now) and those with const qualification.; // TODO: Local variables should not be allowed if their type declaration has; // ReadOnlyPlacementAttr attribute. To be handled in follow-up patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:91,Modifiability,variab,variables,91,// Ignore local declarations (for now) and those with const qualification.; // TODO: Local variables should not be allowed if their type declaration has; // ReadOnlyPlacementAttr attribute. To be handled in follow-up patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Availability,error,error,78,"// mutable can only appear on non-static class members, so it's always; // an error here",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Modifiability,variab,variable,11,"// If this variable has a VLA type and an initializer, try to; // fold to a constant-sized type. This is otherwise invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:87,Modifiability,variab,variables,87,// [dcl.stc] p2: The auto or register specifiers shall be applied only; // to names of variables declared in a block or to function parameters.; // [dcl.stc] p6: The extern specifier cannot be used in the declaration; // of class members,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Modifiability,variab,variable,48,"// There is an extraneous 'template<>' for this variable. Complain; // about it, but allow the declaration of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:114,Modifiability,variab,variable,114,"// There is an extraneous 'template<>' for this variable. Complain; // about it, but allow the declaration of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Modifiability,variab,variable,23,// Only C++1y supports variable templates (N3651).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,variab,variable,31,"// If this is supposed to be a variable template, create it as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Modifiability,variab,variable,81,"// If we have any template parameter lists that don't directly belong to; // the variable (matching the scope specifier), store them.; // An explicit variable template specialization does not own any template; // parameter lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:150,Modifiability,variab,variable,150,"// If we have any template parameter lists that don't directly belong to; // the variable (matching the scope specifier), store them.; // An explicit variable template specialization does not own any template; // parameter lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Modifiability,variab,variable,42,// 'inline' is not allowed on block scope variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Modifiability,variab,variable,60,// C++11 [dcl.stc]p4:; // When thread_local is applied to a variable of block scope the; // storage-class-specifier static is implied if it does not appear; // explicitly.; // Core issue: 'static' is not implied if the variable is declared; // 'extern'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:219,Modifiability,variab,variable,219,// C++11 [dcl.stc]p4:; // When thread_local is applied to a variable of block scope the; // storage-class-specifier static is implied if it does not appear; // explicitly.; // Core issue: 'static' is not implied if the variable is declared; // 'extern'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:12,Availability,error,error,12,// Postpone error emission until we've collected attributes required to; // figure out whether it's a host or device variable and whether the; // error should be ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:146,Availability,error,error,146,// Postpone error emission until we've collected attributes required to; // figure out whether it's a host or device variable and whether the; // error should be ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:117,Modifiability,variab,variable,117,// Postpone error emission until we've collected attributes required to; // figure out whether it's a host or device variable and whether the; // error should be ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Modifiability,variab,variable,29,// We still need to mark the variable as TLS so it shows up in AST with; // proper storage class for other tools to use even if we're not going; // to emit any code for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:124,Modifiability,variab,variable,124,// C++1z [dcl.spec.constexpr]p1:; // A static data member declared with the constexpr specifier is; // implicitly an inline variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:331,Modifiability,variab,variable,331,"// C99 6.7.4p3; // An inline definition of a function with external linkage shall; // not contain a definition of a modifiable object with static or; // thread storage duration...; // We only apply this when the function is required to be defined; // elsewhere, i.e. when the function is not 'extern inline'. Note; // that a local variable with thread storage duration still has to; // be marked 'static'. Also note that it's possible to get these; // semantics in C++ using __attribute__((gnu_inline)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:172,Availability,error,error,172,// WebAssembly tables are always in address space 1 (wasm_var). Don't apply; // address space if the table has local storage (semantic checks elsewhere; // will produce an error anyway).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Modifiability,variab,variables,44,"// CUDA B.2.5: ""__shared__ and __constant__ variables have implied static; // storage [duration].""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Deployability,release,release,18,"// In auto-retain/release, infer strong retension for variables of; // retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:54,Modifiability,variab,variables,54,"// In auto-retain/release, infer strong retension for variables of; // retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Modifiability,Variab,Variable,2,/*Variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:77,Availability,error,error,77,"// CheckVariableDeclaration will set NewVD as invalid if something is in; // error like WebAssembly tables being declared as arrays with a non-zero; // size, but then parsing continues and emits further errors on that line.; // To avoid that we check here if it happened and return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:203,Availability,error,errors,203,"// CheckVariableDeclaration will set NewVD as invalid if something is in; // error like WebAssembly tables being declared as arrays with a non-zero; // size, but then parsing continues and emits further errors on that line.; // To avoid that we check here if it happened and return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:231,Safety,avoid,avoid,231,"// CheckVariableDeclaration will set NewVD as invalid if something is in; // error like WebAssembly tables being declared as arrays with a non-zero; // size, but then parsing continues and emits further errors on that line.; // To avoid that we check here if it happened and return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Modifiability,variab,variable,128,"// Check the template parameter list of this declaration, possibly; // merging in the template parameter list from the previous variable; // template declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:62,Modifiability,variab,variable,62,"// If we are providing an explicit specialization of a static variable; // template, make a note of that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:21,Modifiability,variab,variables,21,// Diagnose shadowed variables iff this isn't a redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:61,Deployability,update,update,61,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Modifiability,variab,variable,51,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:88,Modifiability,variab,variables,88,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Modifiability,variab,variable,23,// Special handling of variable named 'main'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:58,Modifiability,variab,variable,58,// C++ [basic.start.main]p3; // A program that declares a variable main at global scope is ill-formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Modifiability,variab,variable,30,"// In C, and external-linkage variable named main results in undefined; // behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:83,Modifiability,variab,variable,83,"/// Return the location of the capture if the given lambda captures the given; /// variable \p VD, or an invalid source location otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Modifiability,variab,variable,60,// Only diagnose if we're shadowing an unambiguous field or variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Modifiability,variab,variable,49,"/// Return the declaration shadowed by the given variable \p D, or null; /// if it doesn't shadow any declaration or shadowing warnings are disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Modifiability,variab,variable,49,"/// Return the declaration shadowed by the given variable \p D, or null; /// if it doesn't shadow any declaration or shadowing warnings are disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:13,Modifiability,variab,variable,13,"/// Diagnose variable or built-in function shadowing. Implements; /// -Wshadow.; ///; /// This method is called whenever a VarDecl is added to a ""useful""; /// scope.; ///; /// \param ShadowedDecl the declaration that is shadowed by the given variable; /// \param R the lookup of the name; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:242,Modifiability,variab,variable,242,"/// Diagnose variable or built-in function shadowing. Implements; /// -Wshadow.; ///; /// This method is called whenever a VarDecl is added to a ""useful""; /// scope.; ///; /// \param ShadowedDecl the declaration that is shadowed by the given variable; /// \param R the lookup of the name; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Modifiability,variab,variables,30,// Fields are not shadowed by variables in C++ static methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:101,Integrability,depend,depending,101,// Remember that this was shadowed so we can either warn about its; // modification or its existence depending on warning settings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Safety,avoid,avoid,10,// Try to avoid warnings for lambdas with an explicit capture; // list. Warn only when the lambda captures the shadowed decl; // explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Safety,avoid,avoid,45,// Remember that this was shadowed so we can avoid the warning if; // the shadowed decl isn't captured and the warning settings allow; // it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Availability,avail,available,139,"// If lambda can capture this, then emit default shadowing warning,; // Otherwise it is not really a shadowing case since field is not; // available in lambda's body.; // At this point we don't know that lambda can capture this, so; // remember that this was shadowed and delay until we know.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:5,Modifiability,variab,variable,5,"// A variable can't shadow a local variable in an enclosing scope, if; // they are separated by a non-capturing declaration context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Modifiability,variab,variable,35,"// A variable can't shadow a local variable in an enclosing scope, if; // they are separated by a non-capturing declaration context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Modifiability,variab,variable,44,// Never warn about shadowing a placeholder variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Modifiability,variab,variables,27,/// Diagnose shadowing for variables shadowed in the lambda record \p LambdaRD; /// when these variables are captured by the lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:95,Modifiability,variab,variables,95,/// Diagnose shadowing for variables shadowed in the lambda record \p LambdaRD; /// when these variables are captured by the lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Safety,avoid,avoid,10,// Try to avoid the warning when the shadowed decl isn't captured.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Avoid,Avoid,3,// Avoid issuing multiple warnings about the same decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:134,Modifiability,variab,variable,134,"// This is a global, non-extern ""C"" declaration, and there is a previous; // non-global extern ""C"" declaration. Diagnose if this is a variable; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Performance,perform,performed,19,// We have already performed the lookup into the translation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:177,Modifiability,variab,variables,177,"// FIXME: If we have any other entity with this name in global scope,; // the declaration is ill-formed, but that is a defect: it breaks the; // 'stat' hack, for instance. Only variables can have mangled name; // clashes with extern ""C"" declarations, so only they deserve a; // diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:224,Modifiability,variab,variable,224,"/// Apply special rules for handling extern ""C"" declarations. Returns \c true; /// if we have found that this is a redeclaration of some prior entity.; ///; /// Per C++ [dcl.link]p6:; /// Two declarations [for a function or variable] with C language linkage; /// with the same name that appear in different scopes refer to the same; /// [entity]. An entity with C language linkage shall not be declared with; /// the same name as an entity in global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,Modifiability,variab,variable,33,"// In C, when declaring a global variable, look for a corresponding 'extern'; // variable declared in function scope. We don't need this in C++, because; // we find local extern decls in the surrounding file-scope DeclContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Modifiability,variab,variable,81,"// In C, when declaring a global variable, look for a corresponding 'extern'; // variable declared in function scope. We don't need this in C++, because; // we find local extern decls in the surrounding file-scope DeclContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Availability,error,error,11,"// Emit an error if an address space was applied to decl with local storage.; // This includes arrays of objects with address space qualifiers, but not; // automatic variables that point to other address spaces.; // ISO/IEC TR 18037 S5.1.2",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:166,Modifiability,variab,variables,166,"// Emit an error if an address space was applied to decl with local storage.; // This includes arrays of objects with address space qualifiers, but not; // automatic variables that point to other address spaces.; // ISO/IEC TR 18037 S5.1.2",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:55,Modifiability,variab,variables,55,// OpenCL v1.1 s6.5.2 and s6.5.3: no local or constant variables; // in functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Modifiability,variab,variables,53,// OpenCL v2.0 s6.5.2 and s6.5.3: local and constant variables must be; // in the outermost scope of a kernel function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Modifiability,variab,variable,50,// Do not allow other address spaces on automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:58,Modifiability,variab,variable,58,// PPC MMA non-pointer types are not allowed as non-local variable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Availability,avail,available,60,// Check that SVE types are only used in functions with SVE available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:451,Availability,error,error,451,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:91,Integrability,rout,routine,91,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Modifiability,variab,variable,49,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:153,Modifiability,variab,variable,153,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:228,Modifiability,variab,variables,228,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:347,Modifiability,variab,variables,347,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:504,Modifiability,variab,variable,504,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Performance,perform,performs,99,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:453,Availability,error,errors,453,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Integrability,rout,routine,79,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:121,Integrability,message,messages,121,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:230,Performance,perform,performing,230,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:374,Performance,perform,performed,374,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:92,Availability,error,errors,92,"// Retry building the function declaration with the new previous; // declarations, and with errors suppressed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,Availability,error,errors,8,// Trap errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Modifiability,Refactor,Refactor,9,// TODO: Refactor ActOnFunctionDeclarator so that we can call only the; // pieces need to verify the typo-corrected C++ declaration and hopefully; // eliminate the need for the parameter pack ExtraArgs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,Integrability,depend,dependent,8,"// Size dependent types are just typedefs to normal integer types; // (e.g. unsigned long), so we cannot distinguish them from other typedefs to; // integers other than by their names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:70,Integrability,depend,dependent,70,// Remove typedefs one by one until we reach a typedef; // for a size dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:59,Availability,avail,available,59,// If template type is not ODR-used its definition is only available; // in the template definition not its instantiation.; // FIXME: This logic doesn't work for types that depend on template; // parameter (PR58590).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:173,Integrability,depend,depend,173,// If template type is not ODR-used its definition is only available; // in the template definition not its instantiation.; // FIXME: This logic doesn't work for types that depend on template; // parameter (PR58590).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Testability,log,logic,139,// If template type is not ODR-used its definition is only available; // in the template definition not its instantiation.; // FIXME: This logic doesn't work for types that depend on template; // parameter (PR58590).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Cache,Cache,3,// Cache the valid types we encounter to avoid rechecking structs that are; // used again,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Safety,avoid,avoid,41,// Cache the valid types we encounter to avoid rechecking structs that are; // used again,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:14,Availability,error,error,14,"// We have an error, now let's go back up through history and show where; // the offending field came from",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Integrability,depend,dependent,35,"// If we're adding a template to a dependent context, we may need to; // rebuilding some of the types used within the template parameter list,; // now that we know what the current instantiation is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:184,Usability,clear,clearly,184,"// If we remove the template<> and the name is not a; // template-id, we're actually silently creating a problem:; // the friend declaration will refer to an untemplated decl,; // and clearly the user wants a template specialization. So; // we need to insert '<>' after the name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by faking up an empty template argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by faking up an empty template argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:130,Integrability,depend,dependent,130,"// If the function template is referenced directly (for instance, as a; // member of the current instantiation), pretend it has a dependent type.; // This is not really justified by the standard, but is the only sane; // thing to do.; // FIXME: For a friend function, we have not marked the function as being; // a friend yet, so 'isDependentContext' on the FD doesn't work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Modifiability,variab,variable,53,"// C++20 [dcl.inline]/7; // If an inline function or variable that is attached to a named module; // is declared in a definition domain, it shall be defined in that; // domain.; // So, if the current declaration does not have a definition, we must; // check at the end of the TU (or when the PMF starts) to see that we; // have a definition at that point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Modifiability,Variab,Variable,2,/*Variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:108,Availability,avail,available,108,"// Copy the parameter declarations from the declarator D to the function; // declaration NewFD, if they are available. First scavenge them into Params.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:148,Integrability,inject,injection,148,"// In C, find all the tag declarations from the prototype and move them; // into the function DeclContext. Remove them from the surrounding tag; // injection context of the function, which is typically but not always; // the TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:148,Security,inject,injection,148,"// In C, find all the tag declarations from the prototype and move them; // into the function DeclContext. Remove them from the surrounding tag; // injection context of the function, which is typically but not always; // the TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:73,Integrability,inject,injection,73,"// Preserve the lexical DeclContext if it is not the surrounding tag; // injection context of the FD. In this example, the semantic context of; // E will be f and the lexical context will be S, while both the; // semantic and lexical contexts of S will be f:; // void f(struct S { enum E { a } f; } s);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:73,Security,inject,injection,73,"// Preserve the lexical DeclContext if it is not the surrounding tag; // injection context of the FD. In this example, the semantic context of; // E will be f and the lexical context will be S, while both the; // semantic and lexical contexts of S will be f:; // void f(struct S { enum E { a } f; } s);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Deployability,install,install,60,"// Finally, we know we have the right number of parameters, install them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Modifiability,variab,variably,25,// Functions returning a variably modified type violate C99 6.7.5.2p2; // because all functions have linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:211,Availability,error,error,211,// Neither OpenCL nor HLSL allow an address space qualifyer on a return; // type.; //; // OpenCL v1.1 s6.5: Using an address space qualifier in a function return; // type declaration will generate a compilation error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform semantic checking on the function declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:270,Modifiability,inherit,inherits,270,"// We do not add HD attributes to specializations here because; // they may have different constexpr-ness compared to their; // templates and, after maybeAddCUDAHostDeviceAttrs() is applied,; // may end up with different effective targets. Instead, a; // specialization inherits its target attributes from its template; // in the CheckFunctionTemplateSpecialization() call below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Integrability,depend,dependent,50,"// For friend function specializations, this is a dependent; // specialization if its semantic context is dependent, its; // type is dependent, or if its template-id is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Integrability,depend,dependent,106,"// For friend function specializations, this is a dependent; // specialization if its semantic context is dependent, its; // type is dependent, or if its template-id is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:133,Integrability,depend,dependent,133,"// For friend function specializations, this is a dependent; // specialization if its semantic context is dependent, its; // type is dependent, or if its template-id is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:169,Integrability,depend,dependent,169,"// For friend function specializations, this is a dependent; // specialization if its semantic context is dependent, its; // type is dependent, or if its template-id is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:97,Integrability,depend,dependent,97,"// For class-scope explicit specializations of function templates,; // if the lexical context is dependent, then the specialization; // is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Integrability,depend,dependent,139,"// For class-scope explicit specializations of function templates,; // if the lexical context is dependent, then the specialization; // is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:13,Integrability,depend,dependent,13,"// If it's a dependent specialization, it may not be possible; // to determine the primary template (for explicit specializations); // or befriended declaration (for friends) until the enclosing; // template is instantiated. In such cases, we store the declarations; // found by name lookup and defer resolution until instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:158,Integrability,depend,dependent,158,// C++ [dcl.stc]p1:; // A storage-class-specifier shall not be specified in an explicit; // specialization (14.7.3); // FIXME: We should be checking this for dependent specializations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform semantic checking on the function declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:14,Security,access,access,14,// Fake up an access specifier if it's supposed to be a class member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:497,Availability,error,error,497,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:613,Availability,error,error,613,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,Integrability,depend,dependent-scope,57,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:145,Integrability,depend,dependent,145,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:310,Integrability,depend,dependent,310,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:471,Integrability,depend,dependent,471,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Security,Validat,Validate,3,// Validate the type matches unless this builtin is specified as; // matching regardless of its declared type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:61,Deployability,update,update,61,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Modifiability,variab,variable,51,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:88,Modifiability,variab,variables,88,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Integrability,depend,depends,86,"// Precalculate whether this is a friend function template with a constraint; // that depends on an enclosing template, per [temp.friend]p9.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Integrability,depend,depends,78,// C++ [temp.friend]p9:; // A friend function template with a constraint that depends on a; // template parameter from an enclosing template shall be a definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:12,Availability,avail,availability,12,// Diagnose availability attributes. Availability cannot be used on functions; // that are run during load/unload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:37,Availability,Avail,Availability,37,// Diagnose availability attributes. Availability cannot be used on functions; // that are run during load/unload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Performance,load,load,102,// Diagnose availability attributes. Availability cannot be used on functions; // that are run during load/unload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:203,Security,access,access,203,"// Diagnose no_builtin attribute on function declaration that are not a; // definition.; // FIXME: We should really be doing this in; // SemaDeclAttr.cpp::handleNoBuiltinAttr, unfortunately we only have access to; // the FunctionDecl and at this point of the code; // FunctionDecl::isThisDeclarationADefinition() which always returns `false`; // because Sema::ActOnStartOfFunctionDef has not been called yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:672,Availability,avail,available,672,"/// Return a CodeSegAttr from a containing class. The Microsoft docs say; /// when __declspec(code_seg) ""is applied to a class, all member functions of; /// the class and nested classes -- this includes compiler-generated special; /// member functions -- are put in the specified segment.""; /// The actual behavior is a little more complicated. The Microsoft compiler; /// won't check outer classes if there is an active value from #pragma code_seg.; /// The CodeSeg is always applied from the direct parent but only from outer; /// classes when the #pragma code_seg stack is empty. See:; /// https://reviews.llvm.org/D22931, the Microsoft feedback page is no longer; /// available since MS has removed the page.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:640,Usability,feedback,feedback,640,"/// Return a CodeSegAttr from a containing class. The Microsoft docs say; /// when __declspec(code_seg) ""is applied to a class, all member functions of; /// the class and nested classes -- this includes compiler-generated special; /// member functions -- are put in the specified segment.""; /// The actual behavior is a little more complicated. The Microsoft compiler; /// won't check outer classes if there is an active value from #pragma code_seg.; /// The CodeSeg is always applied from the direct parent but only from outer; /// classes when the #pragma code_seg stack is empty. See:; /// https://reviews.llvm.org/D22931, the Microsoft feedback page is no longer; /// available since MS has removed the page.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Performance,perform,perform,25,"/// Determines if we can perform a correct type check for \p D as a; /// redeclaration of \p PrevDecl. If not, we can generally still perform a; /// best-effort check.; ///; /// \param NewD The new declaration.; /// \param OldD The old declaration.; /// \param NewT The portion of the type of the new declaration to check.; /// \param OldT The portion of the type of the old declaration to check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:134,Performance,perform,perform,134,"/// Determines if we can perform a correct type check for \p D as a; /// redeclaration of \p PrevDecl. If not, we can generally still perform a; /// best-effort check.; ///; /// \param NewD The new declaration.; /// \param OldD The old declaration.; /// \param NewT The portion of the type of the new declaration to check.; /// \param OldT The portion of the type of the old declaration to check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Integrability,depend,dependently-typed,7,"// For dependently-typed local extern declarations and friends, we can't; // perform a correct type check in general until instantiation:; //; // int f();; // template<typename T> void g() { T f(); }; //; // (valid if g() is only instantiated with T = int).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:77,Performance,perform,perform,77,"// For dependently-typed local extern declarations and friends, we can't; // perform a correct type check in general until instantiation:; //; // int f();; // template<typename T> void g() { T f(); }; //; // (valid if g() is only instantiated with T = int).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Integrability,depend,dependent,48,"// Similarly, if the previous declaration was a dependent local extern; // declaration, we don't really know its type yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Integrability,depend,dependent,46,/// Checks if the new declaration declared in dependent context must be; /// put in the same redeclaration chain as the specified declaration.; ///; /// \param D Declaration that is checked.; /// \param PrevDecl Previous declaration found with proper lookup method for the; /// same declaration name.; /// \returns True if D must be added to the redeclaration chain which PrevDecl; /// belongs to.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Integrability,depend,dependent,15,"// Don't chain dependent friend function definitions until instantiation, to; // permit cases like; //; // void func();; // template<typename T> class C1 { friend void func() {} };; // template<typename T> class C2 { friend void func() {} };; //; // ... which is valid if only one of C1 and C2 is ever instantiated.; //; // FIXME: This need only apply to function definitions. For now, we proxy; // this by checking for a file-scope function. We do not want this to apply; // to friend declarations nominating member functions, because that gets in; // the way of access checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:564,Security,access,access,564,"// Don't chain dependent friend function definitions until instantiation, to; // permit cases like; //; // void func();; // template<typename T> class C1 { friend void func() {} };; // template<typename T> class C2 { friend void func() {} };; //; // ... which is valid if only one of C1 and C2 is ever instantiated.; //; // FIXME: This need only apply to function definitions. For now, we proxy; // this by checking for a file-scope function. We do not want this to apply; // to friend declarations nominating member functions, because that gets in; // the way of access checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:136,Availability,error,error,136,"/// Check the target or target_version attribute of the function for; /// MultiVersion validity.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:222,Availability,error,error,222,"/// Check the validity of a multiversion function declaration that is the; /// first of its kind. Also sets the multiversion'ness' of the function itself.; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:268,Availability,error,error,268,"/// Check the validity of a multiversion function declaration that is the; /// first of its kind. Also sets the multiversion'ness' of the function itself.; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:95,Usability,simpl,simple,95,"// If the old decl is NOT MultiVersioned yet, and we don't cause that; // to change, this is a simple redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Availability,error,errors,139,"// Handle CPUDispatch/CPUSpecific versions.; // Only 1 CPUDispatch function is allowed, this will make it go through; // the redeclaration errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Availability,error,error,47,"// If the declarations don't match, this is an error condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:17,Usability,simpl,simply,17,"// Else, this is simply a non-redecl case. Checking the 'value' is only; // necessary in the Target case, since The CPUSpecific/Dispatch cases are; // handled in the attribute adding step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:192,Availability,error,error,192,"/// Check the validity of a mulitversion function declaration.; /// Also sets the multiversion'ness' of the function itself.; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:238,Availability,error,error,238,"/// Check the validity of a mulitversion function declaration.; /// Also sets the multiversion'ness' of the function itself.; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Performance,optimiz,optimization,128,"// Main isn't allowed to become a multiversion function, however it IS; // permitted to have 'main' be marked with the 'target' optimization hint,; // for 'target_version' only default is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:109,Availability,error,error,109,"// If there's no previous declaration, AND this isn't attempting to cause; // multiversioning, this isn't an error condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:759,Availability,error,error,759,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:147,Integrability,rout,routine,147,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:71,Performance,Perform,Performs,71,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:155,Performance,perform,performs,155,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Performance,perform,performing,39,"// Warn that we did this, if we're not performing template instantiation.; // In that case, we'll have warned already when the template was defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Modifiability,inherit,inherit,56,// Explicit specializations of a member template do not inherit deleted; // status from the parent member template that they are specializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Testability,assert,assert,15,// FIXME: This assert will not hold in the presence of modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:21,Deployability,update,update,21,// FIXME: We need an update record for this AST mutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Integrability,depend,dependent,102,"// We check here for invalid destructor names.; // If we have a friend destructor declaration that is dependent, we can't; // diagnose right away because cases like this are still valid:; // template <class T> struct A { friend T::X::~Y(); };; // struct B { struct Y { ~Y(); }; using X = Y; };; // template struct A<B>;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Usability,guid,guide,15,// A deduction guide is not on the list of entities that can be; // explicitly specialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:667,Modifiability,variab,variable,667,"// C++20: dcl.decl.general p4:; // The optional requires-clause ([temp.pre]) in an init-declarator or; // member-declarator shall be present only if the declarator declares a; // templated function ([dcl.fct]).; //; // [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:940,Modifiability,variab,variable,940,"// C++20: dcl.decl.general p4:; // The optional requires-clause ([temp.pre]) in an init-declarator or; // member-declarator shall be present only if the declarator declares a; // templated function ([dcl.fct]).; //; // [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:954,Modifiability,variab,variable,954,"// C++20: dcl.decl.general p4:; // The optional requires-clause ([temp.pre]) in an init-declarator or; // member-declarator shall be present only if the declarator declares a; // templated function ([dcl.fct]).; //; // [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:977,Modifiability,variab,variable,977,"// C++20: dcl.decl.general p4:; // The optional requires-clause ([temp.pre]) in an init-declarator or; // member-declarator shall be present only if the declarator declares a; // templated function ([dcl.fct]).; //; // [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:151,Availability,error,error,151,"// If the function violates [temp.friend]p9 because it is missing; // a definition, and adding a definition would make it templated,; // then let that error take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:259,Availability,error,error,259,"// C++11 [basic.start.main]p3:; // A program that [...] declares main to be inline, static or; // constexpr is ill-formed.; // C11 6.7.4p4: In a hosted environment, no function specifier(s) shall; // appear in a declaration of main.; // static main is not an error under C99, but we should warn about it.; // We accept _Noreturn main as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Availability,error,error,38,"// Otherwise, this is just a flat-out error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:115,Testability,log,logic,115,"// Darwin passes an undocumented fourth argument of type char**. If; // other platforms start sprouting these, the logic below will start; // getting shifty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Usability,undo,undocumented,20,"// Darwin passes an undocumented fourth argument of type char**. If; // other platforms start sprouting these, the logic below will start; // getting shifty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,Safety,safe,safe,174,"// See if a warning is needed by checking the first difference in index; // numbers. If field being used has index less than the field being; // initialized, then the use is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Modifiability,variab,variables,27,// Check for static member variables and don't warn on them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Security,access,accesses,81,"// Warn when a non-static method call is followed by non-static member; // field accesses, which is followed by a DeclRefExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Modifiability,variab,variables,9,// Local variables will be handled by the CFG analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,Availability,avail,available,74,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Integrability,wrap,wrapper,10,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Modifiability,variab,variable,39,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:58,Modifiability,variab,variable,58,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Usability,Simpl,Simple,3,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Safety,safe,safety,56,"// Warn if we deduced 'id'. 'auto' usually implies type-safety, but using; // 'id' instead of a specific object type prevents most of our usual; // checks.; // We only want to warn outside of template instantiations, though:; // inside a template, the 'id' could have come from a parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Modifiability,variab,variable,41,// Check the deduced type is valid for a variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it. Just ignore; // the initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Modifiability,variab,variable,52,// WebAssembly tables can't be used to initialise a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Availability,recover,recovery,78,"// There are unresolved typos in Init, just drop them.; // FIXME: improve the recovery strategy to preserve the Init.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Safety,recover,recovery,78,"// There are unresolved typos in Init, just drop them.; // FIXME: improve the recovery strategy to preserve the Init.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Availability,recover,recovery-expr,53,// Invalidate the decl as we don't know the type for recovery-expr yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Safety,recover,recovery-expr,53,// Invalidate the decl as we don't know the type for recovery-expr yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,variab,variable,31,// dllimport cannot be used on variable definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Modifiability,variab,variable,7,// The variable can not have an abstract class type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:121,Modifiability,variab,variable,121,"// If adding the initializer will turn this declaration into a definition,; // and we already have a definition for this variable, diagnose or otherwise; // handle the situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:501,Performance,perform,performed,501,"// C++ [class.static.data]p4; // If a static data member is of const integral or const; // enumeration type, its declaration in the class definition can; // specify a constant-initializer which shall be an integral; // constant expression (5.19). In that case, the member can appear; // in integral constant expressions. The member shall still be; // defined in a namespace scope if it is used in the program and the; // namespace scope definition shall not contain an initializer.; //; // We already performed a redefinition check above, but for static; // data members we also need to check whether there was an in-class; // declaration with an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Energy Efficiency,allocate,allocated,32,"// OpenCL 1.1 6.5.2: ""Variables allocated in the __local address space inside; // a kernel function cannot be initialized.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Modifiability,Variab,Variables,22,"// OpenCL 1.1 6.5.2: ""Variables allocated in the __local address space inside; // a kernel function cannot be initialized.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Performance,Load,LoaderUninitialized,7,// The LoaderUninitialized attribute acts as a definition (of undef).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:89,Modifiability,variab,variable,89,// Expressions default to 'id' when we're in a debugger; // and we are assigning it to a variable of Objective-C pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform the initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Availability,recover,recovery,81,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Availability,recover,recovery,106,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Safety,recover,recovery,81,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Safety,recover,recovery,106,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Availability,error,error,19,"// In general, for error recovery purposes, the initalizer doesn't play; // part in the valid bit of the declaration. There are a few exceptions:; // 1) if the var decl has a deduced auto type, and the type cannot be; // deduced by an invalid initializer;; // 2) if the var decl is decompsition decl with a non-deduced type, and; // the initialization fails (e.g. `int [a] = {1, 2};`);; // Case 1) was already handled elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Availability,recover,recovery,25,"// In general, for error recovery purposes, the initalizer doesn't play; // part in the valid bit of the declaration. There are a few exceptions:; // 1) if the var decl has a deduced auto type, and the type cannot be; // deduced by an invalid initializer;; // 2) if the var decl is decompsition decl with a non-deduced type, and; // the initialization fails (e.g. `int [a] = {1, 2};`);; // Case 1) was already handled elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Safety,recover,recovery,25,"// In general, for error recovery purposes, the initalizer doesn't play; // part in the valid bit of the declaration. There are a few exceptions:; // 1) if the var decl has a deduced auto type, and the type cannot be; // deduced by an invalid initializer;; // 2) if the var decl is decompsition decl with a non-deduced type, and; // the initialization fails (e.g. `int [a] = {1, 2};`);; // Case 1) was already handled elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:36,Modifiability,variab,variable,36,"// Check for self-references within variable initializers.; // Variables declared within a function/method body (except for references); // are handled by a dataflow analysis.; // This is undefined behavior in C++, but valid in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:63,Modifiability,Variab,Variables,63,"// Check for self-references within variable initializers.; // Variables declared within a function/method body (except for references); // are handled by a dataflow analysis.; // This is undefined behavior in C++, but valid in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:55,Modifiability,variab,variable,55,// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Safety,safe,safe,9,// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:934,Integrability,depend,dependent,934,"// This is an in-class initialization for a static data member, e.g.,; //; // struct S {; // static const int value = 17;; // };; // C++ [class.mem]p4:; // A member-declarator can contain a constant-initializer only; // if it declares a static member (9.4) of const integral or; // const enumeration type, see 9.4.2.; //; // C++11 [class.static.data]p3:; // If a non-volatile non-inline const static data member is of integral; // or enumeration type, its declaration in the class definition can; // specify a brace-or-equal-initializer in which every initializer-clause; // that is an assignment-expression is a constant expression. A static; // data member of literal type can be declared in the class definition; // with the constexpr specifier; if so, its declaration shall specify a; // brace-or-equal-initializer in which every initializer-clause that is; // an assignment-expression is a constant expression.; // Do nothing on dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:127,Modifiability,variab,variable,127,"// Allow any 'static constexpr' members, whether or not they are of literal; // type. We separately check that every constexpr variable is of literal; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:84,Modifiability,variab,variables,84,"// In C, extern is typically used to avoid tentative definitions when; // declaring variables in headers, but adding an intializer makes it a; // definition. This is somewhat confusing, so GCC and Clang both warn on it.; // In C++, extern is often used to give implictly static const variables; // external linkage, so don't warn in that case. If selectany is present,; // this might be header code intended for C and C++ inclusion, so apply the; // C++ rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:284,Modifiability,variab,variables,284,"// In C, extern is typically used to avoid tentative definitions when; // declaring variables in headers, but adding an intializer makes it a; // definition. This is somewhat confusing, so GCC and Clang both warn on it.; // In C++, extern is often used to give implictly static const variables; // external linkage, so don't warn in that case. If selectany is present,; // this might be header code intended for C and C++ inclusion, so apply the; // C++ rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:37,Safety,avoid,avoid,37,"// In C, extern is typically used to avoid tentative definitions when; // declaring variables in headers, but adding an intializer makes it a; // definition. This is somewhat confusing, so GCC and Clang both warn on it.; // In C++, extern is often used to give implictly static const variables; // external linkage, so don't warn in that case. If selectany is present,; // this might be header code intended for C and C++ inclusion, so apply the; // C++ rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Modifiability,variab,variable,34,"// In Microsoft C++ mode, a const variable defined in namespace scope has; // external linkage by default if the variable is declared with; // __declspec(dllexport).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:113,Modifiability,variab,variable,113,"// In Microsoft C++ mode, a const variable defined in namespace scope has; // external linkage by default if the variable is declared with; // __declspec(dllexport).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Availability,error,error,52,"/// ActOnInitializerError - Given that there was an error parsing an; /// initializer for the given declaration, try to at least re-establish; /// invariants such as whether a variable's type is either dependent or; /// complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:202,Integrability,depend,dependent,202,"/// ActOnInitializerError - Given that there was an error parsing an; /// initializer for the given declaration, try to at least re-establish; /// invariants such as whether a variable's type is either dependent or; /// complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:176,Modifiability,variab,variable,176,"/// ActOnInitializerError - Given that there was an error parsing an; /// initializer for the given declaration, try to at least re-establish; /// invariants such as whether a variable's type is either dependent or; /// complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:93,Integrability,depend,dependent,93,"// Our main concern here is re-establishing invariants like ""a; // variable's type is either dependent or complete"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:67,Modifiability,variab,variable,67,"// Our main concern here is re-establishing invariants like ""a; // variable's type is either dependent or complete"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Usability,usab,usable,20,// Bindings are not usable if we can't make sense of the initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it. Just ignore it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:276,Modifiability,variab,variable,276,"// C++11 [class.static.data]p3: A static data member can be declared with; // the constexpr specifier; if so, its declaration shall specify; // a brace-or-equal-initializer.; // C++11 [dcl.constexpr]p1: The constexpr specifier shall be applied only to; // the definition of a variable [...] or the declaration of a static data; // member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Modifiability,variab,variables,23,// OpenCL v1.1 s6.5.3: variables declared in the constant address space must; // be initialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:346,Availability,error,error,346,"// C99 6.9.2p3: If the declaration of an identifier for an object is; // a tentative definition and has internal linkage (C99 6.2.2p3), the; // declared type shall not be an incomplete type.; // NOTE: code such as the following; // static struct s;; // struct s { int a; };; // is accepted by gcc. Hence here we issue a warning instead of; // an error and we do not invalidate the static declaration.; // NOTE: to avoid multiple warnings, only check the first declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:414,Safety,avoid,avoid,414,"// C99 6.9.2p3: If the declaration of an identifier for an object is; // a tentative definition and has internal linkage (C99 6.2.2p3), the; // declared type shall not be an incomplete type.; // NOTE: code such as the following; // static struct s;; // struct s { int a; };; // is accepted by gcc. Hence here we issue a warning instead of; // an error and we do not invalidate the static declaration.; // NOTE: to avoid multiple warnings, only check the first declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Modifiability,variab,variable,51,// Provide a specific diagnostic for uninitialized variable; // definitions with incomplete array type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Modifiability,variab,variable,51,// Provide a specific diagnostic for uninitialized variable; // definitions with reference type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Integrability,depend,dependent,80,// Do not attempt to type-check the default initializer for a; // variable with dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:66,Modifiability,variab,variable,66,// Do not attempt to type-check the default initializer for a; // variable with dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Modifiability,variab,variable,7,// The variable can not have an abstract class type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:94,Modifiability,variab,variable,94,"// Check for jumps past the implicit initializer. C++0x; // clarifies that this applies to a ""variable with automatic; // storage duration"", not a ""local variable"".; // C++11 [stmt.dcl]p3; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope is; // ill-formed unless the variable has scalar type, class type with a; // trivial default constructor and a trivial destructor, a cv-qualified; // version of one of these types, or an array of one of the preceding; // types and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:154,Modifiability,variab,variable,154,"// Check for jumps past the implicit initializer. C++0x; // clarifies that this applies to a ""variable with automatic; // storage duration"", not a ""local variable"".; // C++11 [stmt.dcl]p3; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope is; // ill-formed unless the variable has scalar type, class type with a; // trivial default constructor and a trivial destructor, a cv-qualified; // version of one of these types, or an array of one of the preceding; // types and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:234,Modifiability,variab,variable,234,"// Check for jumps past the implicit initializer. C++0x; // clarifies that this applies to a ""variable with automatic; // storage duration"", not a ""local variable"".; // C++11 [stmt.dcl]p3; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope is; // ill-formed unless the variable has scalar type, class type with a; // trivial default constructor and a trivial destructor, a cv-qualified; // version of one of these types, or an array of one of the preceding; // types and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:356,Modifiability,variab,variable,356,"// Check for jumps past the implicit initializer. C++0x; // clarifies that this applies to a ""variable with automatic; // storage duration"", not a ""local variable"".; // C++11 [stmt.dcl]p3; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope is; // ill-formed unless the variable has scalar type, class type with a; // trivial default constructor and a trivial destructor, a cv-qualified; // version of one of these types, or an array of one of the preceding; // types and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Availability,recover,recovery-expr,35,"// If default-init fails, attach a recovery-expr initializer to track; // that initialization was attempted and failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Safety,recover,recovery-expr,35,"// If default-init fails, attach a recovery-expr initializer to track; // that initialization was attempted and failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it. Ignore it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:37,Modifiability,variab,variable,37,// OpenCL v2.0 s6.12.5 - Every block variable declaration must have an; // initialiser,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:95,Modifiability,variab,variable,95,"// In Objective-C, don't allow jumps past the implicit initialization of a; // local retaining variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,Modifiability,variab,variables,33,"// Warn about externally-visible variables being defined without a; // prior declaration. We only want to do this for global; // declarations, but we also specifically need to avoid doing it for; // class members because the linkage of an anonymous class can; // change if it's later given a typedef name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:176,Safety,avoid,avoid,176,"// Warn about externally-visible variables being defined without a; // prior declaration. We only want to do this for global; // declarations, but we also specifically need to avoid doing it for; // class members because the linkage of an anonymous class can; // change if it's later given a typedef name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,variab,variable,3,/* variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Cache,Cache,3,// Cache the result of checking for constant initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:197,Integrability,depend,depend,197,"// If this variable might have a constant initializer or might be usable in; // constant expressions, check whether or not it actually is now. We can't; // do this lazily, because the result might depend on things that change; // later, such as which constexpr functions happen to be defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Modifiability,variab,variable,11,"// If this variable might have a constant initializer or might be usable in; // constant expressions, check whether or not it actually is now. We can't; // do this lazily, because the result might depend on things that change; // later, such as which constexpr functions happen to be defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:66,Usability,usab,usable,66,"// If this variable might have a constant initializer or might be usable in; // constant expressions, check whether or not it actually is now. We can't; // do this lazily, because the result might depend on things that change; // later, such as which constexpr functions happen to be defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Performance,cache,cache,15,"// Compute and cache the constant value, and remember that we have a; // constant initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Modifiability,variab,variables,50,// Apply section attributes and pragmas to global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Modifiability,variab,variable,11,"// If this variable must be emitted, add it as an initializer for the; // current module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Modifiability,variab,variable,11,"// If this variable must be emitted, add it as an initializer for the current; // module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:17,Modifiability,inherit,inherit,17,// Static locals inherit dll attributes from their function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,Modifiability,variab,variable,57,// Export this function to enforce exporting this static variable even; // if it is not used in this compilation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:69,Modifiability,variab,variable,69,// Perform TLS alignment check here after attributes attached to the variable; // which may affect the alignment have been processed. Only perform the check; // if the target has a maximum TLS alignment (zero means no constraints).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform TLS alignment check here after attributes attached to the variable; // which may affect the alignment have been processed. Only perform the check; // if the target has a maximum TLS alignment (zero means no constraints).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Performance,perform,perform,139,// Perform TLS alignment check here after attributes attached to the variable; // which may affect the alignment have been processed. Only perform the check; // if the target has a maximum TLS alignment (zero means no constraints).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Integrability,depend,dependent,51,// Protect the check so that it's not performed on dependent types and; // dependent alignments (we can't determine the alignment in that case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:75,Integrability,depend,dependent,75,// Protect the check so that it's not performed on dependent types and; // dependent alignments (we can't determine the alignment in that case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Performance,perform,performed,38,// Protect the check so that it's not performed on dependent types and; // dependent alignments (we can't determine the alignment in that case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:71,Performance,perform,perform,71,/// FinalizeDeclaration - called by ParseDeclarationAfterDeclarator to perform; /// any semantic actions necessary after any initializer has been attached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Modifiability,variab,variables,56,"// Perform check for initializers of device-side global variables.; // CUDA allows empty constructors as initializers (see E.2.3.1, CUDA; // 7.5). We must also apply the same checks to all __shared__; // variables whether they are local or not. CUDA also allows; // constant initializers for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:204,Modifiability,variab,variables,204,"// Perform check for initializers of device-side global variables.; // CUDA allows empty constructors as initializers (see E.2.3.1, CUDA; // 7.5). We must also apply the same checks to all __shared__; // variables whether they are local or not. CUDA also allows; // constant initializers for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:320,Modifiability,variab,variables,320,"// Perform check for initializers of device-side global variables.; // CUDA allows empty constructors as initializers (see E.2.3.1, CUDA; // 7.5). We must also apply the same checks to all __shared__; // variables whether they are local or not. CUDA also allows; // constant initializers for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,"// Perform check for initializers of device-side global variables.; // CUDA allows empty constructors as initializers (see E.2.3.1, CUDA; // 7.5). We must also apply the same checks to all __shared__; // variables whether they are local or not. CUDA also allows; // constant initializers for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Modifiability,variab,variables,23,"// dllimport/dllexport variables cannot be thread local, their TLS index; // isn't exported with the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:101,Modifiability,variab,variable,101,"// dllimport/dllexport variables cannot be thread local, their TLS index; // isn't exported with the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,Safety,safe,safe,193,"// But if this is a static local in a dlimport/dllexport function, the; // function will never be inlined, which means the var would never be; // imported, so having it marked import/export is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:111,Modifiability,variab,variable,111,"// If there's a #pragma GCC visibility in scope, and this isn't a class; // member, set the visibility of this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Deployability,update,update,46,// Now we have parsed the initializer and can update the table of magic; // tag values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:82,Performance,perform,perform,82,"// For declarators, there are some additional syntactic-ish checks we need; // to perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:72,Modifiability,variab,variable,72,// A declarator that uses 'auto' in any way other than to declare a; // variable with a deduced type cannot be combined with any other; // declarator in the same group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:89,Performance,perform,performing,89,"/// BuildDeclaratorGroup - convert a list of declarations into a declaration; /// group, performing any necessary semantic checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:82,Usability,simpl,simple,82,// [dcl.meaning]p1: An unqualified-id occurring in a declarator-id shall be a; // simple identifier except [...irrelevant cases...].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:107,Availability,toler,tolerate,107,"// In C++11, the 'register' storage class specifier is deprecated.; // In C++17, it is not allowed, but we tolerate it as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by removing the name,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by removing the name,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Modifiability,variab,variables,29,"// Temporarily put parameter variables in the translation unit, not; // the enclosing context. This prevents them from accidentally; // looking like class members in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Modifiability,variab,variable,18,/// Synthesizes a variable for a parameter arising from a; /// typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Availability,error,errors,35,// Don't diagnose unused-parameter errors in template instantiations; we; // will already have done so in the template itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Availability,error,error,99,"// Special cases for arrays:; // - if it's const, use __unsafe_unretained; // - otherwise, it's an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Availability,error,error,99,"// Special cases for arrays:; // - if it's const, use __unsafe_unretained; // - otherwise, it's an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Integrability,interface,interface,35,// Parameter declarators cannot be interface types. All ObjC objects are; // passed by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:17,Availability,error,error,17,// Don't emit an error when this is redefinition of a typo-corrected; // definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:199,Modifiability,variab,variable,199,"// Each ExpressionEvaluationContextRecord also keeps track of whether the; // context is nested in an immediate function context, so smaller contexts; // that appear inside immediate functions (like variable initializers) are; // considered to be inside an immediate function context even though by; // themselves they are not immediate function contexts. But when a new; // function is entered, we need to reset this tracking, since the entered; // function might be not an immediate function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:118,Performance,perform,performed,118,"// See if this is a redefinition. If 'will have body' (or similar) is already; // set, then these checks were already performed when it was set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:399,Modifiability,variab,variables,399,"// If we are instantiating a generic lambda call operator, push; // a LambdaScopeInfo onto the function stack. But use the information; // that's already been calculated (ActOnLambdaExpr) to prime the current; // LambdaScopeInfo.; // When the template operator is being specialized, the LambdaScopeInfo,; // has to be properly restored so that tryCaptureVariable doesn't try; // and capture any new variables. In addition when calculating potential; // captures during transformation of nested lambdas, it is necessary to; // have the LSI properly restored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Security,access,accessible,35,"// If the decl has a name, make it accessible in the current scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,Security,access,accessible,76,"// Similarly, dive into enums and fish their constants out, making them; // accessible in this scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:276,Testability,test,test,276,"// C++ [module.import/6] external definitions are not permitted in header; // units. Deleted and Defaulted functions are implicitly inline (but the; // inline state is not set at this point, so check the BodyKind explicitly).; // FIXME: Consider an alternate location for the test where the inlined(); // state is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Modifiability,variab,variables,80,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,Modifiability,variab,variables,174,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:267,Modifiability,variab,variables,267,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:342,Modifiability,variab,variable,342,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:542,Modifiability,variab,variable,542,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:611,Modifiability,variab,variable,611,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:138,Performance,optimiz,optimization,138,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:231,Performance,optimiz,optimization,231,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:409,Performance,optimiz,optimization,409,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:462,Usability,simpl,simplistic,462,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,Integrability,depend,dependent,105,"// We can't simply call Type::isUndeducedType here, because inside template; // auto can be deduced to a dependent type, which is not considered; // ""undeduced"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:12,Usability,simpl,simply,12,"// We can't simply call Type::isUndeducedType here, because inside template; // auto can be deduced to a dependent type, which is not considered; // ""undeduced"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,// Update the return type to the deduced type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Performance,optimiz,optimization,39,// Try to apply the named return value optimization. We have to check; // if we can do this here because lambdas keep return statements around; // to deduce an implicit return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:217,Safety,detect,detect,217,// GNU warning -Wmissing-prototypes:; // Warn if a global function is defined without a previous; // prototype declaration. This warning is issued even if the; // definition itself provides a prototype. The aim is to detect; // global functions that fail to be declared in header files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:725,Integrability,depend,depending,725,"// The function definition has parameters, so this will change behavior; // in C23. If there is a possible prototype, it comes before the; // function definition.; // FIXME: The declaration may have already been diagnosed as being; // deprecated in GetFullTypeForDeclarator() if it had no arguments, but; // there's no way to test for the ""changes behavior"" condition in; // SemaType.cpp when forming the declaration's function type. So, we do; // this awkward dance instead.; //; // If we have a possible prototype and it declares a function with a; // prototype, we don't want to diagnose it; if we have a possible; // prototype and it has no prototype, it may have already been; // diagnosed in SemaType.cpp as deprecated depending on whether; // -Wstrict-prototypes is enabled. If we already warned about it being; // deprecated, add a note that it also changes behavior. If we didn't; // warn about it being deprecated (because the diagnostic is not; // enabled), warn now that it is deprecated and changes behavior.; // This K&R C function definition definitely changes behavior in C23,; // so diagnose it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:326,Testability,test,test,326,"// The function definition has parameters, so this will change behavior; // in C23. If there is a possible prototype, it comes before the; // function definition.; // FIXME: The declaration may have already been diagnosed as being; // deprecated in GetFullTypeForDeclarator() if it had no arguments, but; // there's no way to test for the ""changes behavior"" condition in; // SemaType.cpp when forming the declaration's function type. So, we do; // this awkward dance instead.; //; // If we have a possible prototype and it declares a function with a; // prototype, we don't want to diagnose it; if we have a possible; // prototype and it has no prototype, it may have already been; // diagnosed in SemaType.cpp as deprecated depending on whether; // -Wstrict-prototypes is enabled. If we already warned about it being; // deprecated, add a note that it also changes behavior. If we didn't; // warn about it being deprecated (because the diagnostic is not; // enabled), warn now that it is deprecated and changes behavior.; // This K&R C function definition definitely changes behavior in C23,; // so diagnose it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,Testability,test,tested,105,"// If we have a possible prototype for the function which is a user-; // visible declaration, we already tested that it has no prototype.; // This will change behavior in C23. This gets a warning rather than a; // note because it's the same behavior-changing problem as with the; // definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,// Update the key-function state if necessary for this ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Availability,error,errors,10,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up; // for deletion in some later function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Usability,clear,clear,32,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up; // for deletion in some later function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Modifiability,variab,variables,24,// Allow local register variables without initializer as they don't; // require prologue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Availability,error,errors,10,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up for; // deletion in some later function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Usability,clear,clear,32,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up for; // deletion in some later function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Integrability,inject,injected,45,"// Find the scope in which the identifier is injected and the corresponding; // DeclContext.; // FIXME: C89 does not say what happens if there is no enclosing block scope.; // In that case, we inject the declaration into the translation unit scope; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,Integrability,inject,inject,193,"// Find the scope in which the identifier is injected and the corresponding; // DeclContext.; // FIXME: C89 does not say what happens if there is no enclosing block scope.; // In that case, we inject the declaration into the translation unit scope; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Security,inject,injected,45,"// Find the scope in which the identifier is injected and the corresponding; // DeclContext.; // FIXME: C89 does not say what happens if there is no enclosing block scope.; // In that case, we inject the declaration into the translation unit scope; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,Security,inject,inject,193,"// Find the scope in which the identifier is injected and the corresponding; // DeclContext.; // FIXME: C89 does not say what happens if there is no enclosing block scope.; // In that case, we inject the declaration into the translation unit scope; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:176,Safety,avoid,avoids,176,"// Loop until we find a DeclContext that is either a function/method or the; // translation unit, which are the only two valid places to implicitly define; // a function. This avoids accidentally defining the function within a tag; // declaration, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Modifiability,variab,variable,160,"// Before we produce a declaration for an implicitly defined; // function, see whether there was a locally-scoped declaration of; // this name as a function or variable. If so, use that; // (non-visible) declaration, and complain about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Integrability,inject,inject,20,// We still need to inject the function into the enclosing block scope so; // that later (non-call) uses can see it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Security,inject,inject,20,// We still need to inject the function into the enclosing block scope so; // that later (non-call) uses can see it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,Availability,error,error,33,"// Extension in C99 (defaults to error). Legal in C89, but warn about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:122,Availability,error,error,122,"// Because typo correction is expensive, only do it if the implicit; // function declaration is going to be treated as an error.; //; // Perform the correction before issuing the main diagnostic, as some; // consumers use typo-correction callbacks to enhance the main diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:251,Modifiability,enhance,enhance,251,"// Because typo correction is expensive, only do it if the implicit; // function declaration is going to be treated as an error.; //; // Perform the correction before issuing the main diagnostic, as some; // consumers use typo-correction callbacks to enhance the main diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:137,Performance,Perform,Perform,137,"// Because typo correction is expensive, only do it if the implicit; // function declaration is going to be treated as an error.; //; // Perform the correction before issuing the main diagnostic, as some; // consumers use typo-correction callbacks to enhance the main diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Availability,Error,ErrorRecovery,2,/*ErrorRecovery*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:132,Availability,failure,failure,132,"// C++2a [basic.stc.dynamic.allocation]p4:; // An allocation function that has a non-throwing exception specification; // indicates failure by returning a null pointer value. Any other allocation; // function never returns a null pointer value and indicates failure only by; // throwing an exception [...]; //; // However, -fcheck-new invalidates this possible assumption, so don't add; // NonNull when that is enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:258,Availability,failure,failure,258,"// C++2a [basic.stc.dynamic.allocation]p4:; // An allocation function that has a non-throwing exception specification; // indicates failure by returning a null pointer value. Any other allocation; // function never returns a null pointer value and indicates failure only by; // throwing an exception [...]; //; // However, -fcheck-new invalidates this possible assumption, so don't add; // NonNull when that is enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:82,Energy Efficiency,allocate,allocate,82,"// C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. [...] If the request succeeds, the value returned by a; // replaceable allocation function is a [...] pointer value p0 different; // from any previously returned value p1 [...]; //; // However, this particular information is being added in codegen,; // because there is an opt-out switch for it (-fno-assume-sane-operator-new); // C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. If it is successful, it returns the address of the start of a; // block of storage whose length in bytes is at least as large as the; // requested size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:538,Energy Efficiency,allocate,allocate,538,"// C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. [...] If the request succeeds, the value returned by a; // replaceable allocation function is a [...] pointer value p0 different; // from any previously returned value p1 [...]; //; // However, this particular information is being added in codegen,; // because there is an opt-out switch for it (-fno-assume-sane-operator-new); // C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. If it is successful, it returns the address of the start of a; // block of storage whose length in bytes is at least as large as the; // requested size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:347,Modifiability,extend,extended,347,"// FIXME:; // C++2a [basic.stc.dynamic.allocation]p3:; // For an allocation function [...], the pointer returned on a successful; // call shall represent the address of storage that is aligned as follows:; // (3.2) Otherwise, if the allocation function is named operator new[],; // the storage is aligned for any object that does not have; // new-extended alignment ([basic.align]) and is no larger than the; // requested size.; // (3.3) Otherwise, the storage is aligned for any object that does not; // have new-extended alignment and is of the requested size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:514,Modifiability,extend,extended,514,"// FIXME:; // C++2a [basic.stc.dynamic.allocation]p3:; // For an allocation function [...], the pointer returned on a successful; // call shall represent the address of storage that is aligned as follows:; // (3.2) Otherwise, if the allocation function is named operator new[],; // the storage is aligned for any object that does not have; // new-extended alignment ([basic.align]) and is no larger than the; // requested size.; // (3.3) Otherwise, the storage is aligned for any object that does not; // have new-extended alignment and is of the requested size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Integrability,depend,depending,34,"// Add the appropriate attribute, depending on the CUDA compilation mode; // and which target the builtin belongs to. For example, during host; // compilation, aux builtins are __device__, while the rest are __host__.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Availability,error,error,49,// This doesn't use 'isIntegralType' despite the error message mentioning; // integral type because isIntegralType would also allow enum types in C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:55,Integrability,message,message,55,// This doesn't use 'isIntegralType' despite the error message mentioning; // integral type because isIntegralType would also allow enum types in C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Integrability,message,message,80,/// Get diagnostic %select index for tag kind for; /// redeclaration diagnostic message.; /// WARNING: Indexes apply to particular diagnostics only!; ///; /// \returns diagnostic %select index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:117,Safety,avoid,avoids,117,"// We only need to do this matching if we have template parameters; // or a scope specifier, which also conveniently avoids this work; // for non-C++ cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:115,Safety,detect,detect,115,"// Figure out the underlying type if this a enum declaration. We need to do; // this early, because it's needed to detect if this is an incompatible; // redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by falling back to int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by falling back to int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:54,Integrability,depend,dependent,54,"// If this is a friend or a reference to a class in a dependent; // context, don't try to make a decl for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Integrability,depend,dependent,160,"// Name lookup did not find anything. However, if the; // nested-name-specifier refers to the current instantiation,; // and that current instantiation has any dependent base; // classes, we might find something at instantiation time: treat; // this as a dependent elaborated-type-specifier.; // But this only makes any sense for reference-like lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:255,Integrability,depend,dependent,255,"// Name lookup did not find anything. However, if the; // nested-name-specifier refers to the current instantiation,; // and that current instantiation has any dependent base; // classes, we might find something at instantiation time: treat; // this as a dependent elaborated-type-specifier.; // But this only makes any sense for reference-like lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Availability,recover,recovery,42,// Note: there used to be some attempt at recovery here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Safety,recover,recovery,42,// Note: there used to be some attempt at recovery here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:650,Availability,error,error,650,"// C++ [basic.scope.pdecl]p5:; // -- for an elaborated-type-specifier of the form; //; // class-key identifier; //; // if the elaborated-type-specifier is used in the; // decl-specifier-seq or parameter-declaration-clause of a; // function defined in namespace scope, the identifier is; // declared as a class-name in the namespace that contains; // the declaration; otherwise, except as a friend; // declaration, the identifier is declared in the smallest; // non-class, non-function-prototype scope that contains the; // declaration.; //; // C99 6.7.2.3p8 has a similar (but not identical!) provision for; // C structs and unions.; //; // It is an error in C++ to declare (rather than define) an enum; // type, including via an elaborated type specifier. We'll; // diagnose that later; for now, declare the enum in the same; // scope as we would have picked for any other tag type.; //; // GNU C also supports this behavior as part of its incomplete; // enum types extension, while GNU C++ does not.; //; // Find the context where we'll be declaring the tag.; // FIXME: We would like to maintain the current DeclContext as the; // lexical context,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:220,Availability,error,errors,220,"// In C++, we need to do a redeclaration lookup to properly; // diagnose some problems.; // FIXME: redeclaration lookup is also used (with and without C++) to find a; // hidden declaration so that we don't get ambiguity errors when using a; // type declared by an elaborated-type-specifier. In C that is not correct; // and we should instead merge compatible types found by lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Performance,perform,perform,19,"// FIXME: This can perform qualified lookups into function contexts,; // which are meaningless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by ignoring the old declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by ignoring the old declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by making this an anonymous redefinition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by making this an anonymous redefinition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Availability,recover,recovered,48,"// All conflicts with previous declarations are recovered by; // returning the previous declaration, unless this is a definition,; // in which case we want the caller to bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Safety,recover,recovered,48,"// All conflicts with previous declarations are recovered by; // returning the previous declaration, unless this is a definition,; // in which case we want the caller to bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:414,Integrability,inject,injected,414,"// This declaration is a reference to an existing entity, but; // has different visibility from that entity: it either makes; // a friend visible or it makes a type visible in a new module.; // In either case, create a new declaration. We only do this if; // the declaration would have meant the same thing if no prior; // declaration were found, that is, if it was found in the same; // scope where we would have injected a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:414,Security,inject,injected,414,"// This declaration is a reference to an existing entity, but; // has different visibility from that entity: it either makes; // a friend visible or it makes a type visible in a new module.; // In either case, create a new declaration. We only do this if; // the declaration would have meant the same thing if no prior; // declaration were found, that is, if it was found in the same; // scope where we would have injected a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Integrability,inject,injected,18,"// This is in the injected scope, create a new declaration in; // that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Security,inject,injected,18,"// This is in the injected scope, create a new declaration in; // that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:119,Availability,error,error,119,"// If we're defining a specialization and the previous definition; // is from an implicit instantiation, don't emit an error; // here; we'll catch this in the general case below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Availability,recover,recover,30,"// If this is a redefinition, recover by making this; // struct be anonymous, which will make any later; // references get the previous definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Safety,recover,recover,30,"// If this is a redefinition, recover by making this; // struct be anonymous, which will make any later; // references get the previous definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:181,Security,access,access,181,"// Okay, we're going to make a redeclaration. If this is some kind; // of reference, make sure we build the redeclaration in the same DC; // as the original, and ignore the current access specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Availability,error,error,78,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:88,Availability,recover,recover,88,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:88,Safety,recover,recover,88,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Usability,clear,clear,79,"// The existing declaration isn't relevant to us; we're in a; // new scope, so clear out the previous declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Usability,simpl,simple,47,// FIXME: Look for a way to use RecordDecl for simple structs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:96,Availability,error,error,96,"// __module_private__ does not apply to local classes. However, we only; // diagnose this as an error when the declaration specifiers are; // freestanding. Here, we just ignore the __module_private__.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,Integrability,inject,inject,174,"// If we're declaring or defining a tag in function prototype scope in C,; // note that this type can only be used within the function and add it to; // the list of decls to inject into the function definition scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,Security,inject,inject,174,"// If we're declaring or defining a tag in function prototype scope in C,; // note that this type can only be used within the function and add it to; // the list of decls to inject into the function definition scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Security,access,access,11,// Set the access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:93,Security,access,access,93,"// We might be replacing an existing declaration in the lookup tables;; // if so, borrow its access specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Availability,error,error,26,// can be null along some error paths,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,Availability,recover,recover,57,"// In C++, don't return an invalid declaration. We can't recover well from; // the cases where we make the type anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,Safety,recover,recover,57,"// In C++, don't return an invalid declaration. We can't recover well from; // the cases where we make the type anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:121,Integrability,inject,injected-class-name,121,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:183,Integrability,inject,injected-class-name,183,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:121,Security,inject,injected-class-name,121,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:162,Security,access,access,162,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:183,Security,inject,injected-class-name,183,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Integrability,interface,interface,27,// Exit this scope of this interface definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Usability,undo,undoing,9,"// We're undoing ActOnTagStartDefinition here, not; // ActOnStartCXXMemberDeclarations, so we don't have to mess with; // the FieldCollector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Availability,error,error,56,// Handle incomplete and sizeless types with a specific error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Integrability,depend,dependent,38,"// If the bit-width is type- or value-dependent, don't try to check; // it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Availability,error,error,30,// Over-wide bitfields are an error in C or when using the MSVC bitfield; // ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:72,Integrability,rout,routine,72,"/// Build a new FieldDecl and check its well-formedness.; ///; /// This routine builds a new FieldDecl given the fields name, type,; /// record, etc. \p PrevDecl should refer to any previous declaration; /// with the same name and in the same scope as the field to be; /// created.; ///; /// \returns a new FieldDecl.; ///; /// \todo The Declarator argument is a hack. It will be removed once",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Availability,recover,recover,32,"// If we receive a broken type, recover by assuming 'int' and; // marking this declaration as invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Safety,recover,recover,32,"// If we receive a broken type, recover by assuming 'int' and; // marking this declaration as invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Modifiability,variab,variably,86,// C99 6.7.2.1p8: A member of a structure or union may have any type other; // than a variably modified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Deployability,release,release,18,"// In auto-retain/release, infer strong retension for fields of; // retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Availability,error,error,31,"// Objective-C++ ARC: it is an error to have a non-trivial field of; // a union. However, system headers in Objective-C programs; // occasionally have Objective-C lifetime objects within unions,; // and rather than cause the program to fail, we make those; // members unavailable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Integrability,inject,inject,99,"// FIXME: Unnamed fields can be handled in various different ways, for; // example, unnamed unions inject all members into the struct namespace!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Security,inject,inject,99,"// FIXME: Unnamed fields can be handled in various different ways, for; // example, unnamed unions inject all members into the struct namespace!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Security,validat,validate,23,// Not a bitfield.; // validate II.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Modifiability,variab,variably,86,// C99 6.7.2.1p8: A member of a structure or union may have any type other; // than a variably modified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Security,access,access,23,// Get the visibility (access control) for this ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Integrability,interface,interface,48,// Must set ivar's DeclContext to its enclosing interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Integrability,interface,interfaces,15,"// FIXME: When interfaces are DeclContexts, we'll need to add; // these to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Integrability,interface,interface,79,"// FIXME: When interfaces are DeclContexts, we'll need to add; // these to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Integrability,rout,routine,29,"/// ActOnLastBitfield - This routine handles synthesized bitfields rules for; /// class and class extensions. For every class \@interface and class; /// extension \@interface, if the last ivar is a bitfield of any type,; /// then add an implicit `char :0` ivar to the end of that interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Integrability,interface,interface,128,"/// ActOnLastBitfield - This routine handles synthesized bitfields rules for; /// class and class extensions. For every class \@interface and class; /// extension \@interface, if the last ivar is a bitfield of any type,; /// then add an implicit `char :0` ivar to the end of that interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:165,Integrability,interface,interface,165,"/// ActOnLastBitfield - This routine handles synthesized bitfields rules for; /// class and class extensions. For every class \@interface and class; /// extension \@interface, if the last ivar is a bitfield of any type,; /// then add an implicit `char :0` ivar to the end of that interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:280,Integrability,interface,interface,280,"/// ActOnLastBitfield - This routine handles synthesized bitfields rules for; /// class and class extensions. For every class \@interface and class; /// extension \@interface, if the last ivar is a bitfield of any type,; /// then add an implicit `char :0` ivar to the end of that interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:94,Performance,perform,performed,94,"/// [class.dtor]p4:; /// At the end of the definition of a class, overload resolution is; /// performed among the prospective destructors declared in that class with; /// an empty argument list to select the destructor for the class, also; /// known as the selected destructor.; ///; /// We do the overload resolution here, then mark the selected constructor in the AST.; /// Later CXXRecordDecl::getDestructor() will return the selected constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Availability,error,error,51,// It's a bit hacky: At this point we've raised an error but we want the; // rest of the compiler to continue somehow working. However almost; // everything we'll try to do with the class will depend on there being a; // destructor. So let's pretend the first one is selected and hope for the; // best.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,Integrability,depend,depend,193,// It's a bit hacky: At this point we've raised an error but we want the; // rest of the compiler to continue somehow working. However almost; // everything we'll try to do with the class will depend on there being a; // destructor. So let's pretend the first one is selected and hope for the; // best.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:16,Availability,error,error,16,// There was an error with the constraints comparison. Exit the loop; // and don't consider this function eligible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:123,Integrability,interface,interface,123,// If this is an Objective-C @implementation or category and we have; // new fields here we should reset the layout of the interface since; // it will now change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,Flexible,Flexible,3,// Flexible array member.; // Microsoft and g++ is more permissive regarding flexible array.; // It will accept flexible array in union and also; // as the sole element of a struct/class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:77,Modifiability,flexible,flexible,77,// Flexible array member.; // Microsoft and g++ is more permissive regarding flexible array.; // It will accept flexible array in union and also; // as the sole element of a struct/class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:112,Modifiability,flexible,flexible,112,// Flexible array member.; // Microsoft and g++ is more permissive regarding flexible array.; // It will accept flexible array in union and also; // as the sole element of a struct/class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:207,Modifiability,flexible,flexible,207,"// While the layout of types that contain virtual bases is not specified; // by the C++ standard, both the Itanium and Microsoft C++ ABIs place; // virtual bases after the derived members. This would make a flexible; // array member declared at the end of an object not adjacent to the end; // of the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Modifiability,flexible,flexible,25,"// Okay, we have a legal flexible array member at the end of the struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Modifiability,flexible,flexible,27,// A type which contains a flexible array member is considered to be a; // flexible array member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:75,Modifiability,flexible,flexible,75,// A type which contains a flexible array member is considered to be a; // flexible array member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:101,Modifiability,variab,variable,101,"// If this is a struct/class and this is not the last element, reject; // it. Note that GCC supports variable sized arrays in the middle of; // structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:14,Modifiability,flexible,flexible,14,// We support flexible arrays at the end of structs in; // other structs as an extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Security,access,access,7,// Set access bits correctly on the directly-declared conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Availability,error,errors,79,// case of ivars in class extension; all other cases have been; // reported as errors elsewhere.; // FIXME. Class extension does not have a LocEnd field.; // CDecl->setLocEnd(RBrac);; // Add ivar's to class extension's DeclContext.; // Diagnose redeclaration of private ivars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:146,Performance,perform,perform,146,"// In Obj-C and Microsoft mode, require the enumeration value to be; // representable in the underlying type of the enumeration. In C++11,; // we perform a non-narrowing conversion as part of converted constant; // expression checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Integrability,wrap,wrap,106,"// There is no integral type larger enough to represent this; // value. Complain, then allow the value to wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Avoid,Avoid,3,// Avoid anonymous enums,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Safety,avoid,avoid,27,// Use int64_t as a key to avoid needing special handling for map keys.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,// Update entry to point to the duplicates vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:130,Availability,mask,masks,130,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:208,Availability,mask,masks,208,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:361,Availability,mask,mask,361,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:396,Availability,mask,mask,396,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:482,Availability,error,error,482,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:476,Testability,log,logic,476,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:58,Modifiability,variab,variable,58,"// If a declaration that:; // 1) declares a function or a variable; // 2) has external linkage; // already exists, add a label attribute to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Modifiability,Variab,Variable,2,/*Variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:192,Testability,stub,stub,192,"// When compiling for device, host functions are never emitted. Similarly,; // when compiling for host, device and global functions are never emitted.; // (Technically, we do emit a host-side stub for global functions, but this; // doesn't count for our purposes here.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:62,Testability,stub,stub,62,"// Host-side references to a __global__ function refer to the stub, so the; // function itself is never emitted and therefore should not be marked.; // If we have host fn calls kernel fn calls host+device, the HD function; // does not get instantiated on the host. We model this by omitting at the; // call to the kernel from the callgraph. This ensures that, when compiling; // for host, only HD functions actually called from the host get marked as; // known-emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:330,Modifiability,variab,variable,330,// end namespace AttributeLangSupport; //===----------------------------------------------------------------------===//; // Helper functions; //===----------------------------------------------------------------------===//; /// isFunctionOrMethod - Return true if the given decl has function; /// type (function or function-typed variable) or an Objective-C; /// method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:85,Modifiability,variab,variable,85,/// Return true if the given decl has function type (function or; /// function-typed variable) or an Objective-C method or a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:97,Availability,error,error,97,/// getFunctionOrMethodNumParams - Return number of function or method; /// parameters. It is an error to call this on a K&R function (use; /// hasFunctionProto first).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:108,Availability,failure,failure,108,"/// If Expr is a valid integer constant, get the value of the integer; /// expression and return success or failure. May output an error.; ///; /// Negative argument is implicitly converted to unsigned, unless; /// \p StrictlyUnsigned is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:131,Availability,error,error,131,"/// If Expr is a valid integer constant, get the value of the integer; /// expression and return success or failure. May output an error.; ///; /// Negative argument is implicitly converted to unsigned, unless; /// \p StrictlyUnsigned is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper around checkUInt32Argument, with an extra check to be sure; /// that the result will fit into a regular (signed) int. All args have the same; /// purpose as they do in checkUInt32Argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:104,Availability,error,error,104,/// Check if IdxExpr is a valid parameter index for a function or; /// instance method D. May output an error.; ///; /// \returns true if IdxExpr is a valid index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:73,Availability,error,error,73,"/// Check if the argument \p E is a ASCII string literal. If not emit an error; /// and return false, otherwise set \p Str to the value of the string literal; /// and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:94,Availability,error,error,94,/// Check if the argument \p ArgNum of \p Attr is a ASCII string literal.; /// If not emit an error and return false. If the argument is an identifier it; /// will emit an error with a fixit hint and treat it as if it was a string; /// literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:172,Availability,error,error,172,/// Check if the argument \p ArgNum of \p Attr is a ASCII string literal.; /// If not emit an error and return false. If the argument is an identifier it; /// will emit an error with a fixit hint and treat it as if it was a string; /// literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:52,Performance,perform,performing,52,/// Applies the given attribute to the Decl without performing any; /// additional semantic checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:91,Availability,error,error,91,/// Check if passed in Decl is a pointer type.; /// Note that this function may produce an error message.; /// \return true if the Decl is a pointer type; false otherwise,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:97,Integrability,message,message,97,/// Check if passed in Decl is a pointer type.; /// Note that this function may produce an error message.; /// \return true if the Decl is a pointer type; false otherwise,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:130,Safety,avoid,avoid,130,"// If it's an incomplete type, it could be a smart pointer; skip it.; // (We don't want to force template instantiation if we can avoid it,; // since that would alter the order in which templates are instantiated.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:71,Testability,log,logic,71,"// Capability expressions are simple expressions involving the boolean logic; // operators &&, || or !, a simple DeclRefExpr, CastExpr or a ParenExpr. Once; // a DeclRefExpr is found, its type should be checked to determine whether it; // is a capability or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:30,Usability,simpl,simple,30,"// Capability expressions are simple expressions involving the boolean logic; // operators &&, || or !, a simple DeclRefExpr, CastExpr or a ParenExpr. Once; // a DeclRefExpr is found, its type should be checked to determine whether it; // is a capability or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:106,Usability,simpl,simple,106,"// Capability expressions are simple expressions involving the boolean logic; // operators &&, || or !, a simple DeclRefExpr, CastExpr or a ParenExpr. Once; // a DeclRefExpr is found, its type should be checked to determine whether it; // is a capability or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:229,Testability,log,logic,229,"// If the type does not have a capability, see if the components of the; // expression have capabilities. This allows for writing C code where the; // capability may be on the type, and the expression is a capability; // boolean logic expression. Eg) requires_capability(A || B && !C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:73,Modifiability,variab,variables,73,// The IBOutlet/IBOutletCollection attributes only apply to instance; // variables or properties of Objective-C classes. The outlet must also; // have an object reference type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:50,Integrability,message,message,50,// Handle the case where the attribute has a text message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:6,Availability,error,error,6,// No error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:50,Integrability,message,message,50,// Handle the case where the attribute has a text message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:27,Availability,avail,availability,27,// If there is an existing availability attribute for this platform that; // has a lower priority use the existing one and discard the new; // attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:46,Availability,avail,availability,46,// Allow different 'introduced' / 'obsoleted' availability versions; // on a method that implements an optional protocol requirement. It; // makes less sense to allow this for 'deprecated' as the user can't; // see if the method is 'deprecated' as 'respondsToSelector' will; // still return true when the method is deprecated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:112,Integrability,protocol,protocol,112,// Allow different 'introduced' / 'obsoleted' availability versions; // on a method that implements an optional protocol requirement. It; // makes less sense to allow this for 'deprecated' as the user can't; // see if the method is 'deprecated' as 'respondsToSelector' will; // still return true when the method is deprecated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Availability,avail,availability,22,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:50,Availability,avail,availability,50,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:97,Availability,avail,availability,97,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:156,Availability,avail,availability,156,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:203,Availability,avail,availability,203,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:69,Integrability,protocol,protocol,69,// objc_direct cannot be set on methods declared in the context of a protocol,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:201,Availability,error,error,201,"// It is okay to include this attribute on properties, e.g.:; //; // @property (retain, nonatomic) struct Bork *Q __attribute__((NSObject));; //; // In this case it follows tradition and suppresses an error in the above; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:15,Availability,error,error,15,"// FIXME: This error message could be improved, it would be nice; // to say what the bounds actually are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:21,Integrability,message,message,21,"// FIXME: This error message could be improved, it would be nice; // to say what the bounds actually are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:47,Modifiability,variab,variable,47,// The standard attribute cannot be applied to variable declarations such; // as a function pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:31,Modifiability,variab,variable,31,// weak_import only applies to variable & function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:46,Modifiability,inherit,inherit,46,// Explicit or partial specializations do not inherit; // the section attribute from the primary template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:209,Availability,Error,Error,209,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:313,Availability,error,errors,313,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:25,Performance,perform,perform,25,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:263,Usability,simpl,simple,263,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Security,validat,validate,22,// Let MCSectionMachO validate this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:46,Modifiability,inherit,inherit,46,// Explicit or partial specializations do not inherit; // the code_seg attribute from the primary template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:19,Performance,tune,tune,19,// Diagnose use of tune if target doesn't support it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:23,Usability,simpl,simple,23,"// gcc only allows for simple identifiers. Since we support more than gcc, we; // will warn the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Performance,perform,perform,8,"// Only perform the priority check if the attribute is outside of a system; // header. Values <= 100 are reserved for the implementation, and libc++; // benefits from being able to specify values in that range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:52,Testability,test,test,52,// FIXME: this isn't fully correct; we also need to test whether the; // members of the union would all have the same calling convention as the; // first member of the union. Checking just the size and alignment isn't; // sufficient (consider structs passed on the stack instead of in registers; // as an example).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Integrability,depend,dependent,8,// Save dependent expressions in the AST to be instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:117,Modifiability,variab,variable,117,"/// Perform checking of type validity; ///; /// C++11 [dcl.align]p1:; /// An alignment-specifier may be applied to a variable or to a class; /// data member, but it shall not be applied to a bit-field, a function; /// parameter, the formal parameter of a catch clause, or a variable; /// declared with the register storage class specifier. An; /// alignment-specifier may also be applied to the declaration of a class; /// or enumeration type.; /// CWG 2354:; /// CWG agreed to remove permission for alignas to be applied to; /// enumerations.; /// C11 6.7.5/2:; /// An alignment attribute shall not be specified in a declaration of; /// a typedef, or a bit-field, or a function, or a parameter, or an; /// object declared with the register storage-class specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:274,Modifiability,variab,variable,274,"/// Perform checking of type validity; ///; /// C++11 [dcl.align]p1:; /// An alignment-specifier may be applied to a variable or to a class; /// data member, but it shall not be applied to a bit-field, a function; /// parameter, the formal parameter of a catch clause, or a variable; /// declared with the register storage class specifier. An; /// alignment-specifier may also be applied to the declaration of a class; /// or enumeration type.; /// CWG 2354:; /// CWG agreed to remove permission for alignas to be applied to; /// enumerations.; /// C11 6.7.5/2:; /// An alignment attribute shall not be specified in a declaration of; /// a typedef, or a bit-field, or a function, or a parameter, or an; /// object declared with the register storage-class specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:4,Performance,Perform,Perform,4,"/// Perform checking of type validity; ///; /// C++11 [dcl.align]p1:; /// An alignment-specifier may be applied to a variable or to a class; /// data member, but it shall not be applied to a bit-field, a function; /// parameter, the formal parameter of a catch clause, or a variable; /// declared with the register storage class specifier. An; /// alignment-specifier may also be applied to the declaration of a class; /// or enumeration type.; /// CWG 2354:; /// CWG agreed to remove permission for alignas to be applied to; /// enumerations.; /// C11 6.7.5/2:; /// An alignment attribute shall not be specified in a declaration of; /// a typedef, or a bit-field, or a function, or a parameter, or an; /// object declared with the register storage-class specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Integrability,depend,dependent,22,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""alignment-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:51,Integrability,depend,dependent,51,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""alignment-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:129,Integrability,depend,dependent,129,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""alignment-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:152,Integrability,depend,dependent,152,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""alignment-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Integrability,depend,dependent,8,// Save dependent expressions in the AST to be instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:10,Performance,Cache,Cache,10,// FIXME: Cache the number on the AL object?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:85,Modifiability,variab,variable,85,"// On AIX, an aligned attribute can not decrease the alignment when applied; // to a variable declaration with vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Integrability,depend,dependent,22,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""type-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:51,Integrability,depend,dependent,51,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""type-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:124,Integrability,depend,dependent,124,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""type-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:147,Integrability,depend,dependent,147,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""type-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:85,Modifiability,variab,variable,85,"// On AIX, an aligned attribute can not decrease the alignment when applied; // to a variable declaration with vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:123,Testability,log,logical,123,"/// handleModeAttr - This attribute modifies the width of a decl with primitive; /// type.; ///; /// Despite what would be logical, the mode attribute is a decl attribute, not a; /// type attribute: 'int ** __attribute((mode(HI))) *G;' tries to make 'G' be; /// HImode, not an intermediate pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Safety,Avoid,Avoid,3,// Avoid duplicate warning from template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Deployability,Install,Install,3,// Install the new type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:48,Modifiability,variab,variables,48,// Attribute does not apply to non-static local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:48,Modifiability,variab,variables,48,// Attribute does not apply to non-static local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:13,Modifiability,variab,variable,13,"// constexpr variable may already get an implicit constant attr, which should; // be replaced by the explicit constant attr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:58,Availability,down,down,58,"// Only warn for ""inline"" when compiling for host, to cut down on noise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:272,Safety,avoid,avoid,272,"// In host compilation the kernel is emitted as a stub function, which is; // a helper function for launching the kernel. The instructions in the helper; // function has nothing to do with the source code of the kernel. Do not emit; // debug info for the stub function to avoid confusing the debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:50,Testability,stub,stub,50,"// In host compilation the kernel is emitted as a stub function, which is; // a helper function for launching the kernel. The instructions in the helper; // function has nothing to do with the source code of the kernel. Do not emit; // debug info for the stub function to avoid confusing the debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:255,Testability,stub,stub,255,"// In host compilation the kernel is emitted as a stub function, which is; // a helper function for launching the kernel. The instructions in the helper; // function has nothing to do with the source code of the kernel. Do not emit; // debug info for the stub function to avoid confusing the debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:40,Modifiability,variab,variables,40,// Analyzer suppression applies only to variables and statements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:220,Availability,error,error,220,"// Checks whether an argument of launch_bounds attribute is; // acceptable, performs implicit conversion to Rvalue, and returns; // non-nullptr Expr result on success. Otherwise, it returns nullptr; // and may output an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:76,Performance,perform,performs,76,"// Checks whether an argument of launch_bounds attribute is; // acceptable, performs implicit conversion to Rvalue, and returns; // non-nullptr Expr result on success. Otherwise, it returns nullptr; // and may output an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:45,Integrability,depend,depend,45,// Accept template arguments for now as they depend on something else.; // We'll get to check them when they eventually get instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:18,Performance,perform,perform,18,// We may need to perform implicit conversion of the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:102,Integrability,depend,dependent,102,"// These attributes are normally just advisory, but in ARC, ns_consumed; // is significant. Allow non-dependent code to contain inappropriate; // attributes even in ARC, but require template instantiations to be; // set up correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:52,Integrability,interface,interfaces,52,// This attribute can only be applied to methods in interfaces or class; // extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:88,Security,access,access,88,// When a user wants to use objc_boxable with a union or struct; // but they don't have access to the declaration (legacy/third-party code); // then they can 'enable' this feature with a typedef:; // typedef struct __attribute((objc_boxable)) legacy_struct legacy_struct;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:17,Security,validat,validation,17,// No additional validation required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:303,Modifiability,variab,variable,303,"// For a function, this will validate a compound Swift name, e.g.; // <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>, and; // the function will output the number of parameter names, and whether this is a; // single-arg initializer.; //; // For a type, enum constant, property, or variable declaration, this will; // validate either a simple identifier, or a qualified; // <code>context.identifier</code> name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:29,Security,validat,validate,29,"// For a function, this will validate a compound Swift name, e.g.; // <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>, and; // the function will output the number of parameter names, and whether this is a; // single-arg initializer.; //; // For a type, enum constant, property, or variable declaration, this will; // validate either a simple identifier, or a qualified; // <code>context.identifier</code> name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:339,Security,validat,validate,339,"// For a function, this will validate a compound Swift name, e.g.; // <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>, and; // the function will output the number of parameter names, and whether this is a; // single-arg initializer.; //; // For a type, enum constant, property, or variable declaration, this will; // validate either a simple identifier, or a qualified; // <code>context.identifier</code> name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:357,Usability,simpl,simple,357,"// For a function, this will validate a compound Swift name, e.g.; // <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>, and; // the function will output the number of parameter names, and whether this is a; // single-arg initializer.; //; // For a type, enum constant, property, or variable declaration, this will; // validate either a simple identifier, or a qualified; // <code>context.identifier</code> name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:15,Security,access,accessor,15,// A subscript accessor must be a getter or setter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:167,Availability,error,error,167,"// ""newValue"" indicates the ""newValue"" argument for a setter.; // There should only be one 'newValue', but it's only significant for; // subscript accessors, so don't error right away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:147,Security,access,accessors,147,"// ""newValue"" indicates the ""newValue"" argument for a setter.; // There should only be one 'newValue', but it's only significant for; // subscript accessors, so don't error right away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:12,Security,access,accessors,12,// Property accessors must have exactly the number of expected params.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Usability,GUID,GUID,3,"// GUID format is ""XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"" or; // ""{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}"", normalize to the former.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Security,Validat,Validate,3,// Validate GUID length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:12,Usability,GUID,GUID,12,// Validate GUID length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Security,Validat,Validate,3,// Validate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:45,Integrability,depend,depend,45,// Accept template arguments for now as they depend on something else.; // We'll get to check them when they eventually get instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:45,Integrability,depend,depend,45,// Accept template arguments for now as they depend on something else.; // We'll get to check them when they eventually get instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:51,Integrability,message,message,51,// Handle the cases where the attribute has a text message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:29,Integrability,message,message,29,// Support a single optional message only for Declspec and [[]] spellings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:553,Testability,assert,assertions,553,"// FIXME: Rather than create a NoSanitizeSpecificAttr, this creates a; // NoSanitizeAttr object; but we need to calculate the correct spelling list; // index rather than incorrectly assume the index for NoSanitizeSpecificAttr; // has the same spellings as the index for NoSanitizeAttr. We don't have a; // general way to ""translate"" between the two, so this hack attempts to work; // around the issue with hard-coded indices. This is critical for calling; // getSpelling() or prettyPrint() on the resulting semantic attribute object; // without failing assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:30,Security,access,access,30,// Check if there is only one access qualifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:303,Availability,error,error,303,"// OpenCL v2.0 s6.6 - read_write can be used for image types to specify that; // an image object can be read and written. OpenCL v2.0 s6.13.6 - A kernel; // cannot read from and write to the same pipe object. Using the read_write; // (or __read_write) qualifier with the pipe qualifier is a compilation error.; // OpenCL v3.0 s6.8 - For OpenCL C 2.0, or with the; // __opencl_c_read_write_images feature, image objects specified as arguments; // to a kernel can additionally be declared to be read-write.; // C++ for OpenCL 1.0 inherits rule from OpenCL C v2.0.; // C++ for OpenCL 2021 inherits rule from OpenCL C v3.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:528,Modifiability,inherit,inherits,528,"// OpenCL v2.0 s6.6 - read_write can be used for image types to specify that; // an image object can be read and written. OpenCL v2.0 s6.13.6 - A kernel; // cannot read from and write to the same pipe object. Using the read_write; // (or __read_write) qualifier with the pipe qualifier is a compilation error.; // OpenCL v3.0 s6.8 - For OpenCL C 2.0, or with the; // __opencl_c_read_write_images feature, image objects specified as arguments; // to a kernel can additionally be declared to be read-write.; // C++ for OpenCL 1.0 inherits rule from OpenCL C v2.0.; // C++ for OpenCL 2021 inherits rule from OpenCL C v3.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:586,Modifiability,inherit,inherits,586,"// OpenCL v2.0 s6.6 - read_write can be used for image types to specify that; // an image object can be read and written. OpenCL v2.0 s6.13.6 - A kernel; // cannot read from and write to the same pipe object. Using the read_write; // (or __read_write) qualifier with the pipe qualifier is a compilation error.; // OpenCL v3.0 s6.8 - For OpenCL C 2.0, or with the; // __opencl_c_read_write_images feature, image objects specified as arguments; // to a kernel can additionally be declared to be read-write.; // C++ for OpenCL 1.0 inherits rule from OpenCL C v2.0.; // C++ for OpenCL 2021 inherits rule from OpenCL C v3.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:43,Modifiability,flexible,flexible,43,"// The ""counted_by"" attribute must be on a flexible array member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:45,Modifiability,flexible,flexible,45,"// The ""counted_by"" field can't point to the flexible array member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:175,Testability,test,tests,175,"// FIXME: it would be good to better handle attribute merging rather than; // silently replacing the existing attribute, so long as it does not break; // the expected codegen tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:55,Modifiability,variab,variables,55,// The attributes only really makes sense for __strong variables; ignore any; // attempts to annotate a parameter with any other lifetime qualifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:135,Availability,error,error,135,"// Tampering with the type of a VarDecl here is a bit of a hack, but we need; // to ensure that the variable is 'const' so that we can error on; // modification, which can otherwise over-release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:187,Deployability,release,release,187,"// Tampering with the type of a VarDecl here is a bit of a hack, but we need; // to ensure that the variable is 'const' so that we can error on; // modification, which can otherwise over-release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:100,Modifiability,variab,variable,100,"// Tampering with the type of a VarDecl here is a bit of a hack, but we need; // to ensure that the variable is 'const' so that we can error on; // modification, which can otherwise over-release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Availability,Error,Error,3,"// Error recovery: drop the non-leaf attribute so that to suppress; // all future warnings caused by erroneous attributes. The leaf attribute; // needs to be kept because it can only suppresses warnings, not cause them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:9,Availability,recover,recovery,9,"// Error recovery: drop the non-leaf attribute so that to suppress; // all future warnings caused by erroneous attributes. The leaf attribute; // needs to be kept because it can only suppresses warnings, not cause them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:9,Safety,recover,recovery,9,"// Error recovery: drop the non-leaf attribute so that to suppress; // all future warnings caused by erroneous attributes. The leaf attribute; // needs to be kept because it can only suppresses warnings, not cause them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Availability,error,error,8,// More error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:14,Availability,recover,recovery,14,// More error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:14,Safety,recover,recovery,14,// More error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:43,Integrability,depend,dependent,43,// Last case is if the expression is value dependent then it must delay; // arguments unless the corresponding argument is able to hold the; // expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Safety,Avoid,Avoid,3,// Avoid adding duplicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:145,Modifiability,portab,portability,145,"// Suggest moving the attribute to the type instead, but only for our; // own vendor attributes; moving other vendors' attributes might hurt; // portability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:298,Testability,log,logic,298,"// `regparm` is a special case: It's a type attribute but we still want; // to treat it as if it had been written on the declaration because that; // way we'll be able to handle it directly in `processTypeAttr()`.; // If we treated `regparm` it as if it had been written on the; // `DeclSpec`, the logic in `distributeFunctionTypeAttrFromDeclSepc()`; // would try to move it to the declarator, but that doesn't work: We; // can't remove the attribute from the list of declaration attributes; // because it might be needed by other declarators in the same; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:10,Safety,safe,safety,10,// Thread safety attributes:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Safety,safe,safety,8,// Type safety attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:33,Availability,error,error,33,// FIXME: This emits a different error message than; // diag::err_attribute_wrong_decl_type + ExpectedKernelFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:39,Integrability,message,message,39,// FIXME: This emits a different error message than; // diag::err_attribute_wrong_decl_type + ExpectedKernelFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:66,Security,access,access,66,// Annotation attributes are the only attributes allowed after an access; // specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:21,Modifiability,variab,variables,21,// Fake up parameter variables; they are declared as if this were; // a typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:124,Deployability,integrat,integration,124,"// Silently accept unsupported uses of __weak in both user and system; // declarations when it's been disabled, for ease of integration with; // -fno-objc-arc files. We do have to take some care against attempts; // to define such things; for now, we've only done that for ivars; // and properties.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:124,Integrability,integrat,integration,124,"// Silently accept unsupported uses of __weak in both user and system; // declarations when it's been disabled, for ease of integration with; // -fno-objc-arc files. We do have to take some care against attempts; // to define such things; for now, we've only done that for ivars; // and properties.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Availability,failure,failures,22,"// Currently, all the failures dealt with this way are due to ARC; // restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:81,Integrability,message,messages,81,// FIXME: we may want to suppress diagnostics for all; // kind of forbidden type messages on unavailable functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:20,Security,access,access,20,// Only produce one access control diagnostic for a structured binding; // declaration: we don't need to tell the user that all the fields are; // inaccessible one at a time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:230,Modifiability,variab,variables,230,"/// CheckDefaultArgumentVisitor - C++ [dcl.fct.default] Traverses; /// the default argument of a parameter to determine whether it; /// contains any ill-formed subexpressions. For example, this will; /// diagnose the use of local variables or parameters within the; /// default argument expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:38,Modifiability,variab,variables,38,"// C++ [dcl.fct.default]p7:; // Local variables shall not be used in default argument; // expressions.; //; // C++17 [dcl.fct.default]p7 (by CWG 2082):; // A local variable shall not appear as a potentially-evaluated; // expression in a default argument.; //; // C++20 [dcl.fct.default]p7 (DR as part of P0588R1, see also CWG 2346):; // Note: A local variable cannot be odr-used (6.3) in a default; // argument.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:164,Modifiability,variab,variable,164,"// C++ [dcl.fct.default]p7:; // Local variables shall not be used in default argument; // expressions.; //; // C++17 [dcl.fct.default]p7 (by CWG 2082):; // A local variable shall not appear as a potentially-evaluated; // expression in a default argument.; //; // C++20 [dcl.fct.default]p7 (DR as part of P0588R1, see also CWG 2346):; // Note: A local variable cannot be odr-used (6.3) in a default; // argument.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:351,Modifiability,variab,variable,351,"// C++ [dcl.fct.default]p7:; // Local variables shall not be used in default argument; // expressions.; //; // C++17 [dcl.fct.default]p7 (by CWG 2082):; // A local variable shall not appear as a potentially-evaluated; // expression in a default argument.; //; // C++20 [dcl.fct.default]p7 (DR as part of P0588R1, see also CWG 2346):; // Note: A local variable cannot be odr-used (6.3) in a default; // argument.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:249,Modifiability,variab,variable,249,"// C++ [dcl.fct.default]p5; // A default argument expression is implicitly converted (clause; // 4) to the parameter type. The default argument expression has; // the same semantic constraints as the initializer expression in; // a declaration of a variable of the parameter type, using the; // copy-initialization semantics (8.5).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Availability,Recover,Recover,3,// Recover by discarding the default argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Safety,Recover,Recover,3,// Recover by discarding the default argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:221,Integrability,rout,routine,221,"/// CheckExtraCXXDefaultArguments - Check for any extra default; /// arguments in the declarator, which is not a function declaration; /// or definition and therefore is not permitted to have default; /// arguments. This routine should be invoked for every declarator; /// that is not a function declaration or definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:204,Availability,error,error,204,"/// MergeCXXFunctionDecl - Merge two declarations of the same C++; /// function, once we already know that they have the same; /// type. Subroutine of MergeFunctionDecl. Returns true if there was an; /// error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:275,Testability,test,test,275,"// FIXME: If we knew where the '=' was, we could easily provide a fix-it; // hint here. Alternatively, we could walk the type-source information; // for NewParam to find the last source location in the type... but it; // isn't worth the effort right now. This is the kind of test case that; // is hard to get right:; // int f(int);; // void g(int (*fp)(int) = f);; // void g(int (*fp)(int) = &f);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:183,Modifiability,inherit,inherited,183,// Merge the old default argument into the new parameter unless the new; // function is a friend declaration in a template class. In the latter; // case the default arguments will be inherited when the friend; // declaration will be instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:419,Integrability,depend,dependent,419,// C++ [dcl.fct.default]p6 (DR217):; // Default arguments for a member function of a class template shall; // be specified on the initial declaration of the member function; // within the class template.; //; // Reading the tea leaves a bit in DR217 and its reference to DR205; // leads me to the conclusion that one cannot add default function; // arguments for an out-of-line definition of a member function of a; // dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:22,Usability,guid,guide,22,// C++17 [temp.deduct.guide]p3:; // Two deduction guide declarations in the same translation unit; // for the same class template shall not have equivalent; // parameter-declaration-clauses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:50,Usability,guid,guide,50,// C++17 [temp.deduct.guide]p3:; // Two deduction guide declarations in the same translation unit; // for the same class template shall not have equivalent; // parameter-declaration-clauses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:58,Usability,simpl,simple-declaration,58,"// The syntax only allows a decomposition declarator as a simple-declaration,; // a for-range-declaration, or a condition in Clang, but we parse it in more; // cases than that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,Usability,usab,usable,100,"// FIXME: There's no rule against this, but there are also no rules that; // would actually make it usable, so we reject it for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:108,Modifiability,variab,variable,108,// Don't add FixItHints to remove the specifiers; we do still respect; // them when building the underlying variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Availability,recover,recover,12,// We can't recover from it being declared as a typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Safety,recover,recover,12,// We can't recover from it being declared as a typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:45,Modifiability,variab,variable,45,"// There are no prior lookup results for the variable itself, because it; // is unnamed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:13,Modifiability,variab,variable,13,// Build the variable that holds the non-decomposed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:120,Usability,usab,usable,120,"// If we get this far, we've committed to the tuple interpretation, but; // we can still fail if there actually isn't a usable ::value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:97,Security,access,access,97,// [dcl.decomp]p3:; // The unqualified-id get is looked up in the scope of E by class member; // access lookup ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:16,Modifiability,variab,variable,16,"// each vi is a variable of type ""reference to T"" initialized with the; // initializer, where the reference is an lvalue reference if the; // initializer is an lvalue and an rvalue reference otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:167,Performance,perform,perform,167,"/// Find the base class to decompose in a built-in decomposition of a class type.; /// This base class search is, unfortunately, not quite like any other that we; /// perform anywhere else in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:8,Security,access,accessible,8,"// ... [accessible, implied by other rules] base class of E.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,Security,access,accessible,21,// The field must be accessible in the context of the structured binding.; // We already checked that the base class is accessible.; // FIXME: Add 'const' to AccessedEntity's classes so we can remove the; // const_cast here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:120,Security,access,accessible,120,// The field must be accessible in the context of the structured binding.; // We already checked that the base class is accessible.; // FIXME: Add 'const' to AccessedEntity's classes so we can remove the; // const_cast here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:158,Security,Access,AccessedEntity,158,// The field must be accessible in the context of the structured binding.; // We already checked that the base class is accessible.; // FIXME: Add 'const' to AccessedEntity's classes so we can remove the; // const_cast here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:39,Integrability,depend,dependent,39,"// If the type of the decomposition is dependent, then so is the type of; // each binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Modifiability,variab,variable,46,/// Merge the exception specifications of two variable declarations.; ///; /// This is called when there's a redeclaration of a VarDecl. The function; /// checks if the redeclaration might have an exception specification and; /// validates compatibility and merges the specs if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:230,Security,validat,validates,230,/// Merge the exception specifications of two variable declarations.; ///; /// This is called when there's a redeclaration of a VarDecl. The function; /// checks if the redeclaration might have an exception specification and; /// validates compatibility and merges the specs if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:73,Integrability,message,message,73,/// Get diagnostic %select index for tag kind for; /// record diagnostic message.; /// WARNING: Indexes apply to particular diagnostics only!; ///; /// \returns diagnostic %select index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:15,Modifiability,variab,variably-modified,15,// Don't allow variably-modified types in constexpr functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:73,Modifiability,variab,variable,73,// C++1y [dcl.constexpr]p3 allows anything except:; // a definition of a variable of non-literal type or of static or; // thread storage duration or [before C++2a] for which no; // initialization is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:199,Performance,perform,performed,199,// C++1y [dcl.constexpr]p3 allows anything except:; // a definition of a variable of non-literal type or of static or; // thread storage duration or [before C++2a] for which no; // initialization is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Modifiability,variab,variable,2,/*variable of non-literal type*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:475,Availability,error,error,475,"/// Check that the given field is initialized within a constexpr constructor.; ///; /// \param Dcl The constexpr constructor being checked.; /// \param Field The field being checked. This may be a member of an anonymous; /// struct or union nested within the class being checked.; /// \param Inits All declarations, including anonymous struct/union members and; /// indirect members, for which any initialization was provided.; /// \param Diagnosed Whether we've emitted the error message yet. Used to attach; /// multiple notes for different members to the same error.; /// \param Kind Whether we're diagnosing a constructor as written or determining; /// whether the formal requirements are satisfied.; /// \return \c false if we're checking for validity and the constructor does; /// not satisfy the requirements on a constexpr constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:563,Availability,error,error,563,"/// Check that the given field is initialized within a constexpr constructor.; ///; /// \param Dcl The constexpr constructor being checked.; /// \param Field The field being checked. This may be a member of an anonymous; /// struct or union nested within the class being checked.; /// \param Inits All declarations, including anonymous struct/union members and; /// indirect members, for which any initialization was provided.; /// \param Diagnosed Whether we've emitted the error message yet. Used to attach; /// multiple notes for different members to the same error.; /// \param Kind Whether we're diagnosing a constructor as written or determining; /// whether the formal requirements are satisfied.; /// \return \c false if we're checking for validity and the constructor does; /// not satisfy the requirements on a constexpr constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:481,Integrability,message,message,481,"/// Check that the given field is initialized within a constexpr constructor.; ///; /// \param Dcl The constexpr constructor being checked.; /// \param Field The field being checked. This may be a member of an anonymous; /// struct or union nested within the class being checked.; /// \param Inits All declarations, including anonymous struct/union members and; /// indirect members, for which any initialization was provided.; /// \param Diagnosed Whether we've emitted the error message yet. Used to attach; /// multiple notes for different members to the same error.; /// \param Kind Whether we're diagnosing a constructor as written or determining; /// whether the formal requirements are satisfied.; /// \return \c false if we're checking for validity and the constructor does; /// not satisfy the requirements on a constexpr constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:116,Modifiability,variab,variable,116,"// C++1y allows all of these. We don't allow them as extensions in C++11,; // because they don't make sense without variable mutation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:61,Modifiability,variab,variable,61,"// C++1y allows switch-statements, and since they don't need variable; // mutation, we can reasonably allow them in C++11 as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:122,Integrability,Depend,Dependent,122,// Check initialization of non-static data members. Base classes are; // always initialized so do not need to be checked. Dependent bases; // might not have initializers in the member initializer list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:118,Deployability,update,update,118,"/// Determine whether the identifier II is a typo for the name of; /// the class type currently being defined. If so, update it to the identifier; /// that should have been used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,Integrability,depend,dependent,100,"/// Determine whether the given class is a base class of the given; /// class, including looking at dependent bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:30,Security,access,access,30,"// In HLSL, unspecified class access is public rather than private.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,Availability,error,error,49,// Already emitted a diagnostic when parsing the error type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:63,Integrability,depend,dependent,63,"// Make sure that we don't have circular inheritance among our dependent; // bases. For non-dependent bases, the check for completeness below handles; // this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:92,Integrability,depend,dependent,92,"// Make sure that we don't have circular inheritance among our dependent; // bases. For non-dependent bases, the check for completeness below handles; // this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:41,Modifiability,inherit,inheritance,41,"// Make sure that we don't have circular inheritance among our dependent; // bases. For non-dependent bases, the check for completeness below handles; // this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:271,Availability,error,errory-recovery,271,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:89,Integrability,depend,dependent,89,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:147,Integrability,depend,dependent,147,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:278,Safety,recover,recovery,278,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:24,Modifiability,polymorphi,polymorphic,24,"// If the base class is polymorphic or isn't empty, the new one is/isn't, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Modifiability,flexible,flexible,28,"// A class which contains a flexible array member is not suitable for use as a; // base class:; // - If the layout determines that a base comes before another base,; // the flexible array member would index into the subsequent base.; // - If the layout determines that base comes before the derived class,; // the flexible array member would index into the derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:173,Modifiability,flexible,flexible,173,"// A class which contains a flexible array member is not suitable for use as a; // base class:; // - If the layout determines that a base comes before another base,; // the flexible array member would index into the subsequent base.; // - If the layout determines that base comes before the derived class,; // the flexible array member would index into the derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:314,Modifiability,flexible,flexible,314,"// A class which contains a flexible array member is not suitable for use as a; // base class:; // - If the layout determines that a base comes before another base,; // the flexible array member would index into the subsequent base.; // - If the layout determines that base comes before the derived class,; // the flexible array member would index into the derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Performs,4,/// Performs the actual work of attaching the given base class; /// specifiers to a C++ class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Availability,redundant,redundant,101,"// Used to keep track of which base types we have already seen, so; // that we can properly diagnose redundant direct base types. Note; // that the key is always the unqualified canonical type of the base; // class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Safety,redund,redundant,101,"// Used to keep track of which base types we have already seen, so; // that we can properly diagnose redundant direct base types. Note; // that the key is always the unqualified canonical type of the base; // class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Availability,redundant,redundant,12,// Copy non-redundant base specifiers into permanent storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Safety,redund,redundant,12,// Copy non-redundant base specifiers into permanent storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:96,Integrability,interface,interfaces,96,// The Microsoft extension __interface does not permit bases that; // are not themselves public interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Integrability,depend,dependent,12,// Skip all dependent types in templates being used as base specifiers.; // Checks below assume that the base specifier is a CXXRecord.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Modifiability,inherit,inheritance,104,"// FIXME: In a modules build, do we need the entire path to be visible for us; // to be able to use the inheritance relationship?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:419,Availability,error,error,419,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:489,Availability,error,error,489,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:617,Availability,error,error,617,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:375,Integrability,rout,routine,375,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:696,Performance,perform,performed,696,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:233,Security,access,accessible,233,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Modifiability,inherit,inherits,53,"// For MSVC compatibility, check if Derived directly inherits from Base. Clang; // warns about this hierarchy under -Winaccessible-base, but MSVC allows the; // user to access such bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:169,Security,access,access,169,"// For MSVC compatibility, check if Derived directly inherits from Base. Clang; // warns about this hierarchy under -Winaccessible-base, but MSVC allows the; // user to access such bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Security,access,accessed,36,// Check that the base class can be accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:106,Performance,Perform,Perform,106,"// We know that the derived-to-base conversion is ambiguous, and; // we're going to produce a diagnostic. Perform the derived-to-base; // search just one more time to compute all of the possible paths so; // that we can print them out. This is more expensive than any of; // the previous derived-to-base checks we've done, but at this point; // performance isn't as much of an issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:345,Performance,perform,performance,345,"// We know that the derived-to-base conversion is ambiguous, and; // we're going to produce a diagnostic. Perform the derived-to-base; // search just one more time to compute all of the possible paths so; // that we can print them out. This is more expensive than any of; // the previous derived-to-base checks we've done, but at this point; // performance isn't as much of an issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:197,Availability,error,error,197,/// Builds a string representing ambiguous paths from a; /// specific derived class to different subobjects of the same base; /// class.; ///; /// This function builds a string that can be used in error messages; /// to show the different paths that one can take through the; /// inheritance hierarchy to go from the derived class to different; /// subobjects of a base class. The result looks something like this:; /// @code; /// struct D -> struct B -> struct A; /// struct D -> struct C -> struct A; /// @endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:203,Integrability,message,messages,203,/// Builds a string representing ambiguous paths from a; /// specific derived class to different subobjects of the same base; /// class.; ///; /// This function builds a string that can be used in error messages; /// to show the different paths that one can take through the; /// inheritance hierarchy to go from the derived class to different; /// subobjects of a base class. The result looks something like this:; /// @code; /// struct D -> struct B -> struct A; /// struct D -> struct C -> struct A; /// @endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:280,Modifiability,inherit,inheritance,280,/// Builds a string representing ambiguous paths from a; /// specific derived class to different subobjects of the same base; /// class.; ///; /// This function builds a string that can be used in error messages; /// to show the different paths that one can take through the; /// inheritance hierarchy to go from the derived class to different; /// subobjects of a base class. The result looks something like this:; /// @code; /// struct D -> struct B -> struct A; /// struct D -> struct C -> struct A; /// @endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:231,Security,access,access,231,//===----------------------------------------------------------------------===//; // C++ class member Handling; //===----------------------------------------------------------------------===//; /// ActOnAccessSpecifier - Parsed an access specifier followed by a colon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,depend,dependent,18,// We can't check dependent instance methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:110,Security,access,access,110,"/// ActOnCXXMemberDeclarator - This is invoked when a C++ class member; /// declarator is parsed. 'AS' is the access specifier, 'BW' specifies the; /// bitfield width if there is one, 'InitExpr' specifies the initializer if; /// one has been parsed, and 'InitStyle' is set if an in-class initializer is; /// present (but parsing it has been deferred).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:118,Availability,error,errors,118,// FIXME: It would be nicer if the keyword was ignored only for this; // declarator. Otherwise we could get follow-up errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:94,Security,access,access,94,"// If we have declared a member function template or static data member; // template, set the access of the templated declaration as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:124,Security,access,access,124,// C++ [temp.deduct.guide]p3:; // A deduction guide [...] for a member class template [shall be; // declared] with the same access [as the template].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:20,Usability,guid,guide,20,// C++ [temp.deduct.guide]p3:; // A deduction guide [...] for a member class template [shall be; // declared] with the same access [as the template].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Usability,guid,guide,46,// C++ [temp.deduct.guide]p3:; // A deduction guide [...] for a member class template [shall be; // declared] with the same access [as the template].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Security,Access,Access,3,// Access specifiers are only meaningful if both the template and the; // deduction guide are from the same scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Usability,guid,guide,84,// Access specifiers are only meaningful if both the template and the; // deduction guide are from the same scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Deployability,Update,Update,3,// Update the end location of a method that has a virt-specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Integrability,depend,dependent,104,"// Remember all explicit private FieldDecls that have a name, no side; // effects and are not part of a dependent type declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Modifiability,Variab,Variables,3,"// Variables to hold state when processing an initializer list. When; // InitList is true, special case initialization of FieldDecls matching; // InitListFieldDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Safety,detect,detected,28,"// If a field assignment is detected, remove the field from the; // uninitiailized field set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:33,Modifiability,variab,variable,33,// We did not find a placeholder variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Availability,error,error,104,"// The user wrote a constructor initializer on a function that is; // not a C++ constructor. Ignore the error for now, because we may; // have more member initializers coming; we'll diagnose it just; // once in ActOnMemInitializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:17,Security,access,access-control,17,// We don't want access-control diagnostics here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Integrability,depend,dependent,46,// Can't check initialization for a member of dependent type or when; // any of the arguments are type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:103,Integrability,depend,dependent,103,// Can't check initialization for a member of dependent type or when; // any of the arguments are type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:106,Availability,Recover,RecoveryExpr,106,// Args were sensible expressions but we couldn't initialize the member; // from them. Preserve them in a RecoveryExpr instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:106,Safety,Recover,RecoveryExpr,106,// Args were sensible expressions but we couldn't initialize the member; // from them. Preserve them in a RecoveryExpr instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,depend,dependent,18,"// If we are in a dependent context, template instantiation will; // perform this type-checking again. Just save the arguments that we; // received in a ParenListExpr.; // FIXME: This isn't quite ideal, since our ASTs don't capture all; // of the information that we have about the base; // initializer. However, deconstructing the ASTs is a dicey process,; // and this approach is far more likely to get the corner cases right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:69,Performance,perform,perform,69,"// If we are in a dependent context, template instantiation will; // perform this type-checking again. Just save the arguments that we; // received in a ParenListExpr.; // FIXME: This isn't quite ideal, since our ASTs don't capture all; // of the information that we have about the base; // initializer. However, deconstructing the ASTs is a dicey process,; // and this approach is far more likely to get the corner cases right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:440,Integrability,depend,dependent,440,"// C++ [class.base.init]p2:; // [...] Unless the mem-initializer-id names a nonstatic data; // member of the constructor's class or a direct or virtual base; // of that class, the mem-initializer is ill-formed. A; // mem-initializer-list can initialize a base class using any; // name that denotes that base class type.; // We can store the initializers in ""as-written"" form and delay analysis until; // instantiation if the constructor is dependent. But not for dependent; // (broken) code in a non-template! SetCtorInitializers does not expect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:463,Integrability,depend,dependent,463,"// C++ [class.base.init]p2:; // [...] Unless the mem-initializer-id names a nonstatic data; // member of the constructor's class or a direct or virtual base; // of that class, the mem-initializer is ill-formed. A; // mem-initializer-list can initialize a base class using any; // name that denotes that base class type.; // We can store the initializers in ""as-written"" form and delay analysis until; // instantiation if the constructor is dependent. But not for dependent; // (broken) code in a non-template! SetCtorInitializers does not expect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:24,Integrability,depend,dependent,24,"// If the class has any dependent bases, then it's possible that; // one of those types will resolve to the same type as; // BaseType. Therefore, just treat this as a dependent base; // class initialization. FIXME: Should we try to check the; // initialization anyway? It seems odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:167,Integrability,depend,dependent,167,"// If the class has any dependent bases, then it's possible that; // one of those types will resolve to the same type as; // BaseType. Therefore, just treat this as a dependent base; // class initialization. FIXME: Should we try to check the; // initialization anyway? It seems odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:139,Modifiability,inherit,inherited,139,"// C++ [base.class.init]p2:; // If a mem-initializer-id is ambiguous because it designates both; // a direct non-virtual base class and an inherited virtual base; // class, the mem-initializer is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,depend,dependent,18,"// If we are in a dependent context, template instantiation will; // perform this type-checking again. Just save the arguments that we; // received in a ParenListExpr.; // FIXME: This isn't quite ideal, since our ASTs don't capture all; // of the information that we have about the base; // initializer. However, deconstructing the ASTs is a dicey process,; // and this approach is far more likely to get the corner cases right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:69,Performance,perform,perform,69,"// If we are in a dependent context, template instantiation will; // perform this type-checking again. Just save the arguments that we; // received in a ParenListExpr.; // FIXME: This isn't quite ideal, since our ASTs don't capture all; // of the information that we have about the base; // initializer. However, deconstructing the ASTs is a dicey process,; // and this approach is far more likely to get the corner cases right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:29,Safety,avoid,avoid,29,// Cast to the base class to avoid ambiguities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:73,Availability,error,errors,73,// Don't try to build an implicit initializer if there were semantic; // errors in any of the initializers (and therefore we might be; // missing some that the user actually wrote).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:50,Availability,error,errors,50,// Let template instantiation know whether we had errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:10,Integrability,depend,dependent,10,"// Ignore dependent contexts. Also ignore unions, since their members never; // have destructors implicitly called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Security,access,access-control,18,"// FIXME: all the access-control diagnostics are positioned on the; // field/base declaration. That's probably good; that said, the; // user might reasonably want to know why the destructor is being; // emitted, and we currently don't say.; // Non-static data members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:185,Safety,avoid,avoid,185,"// If the destructor exists and has already been marked used in the MS ABI,; // then virtual base destructors have already been checked and marked used.; // Skip checking them again to avoid duplicate diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,Integrability,depend,dependent,49,// Bases are always records in a well-formed non-dependent class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:69,Modifiability,inherit,inherits,69,// C++ [class.abstract]p4:; // A class is abstract if it contains or inherits at least one; // pure virtual function for which the final overrider is pure; // virtual.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:7,Safety,safe,safety,7,"// For safety's sake, just ignore it if we don't have type source; // information. This should never happen for non-implicit methods,; // but...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,Modifiability,variab,variables,21,// Fields and static variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Modifiability,variab,variables,18,// Defined static variables that are members of an exported base; // class must be marked export too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:23,Integrability,depend,dependent,23,"// If the class is non-dependent, mark the default arguments as ODR-used so; // that we can properly codegen the constructor closure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Integrability,rout,routines,31,// Mark any compiler-generated routines with the implicit code_seg attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:8,Modifiability,inherit,inherits,8,// MSVC inherits DLL attributes to partial class template specializations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:243,Safety,avoid,avoid,243,// MSVC allows imported or exported template classes that have UniqueExternal; // linkage. This occurs when the template class has been instantiated with; // a template parameter which itself has internal linkage.; // We drop the attribute to avoid exporting or importing any members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:9,Modifiability,inherit,inherit,9,// Don't inherit dll attribute until the template is instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Modifiability,inherit,inherit,53,// Force declaration of implicit members so they can inherit the attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Modifiability,inherit,inherit,34,// Only methods and static fields inherit the attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,/// Perform propagation of DLL attributes from a derived class to a; /// templated base class for MS compatibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,Availability,error,error,14,"/// Report an error regarding overriding, along with any relevant; /// overridden methods.; ///; /// \param DiagID the primary error to report.; /// \param MD the overriding method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:127,Availability,error,error,127,"/// Report an error regarding overriding, along with any relevant; /// overridden methods.; ///; /// \param DiagID the primary error to report.; /// \param MD the overriding method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic checks on a class definition that has been; /// completing, introducing implicitly-declared members, checking for; /// abstract types, etc.; ///; /// \param S The scope in which the class was parsed. Null if we didn't just; /// parse a class definition.; /// \param Record The completed class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:116,Integrability,depend,depend,116,"// Explicitly-defaulted secondary comparison functions (!=, <, <=, >, >=).; // We check these last because they can depend on the properties of the; // primary comparison functions (==, <=>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,"// Perform checks that can't be done until we know all the properties of a; // member function (whether it's defaulted, deleted, virtual, overriding,; // ...).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,Integrability,depend,dependent,49,// Skip the rest of the checks for a member of a dependent class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:37,Integrability,depend,dependent,37,// FIXME: We could do this check for dependent types with non-dependent; // bases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:62,Integrability,depend,dependent,62,// FIXME: We could do this check for dependent types with non-dependent; // bases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:234,Availability,error,error,234,"// ms_struct is a request to use the same ABI rules as MSVC. Check; // whether this class uses any C++ features that are implemented; // completely differently in MSVC, and if so, emit a diagnostic.; // That diagnostic defaults to an error, but we allow projects to; // map it down to a warning (or ignore it). It's a fairly common; // practice among users of the ms_struct pragma to mass-annotate; // headers, sweeping up a bunch of types that the project doesn't; // really rely on MSVC-compatible layout for. We must therefore; // support ""ms_struct except for C++ stuff"" as a secondary ABI.; // Don't emit this diagnostic if the feature was enabled as a; // language option (as opposed to via a pragma or attribute), as; // the option -mms-bitfields otherwise essentially makes it impossible; // to build C++ code, unless this diagnostic is turned off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:277,Availability,down,down,277,"// ms_struct is a request to use the same ABI rules as MSVC. Check; // whether this class uses any C++ features that are implemented; // completely differently in MSVC, and if so, emit a diagnostic.; // That diagnostic defaults to an error, but we allow projects to; // map it down to a warning (or ignore it). It's a fairly common; // practice among users of the ms_struct pragma to mass-annotate; // headers, sweeping up a bunch of types that the project doesn't; // really rely on MSVC-compatible layout for. We must therefore; // support ""ms_struct except for C++ stuff"" as a secondary ABI.; // Don't emit this diagnostic if the feature was enabled as a; // language option (as opposed to via a pragma or attribute), as; // the option -mms-bitfields otherwise essentially makes it impossible; // to build C++ code, unless this diagnostic is turned off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:132,Performance,load,loads,132,"// If we want to emit all the vtables, we need to mark it as used. This; // is especially required for cases like vtable assumption loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:75,Modifiability,inherit,inherited,75,/// A mapping from the base classes through which the constructor was; /// inherited to the using shadow declaration in that base class (or a null; /// pointer if the constructor was declared in that base class).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:54,Modifiability,inherit,inherited,54,"// [class.inhctor.init]p2:; // If the constructor was inherited from multiple base class subobjects; // of type B, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Modifiability,inherit,inherited,36,"/// Find the constructor to use for inherited construction of a base class,; /// and whether that base class constructor inherits the constructor from a; /// virtual base class (in which case it won't actually invoke it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:121,Modifiability,inherit,inherits,121,"/// Find the constructor to use for inherited construction of a base class,; /// and whether that base class constructor inherits the constructor from a; /// virtual base class (in which case it won't actually invoke it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:57,Modifiability,inherit,inherited,57,// This is the base class from which the constructor was inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:62,Performance,perform,perform,62,/// Is the special member function which would be selected to perform the; /// specified operation on the specified class type a constexpr constructor?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Modifiability,inherit,inheriting,12,"// If we're inheriting a constructor, see if we need to call it for this base; // class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:252,Performance,perform,performance,252,"// Since default constructor lookup is essentially trivial (and cannot; // involve, for instance, template instantiation), we compute whether a; // defaulted default constructor is constexpr directly within CXXRecordDecl.; //; // This is important for performance; we need to know whether the default; // constructor is constexpr to determine whether the type is a literal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:45,Performance,perform,perform,45,"// For copy or move constructors, we need to perform overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:24,Performance,perform,perform,24,"// In C++1y, we need to perform overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Deployability,Update,Update,3,// Update the type of the special member to use it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:47,Integrability,depend,dependent,47,// Defer all checking for special members of a dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:186,Performance,perform,perform,186,"/// Helper class for building and checking a defaulted comparison.; ///; /// Defaulted functions are built in two phases:; ///; /// * First, the set of operations that the function will perform are; /// identified, and some of them are checked. If any of the checked; /// operations is invalid in certain ways, the comparison function is; /// defined as deleted and no body is built.; /// * Then, if the function is not defined as deleted, the body is built.; ///; /// This is accomplished by performing two visitation steps over the eventual; /// body of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:493,Performance,perform,performing,493,"/// Helper class for building and checking a defaulted comparison.; ///; /// Defaulted functions are built in two phases:; ///; /// * First, the set of operations that the function will perform are; /// identified, and some of them are checked. If any of the checked; /// operations is invalid in certain ways, the comparison function is; /// defined as deleted and no body is built.; /// * Then, if the function is not defined as deleted, the body is built.; ///; /// This is accomplished by performing two visitation steps over the eventual; /// body of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:94,Safety,avoid,avoid,94,// FIXME: Change CreateOverloadedBinOp to take an ArrayRef instead of an; // UnresolvedSet to avoid this copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:186,Security,access,accessible,186,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:249,Security,access,access,249,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:333,Security,access,access,333,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:85,Usability,usab,usable,85,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:141,Performance,perform,performed,141,// C++2a [class.compare.default]p3 [P2002R0]:; // A defaulted comparison function is constexpr-compatible if; // [...] no overlod resolution performed [...] results in a; // non-constexpr function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:94,Availability,failure,failure,94,"// If any callee has an undeduced return type, deduce it now.; // FIXME: It's not clear how a failure here should be handled. For; // now, we produce an eager diagnostic, because that is forward; // compatible with most (all?) other reasonable options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:82,Usability,clear,clear,82,"// If any callee has an undeduced return type, deduce it now.; // FIXME: It's not clear how a failure here should be handled. For; // now, we produce an eager diagnostic, because that is forward; // compatible with most (all?) other reasonable options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:29,Availability,error,error,29,// Don't produce a duplicate error when asked to explain why the; // comparison is deleted: we diagnosed that when initially checking; // the defaulted operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:60,Modifiability,rewrite,rewrite,60,"// If there's no usable candidate, we're done unless we can rewrite a; // '<=>' in terms of '==' and '<'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:17,Usability,usab,usable,17,"// If there's no usable candidate, we're done unless we can rewrite a; // '<=>' in terms of '==' and '<'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:62,Usability,usab,usable,62,"// For any kind of comparison category return type, we need a usable; // '==' and a usable '<'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Usability,usab,usable,84,"// For any kind of comparison category return type, we need a usable; // '==' and a usable '<'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Performance,Perform,PerformADL,2,/*PerformADL=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,/// Perform the unqualified lookups that might be needed to form a defaulted; /// comparison function for the given operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:132,Integrability,depend,dependent,132,"// For 'operator<=>', we also form a 'cmp != 0' expression, and might; // synthesize a three-way comparison from '<' and '=='. In a dependent; // context, we also need to look up '==' in case we implicitly declare a; // defaulted 'operator=='.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,// Perform any unqualified lookups we're going to need to default this; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Availability,recover,recover,31,// Remove the ref qualifier to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Safety,recover,recover,31,// Remove the ref qualifier to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Availability,recover,recover,34,// Add the 'const' to the type to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Safety,recover,recover,34,// Add the 'const' to the type to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:42,Availability,recover,recover,42,// Remove the 'volatile' from the type to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:42,Safety,recover,recover,42,// Remove the 'volatile' from the type to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:33,Integrability,depend,dependent,33,"// For a defaulted function in a dependent class, defer all remaining checks; // until instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:263,Usability,simpl,simple,263,"// C++2a [dcl.fct.def.default]p3 [P2002R0]:; // If a constexpr-compatible function is explicitly defaulted on its first; // declaration, it is implicitly considered to be constexpr.; // FIXME: Only applying this to the first declaration seems problematic, as; // simple reorderings can affect the meaning of the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,// Perform any deferred checking of exception specifications for virtual; // destructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,// Perform any deferred checking of exception specifications for befriended; // special members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:92,Modifiability,inherit,inherited,92,/// CRTP base class for visiting operations performed by a special member; /// function (or inherited constructor).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:44,Performance,perform,performed,44,/// CRTP base class for visiting operations performed by a special member; /// function (or inherited constructor).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:109,Modifiability,inherit,inherited,109,/// Look up the constructor for the specified base class to see if it's; /// overridden due to this being an inherited constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:159,Security,access,accessible,159,"// A member of a union must have a trivial corresponding special member.; // As a weird special case, a destructor call from a union's constructor; // must be accessible and non-deleted, but need not be trivial. Such a; // destructor is never actually called, but is semantically checked as; // if it were.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:70,Availability,error,error,70,"// If program is correct, BaseClass cannot be null, but if it is, the error; // must be reported elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:17,Modifiability,inherit,inheriting,17,"// If we have an inheriting constructor, check whether we're calling an; // inherited constructor instead of a default constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:76,Modifiability,inherit,inherited,76,"// If we have an inheriting constructor, check whether we're calling an; // inherited constructor instead of a default constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:29,Security,access,access,29,"// Note that we do not check access along this path; other than that,; // this is the same as shouldDeleteForSubobjectCall(Base, BaseCtor, false);; // FIXME: Check that the base has a usable destructor! Sink this into; // shouldDeleteForClassSubobject.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:184,Usability,usab,usable,184,"// Note that we do not check access along this path; other than that,; // this is the same as shouldDeleteForSubobjectCall(Base, BaseCtor, false);; // FIXME: Check that the base has a usable destructor! Sink this into; // shouldDeleteForClassSubobject.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:6,Security,access,access,6,// Do access control from the special member function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:92,Modifiability,inherit,inherited,92,"// We should delete the special member in CUDA mode if target inference; // failed.; // For inherited constructors (non-null ICI), CSM may be passed so that MD; // is treated as certain special member, which may not reflect what special; // member MD really is. However inferCUDATargetForImplicitSpecialMember; // expects CSM to match MD, therefore recalculate CSM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,"/// Perform lookup for a special member of the specified kind, and determine; /// whether it is trivial. If the triviality can be determined without the; /// lookup, skip it. This is intended for use when determining whether a; /// special member of a containing object is trivial, and thus does not ever; /// perform overload resolution for default constructors.; ///; /// If \p Selected is not \c NULL, \c *Selected will be filled in with the; /// member that was most likely to be intended to be trivial, if any.; ///; /// If \p ForCall is true, look at CXXRecord::HasTrivialSpecialMembersForCall to; /// determine whether the special member is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:310,Performance,perform,perform,310,"/// Perform lookup for a special member of the specified kind, and determine; /// whether it is trivial. If the triviality can be determined without the; /// lookup, skip it. This is intended for use when determining whether a; /// special member of a containing object is trivial, and thus does not ever; /// perform overload resolution for default constructors.; ///; /// If \p Selected is not \c NULL, \c *Selected will be filled in with the; /// member that was most likely to be intended to be trivial, if any.; ///; /// If \p ForCall is true, look at CXXRecord::HasTrivialSpecialMembersForCall to; /// determine whether the special member is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:174,Performance,perform,performed,174,"// C++11 [class.ctor]p5:; // A default constructor is trivial if:; // - all the [direct subobjects] have trivial default constructors; //; // Note, no overload resolution is performed in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Performance,perform,perform,101,// We must either select the trivial copy constructor or reach an; // ambiguity; no need to actually perform overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Performance,perform,perform,36,"// In C++98, we are not supposed to perform overload resolution here, but we; // treat that as a language defect, as suggested on cxx-abi-dev, to treat; // cases like B as having a non-trivial copy constructor:; // struct A { template<typename T> A(T&); };; // struct B { mutable A a; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Performance,perform,perform,36,"// In C++98, we are not supposed to perform overload resolution here, but we; // treat that as a language defect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,Modifiability,inherit,inherited,177,"// If the method we are checking overrides a method from its base; // don't warn about the other overloaded methods. Clang deviates from; // GCC by only diagnosing overloads of inherited virtual functions that; // do not override any other virtual functions in the base. GCC's; // -Woverloaded-virtual diagnoses any derived function hiding a virtual; // function from a base class. These cases may be better served by a; // warning (not specific to virtual functions) on call sites when the; // call would select a different function from the base class, were it; // visible.; // See FIXME in test/SemaCXX/warn-overload-virtual.cpp for an example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:593,Testability,test,test,593,"// If the method we are checking overrides a method from its base; // don't warn about the other overloaded methods. Clang deviates from; // GCC by only diagnosing overloads of inherited virtual functions that; // do not override any other virtual functions in the base. GCC's; // -Woverloaded-virtual diagnoses any derived function hiding a virtual; // function from a base class. These cases may be better served by a; // warning (not specific to virtual functions) on call sites when the; // call would select a different function from the base class, were it; // visible.; // See FIXME in test/SemaCXX/warn-overload-virtual.cpp for an example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:7,Safety,Detect,DetectVirtual,7,/*bool DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,depend,dependent,18,"// If the type is dependent, then assume it might have; // implicit copy or move ctor because we won't know yet at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:218,Integrability,rout,routine,218,"/// AddImplicitlyDeclaredMembersToClass - Adds any implicitly-declared; /// special functions, such as the default constructor, copy; /// constructor, or destructor, to the given C++ class (C++; /// [special]p1). This routine can only be executed just before the; /// definition of the class is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:236,Modifiability,inherit,inherited,236,// For the MS ABI we need to know whether the copy ctor is deleted. A; // prerequisite for deleting the implicit copy ctor is that the class has; // a move ctor or move assignment that is either user-declared or whose; // semantics are inherited from a subobject. FIXME: We should provide a; // more direct way for CodeGen to ask whether the constructor was deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:477,Performance,perform,performed,477,"/// ActOnStartDelayedCXXMethodDeclaration - We have completed; /// parsing a top-level (non-nested) C++ class, and we are now; /// parsing those parts of the given Method declaration that could; /// not be parsed earlier (C++ [class.mem]p2), such as default; /// arguments. This action should enter the scope of the given; /// Method declaration as if we had just parsed the qualified method; /// name. However, it should not bring the parameters into scope;; /// that will be performed by ActOnDelayedCXXMethodParameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:166,Availability,error,errors,166,"/// CheckConstructorDeclarator - Called by ActOnDeclarator to check; /// the well-formedness of the constructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the invalid bit to true. In any case, the type; /// will be updated to reflect a well-formed type for the constructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:300,Deployability,update,updated,300,"/// CheckConstructorDeclarator - Called by ActOnDeclarator to check; /// the well-formedness of the constructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the invalid bit to true. In any case, the type; /// will be updated to reflect a well-formed type for the constructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:197,Integrability,rout,routine,197,"/// CheckConstructorDeclarator - Called by ActOnDeclarator to check; /// the well-formedness of the constructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the invalid bit to true. In any case, the type; /// will be updated to reflect a well-formed type for the constructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:85,Availability,error,errors,85,"// Rebuild the function type ""R"" without any type qualifiers (in; // case any of the errors above fired) and with ""void"" as the; // return type, since constructors don't have return types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:147,Availability,error,error,147,"/// CheckDestructor - Checks a fully-formed destructor definition for; /// well-formedness, issuing any diagnostics required. Returns true; /// on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:161,Performance,perform,perform,161,"// If the notional 'delete this' expression requires a non-trivial; // conversion from 'this' to the type of a destroying operator delete's; // first parameter, perform that conversion now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:163,Availability,error,errors,163,"/// CheckDestructorDeclarator - Called by ActOnDeclarator to check; /// the well-formednes of the destructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the declarator to invalid. Even if this happens,; /// will be updated to reflect a well-formed type for the destructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:299,Deployability,update,updated,299,"/// CheckDestructorDeclarator - Called by ActOnDeclarator to check; /// the well-formednes of the destructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the declarator to invalid. Even if this happens,; /// will be updated to reflect a well-formed type for the destructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:194,Integrability,rout,routine,194,"/// CheckDestructorDeclarator - Called by ActOnDeclarator to check; /// the well-formednes of the destructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the declarator to invalid. Even if this happens,; /// will be updated to reflect a well-formed type for the destructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:99,Availability,error,errors,99,"// Rebuild the function type ""R"" without any type qualifiers or; // parameters (in case any of the errors above fired) and with; // ""void"" as the return type, since destructors don't have return; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:172,Availability,error,errors,172,"/// CheckConversionDeclarator - Called by ActOnDeclarator to check the; /// well-formednes of the conversion function declarator @p D with; /// type @p R. If there are any errors in the declarator, this routine; /// will emit diagnostics and return true. Otherwise, it will return; /// false. Either way, the type @p R will be updated to reflect a; /// well-formed type for the conversion operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:327,Deployability,update,updated,327,"/// CheckConversionDeclarator - Called by ActOnDeclarator to check the; /// well-formednes of the conversion function declarator @p D with; /// type @p R. If there are any errors in the declarator, this routine; /// will emit diagnostics and return true. Otherwise, it will return; /// false. Either way, the type @p R will be updated to reflect a; /// well-formed type for the conversion operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:203,Integrability,rout,routine,203,"/// CheckConversionDeclarator - Called by ActOnDeclarator to check the; /// well-formednes of the conversion function declarator @p D with; /// type @p R. If there are any errors in the declarator, this routine; /// will emit diagnostics and return true. Otherwise, it will return; /// false. Either way, the type @p R will be updated to reflect a; /// well-formed type for the conversion operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Availability,Recover,Recover,3,"// Recover by incorporating the other type chunks into the result type.; // Note, this does *not* change the name of the function. This is compatible; // with the GCC extension:; // struct S { &operator int(); } s;; // int &r = s.operator int(); // ok in GCC; // S::operator int&() {} // error in GCC, function name is 'operator int'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:288,Availability,error,error,288,"// Recover by incorporating the other type chunks into the result type.; // Note, this does *not* change the name of the function. This is compatible; // with the GCC extension:; // struct S { &operator int(); } s;; // int &r = s.operator int(); // ok in GCC; // S::operator int&() {} // error in GCC, function name is 'operator int'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Safety,Recover,Recover,3,"// Recover by incorporating the other type chunks into the result type.; // Note, this does *not* change the name of the function. This is compatible; // with the GCC extension:; // struct S { &operator int(); } s;; // int &r = s.operator int(); // ok in GCC; // S::operator int&() {} // error in GCC, function name is 'operator int'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:80,Availability,error,errors,80,"// Rebuild the function type ""R"" without any parameters (in case any; // of the errors above fired) and with the conversion type as the; // return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:134,Integrability,rout,routine,134,"/// ActOnConversionDeclarator - Called by ActOnDeclarator to complete; /// the declaration of the given C++ conversion function. This routine; /// is responsible for recording the conversion function in the C++; /// class, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:70,Usability,guid,guide,70,"/// Check the validity of a declarator that we parsed for a deduction-guide.; /// These aren't actually declarators in the grammar, so we need to check that; /// the user didn't specify any pieces that are not part of the deduction-guide; /// grammar. Return true on invalid deduction-guide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:232,Usability,guid,guide,232,"/// Check the validity of a declarator that we parsed for a deduction-guide.; /// These aren't actually declarators in the grammar, so we need to check that; /// the user didn't specify any pieces that are not part of the deduction-guide; /// grammar. Return true on invalid deduction-guide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:285,Usability,guid,guide,285,"/// Check the validity of a declarator that we parsed for a deduction-guide.; /// These aren't actually declarators in the grammar, so we need to check that; /// the user didn't specify any pieces that are not part of the deduction-guide; /// grammar. Return true on invalid deduction-guide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:20,Usability,guid,guide,20,// C++ [temp.deduct.guide]p3:; // A deduction-gide shall be declared in the same scope as the; // corresponding class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:27,Usability,simpl,simple,27,// Check the declarator is simple enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:108,Usability,guid,guide,108,// Check that the return type is written as a specialization of; // the template specified as the deduction-guide's name.; // The template name may not be qualified. [temp.deduct.guide],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:179,Usability,guid,guide,179,// Check that the return type is written as a specialization of; // the template specified as the deduction-guide's name.; // The template name may not be qualified. [temp.deduct.guide],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:41,Usability,guid,guide,41,// we can still create a valid deduction guide here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:162,Safety,avoid,avoid,162,"// 'inline' must appear on the original definition, but not necessarily; // on all extension definitions, so the note should point to the first; // definition to avoid confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,Modifiability,extend,extended,14,// This is an extended namespace definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:66,Deployability,update,update,66,"// This is the first ""real"" definition of the namespace ""std"", so update; // our cache of the ""std"" namespace to point at this definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:81,Performance,cache,cache,81,"// This is the first ""real"" definition of the namespace ""std"", so update; // our cache of the ""std"" namespace to point at this definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Deployability,Update,Update,3,// Update the Record decl in case we encountered a forward declaration on our; // first pass. FIXME: This is a bit of a hack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Availability,Toler,Tolerate,3,// Tolerate empty base classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:64,Deployability,Update,Update,64,// We've successfully built the required types and expressions. Update; // the cache and return the newly cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:79,Performance,cache,cache,79,// We've successfully built the required types and expressions. Update; // the cache and return the newly cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:106,Performance,cache,cached,106,// We've successfully built the required types and expressions. Update; // the cache and return the newly cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:43,Availability,avail,available,43,"// We want the created NamespaceDecl to be available for redeclaration; // lookups, but not for regular name lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:32,Availability,recover,recovery,32,// This can only happen along a recovery path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:32,Safety,recover,recovery,32,// This can only happen along a recovery path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:9,Modifiability,inherit,inheriting,9,// C++11 inheriting constructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,Security,access,access,14,// Warn about access declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:141,Security,access,access,141,"// If the target happens to be one of the previous declarations, we; // don't have a conflict.; //; // FIXME: but we might be increasing its access, in which case we; // should redeclare it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:40,Availability,error,error,40,"// If we're not in a record, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:1265,Integrability,depend,dependent,1265,"/// Hides a using shadow declaration. This is required by the current; /// using-decl implementation when a resolvable using declaration in a; /// class is followed by a declaration which would hide or override; /// one or more of the using decl's targets; for example:; ///; /// struct Base { void foo(int); };; /// struct Derived : Base {; /// using Base::foo;; /// void foo(int);; /// };; ///; /// The governing language is C++03 [namespace.udecl]p12:; ///; /// When a using-declaration brings names from a base class into a; /// derived class scope, member functions in the derived class; /// override and/or hide member functions with the same name and; /// parameter types in a base class (rather than conflicting).; ///; /// There are two ways to implement this:; /// (1) optimistically create shadow decls when they're not hidden; /// by existing declarations, or; /// (2) don't create any shadow decls (or at least don't make them; /// visible) until we've fully parsed/instantiated the class.; /// The problem with (1) is that we might have to retroactively remove; /// a shadow decl, which requires several O(n) operations because the; /// decl structures are (very reasonably) not designed for removal.; /// (2) avoids this but is very fiddly and phase-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:1224,Safety,avoid,avoids,1224,"/// Hides a using shadow declaration. This is required by the current; /// using-decl implementation when a resolvable using declaration in a; /// class is followed by a declaration which would hide or override; /// one or more of the using decl's targets; for example:; ///; /// struct Base { void foo(int); };; /// struct Derived : Base {; /// using Base::foo;; /// void foo(int);; /// };; ///; /// The governing language is C++03 [namespace.udecl]p12:; ///; /// When a using-declaration brings names from a base class into a; /// derived class scope, member functions in the derived class; /// override and/or hide member functions with the same name and; /// parameter types in a base class (rather than conflicting).; ///; /// There are two ways to implement this:; /// (1) optimistically create shadow decls when they're not hidden; /// by existing declarations, or; /// (2) don't create any shadow decls (or at least don't make them; /// visible) until we've fully parsed/instantiated the class.; /// The problem with (1) is that we might have to retroactively remove; /// a shadow decl, which requires several O(n) operations because the; /// decl structures are (very reasonably) not designed for removal.; /// (2) avoids this but is very fiddly and phase-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:52,Integrability,inject,injected-class-name,52,"// No-one ever wants a using-declaration to name an injected-class-name; // of a base class, unless they're declaring an inheriting constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:121,Modifiability,inherit,inheriting,121,"// No-one ever wants a using-declaration to name an injected-class-name; // of a base class, unless they're declaring an inheriting constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:52,Security,inject,injected-class-name,52,"// No-one ever wants a using-declaration to name an injected-class-name; // of a base class, unless they're declaring an inheriting constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,inject,injected-class-name,18,"// Check that the injected-class-name is named as a member of its own; // type; we don't want to suggest 'using Derived::Base;', since that; // means something else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Security,inject,injected-class-name,18,"// Check that the injected-class-name is named as a member of its own; // type; we don't want to suggest 'using Derived::Base;', since that; // means something else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:19,Modifiability,inherit,inheriting,19,// Check that this inheriting constructor declaration actually names a; // direct base class of the current class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Security,access,accessible,46,// FIXME: Check that the base class member is accessible?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:51,Modifiability,inherit,inheriting,51,"// FIXME: We ignore attributes for now.; // For an inheriting constructor declaration, the name of the using; // declaration is the name of a constructor in this class, not in the; // base class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:181,Integrability,depend,dependent,181,"// No redeclaration check is needed here; in non-member contexts we; // diagnosed all possible conflicts with other using-declarations when; // building the template:; //; // For a dependent non-type using declaration, the only valid case is; // if we instantiate to a single enumerator. We check for conflicts; // between shadow declarations we introduce, and we check in the template; // definition for conflicts between a non-type using declaration and any; // other declaration, which together covers all cases.; //; // A dependent typename using declaration will never successfully; // instantiate, since it will always name a class member, so we reject; // that in the template definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:526,Integrability,depend,dependent,526,"// No redeclaration check is needed here; in non-member contexts we; // diagnosed all possible conflicts with other using-declarations when; // building the template:; //; // For a dependent non-type using declaration, the only valid case is; // if we instantiate to a single enumerator. We check for conflicts; // between shadow declarations we introduce, and we check in the template; // definition for conflicts between a non-type using declaration and any; // other declaration, which together covers all cases.; //; // A dependent typename using declaration will never successfully; // instantiate, since it will always name a class member, so we reject; // that in the template definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Modifiability,inherit,inherited,46,// 'using_if_exists' doesn't make sense on an inherited constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Integrability,Depend,Dependent,3,"// Dependent scope, or an unexpanded pack",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:179,Integrability,depend,dependent,179,"// Unlike most lookups, we don't always want to hide tag; // declarations: tag names are visible through the using declaration; // even if hidden by ordinary names, *except* in a dependent context; // where they may be used by two-phase lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Security,Validat,Validate,3,"// Validate the context, now we have a lookup",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:212,Integrability,depend,dependent,212,"// Try to correct typos if possible. If constructor name lookup finds no; // results, that means the named class has no explicit constructors, and we; // suppressed declaring implicit ones (probably because it's dependent or; // invalid).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:58,Safety,detect,detection,58,// HACK 2017-01-08: Work around an issue with libstdc++'s detection of; // ::gets. Sometimes it believes that glibc provides a ::gets in cases where; // it does not. The issue was fixed in libstdc++ 6.3 (2016-12-21) and later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:25,Modifiability,inherit,inheriting,25,"// If we corrected to an inheriting constructor, handle it as one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,Integrability,inject,injected,21,// The parent of the injected class name is the class itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,Security,inject,injected,21,// The parent of the injected class name is the class itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:55,Availability,error,error,55,"// If we asked for a typename and got a non-type decl, error out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Availability,error,error,53,"// If we asked for a non-typename and we got a type, error out,; // but only if this is an instantiation of an unresolved using; // decl. Otherwise just silently find the type name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Modifiability,inherit,inheriting,34,// Some additional rules apply to inheriting constructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Modifiability,inherit,inheriting,101,// Suppress access diagnostics; the access check is instead performed at the; // point of use for an inheriting constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:60,Performance,perform,performed,60,// Suppress access diagnostics; the access check is instead performed at the; // point of use for an inheriting constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Security,access,access,12,// Suppress access diagnostics; the access check is instead performed at the; // point of use for an inheriting constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Security,access,access,36,// Suppress access diagnostics; the access check is instead performed at the; // point of use for an inheriting constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:5,Integrability,depend,dependent,5,// A dependent qualifier outside a class can only ever resolve to an; // enumeration type. Therefore it conflicts with any other non-type; // declaration in the same scope.; // FIXME: How should we check for dependent type-type conflicts at block; // scope?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:208,Integrability,depend,dependent,208,// A dependent qualifier outside a class can only ever resolve to an; // enumeration type. Therefore it conflicts with any other non-type; // declaration in the same scope.; // FIXME: How should we check for dependent type-type conflicts at block; // scope?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:83,Integrability,depend,dependent,83,// using decls differ if one says 'typename' and the other doesn't.; // FIXME: non-dependent using decls?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:155,Availability,error,error,155,"/// Checks that the given nested-name qualifier used in a using decl; /// in the current context is appropriately related to the current; /// scope. If an error is found, diagnoses it and returns true.; /// R is nullptr, if the caller has not (yet) done a lookup, otherwise it's the; /// result of that lookup. UD is likewise nullptr, except when we have an; /// already-populated UsingDecl whose shadow decls contain the same information; /// (i.e. we're instantiating a UsingDecl with non-dependent scope).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:491,Integrability,depend,dependent,491,"/// Checks that the given nested-name qualifier used in a using decl; /// in the current context is appropriately related to the current; /// scope. If an error is found, diagnoses it and returns true.; /// R is nullptr, if the caller has not (yet) done a lookup, otherwise it's the; /// result of that lookup. UD is likewise nullptr, except when we have an; /// already-populated UsingDecl whose shadow decls contain the same information; /// (i.e. we're instantiating a UsingDecl with non-dependent scope).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:277,Integrability,depend,dependent,277,"// C++03 [namespace.udecl]p3:; // C++0x [namespace.udecl]p8:; // A using-declaration for a class member shall be a member-declaration.; // C++20 [namespace.udecl]p7; // ... other than an enumerator ...; // If we weren't able to compute a valid scope, it might validly be a; // dependent class or enumeration scope. If we have a 'typename' keyword,; // the scope must resolve to a class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:15,Modifiability,variab,variable,15,// const[expr] variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:27,Integrability,depend,dependent,27,"// If the named context is dependent, we can't decide much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:475,Performance,cache,cached,475,"// C++03 [namespace.udecl]p4:; // A using-declaration used as a member-declaration shall refer; // to a member of a base class of the class being defined [etc.].; // Salient point: SS doesn't have to name a base class as long as; // lookup only finds members from base classes. Therefore we can; // diagnose here only if we can prove that can't happen,; // i.e. if the class hierarchies provably don't intersect.; // TODO: it would be nice if ""definitely valid"" results were cached; // in the UsingDecl and UsingShadowDecl so that these checks didn't; // need to be repeated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:48,Integrability,depend,dependent,48,// Collect all bases. Return false if we find a dependent base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Integrability,depend,dependent,31,// Returns true if the base is dependent or is one of the accumulated base; // classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:35,Integrability,depend,dependent,35,// Return false if the class has a dependent base or if it or one; // of its bases is present in the base set of the current context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:38,Usability,clear,clearly,38,"// FIXME: The C++0x standard does not clearly say this is ill-formed,; // but we can't reasonably accept it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:62,Performance,cache,cache,62,"// This almost never happens, but if it does, ensure that our cache; // doesn't contain a stale result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Availability,error,error,53,// Register a note to be produced if we encounter an error while; // declaring the special member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:350,Security,expose,exposes,350,"// FIXME: We don't have a location to use here. Using the class's; // location maintains the fiction that we declare all special members; // with the class, but (1) it's not clear that lying about that helps our; // users understand what's going on, and (2) there may be outer contexts; // on the stack (some of which are relevant) and printing them exposes; // our lies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:174,Usability,clear,clear,174,"// FIXME: We don't have a location to use here. Using the class's; // location maintains the fiction that we declare all special members; // with the class, but (1) it's not clear that lying about that helps our; // users understand what's going on, and (2) there may be outer contexts; // on the stack (some of which are relevant) and printing them exposes; // our lies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Availability,reliab,reliable,84,// During template instantiation of implicit special member functions we need; // a reliable TypeSourceInfo for the function prototype in order to allow; // functions to be substituted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,// Perform any delayed checks on exception specifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:51,Modifiability,inherit,inherited,51,// FIXME: Add a new kind of DeclarationName for an inherited constructor.; // For now we use the name of the base class constructor as a member of the; // derived class to indicate a (fake) inherited constructor name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:190,Modifiability,inherit,inherited,190,// FIXME: Add a new kind of DeclarationName for an inherited constructor.; // For now we use the name of the base class constructor as a member of the; // derived class to indicate a (fake) inherited constructor name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:63,Modifiability,inherit,inherited,63,// Check to see if we already have a fake constructor for this inherited; // constructor call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:13,Modifiability,inherit,inherited,13,// Check the inherited constructor is valid and find the list of base classes; // from which it was inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,Modifiability,inherit,inherited,100,// Check the inherited constructor is valid and find the list of base classes; // from which it was inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:23,Performance,perform,performed,23,"// Initializations are performed ""as if by a defaulted default constructor"",; // so enter the appropriate scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:197,Modifiability,inherit,inherited,197,// [class.inhctor.init]p1:; // initialization proceeds as if a defaulted default constructor is used to; // initialize the D object and each base class subobject from which the; // constructor was inherited,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:87,Modifiability,inherit,inherited,87,// Build explicit initializers for all base classes from which the; // constructor was inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:133,Integrability,depend,depends,133,"// We can't check whether an implicit destructor is deleted before we complete; // the definition of the class, because its validity depends on the alignment; // of the class. We'll check this from ActOnFields once the class is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,/// Perform any semantic analysis which needs to be delayed until all; /// pending class member declarations have been parsed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:139,Modifiability,extend,extended,139,"// Replace the destructor's type, building off the existing one. Fortunately,; // the only thing of interest in the destructor type is its extended info.; // The return and arguments are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:153,Safety,avoid,avoid,153,/// An abstract base class for all helper classes used in building the; // copy/move operators. These classes serve as factory functions and help us; // avoid using the same Expr* in the AST twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:204,Performance,optimiz,optimization,204,"// end anonymous namespace; /// When generating a defaulted copy or move assignment operator, if a field; /// should be copied with __builtin_memcpy rather than via explicit assignments,; /// do so. This optimization only applies for arrays of scalars, and for arrays; /// of class type where the selected copy/move-assignment operator is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Integrability,rout,routine,101,"/// Builds a statement that copies/moves the given entity from \p From to; /// \c To.; ///; /// This routine is used to copy/move the members of a class with an; /// implicitly-declared copy/move assignment operator. When the entities being; /// copied are arrays, this routine builds for loops to copy them.; ///; /// \param S The Sema object used for type-checking.; ///; /// \param Loc The location where the implicit copy/move is being generated.; ///; /// \param T The type of the expressions being copied/moved. Both expressions; /// must have this type.; ///; /// \param To The expression we are copying/moving to.; ///; /// \param From The expression we are copying/moving from.; ///; /// \param CopyingBaseSubobject Whether we're copying/moving a base subobject.; /// Otherwise, it's a non-static member subobject.; ///; /// \param Copying Whether we're copying or moving.; ///; /// \param Depth Internal parameter recording the depth of the recursion.; ///; /// \returns A statement or a loop that copies the expressions, or StmtResult(0); /// if a memcpy should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:270,Integrability,rout,routine,270,"/// Builds a statement that copies/moves the given entity from \p From to; /// \c To.; ///; /// This routine is used to copy/move the members of a class with an; /// implicitly-declared copy/move assignment operator. When the entities being; /// copied are arrays, this routine builds for loops to copy them.; ///; /// \param S The Sema object used for type-checking.; ///; /// \param Loc The location where the implicit copy/move is being generated.; ///; /// \param T The type of the expressions being copied/moved. Both expressions; /// must have this type.; ///; /// \param To The expression we are copying/moving to.; ///; /// \param From The expression we are copying/moving from.; ///; /// \param CopyingBaseSubobject Whether we're copying/moving a base subobject.; /// Otherwise, it's a non-static member subobject.; ///; /// \param Copying Whether we're copying or moving.; ///; /// \param Depth Internal parameter recording the depth of the recursion.; ///; /// \returns A statement or a loop that copies the expressions, or StmtResult(0); /// if a memcpy should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:639,Modifiability,rewrite,rewrite,639,"// Suppress the protected check (C++ [class.protected]) for each of the; // assignment operators we found. This strange dance is required when; // we're assigning via a base classes's copy-assignment operator. To; // ensure that we're getting the right base class subobject (without; // ambiguities), we need to cast ""this"" to that subobject type; to; // ensure that we don't go through the virtual call mechanism, we need; // to qualify the operator= name with the base class (see below). However,; // this means that if the base class has a protected copy assignment; // operator, the protected member access check will fail. So, we; // rewrite ""protected"" access to ""public"" access in this case, since we; // know by construction that we're calling from a derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:604,Security,access,access,604,"// Suppress the protected check (C++ [class.protected]) for each of the; // assignment operators we found. This strange dance is required when; // we're assigning via a base classes's copy-assignment operator. To; // ensure that we're getting the right base class subobject (without; // ambiguities), we need to cast ""this"" to that subobject type; to; // ensure that we don't go through the virtual call mechanism, we need; // to qualify the operator= name with the base class (see below). However,; // this means that if the base class has a protected copy assignment; // operator, the protected member access check will fail. So, we; // rewrite ""protected"" access to ""public"" access in this case, since we; // know by construction that we're calling from a derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:659,Security,access,access,659,"// Suppress the protected check (C++ [class.protected]) for each of the; // assignment operators we found. This strange dance is required when; // we're assigning via a base classes's copy-assignment operator. To; // ensure that we're getting the right base class subobject (without; // ambiguities), we need to cast ""this"" to that subobject type; to; // ensure that we don't go through the virtual call mechanism, we need; // to qualify the operator= name with the base class (see below). However,; // this means that if the base class has a protected copy assignment; // operator, the protected member access check will fail. So, we; // rewrite ""protected"" access to ""public"" access in this case, since we; // know by construction that we're calling from a derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:678,Security,access,access,678,"// Suppress the protected check (C++ [class.protected]) for each of the; // assignment operators we found. This strange dance is required when; // we're assigning via a base classes's copy-assignment operator. To; // ensure that we're getting the right base class subobject (without; // ambiguities), we need to cast ""this"" to that subobject type; to; // ensure that we don't go through the virtual call mechanism, we need; // to qualify the operator= name with the base class (see below). However,; // this means that if the base class has a protected copy assignment; // operator, the protected member access check will fail. So, we; // rewrite ""protected"" access to ""public"" access in this case, since we; // know by construction that we're calling from a derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:24,Modifiability,variab,variable,24,// Create the iteration variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Modifiability,variab,variable,28,// Initialize the iteration variable to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:40,Modifiability,variab,variable,40,// Creates a reference to the iteration variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:48,Modifiability,variab,variable,48,// Create the DeclStmt that holds the iteration variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:64,Modifiability,variab,variable,64,"// Subscript the ""from"" and ""to"" expressions with the iteration variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:45,Modifiability,variab,variable,45,// Create the pre-increment of the iteration variable. We can determine; // whether the increment will overflow based on the value of the array; // bound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:130,Performance,perform,performs,130,"// C++0x [class.copy]p30:; // The implicitly-defined or explicitly-defaulted copy assignment operator; // for a non-union class X performs memberwise copy assignment of its; // subobjects. The direct base classes of X are assigned first, in the; // order of their declaration in the base-specifier-list, and then the; // immediate non-static data members of X are assigned, in the order in; // which they were declared in the class definition.; // The statements that form the synthesized function body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:109,Performance,perform,performs,109,"// C++0x [class.copy]p28:; // The implicitly-defined or move assignment operator for a non-union class; // X performs memberwise move assignment of its subobjects. The direct base; // classes of X are assigned first, in the order of their declaration in the; // base-specifier-list, and then the immediate non-static data members of X; // are assigned, in the order in which they were declared in the class; // definition.; // Issue a warning if our implicit move assignment operator will move; // from a virtual base more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:75,Availability,reliab,reliable,75,// During template instantiation of special member functions we need a; // reliable TypeSourceInfo for the parameter types in order to allow functions; // to be substituted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:113,Deployability,Update,Update,113,// Fill in the __invoke function with a dummy implementation. IR generation; // will fill in the actual details. Update its type in case it contained; // an 'auto'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,Availability,down,down,100,"// FIXME: Converting constructors should also be accepted.; // But to fix this, the logic that digs down into a CXXConstructExpr; // to find the source object needs to handle it.; // Right now it assumes the source object is passed directly as the; // first argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Testability,log,logic,84,"// FIXME: Converting constructors should also be accepted.; // But to fix this, the logic that digs down into a CXXConstructExpr; // to find the source object needs to handle it.; // Right now it assumes the source object is passed directly as the; // first argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:23,Modifiability,variab,variable,23,"// If initializing the variable failed, don't also diagnose problems with; // the destructor, they're likely related.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Modifiability,variab,variable,53,"// If the destructor is constexpr, check whether the variable has constant; // destruction now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:223,Availability,error,error,223,"/// Given a constructor and the set of arguments provided for the; /// constructor, convert the arguments and add any required default arguments; /// to form a proper call to this constructor.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Availability,avail,available,28,"// If too few arguments are available, we'll fill in the rest with defaults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:30,Integrability,depend,dependent,30,// Reject even if the type is dependent; an operator delete function is; // required to have a non-dependent result type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:99,Integrability,depend,dependent,99,// Reject even if the type is dependent; an operator delete function is; // required to have a non-dependent result type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,Integrability,depend,dependent,49,"// The first parameter type is not allowed to be dependent. As a tentative; // DR resolution, we allow a dependent parameter type if it is the right; // type anyway, to allow destroying operator delete in class templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:105,Integrability,depend,dependent,105,"// The first parameter type is not allowed to be dependent. As a tentative; // DR resolution, we allow a dependent parameter type if it is the right; // type anyway, to allow destroying operator delete in class templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:38,Modifiability,variab,variable,38,"/// Perform semantic analysis for the variable declaration that; /// occurs within a C++ catch clause, returning the newly-created; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:136,Modifiability,variab,variable,136,"/// Perform semantic analysis for the variable declaration that; /// occurs within a C++ catch clause, returning the newly-created; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic analysis for the variable declaration that; /// occurs within a C++ catch clause, returning the newly-created; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:22,Availability,error,error,22,"// For the purpose of error recovery, we treat rvalue refs like lvalue refs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Availability,recover,recovery,28,"// For the purpose of error recovery, we treat rvalue refs like lvalue refs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Safety,recover,recovery,28,"// For the purpose of error recovery, we treat rvalue refs like lvalue refs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:27,Testability,test,test,27,// FIXME: should this be a test for macosx-fragile specifically?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:33,Modifiability,variab,variables,33,"// In ARC, infer 'retaining' for variables of retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Modifiability,extend,extended,104,"/// Convert character's value, interpreted as a code unit, to a string.; /// The value needs to be zero-extended to 32-bits.; /// FIXME: This assumes Unicode literal encodings",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:13,Energy Efficiency,reduce,reduced,13,"// Bools are reduced to ints during evaluation, but for; // diagnostic purposes we want to print them as; // true or false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Availability,error,error,104,// These have been substituted from template parameters; // and appear as literals in the static assert error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:97,Testability,assert,assert,97,// These have been substituted from template parameters; // and appear as literals in the static assert error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,Usability,simpl,simple,14,// -5 is also simple to understand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:126,Testability,test,test,126,"// In C mode, allow folding as an extension for better compatibility with; // C++ in terms of expressions like static_assert(""test"") or; // static_assert(nullptr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:57,Integrability,message,message,57,"// If the static_assert passes, only verify that; // the message is grammatically valid without evaluating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Availability,Error,ErrorOnInvalidMessage,2,/*ErrorOnInvalidMessage=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Availability,Error,ErrorOnInvalidMessage,2,/*ErrorOnInvalidMessage=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:9,Availability,down,down,9,// Drill down into concept specialization expressions to see why they; // weren't satisfied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,/// Perform semantic analysis of the given friend type declaration.; ///; /// \returns A friend declaration that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:178,Usability,simpl,simple-type-specifier,178,// C++11 [class.friend]p3:; // A friend declaration that does not declare a function shall have one; // of the following forms:; // friend elaborated-type-specifier ;; // friend simple-type-specifier ;; // friend typename-specifier ;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Availability,down,down,84,"// FIXME: don't ignore attributes.; // If it's explicit specializations all the way down, just forget; // about the template header and build an appropriate non-templated; // friend. TODO: for source fidelity, remember the headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:445,Usability,simpl,simple,445,"/// Handle a friend type declaration. This works in tandem with; /// ActOnTag.; ///; /// Notes on friend class templates:; ///; /// We generally treat friend class declarations as if they were; /// declaring a class. So, for example, the elaborated type specifier; /// in a friend declaration is required to obey the restrictions of a; /// class-head (i.e. no typedefs in the scope chain), template; /// parameters are required to match up with simple template-ids, &c.; /// However, unlike when declaring a template specialization, it's; /// okay to refer to a template specialization without an empty; /// template parameter declaration, e.g.; /// friend class A<T>::B<unsigned>;; /// We permit this as a special case; if there are any template; /// parameters present at all, require proper matching, i.e.; /// template <> template \<class T> friend class A<int>::B;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:176,Usability,simpl,simple-type-specifier,176,"// C++ [class.friend]p3:; // A friend declaration that does not declare a function shall have one of; // the following forms:; // friend elaborated-type-specifier ;; // friend simple-type-specifier ;; // friend typename-specifier ;; //; // Any declaration with a type qualifier does not have that form. (It's; // legal to specify a qualified type as a friend, you just can't write the; // keywords.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:25,Availability,error,error,25,"// This is definitely an error in C++98. It's probably meant to; // be forbidden in C++0x, too, but the specification is just; // poorly written.; //; // The problem is with declarations like the following:; // template <T> friend A<T>::foo;; // where deciding whether a class C is a friend or not now hinges; // on whether there exists an instantiation of A that causes; // 'foo' to equal C. There are restrictions on class-heads; // (which we declare (by fiat) elaborated friend declarations to; // be) that makes this tractable.; //; // FIXME: handle ""template <> friend class A<T>;"", which; // is possibly well-formed? Who even knows?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:165,Integrability,depend,dependent,165,"// C++ [class.friend]p1; // A friend of a class is a function or class....; // Note that this sees through typedefs, which is intended.; // It *doesn't* see through dependent types, which is correct; // according to [temp.arg.type]p3:; // If a declaration acquires a function type through a; // type dependent on a template-parameter and this causes; // a declaration that does not use the syntactic form of a; // function declarator to have a function type, the program; // is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:300,Integrability,depend,dependent,300,"// C++ [class.friend]p1; // A friend of a class is a function or class....; // Note that this sees through typedefs, which is intended.; // It *doesn't* see through dependent types, which is correct; // according to [temp.arg.type]p3:; // If a declaration acquires a function type through a; // type dependent on a template-parameter and this causes; // a declaration that does not use the syntactic form of a; // function declarator to have a function type, the program; // is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Availability,recover,recover,36,// It might be worthwhile to try to recover by creating an; // appropriate declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Safety,recover,recover,36,// It might be worthwhile to try to recover by creating an; // appropriate declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:247,Usability,simpl,simple,247,"// C++ [namespace.memdef]p3; // - If a friend declaration in a non-local class first declares a; // class or function, the friend class or function is a member; // of the innermost enclosing namespace.; // - The name of the friend is not found by simple name lookup; // until a matching declaration is provided in that namespace; // scope (either before or after the class declaration granting; // friendship).; // - If a friend function is called, its name may be found by the; // name lookup that considers functions from namespaces and; // classes associated with the types of the function arguments.; // - When looking for a prior declaration of a class or a function; // declared as a friend, scopes outside the innermost enclosing; // namespace scope are not considered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,Availability,recover,recover,177,// There are five cases here.; // - There's no scope specifier and we're in a local class. Only look; // for functions declared in the immediately-enclosing block scope.; // We recover from invalid scope qualifiers as if they just weren't there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,Safety,recover,recover,177,// There are five cases here.; // - There's no scope specifier and we're in a local class. Only look; // for functions declared in the immediately-enclosing block scope.; // We recover from invalid scope qualifiers as if they just weren't there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:125,Availability,error,error,125,"// This is ill-formed, but provide the context that we would have; // declared the function in, if we were permitted to, for error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:131,Availability,recover,recovery,131,"// This is ill-formed, but provide the context that we would have; // declared the function in, if we were permitted to, for error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:131,Safety,recover,recovery,131,"// This is ill-formed, but provide the context that we would have; // declared the function in, if we were permitted to, for error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:19,Integrability,depend,dependent,19,"// - There's a non-dependent scope specifier, in which case we; // compute it and do a previous lookup there for a function; // or function template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:9,Performance,perform,performed,9,"// If we performed typo correction, we might have added a scope specifier; // and changed the decl context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:201,Deployability,update,update,201,"// Add the function declaration to the appropriate lookup tables,; // adjusting the redeclarations list as necessary. We don't; // want to do this yet if the friending class is dependent.; //; // Also update the scope-based lookup if the target context's; // lookup context is in lexical scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,Integrability,depend,dependent,177,"// Add the function declaration to the appropriate lookup tables,; // adjusting the redeclarations list as necessary. We don't; // want to do this yet if the friending class is dependent.; //; // Also update the scope-based lookup if the target context's; // lookup context is in lexical scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:195,Availability,down,down,195,"// We can't look at FD->getPreviousDecl() because it may not have been set; // if we're in a dependent context. If the function is known to be a; // redeclaration, we will have narrowed Previous down to the right decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:93,Integrability,depend,dependent,93,"// We can't look at FD->getPreviousDecl() because it may not have been set; // if we're in a dependent context. If the function is known to be a; // redeclaration, we will have narrowed Previous down to the right decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Availability,recover,recover,12,// We can't recover from this; the declaration might have already; // been used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Safety,recover,recover,12,// We can't recover from this; the declaration might have already; // been used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:5,Integrability,depend,dependent,5,// A dependent function that doesn't locally look defaultable can; // still instantiate to a defaultable function if it's a constructor; // or assignment operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:52,Integrability,depend,dependent,52,// Defer checking functions that are defaulted in a dependent context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:86,Performance,perform,performed,86,"// If this member fn was defaulted on its first declaration, we will have; // already performed the checking in CheckCompletedCXXClass. Such a; // declaration doesn't trigger an implicit definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:120,Availability,error,error,120,"// If the calling conventions mismatch because the new function is static,; // suppress the calling convention mismatch error; the error about static; // function override (err_static_overrides_virtual from; // Sema::CheckFunctionDeclaration) is more clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:131,Availability,error,error,131,"// If the calling conventions mismatch because the new function is static,; // suppress the calling convention mismatch error; the error about static; // function override (err_static_overrides_virtual from; // Sema::CheckFunctionDeclaration) is more clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:251,Usability,clear,clear,251,"// If the calling conventions mismatch because the new function is static,; // suppress the calling convention mismatch error; the error about static; // function override (err_static_overrides_virtual from; // Sema::CheckFunctionDeclaration) is more clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:118,Availability,error,error,118,"// FIXME: this note won't trigger for delayed access control; // diagnostics, and it's impossible to get an undelayed error; // here from access control during the original parse because; // the ParsingDeclSpec/ParsingDeclarator are still in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Security,access,access,46,"// FIXME: this note won't trigger for delayed access control; // diagnostics, and it's impossible to get an undelayed error; // here from access control during the original parse because; // the ParsingDeclSpec/ParsingDeclarator are still in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:138,Security,access,access,138,"// FIXME: this note won't trigger for delayed access control; // diagnostics, and it's impossible to get an undelayed error; // here from access control during the original parse because; // the ParsingDeclSpec/ParsingDeclarator are still in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:56,Modifiability,variab,variable,56,/// Determine whether the given declaration is a global variable or; /// static data member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:38,Performance,perform,perform,38,"// The Microsoft ABI requires that we perform the destructor body; // checks (i.e. operator delete() lookup) when the vtable is marked used, as; // the deleting destructor is emitted with the vtable, not with the; // destructor definition as in the Itanium ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Integrability,rout,routine,31,/// SetIvarInitializers - This routine builds initialization ASTs for the; /// Objective-C implementation whose ivars need be initialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Security,access,accessible,34,// Be sure that the destructor is accessible and is marked as referenced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:65,Integrability,depend,dependent,65,"// Target may not be determinable yet, for instance if this is a dependent; // call in an uninstantiated template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Safety,Avoid,Avoid,3,// Avoid dereferencing a null pointer here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Deployability,Update,Update,3,// Update the exception specification on the function type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:331,Availability,error,error,331,"/// Check whether the given method, which must be in the 'init'; /// family, is a valid member of that family.; ///; /// \param receiverTypeIfCall - if null, check this as if declaring it;; /// if non-null, check this as if making a call to it with the given; /// receiver type; ///; /// \return true to indicate that there was an error and appropriate; /// actions were taken",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:171,Integrability,protocol,protocols,171,// This castAs is safe: methods that don't return an object; // pointer won't be inferred as inits and will reject an explicit; // objc_method_family(init).; // We ignore protocols here. Should we? What about Class?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:18,Safety,safe,safe,18,// This castAs is safe: methods that don't return an object; // pointer won't be inferred as inits and will reject an explicit; // objc_method_family(init).; // We ignore protocols here. Should we? What about Class?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:27,Availability,error,error,27,// fall through: always an error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:92,Integrability,interface,interface,92,// It's okay for the result type to still be a forward declaration; // if we're checking an interface declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:36,Integrability,protocol,protocol,36,"// If this method was declared in a protocol, we can't check; // anything unless we have a receiver type that's an interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:115,Integrability,interface,interface,115,"// If this method was declared in a protocol, we can't check; // anything unless we have a receiver type that's an interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:22,Availability,error,error,22,"// Otherwise, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:63,Integrability,protocol,protocol,63,/// Produce additional diagnostics if a category conforms to a protocol that; /// defines a method taking a non-escaping parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:2,Integrability,Message,Message,2,/*Message=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Usability,simpl,simply,41,"// If we don't have a valid method decl, simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Integrability,rout,routine,37,"/// ActOnStartOfObjCMethodDef - This routine sets up parameters; invisible; /// and user declared, in the method definition's AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Usability,simpl,simply,41,"// If we don't have a valid method decl, simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Deployability,release,release,41,"// In ARC, disallow definition of retain/release/autorelease/retainCount",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:141,Security,validat,validation,141,"// Callback to only accept typo corrections that are Objective-C classes.; // If an ObjCInterfaceDecl* is given to the constructor, then the validation; // function will reject corrections to that class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Availability,avail,availability,12,// Diagnose availability in the context of the ObjC container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:2,Safety,Avoid,AvoidPartialAvailabilityChecks,2,/*AvoidPartialAvailabilityChecks=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:25,Modifiability,inherit,inherit,25,// Diagnose classes that inherit from deprecated classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Integrability,interface,interface,41,"// This handles the following case:; // @interface NewI @end; // typedef NewI DeprI __attribute__((deprecated(""blah""))); // @interface SI : DeprI /* warn here */ @end",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:125,Integrability,interface,interface,125,"// This handles the following case:; // @interface NewI @end; // typedef NewI DeprI __attribute__((deprecated(""blah""))); // @interface SI : DeprI /* warn here */ @end",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:73,Integrability,interface,interface,73,// This handles the following case:; //; // typedef int SuperClass;; // @interface MyClass : SuperClass {} @end; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:48,Deployability,update,update,48,// Create a new type location builder so we can update the type; // location information we have.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:96,Testability,assert,assert,96,"// If the type bound has qualifiers other than CVR, we need to strip; // them or we'll probably assert later when trying to apply new; // qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:67,Availability,error,error,67,"// If there was no explicit type bound (or we removed it due to an error),; // use 'id' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:163,Modifiability,variab,variable,163,"// Diagnose redeclarations of type parameters.; // We do this now because Objective-C type parameters aren't pushed into; // scope until later (after the instance variable block), but we want the; // diagnostics to occur right after we parse the type parameter list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:145,Integrability,interface,interface,145,"// end anonymous namespace; /// Check consistency between two Objective-C type parameter lists, e.g.,; /// between a category/extension and an \@interface or between an \@class and an; /// \@interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:191,Integrability,interface,interface,191,"// end anonymous namespace; /// Check consistency between two Objective-C type parameter lists, e.g.,; /// between a category/extension and an \@interface or between an \@class and an; /// \@interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Deployability,update,update,29,// Diagnose the conflict and update the second declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:168,Integrability,interface,interfaces,168,"// The new type parameter got the implicit bound of 'id'. That's okay for; // categories and extensions (overwrite it later), but not for forward; // declarations and @interfaces, because those must be standalone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Deployability,Update,Update,3,// Update the new type parameter's bound to match the previous one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:42,Integrability,interface,interface,42,// Create a declaration to describe this @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Availability,avail,availability,12,// Diagnose availability in the context of the @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:48,Integrability,interface,interface,48,// Diagnose availability in the context of the @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:30,Integrability,protocol,protocols,30,// Check then save referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:48,Integrability,protocol,protocol,48,/// ActOnTypedefedProtocols - this action finds protocol list as part of the; /// typedef'ed use for a qualified super class and adds them to the list; /// of the protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:163,Integrability,protocol,protocols,163,/// ActOnTypedefedProtocols - this action finds protocol list as part of the; /// typedef'ed use for a qualified super class and adds them to the list; /// of the protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:105,Integrability,protocol,protocol,105,// FIXME: Consider whether this should be an invalid loc since the loc; // is not actually pointing to a protocol name reference but to the; // typedef reference. Note that the base class name loc is also pointing; // at the typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:115,Availability,avail,available,115,"// Create a new protocol that is completely distinct from previous; // declarations, and do not make this protocol available for name lookup.; // That way, we'll end up completely ignoring the duplicate.; // FIXME: Can we turn this into an error?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:240,Availability,error,error,240,"// Create a new protocol that is completely distinct from previous; // declarations, and do not make this protocol available for name lookup.; // That way, we'll end up completely ignoring the duplicate.; // FIXME: Can we turn this into an error?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:16,Integrability,protocol,protocol,16,"// Create a new protocol that is completely distinct from previous; // declarations, and do not make this protocol available for name lookup.; // That way, we'll end up completely ignoring the duplicate.; // FIXME: Can we turn this into an error?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:106,Integrability,protocol,protocol,106,"// Create a new protocol that is completely distinct from previous; // declarations, and do not make this protocol available for name lookup.; // That way, we'll end up completely ignoring the duplicate.; // FIXME: Can we turn this into an error?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:22,Integrability,depend,dependencies,22,// Check for circular dependencies among protocol declarations. This can; // only happen if this protocol was forward-declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Integrability,protocol,protocol,41,// Check for circular dependencies among protocol declarations. This can; // only happen if this protocol was forward-declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:97,Integrability,protocol,protocol,97,// Check for circular dependencies among protocol declarations. This can; // only happen if this protocol was forward-declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,protocol,protocols,31,/// Check then save referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:81,Availability,error,error,81,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:35,Integrability,rout,routine,35,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:52,Integrability,protocol,protocols,52,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:137,Integrability,protocol,protocol,137,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:167,Integrability,Protocol,Protocols,167,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,protocol,protocol,24,"// If this is a forward protocol declaration, get its definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:108,Availability,avail,availability,108,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:32,Integrability,protocol,protocol,32,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Availability,Recover,Recover,100,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Safety,Recover,Recover,100,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:76,Integrability,protocol,protocols,76,// Callback to only accept typo corrections that are either; // Objective-C protocols or valid Objective-C type arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Integrability,protocol,protocols,28,"// If we're allowed to find protocols and we have a protocol, accept it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:52,Integrability,protocol,protocol,52,"// If we're allowed to find protocols and we have a protocol, accept it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:135,Integrability,protocol,protocol,135,"// If we found a tag declaration outside of C++, skip it. This; // can happy because we look for any name when there is no; // bias to protocol or type names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:23,Deployability,update,updates,23,// Local function that updates the declaration specifiers with; // protocol information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:67,Integrability,protocol,protocol,67,// Local function that updates the declaration specifiers with; // protocol information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:40,Modifiability,parameteriz,parameterized,40,"// Determine whether the base type is a parameterized class, in; // which case we want to warn about typos such as; // ""NSArray<NSObject>"" (that should be NSArray<NSObject *>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:108,Availability,avail,availability,108,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:32,Integrability,protocol,protocol,32,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,protocol,protocol,24,"// If this is a forward protocol declaration, get its definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Availability,Recover,Recover,100,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Safety,Recover,Recover,100,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:14,Integrability,protocol,protocols,14,"// All of the protocols listed also have type names, and at least; // one is an Objective-C class name. Check whether all of the; // protocol conformances are declared by the base class itself, in; // which case we warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:133,Integrability,protocol,protocol,133,"// All of the protocols listed also have type names, and at least; // one is an Objective-C class name. Check whether all of the; // protocol conformances are declared by the base class itself, in; // which case we warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:48,Integrability,protocol,protocols,48,// Attempt to resolve all of the identifiers as protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Integrability,protocol,protocols,28,"// If all of the names were protocols, these were protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:50,Integrability,protocol,protocol,50,"// If all of the names were protocols, these were protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Usability,simpl,simply,37,// Form declaration specifiers. They simply refer to the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:23,Deployability,update,updates,23,// Local function that updates the declaration specifiers with; // type argument information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,protocol,protocols,31,// We did not resolve these as protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Availability,Error,Error,3,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:9,Availability,recover,recovery,9,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:78,Integrability,protocol,protocol,78,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:9,Safety,recover,recovery,9,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,protocol,protocol,24,// If we already have a protocol or type. Check whether it is the; // right thing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:54,Integrability,protocol,protocols,54,"// If we haven't figured out whether we want types or protocols; // yet, try to figure it out from this name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,protocol,protocol,33,"// If this name refers to both a protocol and a type (e.g., \c; // NSObject), don't conclude anything yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:83,Integrability,protocol,protocols,83,"// Otherwise, let this name decide whether we'll be correcting; // toward types or protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:14,Integrability,protocol,protocols,14,"// If we want protocols and we have a protocol, there's nothing; // more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:38,Integrability,protocol,protocol,38,"// If we want protocols and we have a protocol, there's nothing; // more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:43,Integrability,protocol,protocols,43,// We have a conflict: some names refer to protocols and others; // refer to types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Performance,Perform,Perform,3,// Perform typo correction on the name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,protocol,protocol,17,// Did we find a protocol?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:43,Integrability,protocol,protocols,43,"// If all of the names were (corrected to) protocols, these were; // protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:69,Integrability,protocol,protocol,69,"// If all of the names were (corrected to) protocols, these were; // protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Availability,error,error,28,// Possibly due to previous error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:47,Integrability,protocol,protocol,47,/// ActOnForwardProtocolDeclaration - Handle \@protocol foo;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:141,Usability,clear,clear,141,// Create an invalid ObjCCategoryDecl to serve as context for; // the enclosing method declarations. We mark the decl invalid; // to make it clear that this isn't a valid AST.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,interface,interface,24,/// Check for duplicate interface declaration for this category,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:77,Availability,avail,availability,77,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:139,Availability,avail,availability,139,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:44,Integrability,protocol,protocols,44,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:169,Integrability,protocol,protocol,169,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Integrability,Protocol,Protocols,3,// Protocols in the class extension belong to the class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:39,Performance,Perform,Perform,39,/// ActOnStartCategoryImplementation - Perform semantic checks on the; /// category implementation declaration and build an ObjCCategoryImplDecl; /// object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:77,Deployability,install,install,77,// Category @implementation with no corresponding @interface.; // Create and install one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:51,Integrability,interface,interface,51,// Category @implementation with no corresponding @interface.; // Create and install one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:10,Integrability,interface,interface,10,"// If the interface has the objc_runtime_visible attribute, we; // cannot implement a category for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Availability,error,error,31,// FIXME: This will produce an error if the definition of the interface has; // been imported from a module but is not visible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:62,Integrability,interface,interface,62,// FIXME: This will produce an error if the definition of the interface has; // been imported from a module but is not visible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:121,Availability,recover,recovery,121,"// Suggest the (potentially) correct interface name. Don't provide a; // code-modification hint or use the typo name for recovery, because; // this is just a warning. The program may actually be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Integrability,interface,interface,37,"// Suggest the (potentially) correct interface name. Don't provide a; // code-modification hint or use the typo name for recovery, because; // this is just a warning. The program may actually be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:121,Safety,recover,recovery,121,"// Suggest the (potentially) correct interface name. Don't provide a; // code-modification hint or use the typo name for recovery, because; // this is just a warning. The program may actually be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:2,Availability,Error,ErrorRecovery,2,/*ErrorRecovery*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,interface,interface,31,// This implementation and its interface do not have the same; // super class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:87,Deployability,install,install,87,"// Legacy case of @implementation with no corresponding @interface.; // Build, chain & install the interface decl into the identifier.; // FIXME: Do we support attributes on the @implementation? If so we should; // copy them over.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:57,Integrability,interface,interface,57,"// Legacy case of @implementation with no corresponding @interface.; // Build, chain & install the interface decl into the identifier.; // FIXME: Do we support attributes on the @implementation? If so we should; // copy them over.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:99,Integrability,interface,interface,99,"// Legacy case of @implementation with no corresponding @interface.; // Build, chain & install the interface decl into the identifier.; // FIXME: Do we support attributes on the @implementation? If so we should; // copy them over.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Integrability,interface,interface,12,"// Mark the interface as being completed, even if it was just as; // @class ....;; // declaration; the user cannot reopen it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,interface,interface,33,/// Check case of non-existing \@interface decl.; /// (legacy objective-c \@implementation decl without an \@interface decl).; /// Add implementations's ivar to the synthesize class's ivar list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:109,Integrability,interface,interface,109,/// Check case of non-existing \@interface decl.; /// (legacy objective-c \@implementation decl without an \@interface decl).; /// Add implementations's ivar to the synthesize class's ivar list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:9,Integrability,interface,interface,9,// Check interface's Ivar list against those in the implementation.; // names and types must match.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:270,Integrability,protocol,protocols,270,"// FIXME: For now ignore 'IncompleteImpl'.; // Previously we grouped all unimplemented methods under a single; // warning, but some users strongly voiced that they would prefer; // separate warnings. We will give that approach a try, as that; // matches what we do with protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:1982,Availability,down,down-casting,1982," can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by callers.; ///; /// Note: This is a stricter requirement than for assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:330,Integrability,protocol,protocols,330,"/// Determines if type B can be substituted for type A. Returns true if we can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:934,Integrability,interface,interface,934,"/// Determines if type B can be substituted for type A. Returns true if we can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:954,Integrability,interface,interface,954,"/// Determines if type B can be substituted for type A. Returns true if we can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:1948,Safety,avoid,avoids,1948," can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by callers.; ///; /// Note: This is a stricter requirement than for assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Integrability,protocol,protocol-unqualified,12,// Reject a protocol-unqualified id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:99,Integrability,protocol,protocols,99,"// If B is a qualified id, then A must also be a qualified id and it must; // implement all of the protocols in B. It may not be a qualified class.; // For example, MyClass<A> can be assigned to id<A>, but MyClass<A> is a; // stricter definition so it is not substitutable for id<A>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:110,Availability,error,error,110,"/// In ARC, check whether the conventional meanings of the two methods; /// match. If they don't, it's a hard error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,rout,routine,33,/// WarnExactTypedMethods - This routine issues a warning if method; /// implementation declaration matches exactly that of its declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Integrability,protocol,protocol,28,// don't issue warning when protocol method is optional because primary; // class is not required to implement it and it is safe for protocol; // to implement it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:133,Integrability,protocol,protocol,133,// don't issue warning when protocol method is optional because primary; // class is not required to implement it and it is safe for protocol; // to implement it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:124,Safety,safe,safe,124,// don't issue warning when protocol method is optional because primary; // class is not required to implement it and it is safe for protocol; // to implement it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:173,Integrability,protocol,protocol,173,/// FIXME: Type hierarchies in Objective-C can be deep. We could most likely; /// improve the efficiency of selector lookups and type checking by associating; /// with each protocol / interface / category the flattened instance tables. If; /// we used an immutable set to keep the table then it wouldn't add significant; /// memory cost and it would be handy for lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:184,Integrability,interface,interface,184,/// FIXME: Type hierarchies in Objective-C can be deep. We could most likely; /// improve the efficiency of selector lookups and type checking by associating; /// with each protocol / interface / category the flattened instance tables. If; /// we used an immutable set to keep the table then it wouldn't add significant; /// memory cost and it would be handy for lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:51,Integrability,protocol,protocols,51,/// Recursively populates a set with all conformed protocols in a class; /// hierarchy that have the 'objc_protocol_requires_explicit_implementation'; /// attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:35,Integrability,rout,routine,35,"/// CheckProtocolMethodDefs - This routine checks unimplemented methods; /// Declared in protocol, and those referenced by it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:89,Integrability,protocol,protocol,89,"/// CheckProtocolMethodDefs - This routine checks unimplemented methods; /// Declared in protocol, and those referenced by it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:11,Integrability,protocol,protocol,11,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:172,Integrability,protocol,protocol,172,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:205,Integrability,protocol,protocol,205,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:264,Integrability,protocol,protocol,264,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:347,Integrability,protocol,protocol,347,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:410,Integrability,protocol,protocols,410,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:516,Integrability,protocol,protocols,516,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:646,Integrability,protocol,protocols,646,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:214,Modifiability,inherit,inheritance,214,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:546,Performance,optimiz,optimization,546,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:396,Testability,log,logic,396,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Integrability,protocol,protocol,37,"// If no super class conforms to the protocol, we should not search; // for methods in the super class to implicitly satisfy the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:129,Integrability,protocol,protocol,129,"// If no super class conforms to the protocol, we should not search; // for methods in the super class to implicitly satisfy the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,protocol,protocol,24,"// If this is a forward protocol declaration, get its definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:136,Integrability,protocol,protocol,136,"// If a method lookup fails locally we still need to look and see if; // the method was implemented by a base class or an inherited; // protocol. This lookup is slow, but occurs rarely in correct code; // and otherwise would terminate in a warning.; // check unimplemented instance methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:122,Modifiability,inherit,inherited,122,"// If a method lookup fails locally we still need to look and see if; // the method was implemented by a base class or an inherited; // protocol. This lookup is slow, but occurs rarely in correct code; // and otherwise would terminate in a warning.; // check unimplemented instance methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:148,Integrability,protocol,protocols,148,"// If a method is not implemented in the category implementation but; // has been declared in its primary class, superclass,; // or in one of their protocols, no need to issue the warning.; // This is because method will be implemented in the primary class; // or one of its super class implementation.; // Ugly, but necessary. Method declared in protocol might have; // have been synthesized due to a property declared in the class which; // uses the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:347,Integrability,protocol,protocol,347,"// If a method is not implemented in the category implementation but; // has been declared in its primary class, superclass,; // or in one of their protocols, no need to issue the warning.; // This is because method will be implemented in the primary class; // or one of its super class implementation.; // Ugly, but necessary. Method declared in protocol might have; // have been synthesized due to a property declared in the class which; // uses the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:452,Integrability,protocol,protocol,452,"// If a method is not implemented in the category implementation but; // has been declared in its primary class, superclass,; // or in one of their protocols, no need to issue the warning.; // This is because method will be implemented in the primary class; // or one of its super class implementation.; // Ugly, but necessary. Method declared in protocol might have; // have been synthesized due to a property declared in the class which; // uses the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,protocol,protocols,17,"// Check on this protocols's referenced protocols, recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:40,Integrability,protocol,protocols,40,"// Check on this protocols's referenced protocols, recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:59,Integrability,interface,interface,59,/// MatchAllMethodDeclarations - Check methods declared in interface; /// or protocol against those declared in their implementations.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:77,Integrability,protocol,protocol,77,/// MatchAllMethodDeclarations - Check methods declared in interface; /// or protocol against those declared in their implementations.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:46,Integrability,interface,interface,46,"// Check and see if instance methods in class interface have been; // implemented in the implementation class. If so, their types match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Security,access,accessor,17,// Skip property accessor function stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:35,Testability,stub,stubs,35,// Skip property accessor function stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:43,Integrability,interface,interface,43,"// Check and see if class methods in class interface have been; // implemented in the implementation class. If so, their types match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Security,access,accessor,17,// Skip property accessor function stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:35,Testability,stub,stubs,35,// Skip property accessor function stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:39,Integrability,protocol,protocols,39,"// Also, check for methods declared in protocols inherited by; // this protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:71,Integrability,protocol,protocol,71,"// Also, check for methods declared in protocols inherited by; // this protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:49,Modifiability,inherit,inherited,49,"// Also, check for methods declared in protocols inherited by; // this protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:57,Integrability,protocol,protocol,57,// Check for any implementation of a methods declared in protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:46,Integrability,interface,interface,46,// Check and see if instance methods in class interface have been; // implemented in the implementation class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:47,Integrability,interface,interface,47,// Check and see if properties declared in the interface have either 1); // an implementation or 2) there is a @synthesize/@dynamic implementation; // of the property in the @implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:58,Integrability,protocol,protocol,58,// Check for type conflict of methods declared in a class/protocol and; // its implementation; if any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:13,Integrability,protocol,protocol,13,// Check the protocol list for unimplemented methods in the @implementation; // class.; // Check and see if class methods in class interface have been; // implemented in the implementation class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:131,Integrability,interface,interface,131,// Check the protocol list for unimplemented methods in the @implementation; // class.; // Check and see if class methods in class interface have been; // implemented in the implementation class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:52,Integrability,protocol,protocols,52,"// For extended class, unimplemented methods in its protocols will; // be reported in the primary class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:7,Modifiability,extend,extended,7,"// For extended class, unimplemented methods in its protocols will; // be reported in the primary class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:8,Integrability,interface,interface,8,// The @interface does not have type parameters. Complain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:68,Security,validat,validate,68,"// Otherwise, use this absurdly complicated algorithm to try to; // validate the basic, low-level compatibility of the two types.; // As a minimum, require the sizes and alignments to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,depend,dependent,33,// Consider all the kinds of non-dependent canonical types:; // - functions and arrays aren't possible as return and parameter types; // - vector types of equal size can be arbitrarily mixed,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:140,Integrability,protocol,protocol,140,"/// MatchTwoMethodDeclarations - Checks that two methods have matching type and; /// returns true, or false, accordingly.; /// TODO: Handle protocol list; such as id<p1,p2> in type comparisons",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,protocol,protocol,31,"// If this method belongs to a protocol but the method in list does not, or; // vice versa, we say the context is not the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:297,Availability,avail,availability,297,"// Looking for method with a type bound requires the correct context exists.; // We need to insert a method into the list if the context is different.; // If the method's declaration matches the list; // a> the method belongs to a different context: we need to insert it, in; // order to emit the availability message, we need to prioritize over; // availability among the methods with the same declaration.; // b> the method belongs to the same context: there is no need to insert a; // new entry.; // If the method's declaration does not match the list, we insert it to the; // end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:350,Availability,avail,availability,350,"// Looking for method with a type bound requires the correct context exists.; // We need to insert a method into the list if the context is different.; // If the method's declaration matches the list; // a> the method belongs to a different context: we need to insert it, in; // order to emit the availability message, we need to prioritize over; // availability among the methods with the same declaration.; // b> the method belongs to the same context: there is no need to insert a; // new entry.; // If the method's declaration does not match the list, we insert it to the; // end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:310,Integrability,message,message,310,"// Looking for method with a type bound requires the correct context exists.; // We need to insert a method into the list if the context is different.; // If the method's declaration matches the list; // a> the method belongs to a different context: we need to insert it, in; // order to emit the availability message, we need to prioritize over; // availability among the methods with the same declaration.; // b> the method belongs to the same context: there is no need to insert a; // new entry.; // If the method's declaration does not match the list, we insert it to the; // end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,interface,interface,33,"// Objective-C doesn't allow an @interface for a class after its; // @implementation. So if Method is not defined and there already is; // an entry for this type signature, Method has to be for a different; // class than PrevObjCMethod.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:20,Usability,clear,clear,20,// FIXME: should we clear the other bits in ListWithSameDeclaration?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:204,Availability,error,errors,204,"/// Determines if this is an ""acceptable"" loose mismatch in the global; /// method pool. This exists mostly as a hack to get around certain; /// global mismatches which we can't afford to make warnings / errors.; /// Really, what we want is a way to take a method out of the global; /// method pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:36,Integrability,protocol,protocol,36,"// Check if the Method belongs to a protocol. We should allow any method; // defined in any protocol, because any subclass could adopt the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:92,Integrability,protocol,protocol,92,"// Check if the Method belongs to a protocol. We should allow any method; // defined in any protocol, because any subclass could adopt the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:139,Integrability,protocol,protocol,139,"// Check if the Method belongs to a protocol. We should allow any method; // defined in any protocol, because any subclass could adopt the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Testability,Test,Test,3,// Test for no method in the pool which should not trigger any warning by; // caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:174,Availability,error,errors,174,"// If we didn't see any strict differences, we won't see any loose; // differences. In ARC, however, we also need to check for loose; // mismatches, because most of them are errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Modifiability,flexible,flexible,29,/// Diagnose attempts to use flexible array member with retainable object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:38,Integrability,interface,interface,38,// Check if variable sized ivar is in interface and visible to subclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Modifiability,variab,variable,12,// Check if variable sized ivar is in interface and visible to subclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Integrability,interface,interface,29,// Subsequent checks require interface decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Modifiability,variab,variable,12,// Check if variable sized ivar is followed by another ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:44,Modifiability,variab,variable,44,// Check if ObjC container adds ivars after variable sized ivar in superclass.; // Perform the check only if OCD is the first container to declare ivars to; // avoid multiple warnings for the same ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:83,Performance,Perform,Perform,83,// Check if ObjC container adds ivars after variable sized ivar in superclass.; // Perform the check only if OCD is the first container to declare ivars to; // avoid multiple warnings for the same ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:160,Safety,avoid,avoid,160,// Check if ObjC container adds ivars after variable sized ivar in superclass.; // Perform the check only if OCD is the first container to declare ivars to; // avoid multiple warnings for the same ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,protocol,protocols,17,"// Check on this protocols's referenced protocols, recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:40,Integrability,protocol,protocols,40,"// Check on this protocols's referenced protocols, recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:20,Security,access,accessor,20,// Make synthesized accessor stub functions visible.; // ActOnPropertyImplDecl() creates them as not visible in case; // they are overridden by an explicit method that is encountered; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Testability,stub,stub,29,// Make synthesized accessor stub functions visible.; // ActOnPropertyImplDecl() creates them as not visible in case; // they are overridden by an explicit method that is encountered; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Integrability,message,messages,41,"/// The following allows us to typecheck messages to ""id"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:26,Modifiability,extend,extend,26,"// Categories are used to extend the class by declaring new methods.; // By the same token, they are also used to add new properties. No; // need to compare the added property to those in the class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:6,Integrability,interface,interface,6,// An interface can subclass another interface with a; // objc_subclassing_restricted attribute when it has that attribute as; // well (because of interfaces imported from Swift). Therefore we have; // to check if we can subclass in the implementation as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Integrability,interface,interface,37,// An interface can subclass another interface with a; // objc_subclassing_restricted attribute when it has that attribute as; // well (because of interfaces imported from Swift). Therefore we have; // to check if we can subclass in the implementation as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:147,Integrability,interface,interfaces,147,// An interface can subclass another interface with a; // objc_subclassing_restricted attribute when it has that attribute as; // well (because of interfaces imported from Swift). Therefore we have; // to check if we can subclass in the implementation as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,interface,interface,17,// Find category interface decl and then check that all methods declared; // in this interface are implemented in the category @implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:85,Integrability,interface,interface,85,// Find category interface decl and then check that all methods declared; // in this interface are implemented in the category @implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:32,Integrability,rout,routine,32,/// CvtQTToAstBitMask - utility routine to produce an AST bitmask for; /// objective-c's type qualifier from the parser version of the same info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Modifiability,inherit,inherits,28,"// If an Objective-C method inherits its related result type, then its; // declared result type must be compatible with its own class type. The; // declared result type is compatible if:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:58,Integrability,protocol,protocol,58,// Any Objective-C pointer type might be acceptable for a protocol; // method; we just don't know.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:133,Integrability,interface,interface,133,"// Prevent the search from reaching this container again. This is; // important with categories, which override methods from the; // interface and each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,protocol,protocol,17,"// A method in a protocol declaration overrides declarations from; // referenced (""parent"") protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:92,Integrability,protocol,protocols,92,"// A method in a protocol declaration overrides declarations from; // referenced (""parent"") protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:94,Integrability,protocol,protocols,94,// A method in a category declaration overrides declarations from; // the main class and from protocols the category references.; // The main class is handled in the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:20,Integrability,protocol,protocols,20,// - any referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:80,Integrability,interface,interface,80,// A method in a class implementation overrides declarations from; // the class interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:55,Availability,down,down,55,// Search for overridden methods and merge information down from them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:86,Integrability,protocol,protocols,86,"// Keep track if the method overrides any method in the class's base classes,; // its protocols, or its categories' protocols; we will keep that info; // in the ObjCMethodDecl.; // For this info, a method in an implementation is not considered as; // overriding the same method in the interface or its categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:116,Integrability,protocol,protocols,116,"// Keep track if the method overrides any method in the class's base classes,; // its protocols, or its categories' protocols; we will keep that info; // in the ObjCMethodDecl.; // For this info, a method in an implementation is not considered as; // overriding the same method in the interface or its categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:285,Integrability,interface,interface,285,"// Keep track if the method overrides any method in the class's base classes,; // its protocols, or its categories' protocols; we will keep that info; // in the ObjCMethodDecl.; // For this info, a method in an implementation is not considered as; // overriding the same method in the interface or its categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:73,Integrability,interface,interface,73,"// OverrideSearch will return as ""overridden"" the same method in the; // interface. For hasOverriddenMethodsInBaseOrProtocol, we need to; // check whether a category of a base class introduced a method with the; // same selector, after the interface method declaration.; // To avoid unnecessary lookups in the majority of cases, we use the; // extra info bits in GlobalMethodPool to check whether there were any; // category methods with this selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:240,Integrability,interface,interface,240,"// OverrideSearch will return as ""overridden"" the same method in the; // interface. For hasOverriddenMethodsInBaseOrProtocol, we need to; // check whether a category of a base class introduced a method with the; // same selector, after the interface method declaration.; // To avoid unnecessary lookups in the majority of cases, we use the; // extra info bits in GlobalMethodPool to check whether there were any; // category methods with this selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:277,Safety,avoid,avoid,277,"// OverrideSearch will return as ""overridden"" the same method in the; // interface. For hasOverriddenMethodsInBaseOrProtocol, we need to; // check whether a category of a base class introduced a method with the; // same selector, after the interface method declaration.; // To avoid unnecessary lookups in the majority of cases, we use the; // extra info bits in GlobalMethodPool to check whether there were any; // category methods with this selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:13,Availability,down,down,13,// Propagate down the 'related result type' bit from overridden methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:30,Safety,detect,detected,30,// Conflicting properties are detected elsewhere.; // Check for overriding methods,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:91,Deployability,update,updated,91,"/// Merge type nullability from for a redeclaration of the same entity,; /// producing the updated type of the redeclared entity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:64,Integrability,interface,interface,64,/// Merge information from the declaration of a method in the \@interface; /// (or a category/extension) into the corresponding method in the; /// @implementation (for a class or category).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:219,Integrability,protocol,protocols,219,"// Look for any other declaration of this method anywhere we can see in this; // compilation unit.; //; // We do not use IDecl->lookupMethod() because we have specific needs:; //; // - we absolutely do not need to walk protocols, because; // diag::err_objc_direct_on_protocol has already been emitted; // during parsing if there's a conflict,; //; // - when we do not find a match in a given @interface container,; // we need to attempt looking it up in the @implementation block if the; // translation unit sees it to find more clashes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:393,Integrability,interface,interface,393,"// Look for any other declaration of this method anywhere we can see in this; // compilation unit.; //; // We do not use IDecl->lookupMethod() because we have specific needs:; //; // - we absolutely do not need to walk protocols, because; // diag::err_objc_direct_on_protocol has already been emitted; // during parsing if there's a conflict,; //; // - when we do not find a match in a given @interface container,; // we need to attempt looking it up in the @implementation block if the; // translation unit sees it to find more clashes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Performance,Perform,Perform,3,"// Perform the default array/function conversions (C99 6.7.5.3p[7,8]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:174,Testability,stub,stub,174,"// If this method overrides a previous @synthesize declaration,; // register it with the property. Linear search through all; // properties here, because the autosynthesized stub hasn't been; // made visible yet, so it can be overridden by a later; // user-specified implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:51,Modifiability,inherit,inherits,51,"// A method is either tagged direct explicitly, or inherits it from its; // canonical declaration.; //; // We have to do the merge upfront and not in mergeInterfaceMethodToImpl(); // because IDecl->lookupMethod() returns more possible matches than just; // the canonical declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,interface,interface,31,// Merge information from the @interface declaration into the; // @implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:146,Integrability,interface,interface,146,"// The Idecl->lookupMethod() above will find declarations for ObjCMethod; // in one of these places:; //; // (1) the canonical declaration in an @interface container paired; // with the ImplDecl,; // (2) non canonical declarations in @interface not paired with the; // ImplDecl for the same Class,; // (3) any superclass container.; //; // Direct methods only allow for canonical declarations in the matching; // container (case 1).; //; // Direct methods overriding a superclass declaration (case 3) is; // handled during overrides checks in CheckObjCMethodOverrides().; //; // We deal with same-class container mismatches (Case 2) here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:235,Integrability,interface,interface,235,"// The Idecl->lookupMethod() above will find declarations for ObjCMethod; // in one of these places:; //; // (1) the canonical declaration in an @interface container paired; // with the ImplDecl,; // (2) non canonical declarations in @interface not paired with the; // ImplDecl for the same Class,; // (3) any superclass container.; //; // Direct methods only allow for canonical declarations in the matching; // container (case 1).; //; // Direct methods overriding a superclass declaration (case 3) is; // handled during overrides checks in CheckObjCMethodOverrides().; //; // We deal with same-class container mismatches (Case 2) here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:34,Integrability,protocol,protocol,34,// Warn if a method declared in a protocol to which a category or; // extension conforms is non-escaping and the implementation's method is; // escaping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:53,Integrability,interface,interface,53,"// For valid code, we should always know the primary interface; // declaration by now, however for invalid code we'll keep parsing; // but we won't find the primary interface and IDecl will be nil.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:165,Integrability,interface,interface,165,"// For valid code, we should always know the primary interface; // declaration by now, however for invalid code we'll keep parsing; // but we won't find the primary interface and IDecl will be nil.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Availability,avail,availability,29,"// + load method cannot have availability attributes. It get called on; // startup, so it has to have the availability of the deployment target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:106,Availability,avail,availability,106,"// + load method cannot have availability attributes. It get called on; // startup, so it has to have the availability of the deployment target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:126,Deployability,deploy,deployment,126,"// + load method cannot have availability attributes. It get called on; // startup, so it has to have the availability of the deployment target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:5,Performance,load,load,5,"// + load method cannot have availability attributes. It get called on; // startup, so it has to have the availability of the deployment target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Availability,error,error,24,// Following is also an error. But it is caused by a missing @end; // and diagnostic is issued elsewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:140,Availability,error,error,140,"// If we switched context to translation unit while we are still lexically in; // an objc container, it means the parser missed emitting an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:94,Modifiability,variab,variables,94,/// Called whenever \@defs(ClassName) is encountered in the source. Inserts the; /// instance variables of ClassName into Decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Modifiability,variab,variables,24,// Collect the instance variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:51,Modifiability,variab,variable,51,/// Build a type-check a new Objective-C exception variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:78,Availability,Recover,Recover,78,"// An @catch parameter must be an unqualified object pointer type;; // FIXME: Recover from ""NSObject foo"" by inserting the * in ""NSObject *foo""?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:78,Safety,Recover,Recover,78,"// An @catch parameter must be an unqualified object pointer type;; // FIXME: Recover from ""NSObject foo"" by inserting the * in ""NSObject *foo""?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Modifiability,variab,variables,33,"// In ARC, infer 'retaining' for variables of retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:142,Availability,error,error,142,"// We allow the ""register"" storage class on exception variables because; // GCC did, but we drop it completely. Any other storage class is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:54,Modifiability,variab,variables,54,"// We allow the ""register"" storage class on exception variables because; // GCC did, but we drop it completely. Any other storage class is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Performance,Load,Load,3,// Load referenced selectors from the external source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:82,Security,access,accessor,82,/// Used by Sema::DiagnoseUnusedBackingIvarInAccessor to check if a property; /// accessor references the backing ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:67,Security,access,accessor,67,// Do not issue this warning if backing ivar is used somewhere and accessor; // implementation makes a self call. This is to prevent false positive in; // cases where the ivar is accessed by another method that the accessor; // delegates to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:179,Security,access,accessed,179,// Do not issue this warning if backing ivar is used somewhere and accessor; // implementation makes a self call. This is to prevent false positive in; // cases where the ivar is accessed by another method that the accessor; // delegates to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:215,Security,access,accessor,215,// Do not issue this warning if backing ivar is used somewhere and accessor; // implementation makes a self call. This is to prevent false positive in; // cases where the ivar is accessed by another method that the accessor; // delegates to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:407,Integrability,rout,routines,407,"//===--- SemaExceptionSpec.cpp - C++ Exception Specifications ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ exception specification testing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:448,Testability,test,testing,448,"//===--- SemaExceptionSpec.cpp - C++ Exception Specifications ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ exception specification testing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:331,Deployability,release,released,331,/// HACK: 2014-11-14 libstdc++ had a bug where it shadows std::swap with a; /// member swap function then tries to call std::swap unqualified from the; /// exception specification of that function. This function detects whether; /// we're in such a case and turns off delay-parsing of exception; /// specifications. Libstdc++ 6.1 (released 2016-04-27) appears to have; /// resolved it as side-effect of commit ddb63209a8d (2015-06-05).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:212,Safety,detect,detects,212,/// HACK: 2014-11-14 libstdc++ had a bug where it shadows std::swap with a; /// member swap function then tries to call std::swap unqualified from the; /// exception specification of that function. This function detects whether; /// we're in such a case and turns off delay-parsing of exception; /// specifications. Libstdc++ 6.1 (released 2016-04-27) appears to have; /// resolved it as side-effect of commit ddb63209a8d (2015-06-05).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:392,Availability,down,downgrade,392,"// C++11 [except.spec]p2:; // A type denoted in an exception-specification shall not denote an; // incomplete type other than a class currently being defined [...].; // A type denoted in an exception-specification shall not denote a; // pointer or reference to an incomplete type, other than (cv) void* or a; // pointer or reference to a class currently being defined.; // In Microsoft mode, downgrade this to a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,extend,extend,39,"// The MSVC compatibility mode doesn't extend to sizeless types,; // so diagnose them separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:7,Availability,failure,failure,7,"// The failure was something other than an missing exception; // specification; return an error, except in MS mode where this is a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:90,Availability,error,error,90,"// The failure was something other than an missing exception; // specification; return an error, except in MS mode where this is a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:7,Integrability,depend,dependent,7,"// For dependent noexcept, we can't just take the expression from the old; // prototype. It likely contains references to the old prototype's parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:3,Deployability,Update,Update,3,// Update the type of the function with the appropriate exception; // specification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:53,Availability,error,error,53,"// FIXME: As usual, we could be more specific in our error messages, but; // that better waits until we've got types with source locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:59,Integrability,message,messages,59,"// FIXME: As usual, we could be more specific in our error messages, but; // that better waits until we've got types with source locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:16,Integrability,depend,dependent,16,"// If there are dependent noexcept specs, assume everything is fine. Unlike; // with the equivalency check, this is safe in this case, because we don't; // want to merge declarations. Checks after instantiation will catch any; // omissions we make here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:116,Safety,safe,safe,116,"// If there are dependent noexcept specs, assume everything is fine. Unlike; // with the equivalency check, this is safe in this case, because we don't; // want to merge declarations. Checks after instantiation will catch any; // omissions we make here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:24,Testability,test,testing,24,// We shouldn't even be testing this unless the arguments are otherwise; // compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:18,Availability,error,error,18,"// This is not an error in C++17 onwards, unless the noexceptness doesn't; // match, but in that case we have a full-on type mismatch, not just a; // type sugar mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:300,Integrability,depend,dependent,300,"// Now we've got the correct types on both sides, check their compatibility.; // This means that the source of the conversion can only throw a subset of; // the exceptions of the target, and any exception specs on arguments or; // return types must be equivalent.; //; // FIXME: If there is a nested dependent exception specification, we should; // not be checking it here. This is fine:; // template<typename T> void f() {; // void (*p)(void (*) throw(T));; // void (*q)(void (*) throw(int)) = p;; // }; // ... because it might be instantiated with T=int.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:153,Performance,perform,perform,153,"// If the old exception specification hasn't been parsed yet, or the new; // exception specification can't be computed yet, remember that we need to; // perform this check when we get to the end of the outermost; // lexically-surrounding class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:60,Security,access,access,60,// Could be a call to a pointer-to-member or a plain member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:99,Modifiability,polymorphi,polymorphic,99,// - a potentially evaluated typeid expression applied to a glvalue; // expression whose type is a polymorphic class type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:8,Integrability,message,message,8,"// ObjC message sends are like function calls, but never have exception; // specs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:56,Testability,test,test,56,"// Many other things have subexpressions, so we have to test those.; // Some are simple:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:81,Usability,simpl,simple,81,"// Many other things have subexpressions, so we have to test those.; // Some are simple:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:17,Integrability,depend,dependent,17,// Some might be dependent for other reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:31,Integrability,depend,dependent,31,// Some expressions are always dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:9,Integrability,depend,dependent,9,"// For a dependent 'if constexpr', the result is dependent if it depends on; // the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:49,Integrability,depend,dependent,49,"// For a dependent 'if constexpr', the result is dependent if it depends on; // the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:65,Integrability,depend,depends,65,"// For a dependent 'if constexpr', the result is dependent if it depends on; // the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,// See if this is an auto-typed variable whose initializer we are parsing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:483,Availability,error,errors,483,"/// Check whether we're in an extern inline function and referring to a; /// variable or function with internal linkage (C11 6.7.4p3).; ///; /// This is only a warning because we used to silently accept this code, but; /// in many cases it will not behave correctly. This is not enabled in C++ mode; /// because the restriction language is a bit weaker (C++11 [basic.def.odr]p6); /// and so while there may still be user mistakes, most of the time we can't; /// prove that there are errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:77,Modifiability,variab,variable,77,"/// Check whether we're in an extern inline function and referring to a; /// variable or function with internal linkage (C11 6.7.4p3).; ///; /// This is only a warning because we used to silently accept this code, but; /// in many cases it will not behave correctly. This is not enabled in C++ mode; /// because the restriction language is a bit weaker (C++11 [basic.def.odr]p6); /// and so while there may still be user mistakes, most of the time we can't; /// prove that there are errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Down,Downgrade,3,"// Downgrade from ExtWarn to Extension if; // (1) the supposedly external inline function is in the main file,; // and probably won't be included anywhere else.; // (2) the thing we're referencing is a pure function.; // (3) the thing we're referencing is another inline function.; // This last can give us false negatives, but it's better than warning on; // wrappers for simple C library functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:360,Integrability,wrap,wrappers,360,"// Downgrade from ExtWarn to Extension if; // (1) the supposedly external inline function is in the main file,; // and probably won't be included anywhere else.; // (2) the thing we're referencing is a pure function.; // (3) the thing we're referencing is another inline function.; // This last can give us false negatives, but it's better than warning on; // wrappers for simple C library functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:373,Usability,simpl,simple,373,"// Downgrade from ExtWarn to Extension if; // (1) the supposedly external inline function is in the main file,; // and probably won't be included anywhere else.; // (2) the thing we're referencing is a pure function.; // (3) the thing we're referencing is another inline function.; // This last can give us false negatives, but it's better than warning on; // wrappers for simple C library functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:340,Availability,error,error,340,"/// Determine whether the use of this declaration is valid, and; /// emit any corresponding diagnostics.; ///; /// This routine diagnoses various problems with referencing; /// declarations that can occur when using a declaration. For example,; /// it might warn if a deprecated or unavailable declaration is being; /// used, or produce an error (and return true) if a C++0x deleted; /// function is being used.; ///; /// \returns true if there was an error (this declaration cannot be; /// referenced), false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:452,Availability,error,error,452,"/// Determine whether the use of this declaration is valid, and; /// emit any corresponding diagnostics.; ///; /// This routine diagnoses various problems with referencing; /// declarations that can occur when using a declaration. For example,; /// it might warn if a deprecated or unavailable declaration is being; /// used, or produce an error (and return true) if a C++0x deleted; /// function is being used.; ///; /// \returns true if there was an error (this declaration cannot be; /// referenced), false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:120,Integrability,rout,routine,120,"/// Determine whether the use of this declaration is valid, and; /// emit any corresponding diagnostics.; ///; /// This routine diagnoses various problems with referencing; /// declarations that can occur when using a declaration. For example,; /// it might warn if a deprecated or unavailable declaration is being; /// used, or produce an error (and return true) if a C++0x deleted; /// function is being used.; ///; /// \returns true if there was an error (this declaration cannot be; /// referenced), false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:188,Safety,avoid,avoid,188,"// Clear out the list of suppressed diagnostics, so that we don't emit; // them again for this specialization. However, we don't obsolete this; // entry from the table, because we want to avoid ever emitting these; // diagnostics again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Usability,Clear,Clear,3,"// Clear out the list of suppressed diagnostics, so that we don't emit; // them again for this specialization. However, we don't obsolete this; // entry from the table, because we want to avoid ever emitting these; // diagnostics again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,// See if this is an auto-typed variable whose initializer we are parsing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:77,Modifiability,variab,variables,77,"// [OpenMP 4.0], 2.15 declare reduction Directive, Restrictions; // Only the variables omp_in and omp_out are allowed in the combiner.; // Only the variables omp_priv and omp_orig are allowed in the; // initializer-clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:148,Modifiability,variab,variables,148,"// [OpenMP 4.0], 2.15 declare reduction Directive, Restrictions; // Only the variables omp_in and omp_out are allowed in the combiner.; // Only the variables omp_priv and omp_orig are allowed in the; // initializer-clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Modifiability,variab,variable,149,"// [OpenMP 5.0], 2.19.7.3. declare mapper Directive, Restrictions; // List-items in map clauses on this construct may only refer to the declared; // variable var and entities that could be referenced by a procedure defined; // at the same location.; // [OpenMP 5.2] Also allow iterator declared variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:295,Modifiability,variab,variables,295,"// [OpenMP 5.0], 2.19.7.3. declare mapper Directive, Restrictions; // List-items in map clauses on this construct may only refer to the declared; // variable var and entities that could be referenced by a procedure defined; // at the same location.; // [OpenMP 5.2] Also allow iterator declared variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Integrability,rout,routine,33,"/// DiagnoseSentinelCalls - This routine checks whether a call or; /// message-send is to a declaration with the sentinel attribute, and; /// if so, it checks that the requirements of the sentinel are; /// satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:71,Integrability,message,message-send,71,"/// DiagnoseSentinelCalls - This routine checks whether a call or; /// message-send is to a declaration with the sentinel attribute, and; /// if so, it checks that the requirements of the sentinel are; /// satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:138,Performance,optimiz,optimizer,138,"// Check to see if we are dereferencing a null pointer. If so,; // and if not volatile-qualified, this is undefined behavior that the; // optimizer will delete, so warn about it. People sometimes try to use this; // to get a deterministic trap and are surprised by clang's behavior. This; // only handles the pattern ""*null"", which is a very syntactic check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Security,access,accesses,33,// OpenCL usually rejects direct accesses to values of 'half' type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Availability,down,down,26,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Modifiability,inherit,inheritance,35,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Load,Loading,3,"// Loading a __weak object implicitly retains the value, so we need a cleanup to; // balance that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:74,Performance,perform,performed,74,/// CallExprUnaryConversions - a special case of an unary conversion; /// performed on a function designator of a call expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:342,Integrability,rout,routine,342,"/// UsualUnaryConversions - Performs various conversions that are common to most; /// operators (C99 6.3). The conversions of array and function types are; /// sometimes suppressed. For example, the array->pointer conversion doesn't; /// apply if the array is an argument to the sizeof or address (&) operators.; /// In these instances, this routine should *not* be called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:28,Performance,Perform,Performs,28,"/// UsualUnaryConversions - Performs various conversions that are common to most; /// operators (C99 6.3). The conversions of array and function types are; /// sometimes suppressed. For example, the array->pointer conversion doesn't; /// apply if the array is an argument to the sizeof or address (&) operators.; /// In these instances, this routine should *not* be called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Performance,perform,perform,10,// Try to perform integral promotions if the object has a theoretically; // promotable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:7,Performance,perform,performs,7,"// C++ performs lvalue-to-rvalue conversion as a default argument; // promotion, even on class types, but note:; // C++11 [conv.lval]p2:; // When an lvalue-to-rvalue conversion occurs in an unevaluated; // operand or a subexpression thereof the value contained in the; // referenced object is not accessed. Otherwise, if the glvalue; // has a class type, the conversion copy-initializes a temporary; // of type T from the glvalue and the result of the conversion; // is a prvalue for the temporary.; // FIXME: add some way to gate this entire thing for correctness in; // potentially potentially evaluated contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:297,Security,access,accessed,297,"// C++ performs lvalue-to-rvalue conversion as a default argument; // promotion, even on class types, but note:; // C++11 [conv.lval]p2:; // When an lvalue-to-rvalue conversion occurs in an unevaluated; // operand or a subexpression thereof the value contained in the; // referenced object is not accessed. Otherwise, if the glvalue; // has a class type, the conversion copy-initializes a temporary; // of type T from the glvalue and the result of the conversion; // is a prvalue for the temporary.; // FIXME: add some way to gate this entire thing for correctness in; // potentially potentially evaluated contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:122,Performance,perform,performed,122,"/// Determine the degree of POD-ness for an expression.; /// Incomplete types are considered POD, since this check can be performed; /// when we're in an unevaluated context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:214,Performance,perform,performed,214,"// C++11 [expr.call]p7:; // After these conversions, if the argument does not have arithmetic,; // enumeration, pointer, pointer to member, or class type, the program; // is ill-formed.; //; // Since we've already performed array-to-pointer and function-to-pointer; // decay, the only such type in C++ is cv void. This also handles; // initializer lists as variadic arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:42,Integrability,interface,interface,42,// Don't allow one to pass an Objective-C interface to a vararg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Performance,perform,performed,55,/// Check that the usual arithmetic conversions can be performed on this pair of; /// expressions that might be of enumeration type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:273,Availability,error,error,273,"/// UsualArithmeticConversions - Performs various conversions that are common to; /// binary operators (C99 6.3.1.8). If both operands aren't arithmetic, this; /// routine returns the first non-arithmetic type found. The client is; /// responsible for emitting appropriate error diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Integrability,rout,routine,164,"/// UsualArithmeticConversions - Performs various conversions that are common to; /// binary operators (C99 6.3.1.8). If both operands aren't arithmetic, this; /// routine returns the first non-arithmetic type found. The client is; /// responsible for emitting appropriate error diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Performance,Perform,Performs,33,"/// UsualArithmeticConversions - Performs various conversions that are common to; /// binary operators (C99 6.3.1.8). If both operands aren't arithmetic, this; /// routine returns the first non-arithmetic type found. The client is; /// responsible for emitting appropriate error diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:588,Modifiability,variab,variably,588,"// We relax the restriction on use of incomplete types and non-object; // types with the type-based extension of _Generic. Allowing incomplete; // objects means those can be used as ""tags"" for a type-safe way to map; // to a value. Similarly, matching on function types rather than; // function pointer types can be useful. However, the restriction on VM; // types makes sense to retain as there are open questions about how; // the selection can be made at compile time.; //; // C11 6.5.1.1p2 ""The type name in a generic association shall specify a; // complete object type other than a variably modified type.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:200,Safety,safe,safe,200,"// We relax the restriction on use of incomplete types and non-object; // types with the type-based extension of _Generic. Allowing incomplete; // objects means those can be used as ""tags"" for a type-safe way to map; // to a value. Similarly, matching on function types rather than; // function pointer types can be useful. However, the restriction on VM; // types makes sense to retain as there are open questions about how; // the selection can be made at compile time.; //; // C11 6.5.1.1p2 ""The type name in a generic association shall specify a; // complete object type other than a variably modified type.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:417,Testability,log,logic,417,"// Because the controlling expression undergoes lvalue conversion,; // array conversion, and function conversion, an association which is; // of array type, function type, or is qualified can never be; // reached. We will warn about this so users are less surprised by; // the unreachable association. However, we don't have to handle; // function types; that's not an object type, so it's handled above.; //; // The logic is somewhat different for C++ because C++ has different; // lvalue to rvalue conversion rules than C. [conv.lvalue]p1 says,; // If T is a non-class type, the type of the prvalue is the cv-; // unqualified version of T. Otherwise, the type of the prvalue is T.; // The result of these rules is that all qualified types in an; // association in C are unreachable, and in C++, only qualified non-; // class types are unreachable.; //; // NB: this does not apply when the first operand is a type rather; // than an expression, because the type form does not undergo; // conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:57,Integrability,depend,dependent,57,"// If we determined that the generic selection is result-dependent, don't; // try to compute the result expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Modifiability,variab,variable,48,// CUDA/HIP: Check whether a captured reference variable is referencing a; // host variable in a device or host device lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:83,Modifiability,variab,variable,83,// CUDA/HIP: Check whether a captured reference variable is referencing a; // host variable in a device or host device lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:31,Modifiability,variab,variable,31,// Check whether the reference variable is referencing a host variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:62,Modifiability,variab,variable,62,// Check whether the reference variable is referencing a host variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:105,Modifiability,variab,variable,105,// Check whether the current function is a device or host device lambda.; // Check whether the reference variable is a capture by getDeclContext(); // since refersToEnclosingVariableOrCapture() is not ready at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variable,34,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:232,Modifiability,variab,variable,232,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:260,Modifiability,variab,variable,260,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:397,Modifiability,variab,variable,397,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:513,Performance,load,loaded,513,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:163,Usability,usab,usable,163,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Modifiability,variab,variable,21,"// All remaining non-variable cases constitute an odr-use. For variables, we; // need to wait and see how the expression is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:63,Modifiability,variab,variables,63,"// All remaining non-variable cases constitute an odr-use. For variables, we; // need to wait and see how the expression is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:369,Availability,error,errors,369,"// C++ [except.spec]p17:; // An exception-specification is considered to be needed when:; // - in an expression, the function is the unique lookup result or; // the selected member of a set of overloaded functions.; //; // We delay doing this until after we've built the function reference and; // marked it as used so that:; // a) if the function is defaulted, we get errors from defining it before /; // instead of errors from computing its exception specification, and; // b) if the function is a defaulted comparison, we can use the body we; // build when defining it as input to the exception specification; // computation rather than computing a new body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:417,Availability,error,errors,417,"// C++ [except.spec]p17:; // An exception-specification is considered to be needed when:; // - in an expression, the function is the unique lookup result or; // the selected member of a set of overloaded functions.; //; // We delay doing this until after we've built the function reference and; // marked it as used so that:; // a) if the function is defaulted, we get errors from defining it before /; // instead of errors from computing its exception specification, and; // b) if the function is a defaulted comparison, we can use the body we; // build when defining it as input to the exception specification; // computation rather than computing a new body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:70,Availability,error,error,70,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Availability,recover,recovery,81,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:365,Availability,error,error,365,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:438,Availability,recover,recover,438,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:147,Integrability,depend,dependent,147,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Safety,recover,recovery,81,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:438,Safety,recover,recover,438,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,Integrability,depend,dependent,170,"// There are two ways we can find a class-scope declaration during template; // instantiation that we did not find in the template definition: if it is a; // member of a dependent base class, or if it is declared after the point of; // use in the same class. Distinguish these by comparing the class in which; // the member was found to the naming class of the lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Availability,recover,recover,29,// Tell the callee to try to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Safety,recover,recover,29,// Tell the callee to try to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:195,Integrability,depend,dependent,195,"// If the original lookup was an unqualified lookup, fake an; // unqualified lookup. This is useful when (for example) the; // original lookup would not have found something because it was a; // dependent name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:14,Availability,error,errors,14,// Don't give errors about ambiguities in this lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Availability,recover,recover,149,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:247,Availability,recover,recover,247,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Safety,recover,recover,149,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:247,Safety,recover,recover,247,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,Availability,recover,recover,99,"// FIXME: We found a keyword. Suggest it, but don't provide a fix-it; // because we aren't able to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,Safety,recover,recover,99,"// FIXME: We found a keyword. Suggest it, but don't provide a fix-it; // because we aren't able to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Availability,recover,recover,37,// Tell the callee whether to try to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Safety,recover,recover,37,// Tell the callee whether to try to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Availability,recover,recover,21,"// Give up, we can't recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Safety,recover,recover,21,"// Give up, we can't recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:245,Availability,recover,recover,245,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:343,Availability,avail,available,343,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:85,Integrability,depend,dependent,85,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:206,Integrability,depend,dependent,206,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:245,Safety,recover,recover,245,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,Availability,recover,recover,15,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Availability,avail,available,106,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:40,Integrability,depend,dependent,40,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,Safety,recover,recover,15,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:85,Availability,avail,available,85,"// Diagnose this as unqualified lookup into a dependent base class. If 'this'; // is available, suggest inserting 'this->' as a fixit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:46,Integrability,depend,dependent,46,"// Diagnose this as unqualified lookup into a dependent base class. If 'this'; // is available, suggest inserting 'this->' as a fixit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:73,Performance,perform,perform,73,// Synthesize a fake NNS that points to the derived class. This will; // perform name lookup during template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Integrability,depend,dependent,55,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:127,Integrability,depend,dependent,127,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:205,Integrability,depend,dependent,205,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:308,Integrability,depend,dependent,308,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:399,Integrability,depend,dependent,399,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform the required lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:239,Performance,perform,performance,239,"// Lookup the template name again to correctly establish the context in; // which it was found. This is really unfortunate as we already did the; // lookup to determine that it was a template name in the first place. If; // this becomes a performance hit, we can work harder to preserve those; // results until we get here but it's likely not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:31,Integrability,depend,dependent,31,"// If the result might be in a dependent base class, this is a dependent; // id-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:63,Integrability,depend,dependent,63,"// If the result might be in a dependent base class, this is a dependent; // id-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:69,Integrability,depend,dependent,69,// Determine whether this name might be a candidate for; // argument-dependent lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Performance,perform,performed,45,// Signal that a correction to a keyword was performed by returning a; // valid-but-null ExprResult.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Modifiability,variab,variable,39,"// If we found an Objective-C instance variable, let; // LookupInObjCMethod build the appropriate expression to; // reference the ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Modifiability,variab,variable,52,"// In a hopelessly buggy code, Objective-C instance variable; // lookup fails and no expression will be built to reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:1119,Integrability,depend,dependent,1119,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:1158,Integrability,depend,dependent,1158,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:995,Safety,safe,safeguards,995,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:62,Security,access,access,62,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:166,Security,access,access,166,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:461,Security,access,access,461,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Modifiability,variab,variable,26,"// In C++1y, if this is a variable template id, then check it; // in BuildTemplateIdExpr().; // The single lookup result must be a variable template declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:131,Modifiability,variab,variable,131,"// In C++1y, if this is a variable template id, then check it; // in BuildTemplateIdExpr().; // The single lookup result must be a variable template declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:271,Modifiability,inherit,inherited,271,"// Don't diagnose problems with invalid record decl, the secondary no_member; // diagnostic during template instantiation is likely bogus, e.g. if a class; // is invalid because it's derived from an invalid base class, then missing; // members were likely supposed to be inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,Availability,recover,recover,110,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:131,Availability,down,downgrade,131,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Integrability,depend,dependent,81,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,Safety,recover,recover,110,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Availability,recover,recover,9,// Don't recover if the caller isn't expecting us to or if we're in a SFINAE; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Safety,recover,recover,9,// Don't recover if the caller isn't expecting us to or if we're in a SFINAE; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Availability,recover,recover,45,// Only issue the fixit if we're prepared to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Safety,recover,recover,45,// Only issue the fixit if we're prepared to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Recover,Recover,3,// Recover by pretending this was an elaborated type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Recover,Recover,3,// Recover by pretending this was an elaborated type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Security,access,access,55,"// Defend against this resolving to an implicit member access. We usually; // won't get here if this might be a legitimate a class member (we end up in; // BuildMemberReferenceExpr instead), but this can be valid if we're forming; // a pointer-to-member or in an unevaluated context in C++11.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Performance,Perform,Perform,106,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar.; ///; /// Ideally, most of this would be done by lookup, but there's; /// actually quite a lot of extra work involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Safety,detect,detected,48,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar.; ///; /// Ideally, most of this would be done by lookup, but there's; /// actually quite a lot of extra work involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,Availability,error,error,13,// Check for error condition which is already reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:521,Availability,error,error,521,"// There are two cases to handle here. 1) scoped lookup could have failed,; // in which case we should look for an ivar. 2) scoped lookup could have; // found a decl, but that decl is outside the current instance method (i.e.; // a global variable). In these two cases, we do a lookup for an ivar with; // this name, if the lookup sucedes, we replace it our current decl.; // If we're in a class method, we don't normally want to look for; // ivars. But if we don't find anything else, and there's an; // ivar, that's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:239,Modifiability,variab,variable,239,"// There are two cases to handle here. 1) scoped lookup could have failed,; // in which case we should look for an ivar. 2) scoped lookup could have; // found a decl, but that decl is outside the current instance method (i.e.; // a global variable). In these two cases, we do a lookup for an ivar with; // this name, if the lookup sucedes, we replace it our current decl.; // If we're in a class method, we don't normally want to look for; // ivars. But if we don't find anything else, and there's an; // ivar, that's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Modifiability,variab,variable,29,// We should warn if a local variable hides an ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:65,Availability,error,error,65,"// If accessing a stand-alone ivar in a class method, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:6,Security,access,accessing,6,"// If accessing a stand-alone ivar in a class method, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:23,Availability,error,error,23,"// Didn't encounter an error, didn't find an ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:74,Availability,error,error,74,"// If we're referencing an invalid decl, just return this as a silent; // error node. The error diagnostic was already emitted on the decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:90,Availability,error,error,90,"// If we're referencing an invalid decl, just return this as a silent; // error node. The error diagnostic was already emitted on the decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Performance,Perform,Perform,106,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar. If so, build an expression referencing; /// that ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Safety,detect,detected,48,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar. If so, build an expression referencing; /// that ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Deployability,Integrat,Integrate,10,// FIXME: Integrate this lookup step into LookupParsedName.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Integrability,Integrat,Integrate,10,// FIXME: Integrate this lookup step into LookupParsedName.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:112,Security,access,access,112,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:156,Security,access,access,156,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:189,Security,access,access,189,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:713,Security,access,access,713,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:725,Security,access,access,725,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:806,Security,access,access,806,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:657,Availability,error,error,657,"// C++ [class.member.lookup]p8:; // [...] Ambiguities can often be resolved by qualifying a name with its; // class name.; //; // If the member was a qualified name and the qualified referred to a; // specific base subobject type, we'll cast to that intermediate type; // first and then to the object in which the member is declared. That allows; // one to resolve ambiguities in, e.g., a diamond-shaped hierarchy such as:; //; // class Base { public: int x; };; // class Derived1 : public Base { };; // class Derived2 : public Base { };; // class VeryDerived : public Derived1, public Derived2 { void f(); };; //; // void VeryDerived::f() {; // x = 17; // error: ambiguous base subobjects; // Derived1::x = 17; // okay, pick the Base subobject of Derived1; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:109,Security,hash,hash,109,"// Otherwise, just build an unresolved lookup expression. Suppress; // any lookup-related diagnostics; we'll hash these out later, when; // we've picked a target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Recover,Recovery,3,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:98,Availability,Recover,RecoveryExpr,98,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Integrability,depend,dependent,75,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Recover,Recovery,3,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:98,Safety,Recover,RecoveryExpr,98,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:121,Integrability,depend,dependent,121,"// Check whether this declaration can be used. Note that we suppress; // this check when we're going to perform argument-dependent lookup; // on this function name, because this might not be the function; // that overload resolution actually selects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:104,Performance,perform,perform,104,"// Check whether this declaration can be used. Note that we suppress; // this check when we're going to perform argument-dependent lookup; // on this function name, because this might not be the function; // that overload resolution actually selects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Usability,simpl,simply,102,"// In 'T ...V;', the type of the declaration 'V' is 'T...', but the type of; // a reference to 'V' is simply (unexpanded) 'T'. The type, like the value,; // is expanded by some outer '...' in the context of the use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:98,Integrability,depend,dependent,98,// Enum constants are always r-values and never references.; // Unresolved using declarations are dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,Integrability,depend,depending,68,// Non-type template parameters are either l-values or r-values; // depending on the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:104,Modifiability,variab,variable,104,"// FIXME: Does the addition of const really only apply in; // potentially-evaluated contexts? Since the variable isn't actually; // captured in an unevaluated context, it seems that the answer is no.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Availability,Recover,RecoveryExpr,149,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Integrability,wrap,wrap,75,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:130,Integrability,depend,dependent-type,130,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Safety,Recover,RecoveryExpr,149,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:165,Safety,avoid,avoid,165,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Availability,error,error,25,"// Overflow is always an error, but underflow is only an error if; // we underflowed to zero (APFloat reports denormals as underflow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:57,Availability,error,error,57,"// Overflow is always an error, but underflow is only an error if; // we underflowed to zero (APFloat reports denormals as underflow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:253,Safety,safe,safe,253,"// NumericLiteralParser wants to overread by one character. Add padding to; // the buffer in case the token is copied to the buffer. If getSpelling(); // returns a StringRef to the memory buffer, it should have a null char at; // the EOF, so it is also safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform literal operator lookup to determine if we're building a raw; // literal or a cooked one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Availability,failure,failure,10,"// Lookup failure for imaginary constants isn't fatal, there's still the; // GNU extension producing _Complex types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:166,Usability,clear,clear,166,"// 'wb/uwb' literals are a C23 feature. We support _BitInt as a type in C++,; // but we do not currently support the suffix in C++ mode because it's not; // entirely clear whether WG21 will prefer this suffix to return a library; // type such as std::bit_int instead of returning a _BitInt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:64,Integrability,depend,depends,64,"// Get the value in the widest-possible width. What is ""widest"" depends on; // whether the literal is a bit-precise integer or not. For a bit-precise; // integer type, try to scan the source to determine how many bits are; // needed to represent the value. This may seem a bit expensive, but trying; // to get the integer value from an overly-wide APInt is *extremely*; // expensive, so the naive approach of assuming; // llvm::IntegerType::MAX_INT_BITS is a big performance hit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:463,Performance,perform,performance,463,"// Get the value in the widest-possible width. What is ""widest"" depends on; // whether the literal is a bit-precise integer or not. For a bit-precise; // integer type, try to scan the source to determine how many bits are; // needed to represent the value. This may seem a bit expensive, but trying; // to get the integer value from an overly-wide APInt is *extremely*; // expensive, so the naive approach of assuming; // llvm::IntegerType::MAX_INT_BITS is a big performance hit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:44,Availability,error,error,44,"// If this value didn't fit into uintmax_t, error and force to ull.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:64,Integrability,wrap,wrapper,64,"// If this is an imaginary literal, create the ImaginaryLiteral wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:56,Performance,scalab,scalable,56,// builtin_vectorelements supports both fixed-sized and scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:30,Availability,error,errors,30,// Invalid types must be hard errors for SFINAE in C++.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Availability,error,error,91,"// Allow sizeof(void)/alignof(void) as an extension, unless in OpenCL where; // this is an error (OpenCL v1.1 s6.3.k)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Integrability,interface,interface,17,// Reject sizeof(interface) and sizeof(interface<proto>) if the; // runtime doesn't allow it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Integrability,interface,interface,39,// Reject sizeof(interface) and sizeof(interface<proto>) if the; // runtime doesn't allow it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:140,Security,validat,validates,140,"/// Check the constraints on expression operands to unary type expression; /// and type traits.; ///; /// Completes any types necessary and validates the constraints on the operand; /// expression. The logic mostly mirrors the type-based overload, but may modify; /// the expression as it completes the type for that expression through template; /// instantiation, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:202,Testability,log,logic,202,"/// Check the constraints on expression operands to unary type expression; /// and type traits.; ///; /// Completes any types necessary and validates the constraints on the operand; /// expression. The logic mostly mirrors the type-based overload, but may modify; /// the expression as it completes the type for that expression through template; /// instantiation, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:166,Integrability,depend,dependent,166,"// The operand for sizeof and alignof is in an unevaluated expression context,; // so side effects could result in unintended consequences.; // Exclude instantiation-dependent expressions, because 'sizeof' is sometimes; // used to build SFINAE gadgets.; // FIXME: Should we consider instantiation-dependent operands to 'alignof'?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:297,Integrability,depend,dependent,297,"// The operand for sizeof and alignof is in an unevaluated expression context,; // so side effects could result in unintended consequences.; // Exclude instantiation-dependent expressions, because 'sizeof' is sometimes; // used to build SFINAE gadgets.; // FIXME: Should we consider instantiation-dependent operands to 'alignof'?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Integrability,depend,dependent,50,// Cannot know anything else if the expression is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:240,Security,access,access,240,"// If it's a field, require the containing struct to have a; // complete definition so that we can compute the layout.; //; // This can happen in C++11 onwards, either by naming the member; // in a way that is not transformed into a member access expression; // (in an unevaluated operand, for instance), or by naming the member; // in a trailing-return-type.; //; // For the record, since __alignof__ on expressions is a GCC; // extension, GCC seems to permit this but always gives the; // nonsensical answer 0.; //; // We don't really need the layout here --- we could instead just; // directly check for all the appropriate alignment-lowing; // attributes --- but that would require duplicating a lot of; // logic that just isn't worth duplicating for such a marginal; // use-case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:711,Testability,log,logic,711,"// If it's a field, require the containing struct to have a; // complete definition so that we can compute the layout.; //; // This can happen in C++11 onwards, either by naming the member; // in a way that is not transformed into a member access expression; // (in an unevaluated operand, for instance), or by naming the member; // in a trailing-return-type.; //; // For the record, since __alignof__ on expressions is a GCC; // extension, GCC seems to permit this but always gives the; // nonsensical answer 0.; //; // We don't really need the layout here --- we could instead just; // directly check for all the appropriate alignment-lowing; // attributes --- but that would require duplicating a lot of; // logic that just isn't worth duplicating for such a marginal; // use-case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:125,Modifiability,flexible,flexible,125,"// Otherwise, if it's a field, and the field doesn't have; // reference type, then it must have a complete type (or be a; // flexible array member, which we explicitly want to; // white-list anyway), which makes the following checks trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Integrability,depend,dependent,50,// Cannot know anything else if the expression is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:23,Availability,down,down,23,// We're going to walk down into the type and look for VLA expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Modifiability,variab,variably-modified,25,// These types are never variably-modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:262,Integrability,rout,routine,262,"/// Check the constraints on operands to unary expression and type; /// traits.; ///; /// This will complete any types necessary, and validate the various constraints; /// on those operands.; ///; /// The UsualUnaryConversions() function is *not* called by this routine.; /// C99 6.3.2.1p[2-4] all state:; /// Except when it is the operand of the sizeof operator ...; ///; /// C++ [expr.sizeof]p4; /// The lvalue-to-rvalue, array-to-pointer, and function-to-pointer; /// standard conversions are not applied to the operand of sizeof.; ///; /// This policy is followed for all of the unary trait expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:134,Security,validat,validate,134,"/// Check the constraints on operands to unary expression and type; /// traits.; ///; /// This will complete any types necessary, and validate the various constraints; /// on those operands.; ///; /// The UsualUnaryConversions() function is *not* called by this routine.; /// C99 6.3.2.1p[2-4] all state:; /// Except when it is the operand of the sizeof operator ...; ///; /// C++ [expr.sizeof]p4; /// The lvalue-to-rvalue, array-to-pointer, and function-to-pointer; /// standard conversions are not applied to the operand of sizeof.; ///; /// This policy is followed for all of the unary trait expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Integrability,depend,dependent,32,// Delay type-checking for type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:6,Availability,error,error,6,"// If error parsing type, ignore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Testability,Test,Test,3,// Test for placeholders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Availability,error,error,91,/// Diagnose if arithmetic on the given ObjC pointer is illegal.; ///; /// \return true on error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:69,Integrability,depend,dependent,69,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Integrability,Depend,DependentTy,102,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:204,Integrability,depend,dependent,204,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:251,Integrability,depend,dependent,251,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:286,Integrability,depend,dependent,286,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:386,Integrability,depend,dependent-sized,386,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:451,Integrability,depend,dependent-typed,451,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:540,Integrability,depend,dependent,540,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:576,Integrability,Depend,DependentTy,576,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:619,Integrability,depend,dependent,619,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:650,Integrability,depend,dependent,650,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:598,Safety,avoid,avoids,598,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:699,Safety,avoid,avoid,699,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:22,Integrability,depend,dependent,22,// Ensure we return a dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:60,Integrability,depend,dependent,60,// Build an unanalyzed expression if either operand is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:375,Testability,log,logic,375,"// Use C++ overloaded-operator rules if either operand has record; // type. The spec says to do this if either type is *overloadable*,; // but enum types can't declare subscript operators or conversion; // operators, so there's nothing interesting for overload resolution; // to do if there aren't any record types involved.; //; // ObjC pointers have their own subscripting logic that is not tied; // to overload resolution and so should not take this path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:65,Integrability,depend,dependent,65,// Build an unanalyzed expression if any of the operands is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,Security,access,access,58,// Bail if the element is an array since it is not memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Security,access,access,51,// Check if the base type is a pointer to a member access of a struct; // marked with noderef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Security,access,access,17,// Not a pointer access,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:60,Integrability,depend,dependent,60,// Build an unanalyzed expression if either operand is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform default conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:59,Availability,error,error,59,// Always try to create iterator declarator to avoid extra error messages; // about unknown declarations use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:65,Integrability,message,messages,65,// Always try to create iterator declarator to avoid extra error messages; // about unknown declarations use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:47,Safety,avoid,avoid,47,// Always try to create iterator declarator to avoid extra error messages; // about unknown declarations use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variable,24,/// Act on the iterator variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Availability,error,error,51,// Invalidate all created iterator declarations if error is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Deployability,update,update,17,// Build counter update.; // Build counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Deployability,update,update,17,// Build counter update.; // I = Begini + counter * Stepi;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Availability,error,error,51,// Invalidate all created iterator declarations if error is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform default conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:14,Testability,log,logic,14,// Use custom logic if this should be the pseudo-object subscript; // expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Usability,clear,cleared,20,"// If we've already cleared out the location for the default argument,; // that means we're parsing it right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Recover,Recover,3,"// Recover by marking the field invalid, unless we're in a SFINAE context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Recover,Recover,3,"// Recover by marking the field invalid, unless we're in a SFINAE context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:278,Integrability,rout,routine,278,"/// ConvertArgumentsForCall - Converts the arguments specified in; /// Args/NumArgs to the parameter types of the function FDecl with; /// function prototype Proto. Call is the call expression itself, and; /// Fn is the function expression. For a C++ member function, this; /// routine does not attempt to convert the object argument. Returns; /// true if the call is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Modifiability,config,config,25,/* kernel function (exec config) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:28,Availability,avail,available,28,"// If too few arguments are available (and we don't have default; // arguments for the remaining parameters), don't make the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:44,Availability,error,error,44,"// If too many are passed and not variadic, error on the extras and drop; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:43,Security,audit,audited,43,// Remember that parameter belongs to a CF audited API.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:443,Security,access,access,443,"/// CheckStaticArrayArgument - If the given argument corresponds to a static; /// array parameter, check that it is non-null, and that if it is formed by; /// array-to-pointer decay, the underlying array is sufficiently large.; ///; /// C99 6.7.5.3p7: If the keyword static also appears within the [ and ] of the; /// array type derivation, then for each call to the function, the value of the; /// corresponding actual argument shall provide access to the first element of; /// an array with at least as many elements as specified by the size expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Security,expose,exposed,102,"// In practice we'll never use this, since all SVE types are sugared; // via TypedefTypes rather than exposed directly as BuiltinTypes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:88,Availability,failure,failure,88,// Apply this processing to all the arguments at once instead of; // dying at the first failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:371,Modifiability,rewrite,rewrite,371,"/// If a builtin function has a pointer argument with no explicit address; /// space, then it should be able to accept a pointer to any address; /// space as input. In order to do this, we need to replace the; /// standard builtin declaration with one that uses the same address space; /// as the call.; ///; /// \returns nullptr If this builtin is not a candidate for a rewrite i.e.; /// it does not contain any pointer arguments without; /// an address space qualifer. Otherwise the rewritten; /// FunctionDecl is returned.; /// TODO: Handle pointer return types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Usability,simpl,simplify,41,// Convert array arguments to pointer to simplify type lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:216,Security,access,access,216,// If the unresolved member functions were found in a 'naming class' that is; // related (either the same or derived from) to the class that contains the; // member function that itself contained the implicit member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:36,Integrability,depend,dependent,36,"// If the enclosing function is not dependent, then this lambda is; // capture ready, so if we can capture this, do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:31,Integrability,depend,dependent,31,"// Determine whether this is a dependent call inside a C++ template,; // in which case we won't do any semantic analysis now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:36,Testability,log,logic,36,// We aren't supposed to apply this logic if there's an '&' involved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the function decl for this builtin by replacing parameters; // with no explicit address space with the address space of the arguments; // in ArgExprs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:327,Performance,perform,perform,327,"// If this expression is a call to a builtin function in HIP device; // compilation, allow a pointer-type argument to default address space to be; // passed as a pointer-type parameter to a non-default address space.; // If Arg is declared in the default address space and Param is declared; // in a non-default address space, perform an implicit address space cast to; // the parameter type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:11,Performance,perform,perform,11,// Finally perform an implicit address space cast,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:275,Availability,avail,available,275,"/// BuildResolvedCallExpr - Build a call to a resolved expression,; /// i.e. an expression not of \p OverloadTy. The expression should; /// unary-convert to an expression of function-pointer or; /// block-pointer type.; ///; /// \param NDecl the declaration being called, if available",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:390,Energy Efficiency,efficient,efficient,390,"// Interrupt handlers don't save off the VFP regs automatically on ARM,; // so there's some risk when calling out to non-interrupt handler functions; // that the callee might not preserve them. This is easy to diagnose here,; // but can be very challenging to debug.; // Likewise, X86 interrupt handlers may only call routines with attribute; // no_caller_saved_registers since there is no efficient way to; // save and restore the non-GPR state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:318,Integrability,rout,routines,318,"// Interrupt handlers don't save off the VFP regs automatically on ARM,; // so there's some risk when calling out to non-interrupt handler functions; // that the callee might not preserve them. This is easy to diagnose here,; // but can be very challenging to debug.; // Likewise, X86 interrupt handlers may only call routines with attribute; // no_caller_saved_registers since there is no efficient way to; // save and restore the non-GPR state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:92,Safety,risk,risk,92,"// Interrupt handlers don't save off the VFP regs automatically on ARM,; // so there's some risk when calling out to non-interrupt handler functions; // that the callee might not preserve them. This is easy to diagnose here,; // but can be very challenging to debug.; // Likewise, X86 interrupt handlers may only call routines with attribute; // no_caller_saved_registers since there is no efficient way to; // save and restore the non-GPR state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:79,Energy Efficiency,allocate,allocate,79,"// Get the number of parameters in the function prototype, if any.; // We will allocate space for max(Args.size(), NumParams) arguments; // in the call expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:144,Integrability,depend,dependent,144,"// C cannot always handle TypoExpr nodes in builtin calls and direct; // function calls as their argument checking don't necessarily handle; // dependent types properly, so make sure any TypoExprs have been; // dealt with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:43,Modifiability,config,configured,43,// CUDA: Calls to global functions must be configured,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:367,Integrability,interface,interface,367,"// If we still haven't found a prototype to use but there are arguments to; // the call, diagnose this as calling a function without a prototype.; // However, if we found a function declaration, check to see if; // -Wdeprecated-non-prototype was disabled where the function was declared.; // If so, we will silence the diagnostic here on the assumption that this; // interface is intentional and the user knows what they're doing. We will; // also silence the diagnostic if there is a function declaration but it; // was implicitly defined (the user already gets diagnostics about the; // creation of the implicit function declaration, so the additional warning; // is not helpful).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Security,secur,security,34,// Warn for unions passing across security boundary (CMSE).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:263,Availability,error,error,263,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:30,Modifiability,variab,variable,30,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:379,Usability,clear,clear,379,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:499,Modifiability,extend,extending,499,"// In C, compound literals are l-values for some reason.; // For GCC compatibility, in C++, file-scope array compound literals with; // constant initializers are also l-values, and compound literals are; // otherwise prvalues.; //; // (GCC also treats C++ list-initialized file-scope array prvalues with; // constant initializers as l-values, but that's non-conforming, so we don't; // follow it there.); //; // FIXME: It would be better to handle the lvalue cases as materializing and; // lifetime-extending a temporary object, but our materialized temporaries; // representation only supports lifetime extension from a variable, not ""out; // of thin air"".; // FIXME: For C++, we might want to instead lifetime-extend only if a pointer; // is bound to the result of applying array-to-pointer decay to the compound; // literal.; // FIXME: GCC supports compound literals of reference type, which should; // obviously have a value kind derived from the kind of reference involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:621,Modifiability,variab,variable,621,"// In C, compound literals are l-values for some reason.; // For GCC compatibility, in C++, file-scope array compound literals with; // constant initializers are also l-values, and compound literals are; // otherwise prvalues.; //; // (GCC also treats C++ list-initialized file-scope array prvalues with; // constant initializers as l-values, but that's non-conforming, so we don't; // follow it there.); //; // FIXME: It would be better to handle the lvalue cases as materializing and; // lifetime-extending a temporary object, but our materialized temporaries; // representation only supports lifetime extension from a variable, not ""out; // of thin air"".; // FIXME: For C++, we might want to instead lifetime-extend only if a pointer; // is bound to the result of applying array-to-pointer decay to the compound; // literal.; // FIXME: GCC supports compound literals of reference type, which should; // obviously have a value kind derived from the kind of reference involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:712,Modifiability,extend,extend,712,"// In C, compound literals are l-values for some reason.; // For GCC compatibility, in C++, file-scope array compound literals with; // constant initializers are also l-values, and compound literals are; // otherwise prvalues.; //; // (GCC also treats C++ list-initialized file-scope array prvalues with; // constant initializers as l-values, but that's non-conforming, so we don't; // follow it there.); //; // FIXME: It would be better to handle the lvalue cases as materializing and; // lifetime-extending a temporary object, but our materialized temporaries; // representation only supports lifetime extension from a variable, not ""out; // of thin air"".; // FIXME: For C++, we might want to instead lifetime-extend only if a pointer; // is bound to the result of applying array-to-pointer decay to the compound; // literal.; // FIXME: GCC supports compound literals of reference type, which should; // obviously have a value kind derived from the kind of reference involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Availability,failure,failures,10,// Ignore failures; dropping the entire initializer list because; // of one failure would be terrible for indexing/etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:76,Availability,failure,failure,76,// Ignore failures; dropping the entire initializer list because; // of one failure would be terrible for indexing/etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:19,Modifiability,extend,extend,19,/// Do an explicit extend of the given block pointer if we're in ARC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Performance,perform,performing,32,"/// Prepares for a scalar cast, performing all the necessary stages; /// except the final cast and returning the kind required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,Usability,simpl,simple,15,// Vectors are simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:113,Performance,scalab,scalable,113,/// Are the two types RVV-bitcast-compatible types? I.e. is bitcasting from the; /// first RVV type (e.g. an RVV scalable type) to the second type (e.g. an RVV; /// VLS type) allowed?; ///; /// This will also return false if the two given types do not make sense from; /// the perspective of RVV bitcasts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,Energy Efficiency,power,power,68,"// ASTContext::getTypeSize will return the size rounded up to a; // power of 2, so instead of using that, we need to use the raw; // element size multiplied by the element count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:144,Integrability,depend,depend,144,"// Disallow lax conversions between scalars and ExtVectors (these; // conversions are allowed for other vector types because common headers; // depend on them). Most scalar OP ExtVector cases are handled by the; // splat path anyway, which does what we want (convert, not bitcast).; // What this rules out for ExtVectors is crazy things like char4*float.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:6,Safety,avoid,avoid,6,"// To avoid having to have a CK_BooleanToSignedFloating cast kind, we cast; // in two steps: boolean to signed integral, then to floating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Testability,assert,assertion,21,// isa<ParenExpr> by assertion at function entrance,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Modifiability,extend,extend,37,"// OpenCL v2.0 specification doesn't extend compatibility of type qualifiers; // (C99 6.7.3) for address spaces. We assume that the check should behave in; // the same manner as it's defined for CVR qualifiers, so for OpenCL two; // qual types are compatible iff; // * corresponded types are compatible; // * CVR qualifiers are equal; // * address spaces are equal; // Thus for conditional operator we merge CVR and address space unqualified; // pointees and if there is a composite type we return a pointer to it with; // merged qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Usability,Simpl,Simple,4,"/// Simple conversion between integer and floating point types.; ///; /// Used when handling the OpenCL conditional operator where the; /// condition is a vector while the other operands are scalar.; ///; /// OpenCL v1.1 s6.3.i and s6.11.6 together require that the scalar; /// types are either integer or floating type. Between the two; /// operands, the type with the higher rank is defined as the ""result; /// type"". The other operand needs to be promoted to the same type. No; /// other type promotion is allowed. We cannot use; /// UsualArithmeticConversions() for this purpose, since it always; /// promotes promotable types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:199,Security,access,access,199,"// Handle things like Class and struct objc_class*. Here we case the result; // to the pseudo-builtin, because that will be implicitly cast back to the; // redefinition type if an attempt is made to access its fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Integrability,interface,interfaces,24,"// If both operands are interfaces and either operand can be; // assigned to the other, use that type as the composite; // type. This allows; // xxx ? (A*) a : (B*) b; // where B is a subclass of A.; //; // Additionally, as for assignment, if either type is 'id'; // allow silent coercion. Finally, if the types are; // incompatible then make sure to use 'id' as the composite; // type so the result is acceptable for sending messages to.; // FIXME: Consider unifying with 'areComparableObjCPointerTypes'.; // It could return the composite type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:426,Integrability,message,messages,426,"// If both operands are interfaces and either operand can be; // assigned to the other, use that type as the composite; // type. This allows; // xxx ? (A*) a : (B*) b; // where B is a subclass of A.; //; // Additionally, as for assignment, if either type is 'id'; // allow silent coercion. Finally, if the types are; // incompatible then make sure to use 'id' as the composite; // type so the result is acceptable for sending messages to.; // FIXME: Consider unifying with 'areComparableObjCPointerTypes'.; // It could return the composite type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Usability,clear,clear,149,"// Need to handle ""id<xx>"" explicitly.; // GCC allows qualified id and any Objective-C type to devolve to; // id. Currently localizing to here until clear this should be; // part of ObjCQualifiedIdTypesAreCompatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:60,Integrability,wrap,wraps,60,/// SuggestParentheses - Emit a note with a fixit hint that wraps; /// ParenRange in parentheses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:95,Testability,log,logical,95,"// This only checks for bitwise-or and bitwise-and, but not bitwise-xor and; // not any of the logical operators. Bitwise-xor is commonly used as a; // logical-xor because there is no logical-xor operator. The logical; // operators, including uses of xor, have a high false positive rate for; // precedence warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:152,Testability,log,logical-xor,152,"// This only checks for bitwise-or and bitwise-and, but not bitwise-xor and; // not any of the logical operators. Bitwise-xor is commonly used as a; // logical-xor because there is no logical-xor operator. The logical; // operators, including uses of xor, have a high false positive rate for; // precedence warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:184,Testability,log,logical-xor,184,"// This only checks for bitwise-or and bitwise-and, but not bitwise-xor and; // not any of the logical operators. Bitwise-xor is commonly used as a; // logical-xor because there is no logical-xor operator. The logical; // operators, including uses of xor, have a high false positive rate for; // precedence warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:210,Testability,log,logical,210,"// This only checks for bitwise-or and bitwise-and, but not bitwise-xor and; // not any of the logical operators. Bitwise-xor is commonly used as a; // logical-xor because there is no logical-xor operator. The logical; // operators, including uses of xor, have a high false positive rate for; // precedence warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:54,Safety,safe,safe,54,"// Make sure this is really a binary operator that is safe to pass into; // BinaryOperator::getOverloadedOpcode(), e.g. it's not a subscript op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:94,Testability,log,logical,94,"/// ExprLooksBoolean - Returns true if E looks boolean, i.e. it has boolean type; /// or is a logical expression such as (x==y) which has int type, but is; /// commonly interpreted as boolean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Integrability,depend,dependent,81,"// C cannot handle TypoExpr nodes in the condition because it; // doesn't handle dependent types properly, so make sure any TypoExprs have; // been dealt with before checking the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Safety,safe,safely,91,"// If the common expression is a class or array prvalue, materialize it; // so that we can safely refer to it multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,checkPoint,checkPointerTypesForAssignment,3,// checkPointerTypesForAssignment - This is a very tricky routine (despite; // being closely modeled after the C99 spec:-). The odd characteristic of this; // routine is it effectively iqnores the qualifiers on the top level pointee.; // This circumvents the usual type rules specified in 6.2.7p1 & 6.7.5.[1-3].; // FIXME: add a couple examples in this comment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,Integrability,rout,routine,58,// checkPointerTypesForAssignment - This is a very tricky routine (despite; // being closely modeled after the C99 spec:-). The odd characteristic of this; // routine is it effectively iqnores the qualifiers on the top level pointee.; // This circumvents the usual type rules specified in 6.2.7p1 & 6.7.5.[1-3].; // FIXME: add a couple examples in this comment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:159,Integrability,rout,routine,159,// checkPointerTypesForAssignment - This is a very tricky routine (despite; // being closely modeled after the C99 spec:-). The odd characteristic of this; // routine is it effectively iqnores the qualifiers on the top level pointee.; // This circumvents the usual type rules specified in 6.2.7p1 & 6.7.5.[1-3].; // FIXME: add a couple examples in this comment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,Usability,simpl,simply,68,"// If we are a multi-level pointer, it's possible that our issue is simply; // one of qualification - e.g. char ** -> const char ** is not allowed. If; // the eventual target type is the same and the pointers have the same; // level of indirection, this must be the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:270,Usability,clear,clear,270,"// Inconsistent address spaces at this point is invalid, even if the; // address spaces would be compatible.; // FIXME: This doesn't catch address space mismatches for pointers of; // different nesting levels, like:; // __local int *** a;; // int ** b = a;; // It's not clear how to actually determine when such pointers are; // invalidly incompatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:47,Integrability,rout,routine,47,/// checkBlockPointerTypesForAssignment - This routine determines whether two; /// block pointer types are compatible or whether a block and normal pointer; /// are compatible. It is more restrict than comparing two function pointer; // types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:180,Modifiability,variab,variable,180,"// FIXME: OpenCL doesn't define the exact compile time semantics for a block; // assignment.; // The current behavior is similar to C++ lambdas. A block might be; // assigned to a variable iff its return type and parameters are compatible; // (C99 6.2.7) with the corresponding return type and parameters of the LHS of; // an assignment. Presumably it should behave in way that a function pointer; // assignment does in C, so for each parameter and return type:; // * CVR and address space of LHS should be a superset of CVR and address; // space of RHS.; // * unqualified types should be compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Integrability,rout,routine,51,"/// CheckAssignmentConstraints (C99 6.5.16) - This routine currently; /// has code to accommodate several GCC extensions when type checking; /// pointers. Here are some objectionable examples that GCC considers warnings:; ///; /// int a, *pint;; /// short *pshort;; /// struct foo *pfoo;; ///; /// pint = pshort; // warning: assignment from incompatible pointer type; /// a = pint; // warning: assignment makes integer from pointer without a cast; /// pint = a; // warning: assignment makes pointer from integer without a cast; /// pint = pfoo; // warning: assignment from incompatible pointer type; ///; /// As a result, the code for dealing with pointers is more complex than the; /// C99 spec dictates.; ///; /// Sets 'Kind' for any result kind except Incompatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:69,Usability,simpl,simply,69,// Disallow assigning a _Complex to a real type in C++ mode since it simply; // discards the imaginary part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:174,Deployability,update,updated,174,"// If ConvertRHS is false, we want to leave the caller's RHS untouched. Sadly,; // we can't avoid *all* modifications at the moment, so we need some somewhere; // to put the updated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:92,Safety,avoid,avoid,92,"// If ConvertRHS is false, we want to leave the caller's RHS untouched. Sadly,; // we can't avoid *all* modifications at the moment, so we need some somewhere; // to put the updated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:488,Performance,Perform,PerformImplicitConversion,488,"// This check seems unnatural, however it is necessary to ensure the proper; // conversion of functions/arrays. If the conversion were done for all; // DeclExpr's (created by ActOnIdExpression), it would mess up the unary; // expressions that suppress this implicit conversion (&, sizeof). This needs; // to happen before we check for null pointer conversions because C does not; // undergo the same implicit conversions as C++ does above (by the calls to; // TryImplicitConversion() and PerformImplicitConversion()) which insert the; // lvalue to rvalue cast before checking for null pointer constraints. This; // addresses code like: nullptr_t val; int *ptr; ptr = val;; //; // Suppress this for references: C++ 8.5.3p5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Energy Efficiency,allocate,allocate,25,// FIXME: We potentially allocate here even if ConvertRHS is false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Availability,error,errors,33,"// Check for various Objective-C errors. If we are not reporting; // diagnostics and just checking for errors, e.g., during overload; // resolution, return Incompatible to indicate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:103,Availability,error,errors,103,"// Check for various Objective-C errors. If we are not reporting; // diagnostics and just checking for errors, e.g., during overload; // resolution, return Incompatible to indicate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:185,Availability,failure,failure,185,"// Check for various Objective-C errors. If we are not reporting; // diagnostics and just checking for errors, e.g., during overload; // resolution, return Incompatible to indicate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Availability,error,errors,91,// Replace the expression with a corrected version and continue so we; // can find further errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:133,Availability,error,error,133,"// Diagnose cases where a scalar was implicitly converted to a vector and; // diagnose the underlying types. Otherwise, diagnose the error; // as invalid vector logical operands for non-C++ cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:161,Testability,log,logical,161,"// Diagnose cases where a scalar was implicitly converted to a vector and; // diagnose the underlying types. Otherwise, diagnose the error; // as invalid vector logical operands for non-C++ cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:367,Availability,error,error,367,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:612,Availability,failure,failure,612,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:134,Performance,perform,performing,134,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:519,Performance,perform,perform,519,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Testability,Test,Test,4,/// Test if a (constant) integer Int can be casted to another integer type; /// IntTy without losing precision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Testability,Test,Test,4,/// Test if a (constant) integer Int can be casted to floating point type; /// FloatTy without losing precision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:215,Safety,avoid,avoided,215,// Reject constants that would be truncated if they were converted to; // the floating point type. Test by simple to/from conversion.; // FIXME: Ideally the conversion to an APFloat and from an APFloat; // could be avoided if there was a convertFromAPInt method; // which could signal back if implicit truncation occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,Testability,Test,Test,99,// Reject constants that would be truncated if they were converted to; // the floating point type. Test by simple to/from conversion.; // FIXME: Ideally the conversion to an APFloat and from an APFloat; // could be avoided if there was a convertFromAPInt method; // which could signal back if implicit truncation occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:107,Usability,simpl,simple,107,// Reject constants that would be truncated if they were converted to; // the floating point type. Test by simple to/from conversion.; // FIXME: Ideally the conversion to an APFloat and from an APFloat; // could be avoided if there was a convertFromAPInt method; // which could signal back if implicit truncation occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:257,Performance,perform,perform,257,"// Accept cases where the vector elements are integers and the scalar is; // an integer.; // FIXME: Notionally if the scalar was a floating point value with a precise; // integral representation, we could cast it to an appropriate integer; // type and then perform the rest of the checks here. GCC will perform; // this conversion in some cases as determined by the input language.; // We should accept it on a language independent basis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:303,Performance,perform,perform,303,"// Accept cases where the vector elements are integers and the scalar is; // an integer.; // FIXME: Notionally if the scalar was a floating point value with a precise; // integral representation, we could cast it to an appropriate integer; // type and then perform the rest of the checks here. GCC will perform; // this conversion in some cases as determined by the input language.; // We should accept it on a language independent basis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:83,Integrability,depend,dependent,83,"// Determine whether this is a constant scalar. In the event that the; // value is dependent (and thus cannot be evaluated by the constant; // evaluator), skip the evaluation. This will then diagnose once the; // expression is instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:27,Safety,safe,safely,27,"// If the scalar cannot be safely casted to the vector element type,; // reject it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Performance,perform,performed,29,// This operation may not be performed on boolean vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:107,Availability,down,down,107,"// FIXME: The code below also handles conversion between vectors and; // non-scalars, we should break this down into fine grained specific checks; // and emit proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:87,Availability,error,error,87,"// OpenCL V1.1 6.2.6.p1:; // If the operands are of more than one vector type, then an error shall; // occur. Implicit conversions between vector types are not permitted, per; // section 6.2.1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Safety,Detect,Detect,25,// checkArithmeticNull - Detect when a NULL constant is used improperly in an; // expression. These are mainly cases where the null pointer is used as an; // integer instead of a pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Avoid,Avoid,3,// Avoid analyzing cases where the result will either be invalid (and; // diagnosed as such) or entirely valid and not something to warn about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Availability,error,error,9,/// Emit error if Operand is incomplete pointer type; ///; /// \returns True if pointer has incomplete type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:101,Integrability,rout,routine,101,"/// Check the validity of a binary arithmetic operation w.r.t. pointer; /// operands.; ///; /// This routine will diagnose any invalid arithmetic on pointer operands much; /// like \see checkArithmeticOpPointerOperand. However, it has special logic; /// for emitting a single diagnostic even for operations where both LHS and RHS; /// are (potentially problematic) pointers.; ///; /// \returns True when the operand is valid to use (even if as an extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:243,Testability,log,logic,243,"/// Check the validity of a binary arithmetic operation w.r.t. pointer; /// operands.; ///; /// This routine will diagnose any invalid arithmetic on pointer operands much; /// like \see checkArithmeticOpPointerOperand. However, it has special logic; /// for emitting a single diagnostic even for operations where both LHS and RHS; /// are (potentially problematic) pointers.; ///; /// \returns True when the operand is valid to use (even if as an extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Availability,error,error,9,/// Emit error when two pointers are incompatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Integrability,interface,interface,41,// Diagnose bad cases where we step over interface counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:221,Integrability,wrap,wrap,221,"// Don't warn if signed overflow is defined, then all the rest of the; // diagnostics will not be triggered because the behavior is defined.; // Also don't warn in C++20 mode (and newer), as signed left shifts; // always wrap and never overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:47,Integrability,rout,routine,47,// Note that LHS might be a scalar because the routine calls not only in; // OpenCL case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Performance,perform,perform,16,"// Shifts don't perform usual arithmetic conversions, they just do integer; // promotions on each operand. C99 6.5.7p3; // For the LHS, do usual unary conversions, but then reset them away; // if this is a compound assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:14,Usability,simpl,simpler,14,// The RHS is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Performance,perform,performed,102,// C++ [expr.rel]p2:; // [...] Pointer conversions (4.10) and qualification; // conversions (4.4) are performed on pointer operands (or on; // a pointer operand and a null pointer constant) to bring; // them to their composite pointer type. [...]; //; // C++ [expr.eq]p1 uses the same notion for (in)equality; // comparisons of pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Integrability,interface,interface,24,// Get the LHS object's interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Integrability,protocol,protocols,9,// Check protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,Availability,error,errors,170,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.; //; // NOTE: Don't warn about comparison expressions resulting from macro; // expansion. Also don't warn about comparisons which are only self; // comparisons within a template instantiation. The warnings should catch; // obvious cases in the definition of the template anyways. The idea is to; // warn when the typed comparison operator will always evaluate to the same; // result.; // Used for indexing into %select in warn_comparison_always",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Testability,log,logic,164,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.; //; // NOTE: Don't warn about comparison expressions resulting from macro; // expansion. Also don't warn about comparisons which are only self; // comparisons within a template instantiation. The warnings should catch; // obvious cases in the definition of the template anyways. The idea is to; // warn when the typed comparison operator will always evaluate to the same; // result.; // Used for indexing into %select in warn_comparison_always",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Integrability,depend,dependent,75,"// Implicit conversion to a narrower type, but the expression is; // value-dependent so we can't tell whether it's actually narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:153,Safety,avoid,avoid,153,"// We can't use `CK_IntegralCast` when the underlying type is 'bool', so we; // promote the boolean type, and all other promotable integer types, to; // avoid this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:124,Performance,perform,performed,124,"// C++2a [expr.spaceship]p6: If at least one of the operands is of pointer; // type, array-to-pointer, ..., conversions are performed on both operands to; // bring them to their composite type.; // Otherwise, all comparisons expect an rvalue, so convert to rvalue before; // any type-related checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Availability,error,error,102,"// This is a gcc extension compatibility comparison.; // In a SFINAE context, we treat this as a hard error to maintain; // conformance with the C++ standard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,Testability,test,test,99,"// FIXME: If LPtrToVoid, we should presumably convert the LHS rather than; // the RHS, but we have test coverage for this behavior.; // FIXME: Consider using convertPointersToCompositeType in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:276,Safety,avoid,avoid,276,"// Return a signed ext_vector_type that is of identical size and number of; // elements. For floating point vectors, return an integer type of identical; // size and number of elements. In the non ext_vector_type case, search from; // the largest type to the smallest type to avoid cases where long long == long,; // where long gets picked over long long.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:96,Modifiability,extend,extended,96,"/// CheckVectorCompareOperands - vector comparisons are a clang extension that; /// operates on extended vector types. Instead of producing an IntTy result,; /// like a scalar comparison, a vector comparison produces a vector of integer; /// types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,Availability,error,errors,170,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Testability,log,logic,164,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,Availability,error,errors,170,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Testability,log,logic,164,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:92,Testability,log,logical,92,// FIXME: The check for C++ here is for GCC compatibility. GCC rejects the; // usage of the logical operators && and || with vectors in C. This; // check could be notionally dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Testability,log,logical,41,// WebAssembly tables can't be used with logical operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Testability,log,logical,41,// Diagnose cases where the user write a logical and/or but probably meant a; // bitwise one. We do this when the LHS is a non-bool integer and the RHS; // is a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:126,Testability,log,logical,126,"// If the RHS can be constant folded, and if it constant folds to something; // that isn't 0 or 1 (which indicate a potential logical operation that; // happened to fold to true/false) then warn.; // Parens on the RHS are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Testability,log,logical,25,// Suggest replacing the logical operator with the bitwise version,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:27,Testability,log,logical,27,"// OpenCL v1.1 s6.3.g: The logical operators and (&&), or (||) do; // not operate on the built-in scalar and vector float types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Safety,safe,safe,20,// The following is safe because we only use this method for; // non-overloadable operands.; // C++ [expr.log.and]p1; // C++ [expr.log.or]p1; // The operands are both contextually converted to type bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Testability,log,log,106,// The following is safe because we only use this method for; // non-overloadable operands.; // C++ [expr.log.and]p1; // C++ [expr.log.or]p1; // The operands are both contextually converted to type bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:131,Testability,log,log,131,// The following is safe because we only use this method for; // non-overloadable operands.; // C++ [expr.log.and]p1; // C++ [expr.log.or]p1; // The operands are both contextually converted to type bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,Testability,log,log,13,// C++ [expr.log.and]p2; // C++ [expr.log.or]p2; // The result is a bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:38,Testability,log,log,38,// C++ [expr.log.and]p2; // C++ [expr.log.or]p2; // The result is a bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:74,Modifiability,variab,variable,74,"/// Is the given expression (which must be 'const') a reference to a; /// variable which was originally non-const, but which has become; /// 'const' due to being captured within a block?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Modifiability,variab,variable,29,// The declaration must be a variable which is not declared 'const'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Modifiability,variab,variable,45,"// For init-capture, it is possible that the variable belongs to the; // template pattern of the current context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Deployability,Update,Update,3,// Update err_typecheck_assign_const and note_typecheck_assign_const; // when this enum is changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:49,Availability,error,error,49,"/// Emit the ""read-only variable not assignable"" error and print notes to give; /// more information about why the variable is not assignable, such as pointing; /// to the declaration of a const variable, showing that a method is const, or; /// that the function is returning a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variable,24,"/// Emit the ""read-only variable not assignable"" error and print notes to give; /// more information about why the variable is not assignable, such as pointing; /// to the declaration of a const variable, showing that a method is const, or; /// that the function is returning a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:115,Modifiability,variab,variable,115,"/// Emit the ""read-only variable not assignable"" error and print notes to give; /// more information about why the variable is not assignable, such as pointing; /// to the declaration of a const variable, showing that a method is const, or; /// that the function is returning a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:195,Modifiability,variab,variable,195,"/// Emit the ""read-only variable not assignable"" error and print notes to give; /// more information about why the variable is not assignable, such as pointing; /// to the declaration of a const variable, showing that a method is const, or; /// that the function is returning a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Availability,error,error,17,// Only emit one error on the first const found. All other consts will emit; // a note to the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:94,Availability,error,error,94,// Only emit one error on the first const found. All other consts will emit; // a note to the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,inherit,inherit,24,// Static fields do not inherit constness from parents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:12,Modifiability,variab,variable,12,// Point to variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:67,Availability,error,error,67,"// Can't determine a more specific message, so display the generic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Integrability,message,message,35,"// Can't determine a more specific message, so display the generic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:12,Availability,error,error,12,/// Emit an error for the case where a record we are trying to assign to has a; /// const-qualified field somewhere in its hierarchy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:90,Availability,error,error,90,"/// CheckForModifiableLvalue - Verify that E is a modifiable lvalue. If not,; /// emit an error and return true. If so, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:117,Modifiability,variab,variables,117,"// In ARC, use some specialized diagnostics for occasions where we; // infer 'const'. These are always pseudo-strong variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:22,Modifiability,variab,variables,22,// - fast enumeration variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:72,Usability,simpl,simple,72,"// If none of the special cases above are triggered, then this is a; // simple const assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variables,24,// Objective-C instance variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Availability,error,error,52,"// Verify that LHS is a modifiable lvalue, and emit error if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:95,Modifiability,variab,variable,95,"// Warn about retain cycles where a block captures the LHS, but; // not if the LHS is a simple variable into which the block is; // being stored...unless that variable can be captured by reference!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:159,Modifiability,variab,variable,159,"// Warn about retain cycles where a block captures the LHS, but; // not if the LHS is a simple variable into which the block is; // being stored...unless that variable can be captured by reference!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:88,Usability,simpl,simple,88,"// Warn about retain cycles where a block captures the LHS, but; // not if the LHS is a simple variable into which the block is; // being stored...unless that variable can be captured by reference!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Modifiability,variab,variable,55,"// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.; // For ObjCWeak only, we do not warn if the assign is to a non-weak; // variable, which will be valid for the current autorelease scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:420,Modifiability,variab,variable,420,"// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.; // For ObjCWeak only, we do not warn if the assign is to a non-weak; // variable, which will be valid for the current autorelease scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Safety,safe,safe,9,"// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.; // For ObjCWeak only, we do not warn if the assign is to a non-weak; // variable, which will be valid for the current autorelease scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Usability,simpl,simple-assignment,29,// C++2a [expr.ass]p5:; // A simple-assignment whose left operand is of a volatile-qualified; // type is deprecated unless the assignment is either a discarded-value; // expression or an unevaluated operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Integrability,depend,dependent,26,// static_cast<void> on a dependent type will not show up as CK_ToVoid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:430,Testability,log,logic,430,"// Scope isn't fine-grained enough to explicitly list the specific cases, so; // instead, skip more than needed, then call back into here with the; // CommaVisitor in SemaStmt.cpp.; // The listed locations are the initialization and increment portions; // of a for loop. The additional checks are on the condition of; // if statements, do/while loops, and for loops.; // Differences in scope flags for C89 mode requires the extra logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,Performance,perform,performs,13,"// C's comma performs lvalue conversion (C99 6.3.2.1) on both its; // operands, but not unary promotions.; // C++'s comma does not do any conversions at all (C++ [expr.comma]p1).; // So we treat the LHS as a ignored value, and in C++ we allow the; // containing site to determine what should be done with the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:71,Integrability,rout,routine,71,"/// CheckIncrementDecrementOperand - unlike most ""Check"" methods, this routine; /// doesn't need to call UsualUnaryConversions or UsualArithmeticConversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Error,Error,3,// Error on enum increments and decrements in C++ mode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:76,Integrability,rout,routine,76,"/// getPrimaryDecl - Helper function for CheckAddressOfOperand().; /// This routine allows us to typecheck complex/recursive expressions; /// where the declaration is needed for type checking. We only need to; /// handle cases when the expression references a function designator; /// or is an lvalue. Here are some examples:; /// - &(x) => x; /// - &*****f => f for f a function designator.; /// - &s.xx => s; /// - &s.zz[1].yy -> s, if zz is an array; /// - *(x + 1) -> x, if x is an array; /// - &""123""[2] -> 0; /// - & __real__ x -> x; ///; /// FIXME: We don't recurse to the RHS of a comma, nor handle pointers to; /// members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:188,Integrability,depend,depending,188,// In OpenCL captures for blocks called as lambda functions; // are located in the private address space. Blocks used in; // enqueue_kernel can be located in a different address space; // depending on a vendor implementation. Thus preventing; // taking an address of the capture to avoid invalid AS casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:282,Safety,avoid,avoid,282,// In OpenCL captures for blocks called as lambda functions; // are located in the private address space. Blocks used in; // enqueue_kernel can be located in a different address space; // depending on a vendor implementation. Thus preventing; // taking an address of the capture to avoid invalid AS casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Availability,down,down,26,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Modifiability,inherit,inheritance,35,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Performance,load,loads,32,// Use a special diagnostic for loads from property references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Availability,error,error,20,// in C++ it is not error to take address of a register; // variable (c++03 7.1.1P3),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:60,Modifiability,variab,variable,60,// in C++ it is not error to take address of a register; // variable (c++03 7.1.1P3),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Availability,down,down,26,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Modifiability,inherit,inheritance,35,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,"// Taking the address of a void variable is technically illegal, but we; // allow it in cases which are otherwise valid.; // Example: ""extern void x; void* y = &x;"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:28,Performance,perform,performed,28,/// Check if a bitwise-& is performed on an Objective-C pointer. This; /// is usually indicative of introspection within the Objective-C pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:54,Energy Efficiency,reduce,reduce,54,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,Security,hash,hashing,110,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:86,Testability,log,logic,86,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:124,Testability,log,logic,124,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Performance,perform,performSelectorXXX,51,// Determine if we are introspecting the result of performSelectorXXX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Integrability,message,messages,16,"// Special case messages to -performSelector and friends, which; // can return non-pointer values boxed in a pointer value.; // Some clients may wish to silence warnings in this subcase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Performance,perform,performSelector,29,"// Special case messages to -performSelector and friends, which; // can return non-pointer values boxed in a pointer value.; // Some clients may wish to silence warnings in this subcase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:90,Integrability,depend,dependent,90,"// C cannot handle TypoExpr nodes on either side of a binop because it; // doesn't handle dependent types properly, so make sure any TypoExprs have; // been dealt with before checking the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Avoid,Avoid,3,// Avoid correcting the RHS to the same Expr as the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,Integrability,rout,routine,119,/// CreateBuiltinBinOp - Creates a new built-in binary operation with; /// operator @p Opc at location @c TokLoc. This routine only supports; /// built-in operations; ActOnBinOp handles overloaded operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:61,Modifiability,variab,variables,61,// Result type of the binary operator.; // The following two variables are used for compound assignment operators,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Modifiability,variab,variables,41,// OpenCLC v2.0 s6.13.11.1 allows atomic variables to be initialized by; // the ATOMIC_VAR_INIT macro.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:82,Modifiability,variab,variable,82,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:185,Modifiability,variab,variable,185,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Performance,optimiz,optimization,149,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Avoid,Avoid,3,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:165,Safety,unsafe,unsafe,165,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:302,Safety,unsafe,unsafe,302,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Testability,log,logical,50,// Bitwise operations are sometimes used as eager logical ops.; // Don't diagnose this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:109,Integrability,wrap,wraps,109,/// It accepts a '&&' expr that is inside a '||' one.; /// Emit a diagnostic together with a fixit hint that wraps the '&&' expression; /// in parentheses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:147,Integrability,wrap,wraps,147,/// Look for bitwise op in the left or right hand of a bitwise op with; /// lower precedence and emit a diagnostic together with a fixit hint that wraps; /// the '&' expression in parentheses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:116,Safety,safe,safe,116,"// Warn about arg1 || arg2 && arg3, as GCC 4.3+ does.; // We don't warn for 'assert(a || b && ""bad"")' since this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:77,Testability,assert,assert,77,"// Warn about arg1 || arg2 && arg3, as GCC 4.3+ does.; // We don't warn for 'assert(a || b && ""bad"")' since this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:82,Usability,simpl,simple,82,"// In the non-overloaded case, we warn about self-assignment (x = x) for; // both simple assignment and certain compound assignments where algebra; // tells us the operation yields a constant result. When the operator is; // overloaded, we can't do the latter because we don't want to assume that; // those algebraic identities still apply; for example, a path-building; // library might use operator/= to append paths. But it's still reasonable; // to assume that simple assignment is just moving/copying values around; // and so self-assignment is likely a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:465,Usability,simpl,simple,465,"// In the non-overloaded case, we warn about self-assignment (x = x) for; // both simple assignment and certain compound assignments where algebra; // tells us the operation yields a constant result. When the operator is; // overloaded, we can't do the latter because we don't want to assume that; // those algebraic identities still apply; for example, a path-building; // library might use operator/= to append paths. But it's still reasonable; // to assume that simple assignment is just moving/copying values around; // and so self-assignment is likely a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Integrability,depend,dependent,50,"// Build the (potentially-overloaded, potentially-dependent); // binary operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:182,Integrability,depend,dependent,182,"// We want to end up calling one of checkPseudoObjectAssignment; // (if the LHS is a pseudo-object), BuildOverloadedBinOp (if; // both expressions are overloadable or either is type-dependent),; // or CreateBuiltinBinOp (in any other case). We also want to get; // any placeholder types out of the way.; // Handle pseudo-objects in the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:221,Integrability,depend,dependently-typed,221,"// We can't actually test that if we still have a placeholder,; // though. Fortunately, none of the exceptions we see in that; // code below are valid when the LHS is an overload set. Note; // that an overload set can be dependently-typed, but it never; // instantiates to having an overloadable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Testability,test,test,21,"// We can't actually test that if we still have a placeholder,; // though. Fortunately, none of the exceptions we see in that; // code below are valid when the LHS is an overload set. Note; // that an overload set can be dependently-typed, but it never; // instantiates to having an overloadable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Integrability,depend,dependent,32,"// If either expression is type-dependent, always build an; // overloaded op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Testability,log,logical,3,"// logical negation; // Unlike +/-/~, integer promotions aren't done here (C99 6.5.3.3p5).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Testability,log,logical,26,// OpenCL v1.1 6.3.h: The logical operator not (!) does not; // operate on scalar float types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Testability,log,logical,26,// OpenCL v1.1 6.3.h: The logical operator not (!) does not; // operate on vector float types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Testability,log,logical,10,// Vector logical not returns the signed variant of the operand type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Testability,log,logical,10,// Vector logical not returns the signed variant of the operand type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:70,Security,access,access,70,"/// Determine whether the given expression is a qualified member; /// access expression, of a form that could be turned into a pointer to member; /// with the address-of operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Testability,log,logic,18,// & gets special logic for several kinds of placeholder.; // The builtin code knows what to do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:62,Modifiability,variab,variable,62,// Type must be complete per C99 7.17p3 because a declaring a variable; // with an incomplete type would be ill-formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:61,Integrability,depend,dependent,61,"// We have the offset of a field, but we can't look into the dependent; // type. Just record the identifier of the field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:59,Modifiability,variab,variable,59,"// Lookup could be ambiguous when looking up a placeholder variable; // __builtin_offsetof(S, _).; // In that case we would already have emitted a diagnostic",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,Availability,error,error,119,"// C99 7.17p3:; // (If the specified member is a bit-field, the behavior is undefined.); //; // We diagnose this as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:11,Integrability,Depend,DependentTy,11,"// Context.DependentTy is used as a placeholder for a missing block; // return type. TODO: what should we do with declarators like:; // ^ * { ... }; // If the answer is ""apply template argument deduction""....",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Modifiability,variab,variables,21,"// Fake up parameter variables if we have a typedef, like; // ^ fntype { ... }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Modifiability,variab,variables,21,// Put the parameter variables in scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Availability,error,error,37,"/// ActOnBlockError - If there is an error parsing a block, this callback; /// is invoked to pop the information about the block from the action impl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Availability,error,error,35,"// If blocks are disabled, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Performance,optimiz,optimization,39,"// Try to apply the named return value optimization. We have to check again; // if we can do this, though, because blocks keep return statements around; // to deduce an implicit return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Modifiability,variab,variables,20,// Set the captured variables on the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,Modifiability,variab,variables,119,"// The capture logic needs the destructor, so make sure we mark it.; // Usually this is unnecessary because most local variables have; // their destructors marked at declaration time, but parameters are; // an exception because it's technically only the call site that; // actually requires the destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,Testability,log,logic,15,"// The capture logic needs the destructor, so make sure we mark it.; // Usually this is unnecessary because most local variables have; // their destructors marked at declaration time, but parameters are; // an exception because it's technically only the call site that; // actually requires the destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Modifiability,variab,variable,50,"// According to the blocks spec, the capture of a variable from; // the stack requires a const copy constructor. This is not true; // of the copy/move done to move a __block variable to the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:174,Modifiability,variab,variable,174,"// According to the blocks spec, the capture of a variable from; // the stack requires a const copy constructor. This is not true; // of the copy/move done to move a __block variable to the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:111,Availability,Recover,Recover,111,// Build a full-expression copy expression if initialization; // succeeded and used a non-trivial constructor. Recover from; // errors by pretending that the copy isn't necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:128,Availability,error,errors,128,// Build a full-expression copy expression if initialization; // succeeded and used a non-trivial constructor. Recover from; // errors by pretending that the copy isn't necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:111,Safety,Recover,Recover,111,// Build a full-expression copy expression if initialization; // succeeded and used a non-trivial constructor. Recover from; // errors by pretending that the copy isn't necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Availability,alive,alive,39,// Pop the block scope now but keep it alive to the end of this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,Modifiability,variab,variables,68,// It also gets a branch-protected scope if any of the captured; // variables needs destruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:1064,Testability,test,test,1064,"// [cstdarg.syn]p1 defers the C++ behavior to what the C standard says,; // and C23 7.16.1.1p2 says, in part:; // If type is not compatible with the type of the actual next argument; // (as promoted according to the default argument promotions), the; // behavior is undefined, except for the following cases:; // - both types are pointers to qualified or unqualified versions of; // compatible types;; // - one type is compatible with a signed integer type, the other; // type is compatible with the corresponding unsigned integer type,; // and the value is representable in both types;; // - one type is pointer to qualified or unqualified void and the; // other is a pointer to a qualified or unqualified character type;; // - or, the type of the next argument is nullptr_t and type is a; // pointer type that has the same representation and alignment; // requirements as a pointer to a character type.; // Given that type compatibility is the primary requirement (ignoring; // qualifications), you would think we could call typesAreCompatible(); // directly to test this. However, in C++, that checks for *same type*,; // which causes false positives when passing an enumeration type to; // va_arg. Instead, get the underlying type of the enumeration and pass; // that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:53,Testability,test,test,53,"// If the types are still not compatible, we need to test whether the; // promoted type and the underlying type are the same except for; // signedness. Ask the AST for the correctly corresponding type and see; // if that's compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:43,Integrability,depend,depending,43,"// The type of __null will be int or long, depending on the size of; // pointers on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform array-to-pointer decay if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:162,Availability,error,error,162,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:238,Availability,checkPoint,checkPointerTypesForAssignment,238,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:454,Availability,checkPoint,checkPointerTypesForAssignment,454,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:311,Modifiability,refactor,refactoring,311,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:221,Performance,perform,performed,221,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Safety,avoid,avoid,39,// Circumvent ICE checking in C++11 to avoid evaluating the expression twice; // in the non-ICE case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:145,Availability,redundant,redundant,145,"// If our only note is the usual ""invalid subexpression"" note, just point; // the caret at its location rather than producing an essentially; // redundant note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:145,Safety,redund,redundant,145,"// If our only note is the usual ""invalid subexpression"" note, just point; // the caret at its location rather than producing an essentially; // redundant note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:309,Availability,Error,Error,309,// We need to special-case DeclRefExprs referring to FieldDecls which; // are not part of a member pointer formation; normal TreeTransforming; // doesn't catch this case because of the way we represent them in the AST.; // FIXME: This is a bit ugly; is it really the best way to handle this; // case?; //; // Error on DeclRefExprs referring to FieldDecls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:103,Usability,simpl,simple-assignment,103,"/// Check whether E, which is either a discarded-value expression or an; /// unevaluated operand, is a simple-assignment to a volatlie-qualified lvalue,; /// and if so, remove it from the list of volatile-qualified assignments that; /// we are going to warn are deprecated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:199,Safety,avoid,avoid,199,"/// Opportunistically remove the callee from ReferencesToConsteval if we can.; /// It's OK if this fails; we'll also remove this in; /// HandleImmediateInvocations, but catching it here allows us to avoid; /// walking the AST looking for it in simple cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:244,Usability,simpl,simple,244,"/// Opportunistically remove the callee from ReferencesToConsteval if we can.; /// It's OK if this fails; we'll also remove this in; /// HandleImmediateInvocations, but catching it here allows us to avoid; /// walking the AST looking for it in simple cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:637,Availability,error,error,637,"// Since an immediate invocation is a full expression itself - it requires; // an additional ExprWithCleanups node, but it can participate to a bigger; // full expression which actually requires cleanups to be run after so; // create ExprWithCleanups without using MaybeCreateExprWithCleanups as it; // may discard cleanups for outer expression too early.; // Note that ExprWithCleanups created here must always have empty cleanup; // objects:; // - compound literals do not create cleanup objects in C++ and immediate; // invocations are C++-only.; // - blocks are not allowed inside constant expressions and compiler will; // issue an error if they appear there.; //; // Hence, in correct code any cleanup objects created inside current; // evaluation context must be outside the immediate invocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Integrability,depend,dependent,10,/// Value-dependent constant expressions should not be immediately; /// evaluated until they are instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Safety,avoid,avoid,29,// Do not rebuild lambdas to avoid creating a new type.; // Lambdas have already been processed inside their eval context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:64,Availability,error,errors,64,// The result may not be usable in case of previous compilation errors.; // In this case evaluation of the expression may result in crash so just; // don't do anything further with the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Usability,usab,usable,25,// The result may not be usable in case of previous compilation errors.; // In this case evaluation of the expression may result in crash so just; // don't do anything further with the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:183,Safety,avoid,avoid,183,"/// When we have more than 1 ImmediateInvocationCandidates or previously; /// failed immediate invocations, we need to check for nested; /// ImmediateInvocationCandidates in order to avoid duplicate diagnostics.; /// Otherwise we only need to remove ReferenceToConsteval in the immediate; /// invocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:59,Availability,error,error,59,"// If the expression is immediate escalating, it is not an error;; // The outer context itself becomes immediate and further errors,; // if any, will be handled by DiagnoseImmediateEscalatingReason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:125,Availability,error,errors,125,"// If the expression is immediate escalating, it is not an error;; // The outer context itself becomes immediate and further errors,; // if any, will be handled by DiagnoseImmediateEscalatingReason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Usability,simpl,simple-assignments,34,// Warn on any volatile-qualified simple-assignments that are not discarded-; // value expressions nor unevaluated operands (those cases get removed from; // this list by CheckUnusedVolatileAssignment).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Usability,clear,clear,50,"// When are coming out of an unevaluated context, clear out any; // temporaries that we may have created as part of the evaluation of; // the expression in that context: they aren't relevant because they; // will never be constructed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:342,Availability,error,error,342,"/// Require that all of the parameter types of function be complete. Normally,; /// parameter types are only required to be complete when a function is called; /// or defined, but to mangle functions with certain calling conventions, the; /// mangler needs to know the size of the parameter list. In this situation,; /// MSVC doesn't emit an error or instantiate templates. Instead, MSVC mangles; /// the function as _foo@0, i.e. zero bytes of parameters, which will usually; /// result in a linker error. Clang doesn't implement this behavior, and instead; /// attempts to error at compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:499,Availability,error,error,499,"/// Require that all of the parameter types of function be complete. Normally,; /// parameter types are only required to be complete when a function is called; /// or defined, but to mangle functions with certain calling conventions, the; /// mangler needs to know the size of the parameter list. In this situation,; /// MSVC doesn't emit an error or instantiate templates. Instead, MSVC mangles; /// the function as _foo@0, i.e. zero bytes of parameters, which will usually; /// result in a linker error. Clang doesn't implement this behavior, and instead; /// attempts to error at compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:574,Availability,error,error,574,"/// Require that all of the parameter types of function be complete. Normally,; /// parameter types are only required to be complete when a function is called; /// or defined, but to mangle functions with certain calling conventions, the; /// mangler needs to know the size of the parameter list. In this situation,; /// MSVC doesn't emit an error or instantiate templates. Instead, MSVC mangles; /// the function as _foo@0, i.e. zero bytes of parameters, which will usually; /// result in a linker error. Clang doesn't implement this behavior, and instead; /// attempts to error at compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Integrability,depend,dependent,75,"/// Declarations in this context are formally odr-used, but this is a; /// dependent context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Modifiability,variab,variables,81,/// Are we within a context in which references to resolved functions or to; /// variables result in odr-use?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:706,Modifiability,variab,variable,706,"// Determine whether we require a function definition to exist, per; // C++11 [temp.inst]p3:; // Unless a function template specialization has been explicitly; // instantiated or explicitly specialized, the function template; // specialization is implicitly instantiated when the specialization is; // referenced in a context that requires a function definition to exist.; // C++20 [temp.inst]p7:; // The existence of a definition of a [...] function is considered to; // affect the semantics of the program if the [...] function is needed for; // constant evaluation by an expression; // C++20 [basic.def.odr]p10:; // Every program shall contain exactly one definition of every non-inline; // function or variable that is odr-used in that program outside of a; // discarded statement; // C++20 [special]p1:; // The implementation will implicitly define [defaulted special members]; // if they are odr-used or needed for constant evaluation.; //; // Note that we skip the implicit instantiation of templates that are only; // used in unused default arguments or by recursive calls to themselves.; // This is formally non-conforming, but seems reasonable in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,Safety,avoid,avoid,58,"// Do not defer instantiations of constexpr functions, to avoid the; // expression evaluator needing to call back into Sema if it sees a; // call to such a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:346,Availability,redundant,redundant,346,"// In the MS C++ ABI, the compiler emits destructor variants where they are; // used. If the destructor is used here but defined elsewhere, mark the; // virtual base destructors referenced. If those virtual base destructors; // are inline, this will ensure they are defined when emitting the complete; // destructor variant. This checking may be redundant if the destructor is; // provided later in this TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:346,Safety,redund,redundant,346,"// In the MS C++ ABI, the compiler emits destructor variants where they are; // used. If the destructor is used here but defined elsewhere, mark the; // virtual base destructors referenced. If those virtual base destructors; // are inline, this will ensure they are defined when emitting the complete; // destructor variant. This checking may be redundant if the destructor is; // provided later in this TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Modifiability,variab,variable,20,"/// Directly mark a variable odr-used. Given a choice, prefer to use; /// MarkVariableReferenced since it does additional checks and then; /// calls MarkVarDeclODRUsed.; /// If the variable must be captured:; /// - if FunctionScopeIndexToStopAt is null, capture it in the CurContext; /// - else capture it in the DeclContext that maps to the; /// *FunctionScopeIndexToStopAt on the FunctionScopeInfo stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:181,Modifiability,variab,variable,181,"/// Directly mark a variable odr-used. Given a choice, prefer to use; /// MarkVariableReferenced since it does additional checks and then; /// calls MarkVarDeclODRUsed.; /// If the variable must be captured:; /// - if FunctionScopeIndexToStopAt is null, capture it in the CurContext; /// - else capture it in the DeclContext that maps to the; /// *FunctionScopeIndexToStopAt on the FunctionScopeInfo stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:36,Modifiability,variab,variables,36,// Keep track of used but undefined variables.; // FIXME: We shouldn't suppress this warning for static data members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Modifiability,variab,variables,35,// Diagnose ODR-use of host global variables in device functions.; // Reference of device global variables in host functions is allowed; // through shadow variables therefore it is not diagnosed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:97,Modifiability,variab,variables,97,// Diagnose ODR-use of host global variables in device functions.; // Reference of device global variables in host functions is allowed; // through shadow variables therefore it is not diagnosed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:155,Modifiability,variab,variables,155,// Diagnose ODR-use of host global variables in device functions.; // Reference of device global variables in host functions is allowed; // through shadow variables therefore it is not diagnosed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:2,Modifiability,variab,variable,2,/*variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Modifiability,variab,variable,33,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:116,Modifiability,variab,variable,116,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:303,Modifiability,variab,variable,303,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:418,Modifiability,variab,variables,418,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:505,Modifiability,variab,variable,505,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:359,Modifiability,variab,variable,359,"// For C code, don't diagnose about capture if we're not actually in code; // right now; it's impossible to write a non-constant expression outside of; // function context, so we'll get other (more useful) diagnostics later.; //; // For C++, things get a bit more nasty... it would be nice to suppress this; // diagnostic for certain cases like using a local variable in an array bound; // for a member of a local class, but the correct predicate is not obvious.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:38,Modifiability,variab,variable,38,// Retrieve the capture type for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:57,Modifiability,variab,variable,57,// Compute the type of an expression that refers to this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:101,Modifiability,variab,variables,101,"// Certain capturing entities (lambdas, blocks etc.) are not allowed to capture; // certain types of variables (unnamed, variably modified types etc.); // so check for eligibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:121,Modifiability,variab,variably,121,"// Certain capturing entities (lambdas, blocks etc.) are not allowed to capture; // certain types of variables (unnamed, variably modified types etc.); // so check for eligibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:46,Modifiability,variab,variables,46,"// Lambdas are not allowed to capture unnamed variables; // (e.g. anonymous unions).; // FIXME: The C++11 rule don't actually state this explicitly, but I'm; // assuming that's the intent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:12,Modifiability,variab,variably-modified,12,// Prohibit variably-modified types in blocks; they're difficult to deal with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Modifiability,flexible,flexible,25,// Prohibit structs with flexible array members too.; // We cannot capture what is in the tail end of the struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:74,Modifiability,variab,variables,74,// Lambdas and captured statements are not allowed to capture __block; // variables; they don't support the expected semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Modifiability,variab,variables,45,// Forbid the block-capture of autoreleasing variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variable,24,// Actually capture the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:22,Modifiability,variab,variable,22,/// Capture the given variable in the captured region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:23,Modifiability,variab,variables,23,"// By default, capture variables by reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variable,24,// Actually capture the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:22,Modifiability,variab,variable,22,/// Capture the given variable in the lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:56,Modifiability,variab,variable,56,// Compute the type of the field that will capture this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:319,Usability,clear,clear,319,"// C++11 [expr.prim.lambda]p15:; // An entity is captured by reference if it is implicitly or; // explicitly captured but not captured by copy. It is; // unspecified whether additional unnamed non-static data; // members are declared in the closure type for entities; // captured by reference.; //; // FIXME: It is not clear whether we want to build an lvalue reference; // to the DeclRefType or to CaptureType.getNonReferenceType(). GCC appears; // to do the former, while EDG does the latter. Core issue 1249 will; // clarify, but for now we follow GCC because it's a more permissive and; // easily defensible position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Modifiability,variab,variables,51,// Forbid the lambda copy-capture of autoreleasing variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Modifiability,variab,variable,52,// Compute the type of a reference to this captured variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:40,Integrability,depend,dependent,40,// Offer a Copy fix even if the type is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:284,Modifiability,variab,variable,284,"/// Create up to 4 fix-its for explicit reference and value capture of \p Var or; /// default capture. Fixes may be omitted if they aren't allowed by the; /// standard, for example we can't emit a default copy capture fix-it if we; /// already explicitly copy capture capture another variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:53,Modifiability,variab,variable,53,"// Offer fixes to insert an explicit capture for the variable.; // [] -> [VarName]; // [OtherCapture] -> [OtherCapture, VarName]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:142,Modifiability,variab,variables,142,"// tryCaptureVariable is called every time a DeclRef is formed,; // it can therefore have non-negigible impact on performances.; // For local variables and when there is no capturing scope,; // we can bailout early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:114,Performance,perform,performances,114,"// tryCaptureVariable is called every time a DeclRef is formed,; // it can therefore have non-negigible impact on performances.; // For local variables and when there is no capturing scope,; // we can bailout early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Modifiability,variab,variables,18,// Capture global variables if it is required to use private copy of this; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:78,Modifiability,variab,variable,78,// Capture global variables if it is required to use private copy of this; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:117,Integrability,depend,depend,117,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:61,Modifiability,variab,variable,61,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:193,Modifiability,variab,variable,193,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:242,Modifiability,variab,variable,242,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:426,Modifiability,variab,variable,426,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:476,Modifiability,variab,variable,476,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:518,Modifiability,variab,variable,518,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Performance,perform,performing,75,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Usability,simpl,simple,91,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Modifiability,variab,variable,10,"// If the variable is declared in the current context, there is no need to; // capture it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:95,Modifiability,variab,variable,95,"// We need to check for the parent *first* because, if we *have*; // private-captured a global variable, we need to recursively capture it in; // intermediate blocks, lambdas, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:98,Modifiability,variab,variables,98,"// If we are instantiating a generic lambda call operator body,; // we do not want to capture new variables. What was captured; // during either a lambdas transformation or initial parsing; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Modifiability,variab,variable-length,18,// Try to capture variable-length arrays types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:23,Availability,down,down,23,// We're going to walk down into the type and look for VLA; // expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Modifiability,variab,variables,18,"// OpenMP private variables should not be captured in outer scope, so; // just break here. Similarly, global variables that are captured in a; // target region should not be captured outside the scope of the region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:109,Modifiability,variab,variables,109,"// OpenMP private variables should not be captured in outer scope, so; // just break here. Similarly, global variables that are captured in a; // target region should not be captured outside the scope of the region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Modifiability,variab,variable,10,"// If the variable is private (i.e. not captured) and has variably; // modified type, we still need to capture the type for correct; // codegen in all regions, associated with the construct. Currently,; // it is captured in the innermost captured region only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,Modifiability,variab,variably,58,"// If the variable is private (i.e. not captured) and has variably; // modified type, we still need to capture the type for correct; // codegen in all regions, associated with the construct. Currently,; // it is captured in the innermost captured region only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:11,Safety,detect,detect,11,"// When we detect target captures we are looking from inside the; // target region, therefore we need to propagate the capture from the; // enclosing region. Therefore, the capture is not initially nested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:86,Modifiability,variab,variable,86,"// No capture-default, and this is not an explicit capture; // so cannot capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Availability,error,error,16,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:83,Modifiability,variab,variable,83,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:336,Modifiability,variab,variable,336,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:471,Modifiability,Variab,VariableCaptureWasInitiallyExplicit,471,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:653,Modifiability,variab,variable,653,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:549,Performance,cache,cache,549,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,Availability,down,down,13,"// Walk back down the scope stack, (e.g. from outer lambda to inner lambda); // computing the type of the capture at each step, checking type-specific; // requirements, and adding captures if requested.; // If the variable had already been captured previously, we start capturing; // at the lambda nested within that one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:214,Modifiability,variab,variable,214,"// Walk back down the scope stack, (e.g. from outer lambda to inner lambda); // computing the type of the capture at each step, checking type-specific; // requirements, and adding captures if requested.; // If the variable had already been captured previously, we start capturing; // at the lambda nested within that one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:101,Modifiability,variab,variables,101,"// Certain capturing entities (lambdas, blocks etc.) are not allowed to capture; // certain types of variables (unnamed, variably modified types etc.); // so check for eligibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:121,Modifiability,variab,variably,121,"// Certain capturing entities (lambdas, blocks etc.) are not allowed to capture; // certain types of variables (unnamed, variably modified types etc.); // so check for eligibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Availability,error,error,25,"// After encountering an error, if we're actually supposed to capture, keep; // capturing in nested contexts to suppress any follow-on diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Modifiability,variab,variable,41,// Determine whether we can capture this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:284,Availability,error,error,284,"/// Walk the set of potential results of an expression and mark them all as; /// non-odr-uses if they satisfy the side-conditions of the NonOdrUseReason.; ///; /// \return A new expression if we found any potential results, ExprEmpty() if; /// not, and ExprError() if we diagnosed an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,"// Per C++11 [basic.def.odr], a variable is odr-used ""unless it is; // an object that satisfies the requirements for appearing in a; // constant expression (5.19) and the lvalue-to-rvalue conversion (4.1); // is immediately applied."" This function handles the lvalue-to-rvalue; // conversion part.; //; // If we encounter a node that claims to be an odr-use but shouldn't be, we; // transform it into the relevant kind of non-odr-use node and rebuild the; // tree of nodes leading to it.; //; // This is a mini-TreeTransform that only transforms a restricted subset of; // nodes (and only certain operands of them).; // Rebuild a subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variable,34,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:213,Modifiability,variab,variable,213,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:510,Modifiability,variab,variable,510,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Usability,usab,usable,164,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:252,Usability,usab,usable,252,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Security,access,access,29,// -- If e is a class member access expression [...] naming a non-static; // data member...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Security,access,access,29,"// -- If e is a class member access expression naming a static data member,; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Modifiability,variab,variable,48,"// If a constant-expression is a reference to a variable where we delay; // deciding whether it is an odr-use, just assume we will apply the; // lvalue-to-rvalue conversion. In the one case where this doesn't happen; // (a non-type template argument), we have special handling anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:8,Modifiability,variab,variable,8,"// If a variable could potentially be odr-used, defer marking it so; // until we finish analyzing the full expression for any; // lvalue-to-rvalue; // or discarded value conversions that would obviate odr-use.; // Add it to the list of potential captures that will be analyzed; // later (ActOnFinishFullExpr) for eventual capture and odr-use marking; // unless the variable is a reference that was initialized by a constant; // expression (this will never need to be captured or odr-used).; //; // FIXME: We can simplify this a lot after implementing P0588R1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:365,Modifiability,variab,variable,365,"// If a variable could potentially be odr-used, defer marking it so; // until we finish analyzing the full expression for any; // lvalue-to-rvalue; // or discarded value conversions that would obviate odr-use.; // Add it to the list of potential captures that will be analyzed; // later (ActOnFinishFullExpr) for eventual capture and odr-use marking; // unless the variable is a reference that was initialized by a constant; // expression (this will never need to be captured or odr-used).; //; // FIXME: We can simplify this a lot after implementing P0588R1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:512,Usability,simpl,simplify,512,"// If a variable could potentially be odr-used, defer marking it so; // until we finish analyzing the full expression for any; // lvalue-to-rvalue; // or discarded value conversions that would obviate odr-use.; // Add it to the list of potential captures that will be analyzed; // later (ActOnFinishFullExpr) for eventual capture and odr-use marking; // unless the variable is a reference that was initialized by a constant; // expression (this will never need to be captured or odr-used).; //; // FIXME: We can simplify this a lot after implementing P0588R1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,// C++20 [expr.const]p12:; // A variable [...] is needed for constant evaluation if it is [...] a; // variable whose name appears as a potentially constant evaluated; // expression that is either a contexpr variable or is of non-volatile; // const-qualified integral type or of reference type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Modifiability,variab,variable,102,// C++20 [expr.const]p12:; // A variable [...] is needed for constant evaluation if it is [...] a; // variable whose name appears as a potentially constant evaluated; // expression that is either a contexpr variable or is of non-volatile; // const-qualified integral type or of reference type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:207,Modifiability,variab,variable,207,// C++20 [expr.const]p12:; // A variable [...] is needed for constant evaluation if it is [...] a; // variable whose name appears as a potentially constant evaluated; // expression that is either a contexpr variable or is of non-volatile; // const-qualified integral type or of reference type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:140,Modifiability,variab,variable,140,"// If this might be a member specialization of a static data member, check; // the specialization is visible. We already did the checks for variable; // template specializations when we created them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:115,Modifiability,variab,variable,115,"// Perform implicit instantiation of static data members, static data member; // templates of class templates, and variable template specializations. Delay; // instantiations of variable templates, except for those that could be used; // in a constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:178,Modifiability,variab,variable,178,"// Perform implicit instantiation of static data members, static data member; // templates of class templates, and variable template specializations. Delay; // instantiations of variable templates, except for those that could be used; // in a constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,"// Perform implicit instantiation of static data members, static data member; // templates of class templates, and variable template specializations. Delay; // instantiations of variable templates, except for those that could be used; // in a constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:107,Modifiability,variab,variable,107,"// Per C++17 [temp.explicit]p10, we may instantiate despite an explicit; // instantiation declaration if a variable is usable in a constant; // expression (among other cases).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,Usability,usab,usable,119,"// Per C++17 [temp.explicit]p10, we may instantiate despite an explicit; // instantiation declaration if a variable is usable in a constant; // expression (among other cases).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variables,34,// Do not defer instantiations of variables that could be used in a; // constant expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Integrability,depend,dependence,55,// Re-set the member to trigger a recomputation of the dependence bits; // for the expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:36,Modifiability,variab,variable,36,"// FIXME: For a specialization of a variable template, we don't; // distinguish between ""declaration and type implicitly instantiated""; // and ""implicit instantiation of definition requested"", so we have; // no direct way to avoid enqueueing the pending instantiation; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:225,Safety,avoid,avoid,225,"// FIXME: For a specialization of a variable template, we don't; // distinguish between ""declaration and type implicitly instantiated""; // and ""implicit instantiation of definition requested"", so we have; // no direct way to avoid enqueueing the pending instantiation; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variable,34,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:209,Modifiability,variab,variable,209,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:510,Modifiability,variab,variable,510,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:913,Modifiability,variab,variables,913,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Usability,usab,usable,164,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:248,Usability,usab,usable,248,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:936,Usability,usab,usable,936,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Modifiability,variab,variable,20,"// In some cases, a variable may not have been marked unevaluated, if it; // appears in a defaukt initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Integrability,depend,dependent,16,"// If this is a dependent context, we don't need to mark variables as; // odr-used, but we may still need to track them for lambda capture.; // FIXME: Do we also need to do this inside dependent typeid expressions; // (which are modeled as unevaluated at this point)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:185,Integrability,depend,dependent,185,"// If this is a dependent context, we don't need to mark variables as; // odr-used, but we may still need to track them for lambda capture.; // FIXME: Do we also need to do this inside dependent typeid expressions; // (which are modeled as unevaluated at this point)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:57,Modifiability,variab,variables,57,"// If this is a dependent context, we don't need to mark variables as; // odr-used, but we may still need to track them for lambda capture.; // FIXME: Do we also need to do this inside dependent typeid expressions; // (which are modeled as unevaluated at this point)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:11,Modifiability,variab,variable,11,"/// Mark a variable referenced, and check whether it is odr-used; /// (C++ [basic.def.odr]p2, C99 6.9p3). Note that this should not be; /// used directly for normal expressions referring to VarDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Integrability,depend,dependent,55,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with an entity captured by copy; // in a lambda-expression that has an explicit object parameter whose type; // is dependent ([dcl.fct]),",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:242,Integrability,depend,dependent,242,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with an entity captured by copy; // in a lambda-expression that has an explicit object parameter whose type; // is dependent ([dcl.fct]),",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Integrability,depend,dependence,106,"/// Perform reference-marking and odr-use handling for a DeclRefExpr.; ///; /// Note, this may change the dependence of the DeclRefExpr, and so needs to be; /// handled with care if the DeclRefExpr is not newly-created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Performance,Perform,Perform,4,"/// Perform reference-marking and odr-use handling for a DeclRefExpr.; ///; /// Note, this may change the dependence of the DeclRefExpr, and so needs to be; /// handled with care if the DeclRefExpr is not newly-created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Deployability,update,update,9,"// TODO: update this with DR# once a defect report is filed.; // C++11 defect. The address of a pure member should not be an ODR use, even; // if it's a qualified reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Performance,Perform,Perform,4,/// Perform reference-marking and odr-use handling for a MemberExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Performance,Perform,Perform,4,/// Perform reference-marking and odr-use handling for a FunctionParmPackExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:160,Modifiability,variab,variables,160,"/// Perform marking for a reference to an arbitrary declaration. It; /// marks the declaration referenced, and performs odr-use checking for; /// functions and variables. This method should not be used when building a; /// normal expression which refers to a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:259,Modifiability,variab,variable,259,"/// Perform marking for a reference to an arbitrary declaration. It; /// marks the declaration referenced, and performs odr-use checking for; /// functions and variables. This method should not be used when building a; /// normal expression which refers to a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Performance,Perform,Perform,4,"/// Perform marking for a reference to an arbitrary declaration. It; /// marks the declaration referenced, and performs odr-use checking for; /// functions and variables. This method should not be used when building a; /// normal expression which refers to a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:111,Performance,perform,performs,111,"/// Perform marking for a reference to an arbitrary declaration. It; /// marks the declaration referenced, and performs odr-use checking for; /// functions and variables. This method should not be used when building a; /// normal expression which refers to a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:381,Testability,log,logic,381,"// Mark all of the declarations used by a type as referenced.; // FIXME: Not fully implemented yet! We need to have a better understanding; // of when we're entering a context we should not recurse into.; // FIXME: This is and EvaluatedExprMarker are more-or-less equivalent to; // TreeTransforms rebuilding the type in a new context. Rather than; // duplicating the TreeTransform logic, we should consider reusing it here.; // Currently that causes problems when rebuilding LambdaExprs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Modifiability,variab,variables,39,"// If we were asked not to visit local variables, don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:147,Availability,error,error-dependent,147,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:130,Integrability,depend,dependent,130,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:153,Integrability,depend,dependent,153,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:196,Integrability,depend,dependence,196,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:73,Modifiability,variab,variable,73,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:203,Modifiability,variab,variables,203,"// namespace; /// Mark any declarations that appear within this expression or any; /// potentially-evaluated subexpressions as ""referenced"".; ///; /// \param SkipLocalVariables If true, don't mark local variables as; /// 'referenced'.; /// \param StopAt Subexpressions that we shouldn't recurse into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variable,34,"// The initializer of a constexpr variable or of the first declaration of a; // static data member is not syntactically a constant evaluated constant,; // but nonetheless is always required to be a constant expression, so we; // can skip diagnosing.; // FIXME: Using the mangling context here is a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,"// FIXME: For any other kind of variable, we should build a CFG for its; // initializer and check whether the context in question is reachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:815,Availability,Failure,Failure,815,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:878,Availability,failure,failures,878,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:123,Integrability,rout,routine,123,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:443,Integrability,rout,routine,443,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:659,Integrability,rout,routine,659,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:588,Performance,queue,queue,588,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Availability,Redundant,Redundant,4,/// Redundant parentheses over an equality comparison can indicate; /// that the user intended an assignment used as condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Safety,Redund,Redundant,4,/// Redundant parentheses over an equality comparison can indicate; /// that the user intended an assignment used as condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Integrability,depend,dependent,18,// Don't warn for dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Integrability,wrap,wraps,52,/// Rebuild an expression which simply semantically wraps another; /// expression which it shares the type and value kind of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Usability,simpl,simply,32,/// Rebuild an expression which simply semantically wraps another; /// expression which it shares the type and value kind of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Integrability,wrap,wraps,52,/// Rebuild an expression which simply semantically wraps another; /// expression which it shares the type and value kind of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Usability,simpl,simply,32,/// Rebuild an expression which simply semantically wraps another; /// expression which it shares the type and value kind of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:377,Modifiability,portab,portably,377,"// __unknown_anytype(...) is a special case used by the debugger when; // it has no idea what a function's signature is.; //; // We want to build this call essentially under the K&R; // unprototyped rules, but making a FunctionNoProtoType in C++; // would foul up all sorts of assumptions. However, we cannot; // simply pass all arguments as variadic arguments, nor can we; // portably just call the function under a non-variadic type; see; // the comment on IR-gen's TargetInfo::isNoProtoCallVariadic.; // However, it turns out that in practice it is generally safe to; // call a function declared as ""A foo(B,C,D);"" under the prototype; // ""A foo(B,C,D,...);"". The only known exception is with the; // Windows ABI, where any variadic function is implicitly cdecl; // regardless of its normal CC. Therefore we change the parameter; // types to match the types of the arguments.; //; // This is a hack, but it is far superior to moving the; // corresponding target-specific code from IR-gen to Sema/AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:562,Safety,safe,safe,562,"// __unknown_anytype(...) is a special case used by the debugger when; // it has no idea what a function's signature is.; //; // We want to build this call essentially under the K&R; // unprototyped rules, but making a FunctionNoProtoType in C++; // would foul up all sorts of assumptions. However, we cannot; // simply pass all arguments as variadic arguments, nor can we; // portably just call the function under a non-variadic type; see; // the comment on IR-gen's TargetInfo::isNoProtoCallVariadic.; // However, it turns out that in practice it is generally safe to; // call a function declared as ""A foo(B,C,D);"" under the prototype; // ""A foo(B,C,D,...);"". The only known exception is with the; // Windows ABI, where any variadic function is implicitly cdecl; // regardless of its normal CC. Therefore we change the parameter; // types to match the types of the arguments.; //; // This is a hack, but it is far superior to moving the; // corresponding target-specific code from IR-gen to Sema/AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:313,Usability,simpl,simply,313,"// __unknown_anytype(...) is a special case used by the debugger when; // it has no idea what a function's signature is.; //; // We want to build this call essentially under the K&R; // unprototyped rules, but making a FunctionNoProtoType in C++; // would foul up all sorts of assumptions. However, we cannot; // simply pass all arguments as variadic arguments, nor can we; // portably just call the function under a non-variadic type; see; // the comment on IR-gen's TargetInfo::isNoProtoCallVariadic.; // However, it turns out that in practice it is generally safe to; // call a function declared as ""A foo(B,C,D);"" under the prototype; // ""A foo(B,C,D,...);"". The only known exception is with the; // Windows ABI, where any variadic function is implicitly cdecl; // regardless of its normal CC. Therefore we change the parameter; // types to match the types of the arguments.; //; // This is a hack, but it is far superior to moving the; // corresponding target-specific code from IR-gen to Sema/AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Availability,avail,available,37,// Rewrite the method result type if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the method result type if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Integrability,message,message,26,// Change the type of the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:184,Integrability,rout,routine,184,// We must match the FunctionDecl's type to the hack introduced in; // RebuildUnknownAnyExpr::VisitCallExpr to vararg functions of unknown; // type. See the lengthy commentary in that routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:5,Modifiability,variab,variables,5,// - variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the casted expression from scratch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Availability,recover,recoverable,9,// Never recoverable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Safety,recover,recoverable,9,// Never recoverable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,Availability,error,error,110,/// Check for operands with placeholder types and complain if found.; /// Returns ExprError() if there was an error and no recovery was possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:123,Availability,recover,recovery,123,/// Check for operands with placeholder types and complain if found.; /// Returns ExprError() if there was an error and no recovery was possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:123,Safety,recover,recovery,123,/// Check for operands with placeholder types and complain if found.; /// Returns ExprError() if there was an error and no recovery was possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:90,Integrability,depend,dependent,90,"// C cannot handle TypoExpr nodes on either side of a binop because it; // doesn't handle dependent types properly, so make sure any TypoExprs have; // been dealt with before checking the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:103,Availability,failure,failure,103,// No guarantees that ResolveAndFixSingleFunctionTemplateSpecialization; // leaves Result unchanged on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Availability,recover,recover,26,"// If that failed, try to recover with a call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Safety,recover,recover,26,"// If that failed, try to recover with a call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Availability,avail,availability,24,"// Transcribe the ""ios"" availability check to ""maccatalyst"" when compiling; // for ""maccatalyst"" if ""maccatalyst"" is not specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Availability,avail,available,16,// The use of `@available` in the enclosing context should be analyzed to; // warn when it's used inappropriately (i.e. not if(@available)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:128,Availability,avail,available,128,// The use of `@available` in the enclosing context should be analyzed to; // warn when it's used inappropriately (i.e. not if(@available)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Integrability,depend,dependent,48,"// We don't know the concrete type, fallback to dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:58,Modifiability,inherit,inheriting,58,"/// Handle the result of the special case name lookup for inheriting; /// constructor declarations. 'NS::X::X' and 'NS::X<...>::X' are treated as; /// constructor names in member using declarations, even if 'X' is not the; /// name of the corresponding type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:46,Integrability,depend,dependent,46,"// When naming a constructor as a member of a dependent context (eg, in a; // friend declaration or an inherited constructor declaration), form an; // unresolved ""typename"" type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:103,Modifiability,inherit,inherited,103,"// When naming a constructor as a member of a dependent context (eg, in a; // friend declaration or an inherited constructor declaration), form an; // unresolved ""typename"" type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:12,Integrability,inject,injected-class-name,12,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,Integrability,inject,injected-class-name,106,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:192,Integrability,inject,injected-class-name,192,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:12,Security,inject,injected-class-name,12,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,Security,inject,injected-class-name,106,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:192,Security,inject,injected-class-name,192,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:51,Integrability,depend,dependent,51,// FIXME: RequireCompleteDeclContext doesn't check dependent contexts; // properly. Work around it here for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:22,Performance,perform,perform,22,"// Determine where to perform name lookup.; // FIXME: This area of the standard is very messy, and the current; // wording is rather unclear about which scopes we search for the; // destructor name; see core issues 399 and 555. Issue 399 in; // particular shows where the current description of destructor name; // lookup is completely out of line with existing practice, e.g.,; // this appears to be ill-formed:; //; // namespace N {; // template <typename T> struct S {; // ~S();; // };; // }; //; // void f(N::S<int>* s) {; // s->N::S<int>::~S();; // }; //; // See also PR6358 and PR6359.; //; // For now, we accept all the cases in which the name given could plausibly; // be interpreted as a correct destructor name, issuing off-by-default; // extension diagnostics on the cases that don't strictly conform to the; // C++20 rules. This basically means we always consider looking in the; // nested-name-specifier prefix, the complete nested-name-specifier, and; // the scope, and accept if we find the expected type in any of the three; // places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:100,Security,access,access,100,"// If we have an object type, it's because we are in a; // pseudo-destructor-expression or a member access expression, and; // we know what type we're looking for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:42,Availability,failure,failure,42,// Don't list a class twice in the lookup failure diagnostic if it's; // found by both its injected-class-name and by the name in the enclosing; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:91,Integrability,inject,injected-class-name,91,// Don't list a class twice in the lookup failure diagnostic if it's; // found by both its injected-class-name and by the name in the enclosing; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:91,Security,inject,injected-class-name,91,// Don't list a class twice in the lookup failure diagnostic if it's; // found by both its injected-class-name and by the name in the enclosing; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:155,Usability,clear,clear,155,"// As an extension, attempt to ""fix"" an ambiguity by erasing all non-type; // results, and all non-matching results if we have a search type. It's not; // clear what the right behavior is if destructor lookup hits an ambiguity,; // but other compilers do generally accept at least some kinds of; // ambiguity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:1391,Integrability,depend,dependent,1391,"// C++2a [basic.lookup.qual]p6:; // In a qualified-id of the form; //; // nested-name-specifier[opt] type-name :: ~ type-name; //; // the second type-name is looked up in the same scope as the first.; //; // We interpret this as meaning that if you do a dual-scope lookup for the; // first name, you also do a dual-scope lookup for the second name, per; // C++ [basic.lookup.classref]p4:; //; // If the id-expression in a class member access is a qualified-id of the; // form; //; // class-name-or-namespace-name :: ...; //; // the class-name-or-namespace-name following the . or -> is first looked; // up in the class of the object expression and the name, if found, is used.; // Otherwise, it is looked up in the context of the entire; // postfix-expression.; //; // This looks in the same scopes as for an unqualified destructor name:; //; // C++ [basic.lookup.classref]p3:; // If the unqualified-id is ~ type-name, the type-name is looked up; // in the context of the entire postfix-expression. If the type T; // of the object expression is of a class type C, the type-name is; // also looked up in the scope of class C. At least one of the; // lookups shall find a name that refers to cv T.; //; // FIXME: The intent is unclear here. Should type-name::~type-name look in; // the scope anyway if it finds a non-matching name declared in the class?; // If both lookups succeed and find a dependent result, which result should; // we retain? (Same question for p->~type-name().)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:435,Security,access,access,435,"// C++2a [basic.lookup.qual]p6:; // In a qualified-id of the form; //; // nested-name-specifier[opt] type-name :: ~ type-name; //; // the second type-name is looked up in the same scope as the first.; //; // We interpret this as meaning that if you do a dual-scope lookup for the; // first name, you also do a dual-scope lookup for the second name, per; // C++ [basic.lookup.classref]p4:; //; // If the id-expression in a class member access is a qualified-id of the; // form; //; // class-name-or-namespace-name :: ...; //; // the class-name-or-namespace-name following the . or -> is first looked; // up in the class of the object expression and the name, if found, is used.; // Otherwise, it is looked up in the context of the entire; // postfix-expression.; //; // This looks in the same scopes as for an unqualified destructor name:; //; // C++ [basic.lookup.classref]p3:; // If the unqualified-id is ~ type-name, the type-name is looked up; // in the context of the entire postfix-expression. If the type T; // of the object expression is of a class type C, the type-name is; // also looked up in the scope of class C. At least one of the; // lookups shall find a name that refers to cv T.; //; // FIXME: The intent is unclear here. Should type-name::~type-name look in; // the scope anyway if it finds a non-matching name declared in the class?; // If both lookups succeed and find a dependent result, which result should; // we retain? (Same question for p->~type-name().)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:48,Integrability,depend,dependent,48,"// We didn't find our type, but that's OK: it's dependent anyway.; // FIXME: What if we have no nested-name-specifier?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:236,Integrability,depend,dependent,236,"// For compatibility with other compilers and older versions of Clang,; //; // nested-name-specifier type-name :: ~ type-name; //; // also looks for type-name in the scope. Unfortunately, we can't; // reasonably apply this fallback for dependent nested-name-specifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:250,Integrability,depend,dependent,250,"// Per C++11 [over.literal]p2, literal operators can only be declared at; // namespace scope. Therefore, this unqualified-id cannot name anything.; // Reject it early, because we have no AST representation for this in the; // case where the scope is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:99,Modifiability,polymorphi,polymorphic,99,// C++ [expr.typeid]p3:; // When typeid is applied to an expression other than an glvalue of a; // polymorphic class type [...] [the] expression is an unevaluated; // operand. [...],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:92,Usability,GUID,GUID,92,"/// Grabs __declspec(uuid()) off a type, or returns 0 if we cannot resolve to; /// a single GUID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:334,Modifiability,extend,extend,334,"// C++0x [class.copymove]p31:; // When certain criteria are met, an implementation is allowed to omit the; // copy/move construction of a class object [...]; //; // - in a throw-expression, when the operand is the name of a; // non-volatile automatic object (other than a function or catch-; // clause parameter) whose scope does not extend beyond the end of the; // innermost enclosing try-block (if there is one), the copy/move; // operation from the operand to the exception object (15.1) can be; // omitted by constructing the automatic object directly into the; // exception object",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:19,Availability,error,error,19,// Don't report an error if 'throw' is used in system headers or in an OpenMP; // target region compiled for a GPU architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:9,Availability,error,error,9,// Delay error emission for the OpenMP device code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:465,Modifiability,extend,extend,465,"// Initialize the exception result. This implicitly weeds out; // abstract types or types with inaccessible copy constructors.; // C++0x [class.copymove]p31:; // When certain criteria are met, an implementation is allowed to omit the; // copy/move construction of a class object [...]; //; // - in a throw-expression, when the operand is the name of a; // non-volatile automatic object (other than a function or; // catch-clause; // parameter) whose scope does not extend beyond the end of the; // innermost enclosing try-block (if there is one), the copy/move; // operation from the operand to the exception object (15.1) can be; // omitted by constructing the automatic object directly into the; // exception object",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:41,Security,access,access,41,// Only add subobjects which have public access throughout the entire chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:27,Security,Validat,Validate,27,/// CheckCXXThrowOperand - Validate the operand of a throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:24,Modifiability,polymorphi,polymorphic,24,"// If we are throwing a polymorphic class type or pointer thereof,; // exception handling will make use of the vtable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:213,Performance,perform,perform,213,"// Attempt to lookup the copy constructor. Various pieces of machinery; // will spring into action, like template instantiation, which means this; // cannot be a simple walk of the class's decls. Instead, we must perform; // lookup and overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:162,Usability,simpl,simple,162,"// Attempt to lookup the copy constructor. Various pieces of machinery; // will spring into action, like template instantiation, which means this; // cannot be a simple walk of the class's decls. Instead, we must perform; // lookup and overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:213,Performance,perform,performed,213,"// The copy constructor is non-trivial, create a mapping from this class; // type to this constructor.; // N.B. The selection of copy constructor is not sensitive to this; // particular throw-site. Lookup will be performed at the catch-site to; // ensure that the copy constructor is, in fact, accessible (via; // friendship or any other means).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:294,Security,access,accessible,294,"// The copy constructor is non-trivial, create a mapping from this class; // type to this constructor.; // N.B. The selection of copy constructor is not sensitive to this; // particular throw-site. Lookup will be performed at the catch-site to; // ensure that the copy constructor is, in fact, accessible (via; // friendship or any other means).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:65,Energy Efficiency,allocate,allocated,65,"// Under the Itanium C++ ABI, memory for the exception object is allocated by; // the runtime with no ability for the compiler to request additional; // alignment. Warn if the exception type requires alignment beyond the minimum; // guaranteed by the target C++ runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:1181,Availability,reliab,reliably,1181,"// Iterate through the stack of lambdas starting from the innermost lambda to; // the outermost lambda, checking if '*this' is ever captured by copy - since; // that could change the cv-qualifiers of the '*this' object.; // The object referred to by '*this' starts out with the cv-qualifiers of its; // member function. We then start with the innermost lambda and iterate; // outward checking to see if any lambda performs a by-copy capture of '*this'; // - and if so, any nested lambda must respect the 'constness' of that; // capturing lamdbda's call operator.; //; // Since the FunctionScopeInfo stack is representative of the lexical; // nesting of the lambda expressions during initial parsing (and is the best; // place for querying information about captures about lambdas that are; // partially processed) and perhaps during instantiation of function templates; // that contain lambda expressions that need to be transformed BUT not; // necessarily during instantiation of a nested generic lambda's function call; // operator (which might even be instantiated at the end of the TU) - at which; // time the DeclContext tree is mature enough to query capture information; // reliably - we use a two pronged approach to walk through all the lexically; // enclosing lambda expressions:; //; // 1) Climb down the FunctionScopeInfo stack as long as each item represents; // a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically; // enclosed by the call-operator of the LSI below it on the stack (while; // tracking the enclosing DC for step 2 if needed). Note the topmost LSI on; // the stack represents the innermost lambda.; //; // 2) If we run out of enclosing LSI's, check if the enclosing DeclContext; // represents a lambda's call operator. If it does, we must be instantiating; // a generic lambda's call operator (represented by the Current LSI, and; // should be the only scenario where an inconsistency between the LSI and the; // DeclContext should occur), so climb o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:1307,Availability,down,down,1307,"// Iterate through the stack of lambdas starting from the innermost lambda to; // the outermost lambda, checking if '*this' is ever captured by copy - since; // that could change the cv-qualifiers of the '*this' object.; // The object referred to by '*this' starts out with the cv-qualifiers of its; // member function. We then start with the innermost lambda and iterate; // outward checking to see if any lambda performs a by-copy capture of '*this'; // - and if so, any nested lambda must respect the 'constness' of that; // capturing lamdbda's call operator.; //; // Since the FunctionScopeInfo stack is representative of the lexical; // nesting of the lambda expressions during initial parsing (and is the best; // place for querying information about captures about lambdas that are; // partially processed) and perhaps during instantiation of function templates; // that contain lambda expressions that need to be transformed BUT not; // necessarily during instantiation of a nested generic lambda's function call; // operator (which might even be instantiated at the end of the TU) - at which; // time the DeclContext tree is mature enough to query capture information; // reliably - we use a two pronged approach to walk through all the lexically; // enclosing lambda expressions:; //; // 1) Climb down the FunctionScopeInfo stack as long as each item represents; // a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically; // enclosed by the call-operator of the LSI below it on the stack (while; // tracking the enclosing DC for step 2 if needed). Note the topmost LSI on; // the stack represents the innermost lambda.; //; // 2) If we run out of enclosing LSI's, check if the enclosing DeclContext; // represents a lambda's call operator. If it does, we must be instantiating; // a generic lambda's call operator (represented by the Current LSI, and; // should be the only scenario where an inconsistency between the LSI and the; // DeclContext should occur), so climb o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2147,Availability,down,down,2147," cv-qualifiers of the '*this' object.; // The object referred to by '*this' starts out with the cv-qualifiers of its; // member function. We then start with the innermost lambda and iterate; // outward checking to see if any lambda performs a by-copy capture of '*this'; // - and if so, any nested lambda must respect the 'constness' of that; // capturing lamdbda's call operator.; //; // Since the FunctionScopeInfo stack is representative of the lexical; // nesting of the lambda expressions during initial parsing (and is the best; // place for querying information about captures about lambdas that are; // partially processed) and perhaps during instantiation of function templates; // that contain lambda expressions that need to be transformed BUT not; // necessarily during instantiation of a nested generic lambda's function call; // operator (which might even be instantiated at the end of the TU) - at which; // time the DeclContext tree is mature enough to query capture information; // reliably - we use a two pronged approach to walk through all the lexically; // enclosing lambda expressions:; //; // 1) Climb down the FunctionScopeInfo stack as long as each item represents; // a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically; // enclosed by the call-operator of the LSI below it on the stack (while; // tracking the enclosing DC for step 2 if needed). Note the topmost LSI on; // the stack represents the innermost lambda.; //; // 2) If we run out of enclosing LSI's, check if the enclosing DeclContext; // represents a lambda's call operator. If it does, we must be instantiating; // a generic lambda's call operator (represented by the Current LSI, and; // should be the only scenario where an inconsistency between the LSI and the; // DeclContext should occur), so climb out the DeclContexts if they; // represent lambdas, while querying the corresponding closure types; // regarding capture information.; // 1) Climb down the function scope info stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:414,Performance,perform,performs,414,"// Iterate through the stack of lambdas starting from the innermost lambda to; // the outermost lambda, checking if '*this' is ever captured by copy - since; // that could change the cv-qualifiers of the '*this' object.; // The object referred to by '*this' starts out with the cv-qualifiers of its; // member function. We then start with the innermost lambda and iterate; // outward checking to see if any lambda performs a by-copy capture of '*this'; // - and if so, any nested lambda must respect the 'constness' of that; // capturing lamdbda's call operator.; //; // Since the FunctionScopeInfo stack is representative of the lexical; // nesting of the lambda expressions during initial parsing (and is the best; // place for querying information about captures about lambdas that are; // partially processed) and perhaps during instantiation of function templates; // that contain lambda expressions that need to be transformed BUT not; // necessarily during instantiation of a nested generic lambda's function call; // operator (which might even be instantiated at the end of the TU) - at which; // time the DeclContext tree is mature enough to query capture information; // reliably - we use a two pronged approach to walk through all the lexically; // enclosing lambda expressions:; //; // 1) Climb down the FunctionScopeInfo stack as long as each item represents; // a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically; // enclosed by the call-operator of the LSI below it on the stack (while; // tracking the enclosing DC for step 2 if needed). Note the topmost LSI on; // the stack represents the innermost lambda.; //; // 2) If we run out of enclosing LSI's, check if the enclosing DeclContext; // represents a lambda's call operator. If it does, we must be instantiating; // a generic lambda's call operator (represented by the Current LSI, and; // should be the only scenario where an inconsistency between the LSI and the; // DeclContext should occur), so climb o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:144,Availability,recover,recover,144,"// This is a lambda call operator that is being instantiated as a default; // initializer. DC must point to the enclosing class type, so we can recover; // the 'this' type from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:144,Safety,recover,recover,144,"// This is a lambda call operator that is being instantiated as a default; // initializer. DC must point to the enclosing class type, so we can recover; // the 'this' type from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:33,Availability,Error,Error,33,"// [=, this] {}; // until C++20: Error: this when = is the default",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:164,Performance,perform,perform,164,"// Regarding (Explicit && idx == MaxFunctionScopesIndex): only the first; // iteration through can be an explicit capture, all enclosing closures,; // if any, must perform implicit captures.; // This closure can capture 'this'; continue looking upwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:29,Integrability,depend,dependent,29,// Avoid creating a non-type-dependent expression that contains typos.; // Non-type-dependent expressions are liable to be discarded without; // checking for embedded typos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:84,Integrability,depend,dependent,84,// Avoid creating a non-type-dependent expression that contains typos.; // Non-type-dependent expressions are liable to be discarded without; // checking for embedded typos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating a non-type-dependent expression that contains typos.; // Non-type-dependent expressions are liable to be discarded without; // checking for embedded typos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:92,Performance,perform,perform,92,"// C++17 [expr.type.conv]p1:; // If the type is a placeholder for a deduced class type, [...perform class; // template argument deduction...]; // C++23:; // Otherwise, if the type contains a placeholder type, it is replaced by the; // type determined by placeholder type deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:142,Performance,perform,performs,142,"// C++17 [expr.type.conv]p2:; // If the type is cv void and the initializer is (), the expression is a; // prvalue of the specified type that performs no initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:51,Modifiability,extend,extended,51,"// C++17 [expr.delete]p10:; // If the type has new-extended alignment, a function with a parameter; // of type std::align_val_t is preferred; otherwise a function without; // such a parameter is preferred",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:37,Modifiability,extend,extended,37,"/// Determine whether a type has new-extended alignment. This may be called when; /// the type is incomplete (for a delete-expression with an incomplete pointee; /// type), in which case it will conservatively return false if the alignment is; /// not known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:115,Energy Efficiency,allocate,allocate,115,"// If it's ambiguous, it should be illegal to call operator delete[]; // on this thing, so it doesn't matter if we allocate extra space or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:573,Energy Efficiency,allocate,allocated,573,"/// Parsed a C++ 'new' expression (C++ 5.3.4).; ///; /// E.g.:; /// @code new (memory) int[size][4] @endcode; /// or; /// @code ::new Foo(23, ""hello"") @endcode; ///; /// \param StartLoc The first location of the expression.; /// \param UseGlobal True if 'new' was prefixed with '::'.; /// \param PlacementLParen Opening paren of the placement arguments.; /// \param PlacementArgs Placement new arguments.; /// \param PlacementRParen Closing paren of the placement arguments.; /// \param TypeIdParens If the type is in parens, the source range.; /// \param D The type to be allocated, as well as array dimensions.; /// \param Initializer The initializing expression or initializer-list, or null; /// if there is none.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:110,Performance,perform,performed,110,"// - If the new-initializer is omitted, the object is default-; // initialized (8.5); if no initialization is performed,; // the object has indeterminate value",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:37,Energy Efficiency,allocate,allocated,37,"// In ARC, infer 'retaining' for the allocated",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:321,Performance,perform,performed,321,"// C++98 [expr.new]p7:; // The expression in a direct-new-declarator shall have integral type; // with a non-negative value.; //; // Let's see if this is a constant < 0. If so, we reject it out of hand,; // per CWG1464. Otherwise, if it's not a constant, we must have an; // unparenthesized array type.; // We've already performed any required implicit conversion to integer or; // unscoped enumeration type.; // FIXME: Per CWG1464, we are required to check the value prior to; // converting to size_t. This will never find a negative array size in; // C++14 onwards, because Value is always unsigned here!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:20,Performance,perform,perform,20,"// We would like to perform some checking on the given `operator new` call,; // but the PlacementArgs does not contain the implicit arguments,; // namely allocation size and maybe allocation alignment,; // so we need to conjure them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Energy Efficiency,allocate,allocate,32,// How many bytes do we want to allocate here?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:47,Energy Efficiency,allocate,allocate,47,"// For non-array operator new, we only want to allocate one element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:98,Energy Efficiency,allocate,allocate,98,"// Let's synthesize the alignment argument in case we will need it.; // Since we *really* want to allocate these on stack, this is slightly ugly; // because there might not be a `std::align_val_t` type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:49,Energy Efficiency,allocate,allocated,49,// Warn if the type is over-aligned and is being allocated by (unaligned); // global operator new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:13,Performance,perform,perform,13,"// If we can perform the initialization, and we've not already done so,; // do it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:42,Energy Efficiency,allocate,allocated,42,/// Checks that a type is suitable as the allocated type; /// in a new-expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:69,Energy Efficiency,allocate,allocated,69,"// C++17 [expr.new]p13:; // If no matching function is found and the allocated object type has; // new-extended alignment, the alignment argument is removed from the; // argument list, and overload resolution is performed again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:103,Modifiability,extend,extended,103,"// C++17 [expr.new]p13:; // If no matching function is found and the allocated object type has; // new-extended alignment, the alignment argument is removed from the; // argument list, and overload resolution is performed again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:212,Performance,perform,performed,212,"// C++17 [expr.new]p13:; // If no matching function is found and the allocated object type has; // new-extended alignment, the alignment argument is removed from the; // argument list, and overload resolution is performed again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:222,Energy Efficiency,allocate,allocated,222,"// --- Choosing an allocation function ---; // C++ 5.3.4p8 - 14 & 18; // 1) If looking in AFS_Global scope for allocation functions, only look in; // the global scope. Else, if AFS_Class, only look in the scope of the; // allocated class. If AFS_Both, look in both.; // 2) If an array size is given, look for operator new[], else look for; // operator new.; // 3) The first argument is always size_t. Append the arguments from the; // placement form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Energy Efficiency,allocate,allocated,32,"// C++ [expr.new]p8:; // If the allocated type is a non-array type, the allocation; // function's name is operator new and the deallocation function's; // name is operator delete. If the allocated type is an array; // type, the allocation function's name is operator new[] and the; // deallocation function's name is operator delete[].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:187,Energy Efficiency,allocate,allocated,187,"// C++ [expr.new]p8:; // If the allocated type is a non-array type, the allocation; // function's name is operator new and the deallocation function's; // name is operator delete. If the allocated type is an array; // type, the allocation function's name is operator new[] and the; // deallocation function's name is operator delete[].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:173,Energy Efficiency,allocate,allocated,173,"// C++1z [expr.new]p9:; // If the new-expression begins with a unary :: operator, the allocation; // function's name is looked up in the global scope. Otherwise, if the; // allocated type is a class type T or array thereof, the allocation; // function's name is looked up in the scope of T.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:52,Energy Efficiency,allocate,allocated,52,"// If this lookup fails to find the name, or if the allocated type is not; // a class type, the allocation function's name is looked up in the; // global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:24,Security,access,access,24,// We do our own custom access checks below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:178,Energy Efficiency,allocate,allocated,178,"// C++ [expr.new]p19:; //; // If the new-expression begins with a unary :: operator, the; // deallocation function's name is looked up in the global; // scope. Otherwise, if the allocated type is a class type T or an; // array thereof, the deallocation function's name is looked up in; // the scope of T. If this lookup fails to find the name, or if; // the allocated type is not a class type or array thereof, the; // deallocation function's name is looked up in the global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:358,Energy Efficiency,allocate,allocated,358,"// C++ [expr.new]p19:; //; // If the new-expression begins with a unary :: operator, the; // deallocation function's name is looked up in the global; // scope. Otherwise, if the allocated type is a class type T or an; // array thereof, the deallocation function's name is looked up in; // the scope of T. If this lookup fails to find the name, or if; // the allocated type is not a class type or array thereof, the; // deallocation function's name is looked up in the global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:307,Performance,perform,perform,307,"// C++ [expr.new]p20:; // A declaration of a placement deallocation function matches the; // declaration of a placement allocation function if it has the; // same number of parameters and, after parameter transformations; // (8.3.5), all parameter types except the first are; // identical. [...]; //; // To perform this comparison, we compute the function type that; // the deallocation function should have, and use that type both; // for template argument deduction and for comparison purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform template argument deduction to try to match the; // expected function type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:19,Modifiability,variab,variable,19,/// Indicates that variable is initialized with mismatching form of \a new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:20,Modifiability,variab,variable,20,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:95,Modifiability,variab,variable,95,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:151,Modifiability,variab,variable,151,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:250,Modifiability,variab,variable,250,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:336,Modifiability,Variab,Variable,336,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,"// Perform lvalue-to-rvalue cast, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:10,Performance,Perform,PerformContextualImplicitConversion,10,// FIXME: PerformContextualImplicitConversion should return ExprError; // itself in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:29,Availability,error,errors,29,// FIXME: This can result in errors if the definition was imported from a; // module but is hidden.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:9,Security,access,access,9,// Check access and ambiguity of destructor if we're going to call it.; // Note that this is required even for a virtual delete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:76,Security,access,access,76,// Qualifiers are irrelevant to this conversion; we're only looking; // for access and ambiguity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:24,Security,access,access,24,// We do our own custom access checks below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:31,Modifiability,variab,variable,31,"/// Check the use of the given variable as a C++ condition in an if,; /// while, do-while, or switch statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:158,Modifiability,variab,variable,158,"// C++11 6.4p4:; // The value of a condition that is an initialized declaration in a statement; // other than a switch statement is the value of the declared variable; // implicitly converted to type bool. If that conversion is ill-formed, the; // program is ill-formed.; // The value of a condition that is an expression is the value of the; // expression, implicitly converted to bool.; //; // C++23 8.5.2p2; // If the if statement is of the form if constexpr, the value of the condition; // is contextually converted to bool and the converted expression shall be; // a constant expression.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:279,Availability,error,error,279,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:285,Integrability,message,message,285,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Performance,Perform,PerformImplicitConversion,4,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Performance,Perform,Perform,32,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:250,Performance,perform,performing,250,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:286,Availability,error,error,286,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:292,Integrability,message,messages,292,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Performance,Perform,PerformImplicitConversion,4,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Performance,Perform,Perform,32,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:242,Performance,perform,performing,242,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the first implicit conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the second implicit conversion,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:16,Modifiability,extend,extend,16,// Make sure we extend blocks if necessary.; // FIXME: doing this here is really ugly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:135,Modifiability,inherit,inheritance,135,// We may not have been able to figure out what this member pointer resolved; // to up until this exact point. Attempt to lock-in it's inheritance model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform half-to-boolean conversion via float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:71,Performance,perform,perform,71,"// If this conversion sequence involved a scalar -> atomic conversion, perform; // that conversion now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:539,Modifiability,portab,portability,539,"// C++0x [meta.unary.prop]p3:; // For all of the class templates X declared in this Clause, instantiating; // that template with a template argument that is a class template; // specialization may result in the implicit instantiation of the template; // argument if and only if the semantics of X require that the argument; // must be a complete type.; // We apply this rule to all the type trait expressions used to implement; // these class templates. We also try to follow any GCC documented behavior; // in these expressions to ensure portability of standard libraries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:208,Deployability,release,release,208,"// Note: semantic analysis depends on Objective-C lifetime types to be; // considered scalar types. However, such types do not actually behave; // like scalar types at run time (since they may require retain/release; // operations), so we report them as non-scalar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:27,Integrability,depend,depends,27,"// Note: semantic analysis depends on Objective-C lifetime types to be; // considered scalar types. However, such types do not actually behave; // like scalar types at run time (since they may require retain/release; // operations), so we report them as non-scalar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:123,Integrability,interface,interface,123,// __is_interface_class only returns true when CL is invoked in /CLR mode and; // even then only when it is used with the 'interface struct ...' syntax; // Clang doesn't support /CLR which makes this type trait moot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:129,Testability,log,logic,129,// This trait is implemented by MSVC 2012 and needed to parse the; // standard library headers. Specifically this is used as the logic; // behind std::is_trivially_move_constructible (20.9.4.3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:127,Testability,log,logic,127,// This trait is implemented by MSVC 2012 and needed to parse the; // standard library headers. Specifically it is used as the logic; // behind std::is_trivially_move_assignable (20.9.4.3),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:538,Availability,error,errors,538,"// http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html:; // If type is const qualified or is a reference type then the; // trait is false. Otherwise if __is_pod (type) is true then the; // trait is true, else if type is a cv class or union type with; // a trivial copy assignment ([class.copy]) then the trait is; // true, else it is false.; // Note: the const and reference restrictions are interesting,; // given that const and reference members don't prevent a class; // from having a trivial copy assignment operator (but do cause; // errors if the copy assignment operator is actually used, q.v.; // [class.copy]p12).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:129,Testability,log,logic,129,// This trait is implemented by MSVC 2012 and needed to parse the; // standard library headers. Specifically this is used as the logic; // behind std::is_nothrow_move_assignable (20.9.4.3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:119,Safety,avoid,avoid,119,// Evaluate ReferenceBindsToTemporary and ReferenceConstructsFromTemporary; // alongside the IsConstructible traits to avoid duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:134,Modifiability,variab,variable,134,"// C++11 [meta.unary.prop]:; // is_trivially_constructible is defined as:; //; // is_constructible<T, Args...>::value is true and the variable; // definition for is_constructible, as defined below, is known to call; // no operation that is not trivial.; //; // The predicate condition for a template specialization; // is_constructible<T, Args...> shall be satisfied if and only if the; // following variable definition would be well-formed for some invented; // variable t:; //; // T t(create<Args>()...);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:400,Modifiability,variab,variable,400,"// C++11 [meta.unary.prop]:; // is_trivially_constructible is defined as:; //; // is_constructible<T, Args...>::value is true and the variable; // definition for is_constructible, as defined below, is known to call; // no operation that is not trivial.; //; // The predicate condition for a template specialization; // is_constructible<T, Args...> shall be satisfied if and only if the; // following variable definition would be well-formed for some invented; // variable t:; //; // T t(create<Args>()...);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:463,Modifiability,variab,variable,463,"// C++11 [meta.unary.prop]:; // is_trivially_constructible is defined as:; //; // is_constructible<T, Args...>::value is true and the variable; // definition for is_constructible, as defined below, is known to call; // no operation that is not trivial.; //; // The predicate condition for a template specialization; // is_constructible<T, Args...> shall be satisfied if and only if the; // following variable definition would be well-formed for some invented; // variable t:; //; // T t(create<Args>()...);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the initialization in an unevaluated context within a SFINAE; // trap at translation unit scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Security,Access,AccessCheckingSFINAE,2,/*AccessCheckingSFINAE=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:501,Performance,perform,performed,501,"// C++0x [meta.rel]p4:; // Given the following function prototype:; //; // template <class T>; // typename add_rvalue_reference<T>::type create();; //; // the predicate condition for a template specialization; // is_convertible<From, To> shall be satisfied if and only if; // the return expression in the following code would be; // well-formed, including any implicit conversions to the return; // type of the function:; //; // To test() {; // return create<From>();; // }; //; // Access checking is performed as if in a context unrelated to To and; // From. Only the validity of the immediate context of the expression; // of the return-statement (including conversions to the return type); // is considered.; //; // We model the initialization as a copy-initialization of a temporary; // of the appropriate type, which for this expression is identical to the; // return statement (since NRVO doesn't apply).; // Functions aren't allowed to return function or array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:482,Security,Access,Access,482,"// C++0x [meta.rel]p4:; // Given the following function prototype:; //; // template <class T>; // typename add_rvalue_reference<T>::type create();; //; // the predicate condition for a template specialization; // is_convertible<From, To> shall be satisfied if and only if; // the return expression in the following code would be; // well-formed, including any implicit conversions to the return; // type of the function:; //; // To test() {; // return create<From>();; // }; //; // Access checking is performed as if in a context unrelated to To and; // From. Only the validity of the immediate context of the expression; // of the return-statement (including conversions to the return type); // is considered.; //; // We model the initialization as a copy-initialization of a temporary; // of the appropriate type, which for this expression is identical to the; // return statement (since NRVO doesn't apply).; // Functions aren't allowed to return function or array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:432,Testability,test,test,432,"// C++0x [meta.rel]p4:; // Given the following function prototype:; //; // template <class T>; // typename add_rvalue_reference<T>::type create();; //; // the predicate condition for a template specialization; // is_convertible<From, To> shall be satisfied if and only if; // the return expression in the following code would be; // well-formed, including any implicit conversions to the return; // type of the function:; //; // To test() {; // return create<From>();; // }; //; // Access checking is performed as if in a context unrelated to To and; // From. Only the validity of the immediate context of the expression; // of the return-statement (including conversions to the return type); // is considered.; //; // We model the initialization as a copy-initialization of a temporary; // of the appropriate type, which for this expression is identical to the; // return statement (since NRVO doesn't apply).; // Functions aren't allowed to return function or array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the initialization in an unevaluated context within a SFINAE; // trap at translation unit scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Security,Access,AccessCheckingSFINAE,2,/*AccessCheckingSFINAE=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Security,Access,AccessCheckingSFINAE,2,/*AccessCheckingSFINAE=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:6,Availability,error,error,6,"// If error parsing the expression, ignore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Integrability,depend,dependent,32,// Delay type-checking for type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:456,Security,access,accessible,456,"// Note: C++ [expr.mptr.oper]p2-3 says that the class type into which the; // member pointer points must be completely-defined. However, there is no; // reason for this semantic distinction, and the rule is not enforced by; // other compilers. Therefore, we do not check this property, as it is; // likely to be considered a defect.; // C++ 5.5p2; // [...] to its first operand, which shall be of class T or of a class of; // which T is an unambiguous and accessible base class. [p3: a pointer to; // such a class]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:104,Security,validat,validation,104,"/// Try to convert a type to another according to C++11 5.16p3.; ///; /// This is part of the parameter validation for the ? operator. If either; /// value operand is a class type, the two operands are attempted to be; /// converted to each other. This function does the conversion in one direction.; /// It returns true if the program is ill-formed and has already been diagnosed; /// as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:105,Security,validat,validation,105,"/// Try to find a common type for two according to C++0x 5.16p5.; ///; /// This is part of the parameter validation for the ? operator. If either; /// value operand is a class type, overload resolution is used to find a; /// conversion to a common type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:21,Performance,Perform,Perform,21,// We found a match. Perform the conversions on the arguments and move on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:16,Modifiability,extend,extended,16,"/// Perform an ""extended"" implicit conversion as returned by; /// TryClassUnification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Performance,Perform,Perform,4,"/// Perform an ""extended"" implicit conversion as returned by; /// TryClassUnification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:65,Integrability,interface,interface,65,"// FIXME: Handle C99's complex types, block pointers and Obj-C++ interface; // pointers.; // Assume r-value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:27,Integrability,depend,dependent,27,// Either of the arguments dependent?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:18,Availability,error,error,18,"// Neither holds, error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:258,Modifiability,extend,extend,258,"// C++11 [expr.cond]p3; // if both are glvalues of the same value category and the same type except; // for cv-qualification, an attempt is made to convert each of those; // operands to the type of the other.; // FIXME:; // Resolving a defect in P0012R1: we extend this to cover all cases where; // one of the operands is reference-compatible with the other, in order; // to support conditionals between functions differing in noexcept. This; // will similarly cover difference in array bounds after P0388R4.; // FIXME: If LTy and RTy have a composite pointer type, should we convert to; // that instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:294,Modifiability,extend,extend,294,"// C++11 [expr.cond]p4; // If the second and third operands are glvalues of the same value; // category and have the same type, the result is of that type and; // value category and it is a bit-field if the second or the third; // operand is a bit-field, or if both are bit-fields.; // We only extend this to bitfields, not to the crazy other kinds of; // l-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:116,Performance,perform,performed,116,"// C++11 [expr.cond]p6; // Lvalue-to-rvalue, array-to-pointer, and function-to-pointer standard; // conversions are performed on the second and third operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:327,Integrability,depend,depending,327,"// After those conversions, one of the following shall hold:; // -- The second and third operands have the same type; the result; // is of that type. If the operands have class type, the result; // is a prvalue temporary of the result type, which is; // copy-initialized from either the second operand or the third; // operand depending on the value of the first operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:114,Performance,perform,performed,114,"// -- The second and third operands have arithmetic or enumeration type;; // the usual arithmetic conversions are performed to bring them to a; // common type, and the result is of that type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:262,Performance,perform,performed,262,"// -- The second and third operands have pointer type, or one has pointer; // type and the other is a null pointer constant, or both are null; // pointer constants, at least one of which is non-integral; pointer; // conversions and qualification conversions are performed to bring them; // to their composite pointer type. The result is of the composite; // pointer type.; // -- The second and third operands have pointer to member type, or one has; // pointer to member type and the other is a null pointer constant;; // pointer to member conversions and qualification conversions are; // performed to bring them to a common type, whose cv-qualification; // shall match the cv-qualification of either the second or the third; // operand. The result is of the common type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:590,Performance,perform,performed,590,"// -- The second and third operands have pointer type, or one has pointer; // type and the other is a null pointer constant, or both are null; // pointer constants, at least one of which is non-integral; pointer; // conversions and qualification conversions are performed to bring them; // to their composite pointer type. The result is of the composite; // pointer type.; // -- The second and third operands have pointer to member type, or one has; // pointer to member type and the other is a null pointer constant;; // pointer to member conversions and qualification conversions are; // performed to bring them to a common type, whose cv-qualification; // shall match the cv-qualification of either the second or the third; // operand. The result is of the common type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:28,Performance,perform,perform,28,"// At the top level, we can perform a base-to-derived pointer-to-member; // conversion:; //; // - [...] where C1 is reference-related to C2 or C2 is; // reference-related to C1; //; // (Note that the only kinds of reference-relatedness in scope here are; // ""same type or derived from"".) At any other level, the class must; // exactly match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:931,Availability,down,down,931,"// - if T1 or T2 is ""pointer to noexcept function"" and the other type is; // ""pointer to function"", where the function types are otherwise the same,; // ""pointer to function"";; // - if T1 or T2 is ""pointer to member of C1 of type function"", the other; // type is ""pointer to member of C2 of type noexcept function"", and C1; // is reference-related to C2 or C2 is reference-related to C1, where; // the function types are otherwise the same, ""pointer to member of C2 of; // type function"" or ""pointer to member of C1 of type function"",; // respectively;; //; // We also support 'noreturn' here, so as a Clang extension we generalize the; // above to:; //; // - [Clang] If T1 and T2 are both of type ""pointer to function"" or; // ""pointer to member function"" and the pointee types can be unified; // by a function pointer conversion, that conversion is applied; // before checking the following rules.; //; // We've already unwrapped down to the function types, and we want to merge; // rather than just convert, so do this ourselves rather than calling; // IsFunctionConversion.; //; // FIXME: In order to match the standard wording as closely as possible, we; // currently only do this under a single level of pointers. Ideally, we would; // allow this in general, and set NeedConstBefore to the relevant depth on; // the side(s) where we changed anything. If we permit that, we should also; // consider this conversion when determining type similarity and model it as; // a qualification conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:42,Performance,perform,perform,42,// There are some more conversions we can perform under exactly one pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:47,Safety,avoid,avoid,47,// FIXME: Let the caller know if these fail to avoid duplicate diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:56,Performance,optimiz,optimization,56,// We hit this case with the lambda conversion-to-block optimization;; // we don't want any extra casts here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:7,Integrability,message,message,7,"// For message sends and property references, we try to find an; // actual method. FIXME: we should infer retention by selector in; // cases where we don't have an actual method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:24,Performance,perform,performSelector,24,"// Don't do reclaims on performSelector calls; despite their; // return type, the invoked method doesn't necessarily actually; // return an object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:36,Safety,avoid,avoid,36,"// If destructor is trivial, we can avoid the extra copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:46,Integrability,wrap,wrap,46,"// FIXME: In order to attach the temporaries, wrap the statement into; // a StmtExpr; currently this is only used for asm statements.; // This is hacky, either create a new CXXStmtWithTemporaries statement or; // a new AsmStmtWithTemporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:21,Performance,perform,perform,21,"// In MS mode, don't perform any extra checking of call return types within a; // decltype expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the semantic checks we delayed until this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:66,Security,access,accessible,66,"// Now all relevant types are complete, check the destructors are accessible; // and non-deleted, and annotate them on the temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:69,Security,access,access,69,/// Note a set of 'operator->' functions that were used for a member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:20,Modifiability,config,configurable,20,// FIXME: Make this configurable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:29,Integrability,depend,dependent,29,"// If we have a pointer to a dependent type and are using the -> operator,; // the object type is the type that the pointer points to. We might still; // have enough information about that type to do something useful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:176,Availability,error,error,176,"// When in a template specialization and on the first loop iteration,; // potentially give the default diagnostic (with the fixit in a; // separate note) instead of having the error reported back to here; // and giving a diagnostic with a fixit attached to the error itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:261,Availability,error,error,261,"// When in a template specialization and on the first loop iteration,; // potentially give the default diagnostic (with the fixit in a; // separate note) instead of having the error reported back to here; // and giving a diagnostic with a fixit attached to the error itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:36,Security,access,access,36,"// Objective-C properties allow ""."" access on Objective-C pointer types,; // so adjust the base type to the object type itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:407,Security,access,access,407,"// C++ [basic.lookup.classref]p2:; // [...] If the type of the object expression is of pointer to scalar; // type, the unqualified-id is looked up in the context of the complete; // postfix-expression.; //; // This also indicates that we could be parsing a pseudo-destructor-name.; // Note that Objective-C class and object types can be pseudo-destructor; // expressions or normal member (ivar or property) access expressions, and; // it's legal for the type to be incomplete if this is a pseudo-destructor; // call. We'll do more incomplete-type checks later in the lookup process,; // so just skip this check for ObjC types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:40,Integrability,depend,dependent,40,"// The object type must be complete (or dependent), or; // C++11 [expr.prim.general]p3:; // Unlike the object expression in other contexts, *this is not required to; // be of complete type for purposes of class member access (5.2.5) outside; // the member function body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:218,Security,access,access,218,"// The object type must be complete (or dependent), or; // C++11 [expr.prim.general]p3:; // Unlike the object expression in other contexts, *this is not required to; // be of complete type for purposes of class member access (5.2.5) outside; // the member function body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:77,Security,access,access,77,"// C++ [basic.lookup.classref]p2:; // If the id-expression in a class member access (5.2.5) is an; // unqualified-id, and the type of the object expression is of a class; // type C (or of pointer to a class type C), the unqualified-id is looked; // up in the scope of class C. [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:39,Performance,perform,perform,39,"// The operator requires a prvalue, so perform lvalue conversions.; // Only do this if we might plausibly end with a pointer, as otherwise; // this was likely to be intended to be a '.'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Availability,recover,recover,32,/// Check if it's ok to try and recover dot pseudo destructor calls on; /// pointer objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Safety,recover,recover,32,/// Check if it's ok to try and recover dot pseudo destructor calls on; /// pointer objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Detect,Detect,3,"// Detect dot pseudo destructor calls on pointer objects, e.g.:; // Foo *foo;; // foo.~Foo();",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by setting the object type to the destructed type and the; // operator to '->'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by setting the object type to the destructed type and the; // operator to '->'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:98,Integrability,depend,dependent,98,// Compute the object type that we should use for name lookup purposes. Only; // record types and dependent types matter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:45,Integrability,depend,dependent,45,"// The name of the type being destroyed is a dependent name, and we; // couldn't find anything useful in scope. Just store the identifier and; // it's location, and we'll perform (qualified) name lookup again at; // template instantiation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:171,Performance,perform,perform,171,"// The name of the type being destroyed is a dependent name, and we; // couldn't find anything useful in scope. Just store the identifier and; // it's location, and we'll perform (qualified) name lookup again at; // template instantiation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:35,Availability,recover,recovery,35,"// If we've performed some kind of recovery, (re-)build the type source; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:12,Performance,perform,performed,12,"// If we've performed some kind of recovery, (re-)build the type source; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:35,Safety,recover,recovery,35,"// If we've performed some kind of recovery, (re-)build the type source; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by dropping this type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by dropping this type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:52,Modifiability,variab,variable,52,"// Don't decrement RefsMinusAssignments if volatile variable with compound; // assignment (+=, ...) or increment/decrement unary operator to avoid; // potential unused-but-set-variable warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:176,Modifiability,variab,variable,176,"// Don't decrement RefsMinusAssignments if volatile variable with compound; // assignment (+=, ...) or increment/decrement unary operator to avoid; // potential unused-but-set-variable warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:141,Safety,avoid,avoid,141,"// Don't decrement RefsMinusAssignments if volatile variable with compound; // assignment (+=, ...) or increment/decrement unary operator to avoid; // potential unused-but-set-variable warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Performance,Perform,Perform,4,/// Perform the conversions required for an expression used in a; /// context that ignores the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:190,Performance,perform,perform,190,"// The C++11 standard defines the notion of a discarded-value expression;; // normally, we don't need to do anything to handle it, but if it is a; // volatile lvalue with a special form, we perform an lvalue-to-rvalue; // conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:160,Integrability,depend,dependent,160,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:287,Integrability,depend,dependent,287,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:540,Integrability,depend,dependent,540,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:123,Modifiability,variab,variable,123,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
