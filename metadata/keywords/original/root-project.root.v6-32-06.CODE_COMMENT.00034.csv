id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:302,Availability,mask,mask,302,"// 3-4) Patterns : {******}{33 zeros}{******}; // {******}{33 ones}{******}; // If the Imm contains 33 consecutive zeros/ones, it means that a total of 31; // bits remain on both sides. Rotate right the Imm to construct an int<32>; // value, use LIS + ORI for int<32> value and then use RLDICL without mask to; // rotate it back.; // This is similar to Pattern 2-6, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:242,Modifiability,variab,variable,242,// Try to select instructions to generate a 64 bit immediate using prefix as; // well as non prefix instructions. The function will return the SDNode; // to materialize that constant or it will return nullptr if it does not; // find one. The variable InstCnt is set to the number of instructions that; // were selected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:258,Availability,mask,mask,258,"// Patterns : {zeros}{ones}{33-bit value}{zeros}; // {zeros}{33-bit value}{zeros}; // {zeros}{ones}{33-bit value}; // {ones}{33-bit value}{zeros}; // We can take advantage of PLI's sign-extension semantics to generate leading; // ones, and then use RLDIC to mask off the ones on both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:205,Availability,mask,mask,205,"// Pattern : {zeros}{33-bit value}{ones}; // Shift right the Imm by (30 - LZ) bits to construct a negative 34 bit value,; // therefore we can take advantage of PLI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-33-bit-||--TO--+ +-------------|--34-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; //; // +----sext-----|--34-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:466,Usability,clear,clear,466,"// Pattern : {zeros}{33-bit value}{ones}; // Shift right the Imm by (30 - LZ) bits to construct a negative 34 bit value,; // therefore we can take advantage of PLI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-33-bit-||--TO--+ +-------------|--34-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; //; // +----sext-----|--34-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:206,Availability,mask,mask,206,"// Patterns : {zeros}{ones}{33-bit value}{ones}; // {ones}{33-bit value}{ones}; // Similar to LI we can take advantage of PLI's sign-extension semantics to; // generate leading ones, and then use RLDICL to mask off the ones in left; // sides (if required) after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:281,Availability,mask,mask,281,"// Patterns : {******}{31 zeros}{******}; // : {******}{31 ones}{******}; // If Imm contains 31 consecutive zeros/ones then the remaining bit count; // is 33. Rotate right the Imm to construct a int<33> value, we can use PLI; // for the int<33> value and then use RLDICL without a mask to rotate it back.; //; // +------|--ones--|------+ +---ones--||---33 bit--+; // |bbbbbb1111111111aaaaaa| -> |1111111111aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:36,Availability,mask,mask,36,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:229,Availability,mask,mask,229,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:50,Modifiability,Variab,Variable,50,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:88,Modifiability,variab,variable,88,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:102,Modifiability,Variab,VariableKnownToBeZero,102,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:158,Modifiability,variab,variable,158,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:83,Availability,mask,masking,83,"// We need to sort so that the non-Repl32 come first because, when we're; // doing masking, the Repl32 bit groups might be subsumed into the 64-bit; // masking operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:152,Availability,mask,masking,152,"// We need to sort so that the non-Repl32 come first because, when we're; // doing masking, the Repl32 bit groups might be subsumed into the 64-bit; // masking operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:19,Availability,mask,masks,19,"// AND instruction masks this bit. If the input is already zero,; // we have nothing to do here. Otherwise, make the bit ConstZero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:79,Modifiability,Variab,VariableKnownToBeZero,79,"// If both inputs are known to be zero and one is ConstZero and; // another is VariableKnownToBeZero, we can select whichever; // we like. To minimize the number of bit groups, we select; // VariableKnownToBeZero if this bit is the next bit of the same; // input variable from the previous bit. Otherwise, we select; // ConstZero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:191,Modifiability,Variab,VariableKnownToBeZero,191,"// If both inputs are known to be zero and one is ConstZero and; // another is VariableKnownToBeZero, we can select whichever; // we like. To minimize the number of bit groups, we select; // VariableKnownToBeZero if this bit is the next bit of the same; // input variable from the previous bit. Otherwise, we select; // ConstZero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:263,Modifiability,variab,variable,263,"// If both inputs are known to be zero and one is ConstZero and; // another is VariableKnownToBeZero, we can select whichever; // we like. To minimize the number of bit groups, we select; // VariableKnownToBeZero if this bit is the next bit of the same; // input variable from the previous bit. Otherwise, we select; // ConstZero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:7,Testability,Assert,AssertZext,7,"// For AssertZext, we look through the operand and; // mark the bits known to be zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:132,Availability,mask,masking,132,// These bits are known to be zero but the AssertZext may be from a value; // that already has some constant zero bits (i.e. from a masking and).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:43,Testability,Assert,AssertZext,43,// These bits are known to be zero but the AssertZext may be from a value; // that already has some constant zero bits (i.e. from a masking and).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:8,Modifiability,extend,extending,8,"// Zero-extending load itself cannot be optimized. So, it is not; // interesting by itself though it gives useful information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:18,Performance,load,load,18,"// Zero-extending load itself cannot be optimized. So, it is not; // interesting by itself though it gives useful information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:40,Performance,optimiz,optimized,40,"// Zero-extending load itself cannot be optimized. So, it is not; // interesting by itself though it gives useful information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:114,Availability,mask,masking,114,"// Collect groups of consecutive bits with the same underlying value and; // rotation factor. If we're doing late masking, we ignore zeros, otherwise; // they break up groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Availability,mask,masking,23,"// If we're doing late masking, then the first bit group always starts; // at zero (even if the first bits were zero).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:206,Safety,avoid,avoid,206,"// Take all (SDValue, RLAmt) pairs and sort them by the number of groups; // associated with each. If the number of groups are same, we prefer a group; // which does not require rotate, i.e. RLAmt is 0, to avoid the first rotate; // instruction. If there is a degeneracy, pick the one that occurs; // first (in the final value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:138,Availability,mask,mask,138,"// In 64-bit mode, rlwinm and friends have a rotation operator that; // replicates the low-order 32 bits into the high-order 32-bits. The mask; // indices of these instructions can only be in the lower 32 bits, so they; // can only represent some 64-bit bit groups. However, when they can be used,; // the 32-bit replication can be used to represent, as a single bit group,; // otherwise separate bit groups. We'll convert to replicated-32-bit bit; // groups when possible. Returns true if any of the bit groups were; // converted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Modifiability,extend,extends,15,"// This method extends an input value to 64 bit if input is 32-bit integer.; // While selecting instructions in BitPermutationSelector in 64-bit mode,; // an input value can be a 32-bit integer if a ZERO_EXTEND node is included.; // In such case, we extend it to 64 bit to be consistent with other values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:250,Modifiability,extend,extend,250,"// This method extends an input value to 64 bit if input is 32-bit integer.; // While selecting instructions in BitPermutationSelector in 64-bit mode,; // an input value can be a 32-bit integer if a ZERO_EXTEND node is included.; // In such case, we extend it to 64 bit to be consistent with other values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:95,Availability,mask,mask,95,"// Depending on the number of groups for a particular value, it might be; // better to rotate, mask explicitly (using andi/andis), and then or the; // result. Select this part of the result first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:3,Integrability,Depend,Depending,3,"// Depending on the number of groups for a particular value, it might be; // better to rotate, mask explicitly (using andi/andis), and then or the; // result. Select this part of the result first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Availability,mask,masks,15,// Compute the masks for andi/andis that would be necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:398,Availability,mask,mask,398,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:658,Availability,mask,mask,658,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:441,Energy Efficiency,schedul,schedule,441,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:529,Energy Efficiency,POWER,POWER,529,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:627,Performance,latency,latency,627,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,Availability,mask,masks,58,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce one if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:72,Availability,avail,available,72,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce one if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:104,Availability,avail,available,104,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce one if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:142,Availability,mask,mask,142,"// We cannot do this with a single instruction, so we'll use two. The; // problem is that we're not free to choose both a rotation amount and mask; // start and end independently. We can choose an arbitrary mask start and; // end, but then the rotation amount is fixed. Rotation, however, can be; // inverted, and so by applying an ""inverse"" rotation first, we can get the; // desired result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:207,Availability,mask,mask,207,"// We cannot do this with a single instruction, so we'll use two. The; // problem is that we're not free to choose both a rotation amount and mask; // start and end independently. We can choose an arbitrary mask start and; // end, but then the rotation amount is fixed. Rotation, however, can be; // inverted, and so by applying an ""inverse"" rotation first, we can get the; // desired result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Availability,mask,mask,16,// The rotation mask for the second instruction must be MaskStart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:56,Availability,Mask,MaskStart,56,// The rotation mask for the second instruction must be MaskStart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,Availability,mask,masks,58,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce a rotate-mask-and-insert if one is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:72,Availability,avail,available,72,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce a rotate-mask-and-insert if one is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:100,Availability,mask,mask-and-insert,100,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce a rotate-mask-and-insert if one is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:126,Availability,avail,available,126,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce a rotate-mask-and-insert if one is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:142,Availability,mask,mask,142,"// We cannot do this with a single instruction, so we'll use two. The; // problem is that we're not free to choose both a rotation amount and mask; // start and end independently. We can choose an arbitrary mask start and; // end, but then the rotation amount is fixed. Rotation, however, can be; // inverted, and so by applying an ""inverse"" rotation first, we can get the; // desired result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:207,Availability,mask,mask,207,"// We cannot do this with a single instruction, so we'll use two. The; // problem is that we're not free to choose both a rotation amount and mask; // start and end independently. We can choose an arbitrary mask start and; // end, but then the rotation amount is fixed. Rotation, however, can be; // inverted, and so by applying an ""inverse"" rotation first, we can get the; // desired result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Availability,mask,mask,16,// The rotation mask for the second instruction must be MaskStart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:56,Availability,Mask,MaskStart,56,// The rotation mask for the second instruction must be MaskStart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:328,Availability,mask,masking,328,"// The idea here is the same as in the 32-bit version, but with additional; // complications from the fact that Repl32 might be true. Because we; // aggressively convert bit groups to Repl32 form (which, for small; // rotation factors, involves no other change), and then coalesce, it might; // be the case that a single 64-bit masking operation could handle both; // some Repl32 groups and some non-Repl32 groups. If converting to Repl32; // form allowed coalescing, then we must use a 32-bit rotaton in order to; // completely capture the new combined bit group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:25,Availability,mask,mask,25,"// We need to add to the mask all bits from the associated bit groups.; // If Repl32 is false, we need to add bits from bit groups that have; // Repl32 true, but are trivially convertable to Repl32 false. Such a; // group is trivially convertable if it overlaps only with the lower 32; // bits, and the group has not been coalesced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:53,Availability,mask,mask,53,// We can use the 32-bit andi/andis technique if the mask does not; // require any higher-order bits. This can save an instruction compared; // to always using the general 64-bit technique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Availability,mask,masks,15,// Compute the masks for andi/andis that would be necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:114,Energy Efficiency,POWER,POWER,114,"// When we'd use andi/andis, we bias toward using the rotates (andi only; // has a record form, and is cracked on POWER cores). However, when using; // general 64-bit constant formation, bias toward the constant form,; // because that exposes more opportunities for CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:235,Security,expose,exposes,235,"// When we'd use andi/andis, we bias toward using the rotates (andi only; // has a record form, and is cracked on POWER cores). However, when using; // general 64-bit constant formation, bias toward the constant form,; // because that exposes more opportunities for CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:173,Safety,avoid,avoided,173,"// When merging multiple bit groups, instruction or is used.; // But when rotate is used, rldimi can inert the rotated value into any; // register, so instruction or can be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:205,Availability,mask,mask,205,"// We actually need to generate a rotation if we have a non-zero rotation; // factor or, in the Repl32 case, if we care about any of the; // higher-order replicated bits. In the latter case, we generate a mask; // backward so that it actually includes the entire 64 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Modifiability,flexible,flexible,35,"// Because 64-bit rotates are more flexible than inserts, we might have a; // preference regarding which one we do first (to save one instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:53,Availability,mask,mask,53,// We can use the 32-bit andi/andis technique if the mask does not; // require any higher-order bits. This can save an instruction compared; // to always using the general 64-bit technique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Availability,mask,masks,15,// Compute the masks for andi/andis that would be necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:79,Availability,mask,masking,79,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:110,Availability,mask,masking,110,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:124,Availability,mask,masking,124,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:311,Availability,mask,masking,311,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:411,Availability,mask,mask,411,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:456,Availability,mask,masking,456,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:154,Energy Efficiency,efficient,efficient,154,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:139,Modifiability,extend,extend,139,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:201,Modifiability,extend,extend,201,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:267,Modifiability,extend,extend,267,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:329,Modifiability,extend,extend,329,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Usability,guid,guide,16,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:18,Modifiability,extend,extending,18,"// If we are zero-extending the result of a logical operation on i1; // values, we can keep the values in GPRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:44,Testability,log,logical,44,"// If we are zero-extending the result of a logical operation on i1; // values, we can keep the values in GPRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:14,Performance,perform,perform,14,"// Attempt to perform logical operations on the results of comparisons while; // keeping the values in GPRs. Without doing so, these would end up being; // lowered to CR-logical operations which suffer from significant latency and; // low ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:219,Performance,latency,latency,219,"// Attempt to perform logical operations on the results of comparisons while; // keeping the values in GPRs. Without doing so, these would end up being; // lowered to CR-logical operations which suffer from significant latency and; // low ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,Testability,log,logical,22,"// Attempt to perform logical operations on the results of comparisons while; // keeping the values in GPRs. Without doing so, these would end up being; // lowered to CR-logical operations which suffer from significant latency and; // low ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:170,Testability,log,logical,170,"// Attempt to perform logical operations on the results of comparisons while; // keeping the values in GPRs. Without doing so, these would end up being; // lowered to CR-logical operations which suffer from significant latency and; // low ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:46,Modifiability,extend,extend,46,// Look through any 32-bit to 64-bit implicit extend nodes to find the; // opcode that is input to the XORI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:43,Testability,log,logical,43,"// If this is not an XORI, it is a reg-reg logical op and we can convert; // it to record-form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:61,Testability,log,logical,61,// Convert the right node to record-form. This is either the logical we're; // looking at or it is the input node to the negation (if we're looking at; // a bitwise negation).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:11,Testability,log,logical,11,"// Lower a logical operation on i1 values into a GPR sequence if possible.; // The result can be kept in a GPR if requested.; // Three types of inputs can be handled:; // - SETCC; // - TRUNCATE; // - Logical operation (AND/OR/XOR); // There is also a special case that is handled (namely a complement operation; // achieved with xor %a, -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:200,Testability,Log,Logical,200,"// Lower a logical operation on i1 values into a GPR sequence if possible.; // The result can be kept in a GPR if requested.; // Three types of inputs can be handled:; // - SETCC; // - TRUNCATE; // - Logical operation (AND/OR/XOR); // There is also a special case that is handled (namely a complement operation; // achieved with xor %a, -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,Testability,log,logic,58,"// Produces a GPR sequence for each operand of the binary logic operation.; // For SETCC, it produces the respective comparison, for TRUNCATE it truncates; // the value in a GPR and for logic operations, it will recursively produce; // a GPR sequence for the operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:186,Testability,log,logic,186,"// Produces a GPR sequence for each operand of the binary logic operation.; // For SETCC, it produces the respective comparison, for TRUNCATE it truncates; // the value in a GPR and for logic operations, it will recursively produce; // a GPR sequence for the operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Modifiability,extend,extended,45,"/// If the value isn't guaranteed to be sign-extended to 64-bits, extend it.; /// Otherwise just reinterpret it as a 64-bit value.; /// Useful when emitting comparison code for 32-bit values without using; /// the compare instruction (which only considers the lower 32-bits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:66,Modifiability,extend,extend,66,"/// If the value isn't guaranteed to be sign-extended to 64-bits, extend it.; /// Otherwise just reinterpret it as a 64-bit value.; /// Useful when emitting comparison code for 32-bit values without using; /// the compare instruction (which only considers the lower 32-bits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,Modifiability,extend,extended,22,// The value was sign extended and then truncated to 32-bits. No need to; // sign extend it again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:82,Modifiability,extend,extend,82,// The value was sign extended and then truncated to 32-bits. No need to; // sign extend it again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Modifiability,extend,extending,23,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:52,Modifiability,extend,extending,52,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:77,Modifiability,extend,extend,77,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:33,Performance,load,load,33,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:62,Performance,load,loads,62,// The input is a sign-extending load. All ppc sign-extending loads; // sign-extend to the full 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,Modifiability,extend,extend,17,// We don't sign-extend constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Modifiability,extend,extended,45,"/// If the value isn't guaranteed to be zero-extended to 64-bits, extend it.; /// Otherwise just reinterpret it as a 64-bit value.; /// Useful when emitting comparison code for 32-bit values without using; /// the compare instruction (which only considers the lower 32-bits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:66,Modifiability,extend,extend,66,"/// If the value isn't guaranteed to be zero-extended to 64-bits, extend it.; /// Otherwise just reinterpret it as a 64-bit value.; /// Useful when emitting comparison code for 32-bit values without using; /// the compare instruction (which only considers the lower 32-bits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:57,Modifiability,extend,extend,57,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:168,Modifiability,extend,extending,168,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:221,Modifiability,extend,extended,221,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:145,Performance,load,load,145,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:178,Performance,load,load,178,// The only condition under which we can omit the actual extend instruction:; // - The value is a positive constant; // - The value comes from a load that isn't a sign-extending load; // An ISD::TRUNCATE needs to be zero-extended unless it is fed by a zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:41,Modifiability,extend,extend,41,// The input is a load that doesn't sign-extend (it will be zero-extended).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:65,Modifiability,extend,extended,65,// The input is a load that doesn't sign-extend (it will be zero-extended).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:18,Performance,load,load,18,// The input is a load that doesn't sign-extend (it will be zero-extended).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Modifiability,extend,extend,35,"// None of the above, need to zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,Modifiability,extend,extended,58,// Produce the value that needs to be either zero or sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:86,Safety,avoid,avoid,86,// The above case covers all the enumerators so it can't have a default clause; // to avoid compiler warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:20,Modifiability,extend,extended,20,/// Produces a zero-extended result of comparing two 32-bit values according to; /// the passed condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:20,Modifiability,extend,extended,20,/// Produces a sign-extended result of comparing two 32-bit values according to; /// the passed condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:20,Modifiability,extend,extended,20,/// Produces a zero-extended result of comparing two 64-bit values according to; /// the passed condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:20,Modifiability,extend,extended,20,/// Produces a sign-extended result of comparing two 64-bit values according to; /// the passed condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:109,Modifiability,extend,extending,109,"// For values that have a single use, the caller should obviously already have; // checked if that use is an extending use. We check the other uses here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Modifiability,extend,extended,45,"// We want the value in a GPR if it is being extended, used for a select, or; // used in logical operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:89,Testability,log,logical,89,"// We want the value in a GPR if it is being extended, used for a select, or; // used in logical operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:178,Energy Efficiency,power,power,178,/// Returns an equivalent of a SETCC node but with the result the same width as; /// the inputs. This can also be used for SELECT_CC if either the true or false; /// values is a power of two while the other is zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:8,Performance,optimiz,optimization,8,// This optimization will emit code that assumes 64-bit registers; // so we don't want to run it in 32-bit mode. Also don't run it; // on functions that are not to be optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:167,Performance,optimiz,optimized,167,// This optimization will emit code that assumes 64-bit registers; // so we don't want to run it in 32-bit mode. Also don't run it; // on functions that are not to be optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:37,Energy Efficiency,efficient,efficiently,37,"// We can codegen setcc op, imm very efficiently compared to a brcond.; // Check for those cases here.; // setcc op, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:31,Performance,load,load,31,/// Does this node represent a load/store node whose address can be represented; /// with a register plus an immediate that's a multiple of \p Val:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:21,Performance,optimiz,optimization,21,"// Without this setb optimization, the outer SELECT_CC will be manually; // selected to SELECT_CC_I4/SELECT_CC_I8 Pseudo, then expand-isel-pseudos pass; // transforms pseudo instruction to isel instruction. When there are more than; // one use for result like zext/sext, with current optimization we only see; // isel is replaced by setb but can't see any significant gain. Since; // setb has longer latency than original isel, we should avoid this. Another; // point is that setb requires comparison always kept, it can break the; // opportunity to get the comparison away if we have in future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:284,Performance,optimiz,optimization,284,"// Without this setb optimization, the outer SELECT_CC will be manually; // selected to SELECT_CC_I4/SELECT_CC_I8 Pseudo, then expand-isel-pseudos pass; // transforms pseudo instruction to isel instruction. When there are more than; // one use for result like zext/sext, with current optimization we only see; // isel is replaced by setb but can't see any significant gain. Since; // setb has longer latency than original isel, we should avoid this. Another; // point is that setb requires comparison always kept, it can break the; // opportunity to get the comparison away if we have in future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:400,Performance,latency,latency,400,"// Without this setb optimization, the outer SELECT_CC will be manually; // selected to SELECT_CC_I4/SELECT_CC_I8 Pseudo, then expand-isel-pseudos pass; // transforms pseudo instruction to isel instruction. When there are more than; // one use for result like zext/sext, with current optimization we only see; // isel is replaced by setb but can't see any significant gain. Since; // setb has longer latency than original isel, we should avoid this. Another; // point is that setb requires comparison always kept, it can break the; // opportunity to get the comparison away if we have in future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:438,Safety,avoid,avoid,438,"// Without this setb optimization, the outer SELECT_CC will be manually; // selected to SELECT_CC_I4/SELECT_CC_I8 Pseudo, then expand-isel-pseudos pass; // transforms pseudo instruction to isel instruction. When there are more than; // one use for result like zext/sext, with current optimization we only see; // isel is replaced by setb but can't see any significant gain. Since; // setb has longer latency than original isel, we should avoid this. Another; // point is that setb requires comparison always kept, it can break the; // opportunity to get the comparison away if we have in future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:88,Availability,mask,mask,88,"// If this is an and of a value rotated between 0 and 31 bits and then and'd; // with a mask, emit rlwinm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:21,Availability,mask,masked,21,"// If this is just a masked value where the input is not handled, and; // is not a rotate-left (handled by a pattern in the .td file), emit rlwinm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:79,Availability,mask,mask,79,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:103,Availability,mask,mask,103,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:117,Integrability,wrap,wrapped,117,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:3,Performance,Optimiz,Optimized,3,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:134,Availability,mask,mask,134,// Rotate left by OnesOnLeft (so leading ones are now trailing ones) and clear; // on the left the bits that are already zeros in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:73,Usability,clear,clear,73,// Rotate left by OnesOnLeft (so leading ones are now trailing ones) and clear; // on the left the bits that are already zeros in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:235,Usability,undo,undo,235,// MB-ME+63 ME MB; // +----------------------+ +----------------------+; // |0000001111111111111111| -> |0001111100000011111111|; // +----------------------+ +----------------------+; // 0 63 0 63; // Rotate back by 64 - OnesOnLeft to undo previous rotate. Then clear on the; // left the number of ones we previously added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:262,Usability,clear,clear,262,// MB-ME+63 ME MB; // +----------------------+ +----------------------+; // |0000001111111111111111| -> |0001111100000011111111|; // +----------------------+ +----------------------+; // 0 63 0 63; // Rotate back by 64 - OnesOnLeft to undo previous rotate. Then clear on the; // left the number of ones we previously added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:113,Availability,mask,mask,113,"// The idea here is to check whether this is equivalent to:; // (c1 & m) | (x & ~m); // where m is a run-of-ones mask. The logic here is that, for each bit in; // c1 and c2:; // - if both are 1, then the output will be 1.; // - if both are 0, then the output will be 0.; // - if the bit in c1 is 0, and the bit in c2 is 1, then the output will; // come from x.; // - if the bit in c1 is 1, and the bit in c2 is 0, then the output will; // be 0.; // If that last condition is never the case, then we can form m from the; // bits that are the same between c1 and c2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:123,Testability,log,logic,123,"// The idea here is to check whether this is equivalent to:; // (c1 & m) | (x & ~m); // where m is a run-of-ones mask. The logic here is that, for each bit in; // c1 and c2:; // - if both are 1, then the output will be 1.; // - if both are 0, then the output will be 0.; // - if the bit in c1 is 0, and the bit in c2 is 1, then the output will; // come from x.; // - if the bit in c1 is 1, and the bit in c2 is 0, then the output will; // be 0.; // If that last condition is never the case, then we can form m from the; // bits that are the same between c1 and c2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:21,Safety,avoid,avoid,21,"// Looking to try to avoid a situation like this one:; // %2 = tail call i64 @llvm.fshl.i64(i64 %word, i64 %word, i64 23); // %and1 = and i64 %2, 9223372036854775807; // In this function we are looking to try to match RLDCL. However, the above; // DAG would better match RLDICL instead which is not what we are looking; // for here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Availability,mask,mask,38,"// If this is a 64-bit zero-extension mask, emit rldicl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:218,Availability,mask,mask,218,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:233,Availability,mask,mask,233,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:264,Availability,mask,mask,264,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:276,Availability,mask,mask,276,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Testability,log,logical,23,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:46,Availability,mask,mask,46,"// If this is a negated 64-bit zero-extension mask,; // i.e. the immediate is a sequence of ones from most significant side; // and all zero for reminder, we should use rldicr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Performance,optimiz,optimizations,35,"// In case any misguided DAG-level optimizations form an ADD with a; // TargetConstant operand, crash here instead of miscompiling (by selecting; // an r+r add instead of some kind of r+i add).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:122,Performance,optimiz,optimized,122,// We will emit PPC::TD or PPC::TW if the 2nd and 3rd operands are reg +; // reg or imm + imm. The imm + imm form will be optimized to either an; // unconditional trap or a nop in a later pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:302,Availability,error,error,302,"// We emit the PPC::FSELS instruction here because of type conflicts with; // the comparison operand. The FSELS instruction is defined to use an 8-byte; // comparison like the FSELD version. The fsels intrinsic takes a 4-byte; // value for the comparison. When selecting through a .td file, a type; // error is raised. Must check this first so we never break on the; // !Subtarget->isISA3_1() check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Deployability,update,update,38,// Vector string isolate instructions update the EQ bit of CR6.; // Generate a SETBC instruction to extract the bit and place it in a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:76,Security,secur,secure,76,// Attach global base pointer on GETtlsADDR32 node in order to; // generate secure plt code for TLS symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Performance,load,loads,23,// Handle preincrement loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:10,Performance,load,loads,10,// Normal loads are handled by code generated from the .td file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:61,Performance,load,loads,61,// Change TLS initial-exec (or TLS local-exec on AIX) D-form loads to; // X-form loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:81,Performance,load,loads,81,// Change TLS initial-exec (or TLS local-exec on AIX) D-form loads to; // X-form loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Performance,load,loads,38,// Handle PPC32 integer and normal FP loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Performance,load,loads,38,// Handle PPC32 integer and normal FP loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:30,Availability,mask,mask,30,"// If this is an 'and' with a mask, try to emit rlwinm/rldicl/rldicr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:329,Safety,avoid,avoid,329,"// Make use of SelectCC to generate the comparison to set CR bits, for; // equality comparisons having one literal operand, SelectCC probably; // doesn't need to materialize the whole literal and just use xoris to; // check it first, it leads the following comparison result can't; // exactly represent GT/LT relationship. So to avoid this we specify; // SETGT/SETUGT here instead of SETEQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:73,Availability,mask,mask,73,"// For little endian, we must swap the input operands and adjust; // the mask elements (reverse and invert them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:259,Testability,log,logical,259,"// A signed comparison of i1 values produces the opposite result to an; // unsigned one if the condition code includes less-than or greater-than.; // This is because 1 is the most negative signed i1 number and the most; // positive unsigned i1 number. The CR-logical operations used for such; // comparisons are non-commutative so for signed comparisons vs. unsigned; // ones, the input operands just need to be swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC only support small, medium and large code model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:49,Security,access,access,49,// 32-bit ELF always uses a small code model toc access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:65,Performance,load,load,65,"// If it is accessed as got-indirect, we need an extra LWZ/LD to load; // the address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:12,Security,access,accessed,12,"// If it is accessed as got-indirect, we need an extra LWZ/LD to load; // the address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:18,Safety,safe,safe,18,// Generate a PIC-safe GOT reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Integrability,depend,depending,45,"// This expands into one of three sequences, depending on whether; // the first operand is odd or even, positive or negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:32,Performance,load,load,32,"// Here we want to handle splat load for type v16i8 and v8i16 when there is; // no direct move, we don't need to use stack for this case. If target has; // direct move, we should be able to get the best selection in the .td file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:83,Availability,mask,mask,83,"// If the alignment for the load is 16 or bigger, we don't need the; // permutated mask to get the required value. The value must be the 0; // element in big endian target or 7/15 in little endian target in the; // result vsx register of lvx instruction.; // Select the instruction in the .td file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:28,Performance,load,load,28,"// If the alignment for the load is 16 or bigger, we don't need the; // permutated mask to get the required value. The value must be the 0; // element in big endian target or 7/15 in little endian target in the; // result vsx register of lvx instruction.; // Select the instruction in the .td file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:39,Availability,Mask,Mask,39,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:125,Availability,Mask,Mask,125,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:204,Availability,Mask,Mask,204,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:324,Availability,Mask,Mask,324,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:68,Performance,Load,LoadLow,68,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:107,Performance,Load,LoadLow,107,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:116,Performance,Load,LoadLow,116,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:233,Performance,Load,LoadLow,233,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:259,Performance,Load,LoadHigh,259,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:305,Performance,Load,LoadLow,305,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:314,Performance,Load,LoadHigh,314,"// v16i8 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // Perm = VPERM LoadLow, LoadLow, Mask; // Splat = VSPLTB 15/0, Perm; //; // v8i16 LD_SPLAT addr; // ======>; // Mask = LVSR/LVSL 0, addr; // LoadLow = LVX 0, addr; // LoadHigh = LVX (LI, 1), addr; // Perm = VPERM LoadLow, LoadHigh, Mask; // Splat = VSPLTH 7/0, Perm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:344,Availability,mask,masking,344,"// If the target supports the cmpb instruction, do the idiom recognition here.; // We don't do this as a DAG combine because we don't want to do it as nodes; // are being combined (because we might miss part of the eventual idiom). We; // don't want to do it during instruction selection because we want to reuse; // the logic for lowering the masking operations already part of the; // instruction selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:321,Testability,log,logic,321,"// If the target supports the cmpb instruction, do the idiom recognition here.; // We don't do this as a DAG combine because we don't want to do it as nodes; // are being combined (because we might miss part of the eventual idiom). We; // don't want to do it during instruction selection because we want to reuse; // the logic for lowering the masking operations already part of the; // instruction selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:152,Integrability,depend,depending,152,"// When we have small integers (i16 to be specific), the form present; // post-legalization uses SETULT in the SELECT_CC for the; // higher-order byte, depending on the fact that the; // even-higher-order bytes are known to all be zero, for example:; // select_cc (xor $lhs, $rhs), 256, 65280, 0, setult; // (so when the second byte is the same, because all higher-order; // bits from bytes 3 and 4 are known to be zero, the result of the; // xor can be at most 255)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:117,Availability,Mask,Mask,117,"// Because we'll be zero-extending the output anyway if don't have a specific; // value for each input byte (via the Mask), we can 'anyext' the inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:25,Modifiability,extend,extending,25,"// Because we'll be zero-extending the output anyway if don't have a specific; // value for each input byte (via the Mask), we can 'anyext' the inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:9,Availability,Mask,Mask,9,// Res = Mask & CMPB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,Availability,Mask,Mask,17,"// Res = (CMPB & Mask) | (~CMPB & Alt); // Which, as suggested here:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // can be written as:; // Res = Alt ^ ((Alt ^ Mask) & CMPB); // useful because the (Alt ^ Mask) can be pre-computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:126,Availability,Mask,MaskedMerge,126,"// Res = (CMPB & Mask) | (~CMPB & Alt); // Which, as suggested here:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // can be written as:; // Res = Alt ^ ((Alt ^ Mask) & CMPB); // useful because the (Alt ^ Mask) can be pre-computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:185,Availability,Mask,Mask,185,"// Res = (CMPB & Mask) | (~CMPB & Alt); // Which, as suggested here:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // can be written as:; // Res = Alt ^ ((Alt ^ Mask) & CMPB); // useful because the (Alt ^ Mask) can be pre-computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:229,Availability,Mask,Mask,229,"// Res = (CMPB & Mask) | (~CMPB & Alt); // Which, as suggested here:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // can be written as:; // Res = Alt ^ ((Alt ^ Mask) & CMPB); // useful because the (Alt ^ Mask) can be pre-computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:60,Modifiability,variab,variable,60,"// When CR bit registers are enabled, an extension of an i1 variable to a i32; // or i64 value is lowered in terms of a SELECT_I[48] operation, and thus; // involves constant materialization of a 0 or a 1 or both. If the result of; // the extension is then operated upon by some operator that can be constant; // folded with a constant 0 or 1, and that constant can be materialized using; // only one instruction (like a zero or one), then we should fold in those; // operations with the select.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:81,Usability,clear,clearly,81,"// FIXME: When the semantics of the interaction between select and undef; // are clearly defined, it may turn out to be unnecessary to break here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:25,Performance,Perform,Perform,25,/// PostprocessISelDAG - Perform some late peephole optimizations; /// on the DAG representation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:52,Performance,optimiz,optimizations,52,/// PostprocessISelDAG - Perform some late peephole optimizations; /// on the DAG representation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:157,Availability,mask,mask,157,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:171,Integrability,wrap,wrap,171,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:65,Usability,clear,clear,65,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:233,Usability,clear,clear,233,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,Usability,clear,clear,22,// SLW and SRW always clear the higher-order bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:84,Modifiability,extend,extended,84,"// For LI and LIS, we need the immediate to be positive (so that it is not; // sign extended).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:26,Usability,clear,clear,26,// LHBRX and LWBRX always clear the higher-order bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:69,Modifiability,extend,extended,69,"// CNT[LT]ZW always produce a 64-bit value in [0,32], and so is zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:76,Availability,mask,mask,76,"// Next, check for those instructions we can look through.; // Assuming the mask does not wrap around, then the higher-order bits are; // taken directly from the first operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:90,Integrability,wrap,wrap,90,"// Next, check for those instructions we can look through.; // Assuming the mask does not wrap around, then the higher-order bits are; // taken directly from the first operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:157,Modifiability,extend,extended,157,"// For ORI and ORIS, we need the higher-order bits of the first operand to be; // zero, and also for the constant to be positive (so that it is not sign; // extended).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:168,Modifiability,extend,extended,168,"// For ANDI and ANDIS, the higher-order bits are zero if either that is true; // of the first operand, or if the second operand is positive (so that it is; // not sign extended).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Modifiability,extend,extend,16,"// When we zero-extend from i32 to i64, we use a pattern like this:; // def : Pat<(i64 (zext i32:$in)),; // (RLDICL (INSERT_SUBREG (i64 (IMPLICIT_DEF)), $in, sub_32),; // 0, 32)>;; // There are several 32-bit shift/rotate instructions, however, that will; // clear the higher-order bits of their output, rendering the RLDICL; // unnecessary. When that happens, we remove it here, and redefine the; // relevant 32-bit operation to be a 64-bit operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:259,Usability,clear,clear,259,"// When we zero-extend from i32 to i64, we use a pattern like this:; // def : Pat<(i64 (zext i32:$in)),; // (RLDICL (INSERT_SUBREG (i64 (IMPLICIT_DEF)), $in, sub_32),; // 0, 32)>;; // There are several 32-bit shift/rotate instructions, however, that will; // clear the higher-order bits of their output, rendering the RLDICL; // unnecessary. When that happens, we remove it here, and redefine the; // relevant 32-bit operation to be a 64-bit operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:50,Usability,clear,clear,50,"// There are some 32-bit instructions that always clear the high-order 32; // bits, there are also some instructions (like AND) that we can look; // through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:123,Safety,abort,abort,123,"// If the ToPromote set contains nodes that have uses outside of the set; // (except for the original INSERT_SUBREG), then abort the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:126,Safety,safe,safely,126,"// Because all to-be-promoted nodes only have users that are other; // promoted nodes (or the original INSERT_SUBREG), we can safely replace; // the i32 result value type with i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:36,Modifiability,extend,extend,36,// Now we replace the original zero extend and its associated INSERT_SUBREG; // with the value feeding the INSERT_SUBREG (which has now been promoted to; // return an i64).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:10,Usability,simpl,simplify,10,// Try to simplify (xxswap (vec-op (xxswap) (xxswap))) where vec-op is; // lane-insensitive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,Performance,load,load,16,"// If this is a load or store with a zero offset, or within the alignment,; // we may be able to fold an add-immediate into the memory operation.; // The check against alignment is below, as it can't occur until we check; // the arguments to N",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:202,Performance,load,load,202,"// When the feeding operation is an add-immediate of some sort,; // determine whether we need to add relocation information to the; // target flags on the immediate operand when we fold it into the; // load instruction.; //; // For something like ADDItocL, the relocation information is; // inferred from the opcode; when we process it in the AsmPrinter,; // we add the necessary relocation there. A load, though, can receive; // relocation from various flavors of ADDIxxx, so we need to carry; // the relocation information in the target flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:400,Performance,load,load,400,"// When the feeding operation is an add-immediate of some sort,; // determine whether we need to add relocation information to the; // target flags on the immediate operand when we fold it into the; // load instruction.; //; // For something like ADDItocL, the relocation information is; // inferred from the opcode; when we process it in the AsmPrinter,; // we add the necessary relocation there. A load, though, can receive; // relocation from various flavors of ADDIxxx, so we need to carry; // the relocation information in the target flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:145,Deployability,update,update,145,"// If we have a addi(toc@l)/addis(toc@ha) pair, and the addis has only; // one use, then we can do this for any offset, we just need to also; // update the offset (i.e. the symbol addend) on the addis also.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:116,Security,access,access,116,"// If we're directly folding the addend from an addi instruction, then:; // 1. In general, the offset on the memory access must be zero.; // 2. If the addend is a constant, then it can be combined with a; // non-zero offset, but only if the result meets the encoding; // requirements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:135,Deployability,update,update,135,"// We found an opportunity. Reverse the operands from the add; // immediate and substitute them into the load or store. If; // needed, update the target flags for the immediate operand to; // reflect the necessary relocation information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:105,Performance,load,load,105,"// We found an opportunity. Reverse the operands from the add; // immediate and substitute them into the load or store. If; // needed, update the target flags for the immediate operand to; // reflect the necessary relocation information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:12,Performance,perform,perform,12,// We can't perform this optimization for data whose alignment; // is insufficient for the instruction encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:25,Performance,optimiz,optimization,25,// We can't perform this optimization for data whose alignment; // is insufficient for the instruction encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:3,Performance,Load,Load,3,// Load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:70,Energy Efficiency,Power,PowerPC-specific,70,"/// createPPCISelDag - This pass converts a legalized DAG into a; /// PowerPC-specific DAG, ready for instruction scheduling.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:114,Energy Efficiency,schedul,scheduling,114,"/// createPPCISelDag - This pass converts a legalized DAG into a; /// PowerPC-specific DAG, ready for instruction scheduling.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:124,Modifiability,variab,variables,124,"// A faster local-exec TLS access sequence (enabled with the; // -maix-small-local-exec-tls option) can be produced for TLS variables;; // consistent with the IBM XL compiler, we apply a max size of slightly under; // 32KB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:27,Security,access,access,27,"// A faster local-exec TLS access sequence (enabled with the; // -maix-small-local-exec-tls option) can be produced for TLS variables;; // consistent with the IBM XL compiler, we apply a max size of slightly under; // 32KB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:87,Performance,load,load,87,// Initialize map that relates the PPC addressing modes to the computed flags; // of a load/store instruction. The map is used to determine the optimal; // addressing mode when selecting load and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:187,Performance,load,load,187,// Initialize map that relates the PPC addressing modes to the computed flags; // of a load/store instruction. The map is used to determine the optimal; // addressing mode when selecting load and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:53,Modifiability,extend,extended,53,"// On PPC32/64, arguments smaller than 4/8 bytes are extended, so all; // arguments are at least 4/8 bytes aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:66,Modifiability,extend,extended,66,// Sub-word ATOMIC_CMP_SWAP need to ensure that the input is zero-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC has an i16 but no i8 (or i1) SEXTLOAD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:6,Modifiability,extend,extending,6,// No extending loads from f16 or HW conversions back and forth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Performance,load,loads,16,// No extending loads from f16 or HW conversions back and forth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC has pre-inc load and store's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,load,23,// PowerPC has pre-inc load and store's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC uses ADDC/ADDE/SUBC/SUBE to propagate carry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not support direct load/store of condition registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:35,Performance,load,load,35,// PowerPC does not support direct load/store of condition registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Availability,avail,available,102,// Expand ppcf128 to i32 by hand for the benefit of llvm-gcc bootstrap on; // PPC (the libcall is not available).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:52,Energy Efficiency,Power,PowerPC,52,// We do not currently implement these libm ops for PowerPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC has no SREM/UREM instructions unless we are on P9; // On P9 we may use a hardware instruction to compute the remainder.; // When the result of both the remainder and the division is required it is; // more efficient to compute the remainder from the result of the division; // rather than use the remainder instruction. The instructions are legalized; // directly because the DivRemPairsPass performs the transformation at the IR; // level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:217,Energy Efficiency,efficient,efficient,217,// PowerPC has no SREM/UREM instructions unless we are on P9; // On P9 we may use a hardware instruction to compute the remainder.; // When the result of both the remainder and the division is required it is; // more efficient to compute the remainder from the result of the division; // rather than use the remainder instruction. The instructions are legalized; // directly because the DivRemPairsPass performs the transformation at the IR; // level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:403,Performance,perform,performs,403,// PowerPC has no SREM/UREM instructions unless we are on P9; // On P9 we may use a hardware instruction to compute the remainder.; // When the result of both the remainder and the division is required it is; // more efficient to compute the remainder from the result of the division; // rather than use the remainder instruction. The instructions are legalized; // directly because the DivRemPairsPass performs the transformation at the IR; // level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Performance,optimiz,optimizations,24,"// If we're enabling GP optimizations, use hardware square root",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:17,Energy Efficiency,Power,PowerPC,17,"// Prior to P10, PowerPC does not have BSWAP, but we can use vector BSWAP; // instruction xxbrd to speed up scalar BSWAP64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have ROTR,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have Select,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC wants to turn select_cc of FP into fsel when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC wants to optimize integer setcc a bit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Performance,optimiz,optimize,20,// PowerPC wants to optimize integer setcc a bit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have BRCOND which requires SetCC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC turns FP_TO_SINT into FCTIWZ and some load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Performance,load,load,49,// PowerPC turns FP_TO_SINT into FCTIWZ and some load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have [U|S]INT_TO_FP,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:251,Integrability,interface,interfaces,251,"// NOTE: EH_SJLJ_SETJMP/_LONGJMP supported here is NOT intended to support; // SjLj exception handling but a light-weight setjmp/longjmp replacement to; // support continuation, user-level threading, and etc.. As a result, no; // other SjLj exception interfaces are implemented and please don't build; // your own exception handling based on them.; // LLVM/Clang supports zero-cost DWARF exception handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not have FP_TO_UINT on 32-bit implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,Power,PowerPC,10,// 64-bit PowerPC implementations can support i64 types directly,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,Power,PowerPC,10,// 64-bit PowerPC wants to expand i128 shifts itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,Power,PowerPC,10,// 32-bit PowerPC wants to expand i64 shifts itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC has better expansions for funnel shifts than the generic; // TargetLowering::expandFunnelShift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:111,Safety,unsafe,unsafe,111,// The nearbyint variants are not allowed to raise the inexact exception; // so we can only code-gen them with unsafe math.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Availability,avail,available,122,"// 128 bit shifts can be accomplished via 3 instructions for SHL and; // SRL, but not for SRA because of the instructions available:; // VS{RL} and VS{RL}O. However due to direct move costs, it's not worth; // doing",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:67,Safety,predict,predictor,67,// Handle constrained floating-point operations of vector.; // The predictor is `hasVSX` because altivec instruction has; // no exception but VSX vector instruction has.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Energy Efficiency,Power,PowerPC,39,// No implementation for these ops for PowerPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Testability,Test,Test,3,// Test data class instructions store results in CR bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Availability,avail,available,122,"// 128 bit shifts can be accomplished via 3 instructions for SHL and; // SRL, but not for SRA because of the instructions available:; // VS{RL} and VS{RL}O.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:31,Safety,avoid,avoid,31,// Set FADD/FSUB as libcall to avoid the legalizer to expand the; // fp_to_uint and int_to_fp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Availability,avail,available,26,// These libcalls are not available in 32-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:224,Safety,predict,predict,224,// TODO: The default entry number is set to 64. This stops most jump table; // generation on PPC. But it is good for current PPC HWs because the indirect; // branch instruction mtctr to the jump table may lead to bad branch predict.; // Re-evaluate this value on future HWs that can do better with mtctr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Safety,predict,predictable,39,// Let the subtarget (CPU) decide if a predictable select is more expensive; // than the corresponding branch. This information is used in CGP to decide; // when to convert selects into branches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1121,Availability,avail,available,1121,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1684,Deployability,update,updated,1684,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1138,Energy Efficiency,Power,Power,1138,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:99,Performance,load,load,99,"// *********************************** NOTE ************************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:264,Performance,load,load,264,"// *********************************** NOTE ************************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1021,Performance,load,load,1021,"// *********************************** NOTE ************************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction i",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1089,Performance,load,load,1089,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1213,Performance,load,load,1213,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1504,Performance,load,load,1504,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1903,Performance,load,load,1903,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1972,Performance,load,load,1972,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Performance,load,load,34,// TODO: Add mapping for quadword load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Availability,mask,mask,62,"/// isVPKUHUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUHUM instruction.; /// The ShuffleKind distinguishes between big-endian operations with; /// two different inputs (0), either-endian operations with two identical; /// inputs (1), and little-endian operations with two different inputs (2).; /// For the latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Availability,mask,mask,62,"/// isVPKUWUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUWUM instruction.; /// The ShuffleKind distinguishes between big-endian operations with; /// two different inputs (0), either-endian operations with two identical; /// inputs (1), and little-endian operations with two different inputs (2).; /// For the latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Availability,mask,mask,62,"/// isVPKUDUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUDUM instruction, AND the VPKUDUM instruction exists for the; /// current subtarget.; ///; /// The ShuffleKind distinguishes between big-endian operations with; /// two different inputs (0), either-endian operations with two identical; /// inputs (1), and little-endian operations with two different inputs (2).; /// For the latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:58,Availability,mask,mask,58,"/// isVMRGLShuffleMask - Return true if this is a shuffle mask suitable for; /// a VMRGL* instruction with the specified unit size (1,2 or 4 bytes).; /// The ShuffleKind distinguishes between big-endian merges with two; /// different inputs (0), either-endian merges with two identical inputs (1),; /// and little-endian merges with two different inputs (2). For the latter,; /// the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:58,Availability,mask,mask,58,"/// isVMRGHShuffleMask - Return true if this is a shuffle mask suitable for; /// a VMRGH* instruction with the specified unit size (1,2 or 4 bytes).; /// The ShuffleKind distinguishes between big-endian merges with two; /// different inputs (0), either-endian merges with two identical inputs (1),; /// and little-endian merges with two different inputs (2). For the latter,; /// the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Availability,mask,mask,153,"/**; * Common function used to match vmrgew and vmrgow shuffles; *; * The indexOffset determines whether to look for even or odd words in; * the shuffle mask. This is based on the of the endianness of the target; * machine.; * - Little Endian:; * - Use offset of 0 to check for odd elements; * - Use offset of 4 to check for even elements; * - Big Endian:; * - Use offset of 0 to check for even elements; * - Use offset of 4 to check for odd elements; * A detailed description of the vector element ordering for little endian and; * big endian can be found at; * http://www.ibm.com/developerworks/library/l-ibm-xl-c-cpp-compiler/index.html; * Targeting your applications - what little endian and big endian IBM XL C/C++; * compiler differences mean to you; *; * The mask to the shuffle vector instruction specifies the indices of the; * elements from the two input vectors to place in the result. The elements are; * numbered in array-access order, starting with the first vector. These vectors; * are always of type v16i8, thus each vector will contain 16 elements of size; * 8. More info on the shuffle vector can be found in the; * http://llvm.org/docs/LangRef.html#shufflevector-instruction; * Language Reference.; *; * The RHSStartValue indicates whether the same input vectors are used (unary); * or two different input vectors are used, based on the following:; * - If the instruction uses the same vector for both inputs, the range of the; * indices will be 0 to 15. In this case, the RHSStart value passed should; * be 0.; * - If the instruction has two different vectors then the range of the; * indices will be 0 to 31. In this case, the RHSStart value passed should; * be 16 (indices 0-15 specify elements in the first vector while indices 16; * to 31 specify elements in the second vector).; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] IndexOffset Specifies whether to look for even or odd elements; * \param[in] RHSStartValue Specifies the starting index for th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:766,Availability,mask,mask,766,"/**; * Common function used to match vmrgew and vmrgow shuffles; *; * The indexOffset determines whether to look for even or odd words in; * the shuffle mask. This is based on the of the endianness of the target; * machine.; * - Little Endian:; * - Use offset of 0 to check for odd elements; * - Use offset of 4 to check for even elements; * - Big Endian:; * - Use offset of 0 to check for even elements; * - Use offset of 4 to check for odd elements; * A detailed description of the vector element ordering for little endian and; * big endian can be found at; * http://www.ibm.com/developerworks/library/l-ibm-xl-c-cpp-compiler/index.html; * Targeting your applications - what little endian and big endian IBM XL C/C++; * compiler differences mean to you; *; * The mask to the shuffle vector instruction specifies the indices of the; * elements from the two input vectors to place in the result. The elements are; * numbered in array-access order, starting with the first vector. These vectors; * are always of type v16i8, thus each vector will contain 16 elements of size; * 8. More info on the shuffle vector can be found in the; * http://llvm.org/docs/LangRef.html#shufflevector-instruction; * Language Reference.; *; * The RHSStartValue indicates whether the same input vectors are used (unary); * or two different input vectors are used, based on the following:; * - If the instruction uses the same vector for both inputs, the range of the; * indices will be 0 to 15. In this case, the RHSStart value passed should; * be 0.; * - If the instruction has two different vectors then the range of the; * indices will be 0 to 31. In this case, the RHSStart value passed should; * be 16 (indices 0-15 specify elements in the first vector while indices 16; * to 31 specify elements in the second vector).; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] IndexOffset Specifies whether to look for even or odd elements; * \param[in] RHSStartValue Specifies the starting index for th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:935,Security,access,access,935,"/**; * Common function used to match vmrgew and vmrgow shuffles; *; * The indexOffset determines whether to look for even or odd words in; * the shuffle mask. This is based on the of the endianness of the target; * machine.; * - Little Endian:; * - Use offset of 0 to check for odd elements; * - Use offset of 4 to check for even elements; * - Big Endian:; * - Use offset of 0 to check for even elements; * - Use offset of 4 to check for odd elements; * A detailed description of the vector element ordering for little endian and; * big endian can be found at; * http://www.ibm.com/developerworks/library/l-ibm-xl-c-cpp-compiler/index.html; * Targeting your applications - what little endian and big endian IBM XL C/C++; * compiler differences mean to you; *; * The mask to the shuffle vector instruction specifies the indices of the; * elements from the two input vectors to place in the result. The elements are; * numbered in array-access order, starting with the first vector. These vectors; * are always of type v16i8, thus each vector will contain 16 elements of size; * 8. More info on the shuffle vector can be found in the; * http://llvm.org/docs/LangRef.html#shufflevector-instruction; * Language Reference.; *; * The RHSStartValue indicates whether the same input vectors are used (unary); * or two different input vectors are used, based on the following:; * - If the instruction uses the same vector for both inputs, the range of the; * indices will be 0 to 15. In this case, the RHSStart value passed should; * be 0.; * - If the instruction has two different vectors then the range of the; * indices will be 0 to 31. In this case, the RHSStart value passed should; * be 16 (indices 0-15 specify elements in the first vector while indices 16; * to 31 specify elements in the second vector).; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] IndexOffset Specifies whether to look for even or odd elements; * \param[in] RHSStartValue Specifies the starting index for th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Availability,mask,mask,42,/**; * Determine if the specified shuffle mask is suitable for the vmrgew or; * vmrgow instructions.; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] CheckEven Check for an even merge (true) or an odd merge (false); * \param[in] ShuffleKind Identify the type of merge:; * - 0 = big-endian merge with two different inputs;; * - 1 = either-endian merge with two identical inputs;; * - 2 = little-endian merge with two different inputs (inputs are swapped for; * little-endian merges).; * \param[in] DAG The current SelectionDAG; * \return true iff this shuffle mask; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:581,Availability,mask,mask,581,/**; * Determine if the specified shuffle mask is suitable for the vmrgew or; * vmrgow instructions.; *; * \param[in] N The shuffle vector SD Node to analyze; * \param[in] CheckEven Check for an even merge (true) or an odd merge (false); * \param[in] ShuffleKind Identify the type of merge:; * - 0 = big-endian merge with two different inputs;; * - 1 = either-endian merge with two identical inputs;; * - 2 = little-endian merge with two different inputs (inputs are swapped for; * little-endian merges).; * \param[in] DAG The current SelectionDAG; * \return true iff this shuffle mask; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:54,Availability,mask,mask,54,"/// isVSLDOIShuffleMask - If this is a vsldoi shuffle mask, return the shift; /// amount, otherwise return -1.; /// The ShuffleKind distinguishes between big-endian operations with two; /// different inputs (0), either-endian operations with two identical inputs; /// (1), and little-endian operations with two different inputs (2). For the; /// latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Availability,mask,mask,49,// Find the first non-undef value in the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Availability,mask,mask,105,"// Check that the indices are consecutive, in the case of a multi-byte element; // splatted with a v16i8 mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Availability,mask,mask,19,"/// Check that the mask is shuffling N byte elements. Within each N byte; /// element of the mask, the indices could be either in increasing or; /// decreasing order as long as they are consecutive.; /// \param[in] N the shuffle vector SD Node to analyze; /// \param[in] Width the element width in bytes, could be 2/4/8/16 (HalfWord/; /// Word/DoubleWord/QuadWord).; /// \param[in] StepLen the delta indices number among the N byte element, if; /// the mask is in increasing/decreasing order then it is 1/-1.; /// \return true iff the mask is shuffling N byte elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:93,Availability,mask,mask,93,"/// Check that the mask is shuffling N byte elements. Within each N byte; /// element of the mask, the indices could be either in increasing or; /// decreasing order as long as they are consecutive.; /// \param[in] N the shuffle vector SD Node to analyze; /// \param[in] Width the element width in bytes, could be 2/4/8/16 (HalfWord/; /// Word/DoubleWord/QuadWord).; /// \param[in] StepLen the delta indices number among the N byte element, if; /// the mask is in increasing/decreasing order then it is 1/-1.; /// \return true iff the mask is shuffling N byte elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:453,Availability,mask,mask,453,"/// Check that the mask is shuffling N byte elements. Within each N byte; /// element of the mask, the indices could be either in increasing or; /// decreasing order as long as they are consecutive.; /// \param[in] N the shuffle vector SD Node to analyze; /// \param[in] Width the element width in bytes, could be 2/4/8/16 (HalfWord/; /// Word/DoubleWord/QuadWord).; /// \param[in] StepLen the delta indices number among the N byte element, if; /// the mask is in increasing/decreasing order then it is 1/-1.; /// \return true iff the mask is shuffling N byte elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:535,Availability,mask,mask,535,"/// Check that the mask is shuffling N byte elements. Within each N byte; /// element of the mask, the indices could be either in increasing or; /// decreasing order as long as they are consecutive.; /// \param[in] N the shuffle vector SD Node to analyze; /// \param[in] Width the element width in bytes, could be 2/4/8/16 (HalfWord/; /// Word/DoubleWord/QuadWord).; /// \param[in] StepLen the delta indices number among the N byte element, if; /// the mask is in increasing/decreasing order then it is 1/-1.; /// \return true iff the mask is shuffling N byte elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,"// Now we look at mask elements 0,4,8,12",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:59,Availability,mask,mask,59,"// Below, let H and L be arbitrary elements of the shuffle mask; // where H is in the range [4,7] and L is in the range [0,3].; // H, 1, 2, 3 or L, 5, 6, 7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask will; // contain only elements from the first one and the second one will be undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,"// Now we look at mask elements 0,4,8,12, which are the beginning of words.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask will; // contain only elements from the first one and the second one will be undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:47,Availability,Mask,Mask,47,// Ensure each word index of the ShuffleVector Mask is consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:168,Usability,simpl,simply,168,// Input vectors need to be swapped if the leading element; // of the result is one of the 3 left elements of the first vector; // (or if we're shifting by 4 - thereby simply swapping the vectors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:456,Availability,mask,mask,456,"/// Can node \p N be lowered to an XXPERMDI instruction? If so, set \p Swap; /// if the inputs to the instruction should be swapped and set \p DM to the; /// value for the immediate.; /// Specifically, set \p Swap to true only if \p N can be lowered to XXPERMDI; /// AND element 0 of the result comes from the first input (LE) or second input; /// (BE). Set \p DM to the calculated result (0-3) only if \p N can be lowered.; /// \return true iff the given mask of shuffle node \p N is a XXPERMDI shuffle; /// mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:509,Availability,mask,mask,509,"/// Can node \p N be lowered to an XXPERMDI instruction? If so, set \p Swap; /// if the inputs to the instruction should be swapped and set \p DM to the; /// value for the immediate.; /// Specifically, set \p Swap to true only if \p N can be lowered to XXPERMDI; /// AND element 0 of the result comes from the first input (LE) or second input; /// (BE). Set \p DM to the calculated result (0-3) only if \p N can be lowered.; /// \return true iff the given mask of shuffle node \p N is a XXPERMDI shuffle; /// mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask will; // contain only elements from the first one and the second one will be undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:224,Testability,log,logical,224,"// If ByteSize of the splat is bigger than the element size of the; // build_vector, then we have a case where we are checking for a splat where; // multiple elements of the buildvector are folded together into a single; // logical element of the splat (e.g. ""vsplish 1"" to splat {0,1}*8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:17,Modifiability,extend,extend,17,// Properly sign extend the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:230,Testability,test,tests,230,"//===----------------------------------------------------------------------===//; // Addressing Mode Selection; //===----------------------------------------------------------------------===//; /// isIntS16Immediate - This method tests to see if the node is either a 32-bit; /// or 64-bit immediate, and if the value can be accurately represented as a; /// sign extension from a 16-bit value. If so, this returns true and the; /// immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:52,Performance,load,loads,52,"/// Used when computing address flags for selecting loads and stores.; /// If we have an OR, check if the LHS and RHS are provably disjoint.; /// An OR of two provably disjoint values is equivalent to an ADD.; /// Most PPC load/store instructions compute the effective address as a sum,; /// so doing this conversion is useful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:223,Performance,load,load,223,"/// Used when computing address flags for selecting loads and stores.; /// If we have an OR, check if the LHS and RHS are provably disjoint.; /// An OR of two provably disjoint values is equivalent to an ADD.; /// Most PPC load/store instructions compute the effective address as a sum,; /// so doing this conversion is useful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Testability,test,tests,36,"/// isIntS34Immediate - This method tests if value of node given can be; /// accurately represented as a sign extension from a 34-bit value. If so,; /// this returns true and the immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:168,Energy Efficiency,efficient,efficiently,168,"/// SelectAddressRegReg - Given the specified addressed, check to see if it; /// can be represented as an indexed [r+r] operation. Returns false if it; /// can be more efficiently represented as [r+imm]. If \p EncodingAlignment is; /// non-zero and N can be represented by a base register plus a signed 16-bit; /// displacement, make a more precise judgement by checking (displacement % \p; /// EncodingAlignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Performance,load,load,20,"// Is there any SPE load/store (f64), which can't handle 16bit offset?; // SPE load/store can only handle 8-bit offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:79,Performance,load,load,79,"// Is there any SPE load/store (f64), which can't handle 16bit offset?; // SPE load/store can only handle 8-bit offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:480,Energy Efficiency,allocate,allocated,480,"// If we happen to be doing an i64 load or store into a stack slot that has; // less than a 4-byte alignment, then the frame-index elimination may need to; // use an indexed load or store instruction (because the offset may not be a; // multiple of 4). The extra register needed to hold the offset comes from the; // register scavenger, and it is possible that the scavenger will need to use; // an emergency spill slot. As a result, we need to make sure that a spill slot; // is allocated when doing an i64 load/store into a less-than-4-byte-aligned; // stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:35,Performance,load,load,35,"// If we happen to be doing an i64 load or store into a stack slot that has; // less than a 4-byte alignment, then the frame-index elimination may need to; // use an indexed load or store instruction (because the offset may not be a; // multiple of 4). The extra register needed to hold the offset comes from the; // register scavenger, and it is possible that the scavenger will need to use; // an emergency spill slot. As a result, we need to make sure that a spill slot; // is allocated when doing an i64 load/store into a less-than-4-byte-aligned; // stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:174,Performance,load,load,174,"// If we happen to be doing an i64 load or store into a stack slot that has; // less than a 4-byte alignment, then the frame-index elimination may need to; // use an indexed load or store instruction (because the offset may not be a; // multiple of 4). The extra register needed to hold the offset comes from the; // register scavenger, and it is possible that the scavenger will need to use; // an emergency spill slot. As a result, we need to make sure that a spill slot; // is allocated when doing an i64 load/store into a less-than-4-byte-aligned; // stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:508,Performance,load,load,508,"// If we happen to be doing an i64 load or store into a stack slot that has; // less than a 4-byte alignment, then the frame-index elimination may need to; // use an indexed load or store instruction (because the offset may not be a; // multiple of 4). The extra register needed to hold the offset comes from the; // register scavenger, and it is possible that the scavenger will need to use; // an emergency spill slot. As a result, we need to make sure that a spill slot; // is allocated when doing an i64 load/store into a less-than-4-byte-aligned; // stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:108,Testability,test,test,108,"// NOTE: We'll exclude negative FIs here, which come from argument; // lowering, because there are no known test cases triggering this problem; // using packed structures (or similar). We can remove this exclusion if; // we find such a test case. The reason why this is so test-case driven is; // because this entire 'fixup' is only to prevent crashes (from the; // register scavenger) on not-really-valid inputs. For example, if we have:; // %a = alloca i1; // %b = bitcast i1* %a to i64*; // store i64* a, i64 b; // then the store should really be marked as 'align 1', but is not. If it; // were marked as 'align 1' then the indexed form would have been; // instruction-selected initially, and the problem this 'fixup' is preventing; // won't happen regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:236,Testability,test,test,236,"// NOTE: We'll exclude negative FIs here, which come from argument; // lowering, because there are no known test cases triggering this problem; // using packed structures (or similar). We can remove this exclusion if; // we find such a test case. The reason why this is so test-case driven is; // because this entire 'fixup' is only to prevent crashes (from the; // register scavenger) on not-really-valid inputs. For example, if we have:; // %a = alloca i1; // %b = bitcast i1* %a to i64*; // store i64* a, i64 b; // then the store should really be marked as 'align 1', but is not. If it; // were marked as 'align 1' then the indexed form would have been; // instruction-selected initially, and the problem this 'fixup' is preventing; // won't happen regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:273,Testability,test,test-case,273,"// NOTE: We'll exclude negative FIs here, which come from argument; // lowering, because there are no known test cases triggering this problem; // using packed structures (or similar). We can remove this exclusion if; // we find such a test case. The reason why this is so test-case driven is; // because this entire 'fixup' is only to prevent crashes (from the; // register scavenger) on not-really-valid inputs. For example, if we have:; // %a = alloca i1; // %b = bitcast i1* %a to i64*; // store i64* a, i64 b; // then the store should really be marked as 'align 1', but is not. If it; // were marked as 'align 1' then the indexed form would have been; // instruction-selected initially, and the problem this 'fixup' is preventing; // won't happen regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Performance,load,load,36,"// FIXME dl should come from parent load or store, not from address",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Performance,LOAD,LOAD,9,"// Match LOAD (ADD (X, Lo(G))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Loading,3,"// Loading from a constant address.; // If this address fits entirely in a 16-bit sext immediate field, codegen; // this as ""d, 0""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Availability,down,down,25,"// Otherwise, break this down into an LIS + disp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Performance,load,loads,105,/// Similar to the 16-bit case but for instructions that take a 34-bit; /// displacement field (prefixed loads/stores).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:143,Energy Efficiency,reduce,reduce,143,"// If the address is the result of an add, we will utilize the fact that the; // address calculation includes an implicit add. However, we can reduce; // register pressure if we do not materialize a constant just for use as the; // index register. We only get rid of the add if it is not an add of a; // value and a 16-bit signed constant and both have a single use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:43,Performance,load,load,43,"/// Returns true if we should use a direct load into vector instruction; /// (such as lxsd or lfd), instead of a load into gpr + direct move sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:113,Performance,load,load,113,"/// Returns true if we should use a direct load into vector instruction; /// (such as lxsd or lfd), instead of a load into gpr + direct move sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:99,Performance,load,load,99,"// If there are any other uses other than scalar to vector, then we should; // keep it as a scalar load -> direct move pattern to prevent multiple; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:151,Performance,load,loads,151,"// If there are any other uses other than scalar to vector, then we should; // keep it as a scalar load -> direct move pattern to prevent multiple; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:194,Performance,load,load,194,"/// getPreIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if the node's address; /// can be legally represented as pre-indexed load / store address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Energy Efficiency,efficient,efficient,134,"// Do not generate pre-inc forms for specific loads that feed scalar_to_vector; // instructions because we can fold these into a more efficient instruction; // instead, (such as LXSD).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Performance,load,loads,46,"// Do not generate pre-inc forms for specific loads that feed scalar_to_vector; // instructions because we can fold these into a more efficient instruction; // instead, (such as LXSD).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC doesn't have preinc load/store instructions for vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:31,Performance,load,load,31,// PowerPC doesn't have preinc load/store instructions for vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:66,Performance,load,load,66,"// PPC64 doesn't have lwau, but it does have lwaux. Reject preinc load of; // sext i32 to i64 when addr mode is r+i.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:41,Security,access,accesses,41,// Generate non-pic code that has direct accesses to the constant pool.; // The address of the global is just (hi(&g)+lo(&g)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Energy Efficiency,Power,PowerPC,14,"// For 64-bit PowerPC, prefer the more compact relative encodings.; // This trades 32 bits per jump table entry for one or two instructions; // on the jump site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Modifiability,variab,variable,102,"// For local-exec and initial-exec on AIX (64-bit), the sequence generated; // involves a load of the variable offset (from the TOC), followed by an; // add of the loaded variable offset to R13 (the thread pointer).; // This code sequence looks like:; // ld reg1,var[TC](2); // add reg2, reg1, r13 // r13 contains the thread pointer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:171,Modifiability,variab,variable,171,"// For local-exec and initial-exec on AIX (64-bit), the sequence generated; // involves a load of the variable offset (from the TOC), followed by an; // add of the loaded variable offset to R13 (the thread pointer).; // This code sequence looks like:; // ld reg1,var[TC](2); // add reg2, reg1, r13 // r13 contains the thread pointer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:90,Performance,load,load,90,"// For local-exec and initial-exec on AIX (64-bit), the sequence generated; // involves a load of the variable offset (from the TOC), followed by an; // add of the loaded variable offset to R13 (the thread pointer).; // This code sequence looks like:; // ld reg1,var[TC](2); // add reg2, reg1, r13 // r13 contains the thread pointer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:164,Performance,load,loaded,164,"// For local-exec and initial-exec on AIX (64-bit), the sequence generated; // involves a load of the variable offset (from the TOC), followed by an; // add of the loaded variable offset to R13 (the thread pointer).; // This code sequence looks like:; // ld reg1,var[TC](2); // add reg2, reg1, r13 // r13 contains the thread pointer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:103,Modifiability,variab,variables,103,"// With the -maix-small-local-exec-tls option, produce a faster access; // sequence for local-exec TLS variables where the offset from the TLS; // base is encoded as an immediate operand.; //; // We only utilize the faster local-exec access sequence when the TLS; // variable has a size within the policy limit. We treat types that are; // not sized or are empty as being over the policy size limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:267,Modifiability,variab,variable,267,"// With the -maix-small-local-exec-tls option, produce a faster access; // sequence for local-exec TLS variables where the offset from the TLS; // base is encoded as an immediate operand.; //; // We only utilize the faster local-exec access sequence when the TLS; // variable has a size within the policy limit. We treat types that are; // not sized or are empty as being over the policy size limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:64,Security,access,access,64,"// With the -maix-small-local-exec-tls option, produce a faster access; // sequence for local-exec TLS variables where the offset from the TLS; // base is encoded as an immediate operand.; //; // We only utilize the faster local-exec access sequence when the TLS; // variable has a size within the policy limit. We treat types that are; // not sized or are empty as being over the policy size limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:234,Security,access,access,234,"// With the -maix-small-local-exec-tls option, produce a faster access; // sequence for local-exec TLS variables where the offset from the TLS; // base is encoded as an immediate operand.; //; // We only utilize the faster local-exec access sequence when the TLS; // variable has a size within the policy limit. We treat types that are; // not sized or are empty as being over the policy size limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:100,Modifiability,variab,variable,100,"// For local-exec and initial-exec on AIX (32-bit), the sequence generated; // involves loading the variable offset from the TOC, generating a call to; // .__get_tpointer to get the thread pointer (which will be in R3), and; // adding the two together:; // lwz reg1,var[TC](2); // bla .__get_tpointer; // add reg2, reg1, r3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:88,Performance,load,loading,88,"// For local-exec and initial-exec on AIX (32-bit), the sequence generated; // involves loading the variable offset from the TOC, generating a call to; // .__get_tpointer to get the thread pointer (which will be in R3), and; // adding the two together:; // lwz reg1,var[TC](2); // bla .__get_tpointer; // add reg2, reg1, r3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Security,access,access,56,// We do not implement the 32-bit version of the faster access sequence; // for local-exec that is controlled by -maix-small-local-exec-tls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:286,Modifiability,variab,variable,286,"// Only Local-Exec, Initial-Exec and General-Dynamic TLS models are currently; // supported models. If Local- or Initial-exec are not possible or specified,; // all GlobalTLSAddress nodes are lowered using the general-dynamic model.; // We need to generate two TOC entries, one for the variable offset, one for; // the region handle. The global address for the TOC entry of the region; // handle is created with the MO_TLSGDM_FLAG flag and the global address; // for the TOC entry of the variable offset is created with MO_TLSGD_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:488,Modifiability,variab,variable,488,"// Only Local-Exec, Initial-Exec and General-Dynamic TLS models are currently; // supported models. If Local- or Initial-exec are not possible or specified,; // all GlobalTLSAddress nodes are lowered using the general-dynamic model.; // We need to generate two TOC entries, one for the variable offset, one for; // the region handle. The global address for the TOC entry of the region; // handle is created with the MO_TLSGDM_FLAG flag and the global address; // for the TOC entry of the variable offset is created with MO_TLSGD_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:44,Security,expose,expose,44,"// If we're comparing for equality to zero, expose the fact that this is; // implemented as a ctlz/srl pair on ppc, so that the dag combiner can; // fold the new nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:79,Performance,optimiz,optimized,79,"// Leave comparisons against 0 and -1 alone for now, since they're usually; // optimized. FIXME: revisit this when we can custom lower all setcc; // optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:149,Performance,optimiz,optimizations,149,"// Leave comparisons against 0 and -1 alone for now, since they're usually; // optimized. FIXME: revisit this when we can custom lower all setcc; // optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,Availability,mask,masking,191,"// If we have an integer seteq/setne, turn it into a compare against zero; // by xor'ing the rhs with the lhs, which is faster than setting a; // condition register, reading it back out, and masking the correct bit. The; // normal approach here uses sub to do this instead of xor. Using xor exposes; // the result to other bit-twiddling opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:291,Security,expose,exposes,291,"// If we have an integer seteq/setne, turn it into a compare against zero; // by xor'ing the rhs with the lhs, which is faster than setting a; // condition register, reading it back out, and masking the correct bit. The; // normal approach here uses sub to do this instead of xor. Using xor exposes; // the result to other bit-twiddling opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Performance,load,load,26,// determine if we should load from reg_save_area or overflow_area,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:115,Energy Efficiency,allocate,allocated,115,"// For the 32-bit SVR4 ABI we follow the layout of the va_list struct.; // We suppose the given va_list is already allocated.; //; // typedef struct {; // char gpr; /* index into the array of 8 GPRs; // * stored in the register save area; // * gpr=0 corresponds to r3,; // * gpr=1 to r4, etc.; // */; // char fpr; /* index into the array of 8 FPRs; // * stored in the register save area; // * fpr=0 corresponds to f1,; // * fpr=1 to f2, etc.; // */; // char *overflow_arg_area;; // /* location on stack that holds; // * the next overflow argument; // */; // char *reg_save_area;; // /* where r3:r10 and f1:f8 (if saved); // * are stored; // */; // } va_list[1];",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Energy Efficiency,allocate,allocated,49,/// FPR - The set of FP registers that should be allocated for arguments; /// on Darwin and AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:143,Availability,Avail,AvailableFPRs,143,"/// CalculateStackSlotUsed - Return whether this argument will use its; /// stack slot (instead of being passed in registers). ArgOffset,; /// AvailableFPRs, and AvailableVRs must hold the current argument; /// position, and will be updated to account for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:162,Availability,Avail,AvailableVRs,162,"/// CalculateStackSlotUsed - Return whether this argument will use its; /// stack slot (instead of being passed in registers). ArgOffset,; /// AvailableFPRs, and AvailableVRs must hold the current argument; /// position, and will be updated to account for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:233,Deployability,update,updated,233,"/// CalculateStackSlotUsed - Return whether this argument will use its; /// stack slot (instead of being passed in registers). ArgOffset,; /// AvailableFPRs, and AvailableVRs must hold the current argument; /// position, and will be updated to account for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate argument on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:962,Energy Efficiency,Power,PowerPC,962,// 32-bit SVR4 ABI Stack Frame Layout:; // +-----------------------------------+; // +--> | Back chain |; // | +-----------------------------------+; // | | Floating-point register save area |; // | +-----------------------------------+; // | | General register save area |; // | +-----------------------------------+; // | | CR save word |; // | +-----------------------------------+; // | | VRSAVE save word |; // | +-----------------------------------+; // | | Alignment padding |; // | +-----------------------------------+; // | | Vector register save area |; // | +-----------------------------------+; // | | Local variable space |; // | +-----------------------------------+; // | | Parameter list area |; // | +-----------------------------------+; // | | LR save word |; // | +-----------------------------------+; // SP--> +--- | Back chain |; // +-----------------------------------+; //; // Specifications:; // System V Application Binary Interface PowerPC Processor Supplement; // AltiVec Technology Programming Interface Manual,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:952,Integrability,Interface,Interface,952,// 32-bit SVR4 ABI Stack Frame Layout:; // +-----------------------------------+; // +--> | Back chain |; // | +-----------------------------------+; // | | Floating-point register save area |; // | +-----------------------------------+; // | | General register save area |; // | +-----------------------------------+; // | | CR save word |; // | +-----------------------------------+; // | | VRSAVE save word |; // | +-----------------------------------+; // | | Alignment padding |; // | +-----------------------------------+; // | | Vector register save area |; // | +-----------------------------------+; // | | Local variable space |; // | +-----------------------------------+; // | | Parameter list area |; // | +-----------------------------------+; // | | LR save word |; // | +-----------------------------------+; // SP--> +--- | Back chain |; // +-----------------------------------+; //; // Specifications:; // System V Application Binary Interface PowerPC Processor Supplement; // AltiVec Technology Programming Interface Manual,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1026,Integrability,Interface,Interface,1026,// 32-bit SVR4 ABI Stack Frame Layout:; // +-----------------------------------+; // +--> | Back chain |; // | +-----------------------------------+; // | | Floating-point register save area |; // | +-----------------------------------+; // | | General register save area |; // | +-----------------------------------+; // | | CR save word |; // | +-----------------------------------+; // | | VRSAVE save word |; // | +-----------------------------------+; // | | Alignment padding |; // | +-----------------------------------+; // | | Vector register save area |; // | +-----------------------------------+; // | | Local variable space |; // | +-----------------------------------+; // | | Parameter list area |; // | +-----------------------------------+; // | | LR save word |; // | +-----------------------------------+; // SP--> +--- | Back chain |; // +-----------------------------------+; //; // Specifications:; // System V Application Binary Interface PowerPC Processor Supplement; // AltiVec Technology Programming Interface Manual,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:622,Modifiability,variab,variable,622,// 32-bit SVR4 ABI Stack Frame Layout:; // +-----------------------------------+; // +--> | Back chain |; // | +-----------------------------------+; // | | Floating-point register save area |; // | +-----------------------------------+; // | | General register save area |; // | +-----------------------------------+; // | | CR save word |; // | +-----------------------------------+; // | | VRSAVE save word |; // | +-----------------------------------+; // | | Alignment padding |; // | +-----------------------------------+; // | | Vector register save area |; // | +-----------------------------------+; // | | Local variable space |; // | +-----------------------------------+; // | | Parameter list area |; // | +-----------------------------------+; // | | LR save word |; // | +-----------------------------------+; // SP--> +--- | Back chain |; // +-----------------------------------+; //; // Specifications:; // System V Application Binary Interface PowerPC Processor Supplement; // AltiVec Technology Programming Interface Manual,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Modifiability,extend,extended,11,// Get the extended size of the argument type in stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Performance,load,load,10,// Create load nodes to retrieve arguments from the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:128,Modifiability,variab,variable,128,"// Assign locations to all of the incoming aggregate by value arguments.; // Aggregates passed by value are stored in the local variable space of the; // caller's stack frame, right above the parameter list area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Performance,optimiz,optimized,84,// Set the size that is at least reserved in caller of this function. Tail; // call optimized function's reserved stack space needs to be aligned so that; // taking the difference between two stack areas will result in an aligned; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Modifiability,variab,variable,25,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Performance,load,loaded,127,// The fixed integer arguments of a variadic function are stored to the; // VarArgsFrameIndex on the stack so that they may be loaded by; // dereferencing the result of va_next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Energy Efficiency,allocate,allocated,102,"// Do a first pass over the arguments to determine whether the ABI; // guarantees that our caller has allocated the parameter save area; // on its stack frame. In the ELFv1 ABI, this is always the case;; // in the ELFv2 ABI, it is true if this is a vararg function or if; // any parameter is located in a stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Performance,load,load,20,"// Add DAG nodes to load the arguments or copy them out of registers. On; // entry to a function on PPC, the arguments start after the linkage area,; // although the first ones are often in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:208,Energy Efficiency,allocate,allocated,208,"// Create a stack object covering all stack doublewords occupied; // by the argument. If the argument is (fully or partially) on; // the stack, or if the argument is fully in registers but the; // caller has allocated the parameter save anyway, we can refer; // directly to the caller's stack frame. Otherwise, create a; // local copy in our own frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Safety,avoid,avoid,153,"// These can be scalar arguments or elements of an integer array type; // passed directly. Clang may use those instead of ""byval"" aggregate; // types to avoid forcing arguments to memory unnecessarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Performance,load,load,14,// We need to load the argument to a virtual register if we determined; // above that we ran out of physical registers of the appropriate type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Performance,optimiz,optimized,84,// Set the size that is at least reserved in caller of this function. Tail; // call optimized functions' reserved stack space needs to be aligned so that; // taking the difference between two stack areas will result in an aligned; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Modifiability,variab,variable,25,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start.; // On ELFv2ABI spec, it writes:; // C programs that are intended to be *portable* across different compilers; // and architectures must use the header file <stdarg.h> to deal with variable; // argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:226,Modifiability,portab,portable,226,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start.; // On ELFv2ABI spec, it writes:; // C programs that are intended to be *portable* across different compilers; // and architectures must use the header file <stdarg.h> to deal with variable; // argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:334,Modifiability,variab,variable,334,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start.; // On ELFv2ABI spec, it writes:; // C programs that are intended to be *portable* across different compilers; // and architectures must use the header file <stdarg.h> to deal with variable; // argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:125,Performance,load,loaded,125,"// If this function is vararg, store any remaining integer argument regs; // to their spots on the stack so that they may be loaded by dereferencing; // the result of va_next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Testability,stub,stub,71,"// If the callee is preemptable, then the static linker will use a plt-stub; // which saves the toc to the stack, and needs a nop after the call; // instruction to convert to a toc-restore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Safety,safe,safely,10,"// We can safely tail call both fastcc and ccc callees from a c calling; // convention caller. If the caller is fastcc, we may have less stack space; // than a non-fastcc caller with the same signature so disable tail-calls in; // that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:220,Performance,optimiz,optimization,220,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:343,Testability,test,test,343,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:445,Testability,test,test,445,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:460,Testability,test,test,460,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:531,Testability,test,test,531,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:546,Testability,test,test,546,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:561,Testability,test,test,561,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:620,Testability,test,test,620,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:94,Performance,optimiz,optimization,94,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:148,Performance,optimiz,optimization,148,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Modifiability,Variab,Variable,3,// Variable argument functions are not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:131,Performance,optimiz,optimized,131,/// EmitTailCallStoreFPAndRetAddr - Move the frame pointer and return address to; /// the appropriate stack slot for the tail call optimized function call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Performance,load,load,34,/// EmitTCFPAndRetAddrLoad - Emit load from frame pointer and return address; /// stack slot. Returns the chain as result and the loaded frame pointers in; /// LROpOut/FPOpout. Used when tail calling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:130,Performance,load,loaded,130,/// EmitTCFPAndRetAddrLoad - Emit load from frame pointer and return address; /// stack slot. Returns the chain as result and the loaded frame pointers in; /// LROpOut/FPOpout. Used when tail calling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the LR and FP stack slot for later adjusting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Performance,optimiz,optimization,127,// Emit a sequence of copyto/copyfrom virtual registers for arguments that; // might overwrite each other in case of tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Deployability,Patch,PatchPoint,3,// PatchPoint calls are not indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:407,Performance,load,load,407,"// AIX and the 64-bit ELF ABIs need to maintain the TOC pointer accross; // indirect calls. The save of the caller's TOC pointer to the stack will be; // inserted into the DAG as part of call lowering. The restore of the TOC; // pointer is modeled by using a pseudo instruction for the call opcode that; // represents the 2 instruction sequence of an indirect branch and link,; // immediately followed by a load of the TOC pointer from the stack save; // slot into gpr2. For 64-bit ELFv2 ABI with PCRel, do not restore the TOC; // as it is not saved or used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:470,Modifiability,rewrite,rewrite,470,"// The ABIs that maintain a TOC pointer accross calls need to have a nop; // immediately following the call instruction if the caller and callee may; // have different TOC bases. At link time if the linker determines the calls; // may not share a TOC base, the call is redirected to a trampoline inserted; // by the linker. The trampoline will (among other things) save the callers; // TOC pointer at an ABI designated offset in the linkage area and the; // linker will rewrite the nop to be a load of the TOC pointer from the; // linkage area into gpr2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:494,Performance,load,load,494,"// The ABIs that maintain a TOC pointer accross calls need to have a nop; // immediately following the call instruction if the caller and callee may; // have different TOC bases. At link time if the linker determines the calls; // may not share a TOC base, the call is redirected to a trampoline inserted; // by the linker. The trampoline will (among other things) save the callers; // TOC pointer at an ABI designated offset in the linkage area and the; // linker will rewrite the nop to be a load of the TOC pointer from the; // linkage area into gpr2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,Security,secur,secure-PLT,191,"// The PLT is only used in 32-bit ELF PIC mode. Attempting to use the PLT in; // a static relocation model causes some versions of GNU LD (2.17.50, at; // least) to force BSS-PLT, instead of secure-PLT, even if all objects are; // built with secure-PLT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:242,Security,secur,secure-PLT,242,"// The PLT is only used in 32-bit ELF PIC mode. Attempting to use the PLT in; // a static relocation model causes some versions of GNU LD (2.17.50, at; // least) to force BSS-PLT, instead of secure-PLT, even if all objects are; // built with secure-PLT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1017,Energy Efficiency,schedul,scheduled,1017,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1161,Energy Efficiency,schedul,scheduled,1161,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1266,Energy Efficiency,schedul,scheduled,1266,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:447,Performance,perform,performed,447,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:603,Performance,Load,Load,603,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:689,Performance,Load,Load,689,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:761,Performance,Load,Load,761,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1007,Performance,load,loads,1007,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1399,Performance,load,loading,1399,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1236,Security,access,access,1236,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,Performance,load,load,7,// One load for the functions entry point address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Performance,load,loading,11,// One for loading the TOC anchor for the module that contains the called; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Performance,load,loading,11,// One for loading the environment pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,loaded,23,// Then copy the newly loaded TOC anchor to the TOC pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:264,Performance,load,load,264,"// For the TOC based ABIs, we have saved the TOC pointer to the linkage area; // on the stack (this would have been done in `LowerCall_64SVR4` or; // `LowerCall_AIX`). The call instruction is a pseudo instruction that; // represents both the indirect branch and a load that restores the TOC; // pointer from the linkage area. The operand for the TOC restore is an add; // of the TOC save offset to the stack pointer. This must be the second; // operand: after the chain input but before any other variadic arguments.; // For 64-bit ELFv2 ABI with PCRel, do not restore the TOC as it is not; // saved or used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Deployability,PATCH,PATCHPOINT,46,"// We cannot add R2/X2 as an operand here for PATCHPOINT, because there is; // no way to mark dependencies as implicit here.; // We will add the R2/X2 dependency in EmitInstrWithCustomInserter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:94,Integrability,depend,dependencies,94,"// We cannot add R2/X2 as an operand here for PATCHPOINT, because there is; // no way to mark dependencies as implicit here.; // We will add the R2/X2 dependency in EmitInstrWithCustomInserter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:151,Integrability,depend,dependency,151,"// We cannot add R2/X2 as an operand here for PATCHPOINT, because there is; // no way to mark dependencies as implicit here.; // We will add the R2/X2 dependency in EmitInstrWithCustomInserter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Performance,perform,performing,8,// When performing tail call optimization the callee pops its arguments off; // the stack. Account for this here so these bytes can be pushed back on in; // PPCFrameLowering::eliminateCallFramePseudoInstr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:29,Performance,optimiz,optimization,29,// When performing tail call optimization the callee pops its arguments off; // the stack. Account for this here so these bytes can be pushed back on in; // PPCFrameLowering::eliminateCallFramePseudoInstr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:185,Performance,load,load,185,// PC Relative calls no longer guarantee that the callee is a Global; // Address Node. The callee could be an indirect tail call in which; // case the SDValue for the callee could be a load (to load the address; // of a function pointer) or it may be a register copy (to move the; // address of the callee from a function parameter into a virtual; // register). It may also be an ExternalSymbolSDNode (ex memcopy).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:194,Performance,load,load,194,// PC Relative calls no longer guarantee that the callee is a Global; // Address Node. The callee could be an indirect tail call in which; // case the SDValue for the callee could be a load (to load the address; // of a function pointer) or it may be a register copy (to move the; // address of the callee from a function parameter into a virtual; // register). It may also be an ExternalSymbolSDNode (ex memcopy).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:133,Modifiability,variab,variable,133,"// Count how many bytes are to be pushed on the stack, including the linkage; // area, parameter list area and the part of the local variable space which; // contains copies of aggregates which are passed by value.; // Assign locations to all of the outgoing arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:133,Availability,avail,available,133,// Handle fixed and variable vector arguments differently.; // Fixed vector arguments go into registers as long as registers are; // available. Variable vector arguments always go into memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Modifiability,variab,variable,20,// Handle fixed and variable vector arguments differently.; // Fixed vector arguments go into registers as long as registers are; // available. Variable vector arguments always go into memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:144,Modifiability,Variab,Variable,144,// Handle fixed and variable vector arguments differently.; // Fixed vector arguments go into registers as long as registers are; // available. Variable vector arguments always go into memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:85,Modifiability,variab,variable,85,"// Size of the linkage area, parameter list area and the part of the local; // space variable where copies of aggregates which are passed by value are; // stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:85,Performance,optimiz,optimization,85,// Calculate by how many bytes the stack has to be adjusted in case of tail; // call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the return address and frame pointer so it can be moved somewhere else; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Availability,avail,available,118,// Set up a copy of the stack pointer for use loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Performance,load,loading,46,// Set up a copy of the stack pointer for use loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:117,Energy Efficiency,allocate,allocated,117,"// Walk the register/memloc assignments, inserting copies/loads.; // i - Tracks the index into the list of registers allocated for the call; // RealArgIdx - Tracks the index into the list of actual function arguments; // j - Tracks the index into the list of byval arguments",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.; // i - Tracks the index into the list of registers allocated for the call; // RealArgIdx - Tracks the index into the list of actual function arguments; // j - Tracks the index into the list of byval arguments",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:107,Modifiability,variab,variable,107,"// Argument is an aggregate which is passed by value, thus we need to; // create a copy of it in the local variable space of the current stack; // frame (which is the stack frame of the caller) and pass the address of; // this copy to the callee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:32,Modifiability,variab,variable,32,// Memory reserved in the local variable space of the callers stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:178,Modifiability,Extend,Extend,178,"// When useCRBits() is true, there can be i1 arguments.; // It is because getRegisterType(MVT::i1) => MVT::i1,; // and for other integer types getRegisterType() => MVT::i32.; // Extend i1 and ensure callee will get i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Safety,avoid,avoid,20,"// On ELFv2, we can avoid allocating the parameter area if all the arguments; // can be passed to the callee in registers.; // For the fast calling convention, there is another check below.; // Note: We should keep consistent with LowerFormalArguments_64SVR4()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid allocating parameter area for fastcc functions if all the arguments; // can be passed in the registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:422,Energy Efficiency,allocate,allocate,422,"// In the old ELFv1 ABI,; // the prolog code of the callee may store up to 8 GPR argument registers to; // the stack, allowing va_start to index over them in memory if its varargs.; // Because we cannot tell if this is needed on the caller side, we have to; // conservatively assume that it is needed. As such, make sure we have at; // least enough stack space for the caller to store the 8 GPRs.; // In the ELFv2 ABI, we allocate the parameter area iff a callee; // really requires memory operands, e.g. a vararg function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:85,Performance,optimiz,optimization,85,// Calculate by how many bytes the stack has to be adjusted in case of tail; // call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:92,Performance,load,loads,92,"// To protect arguments on the stack from being clobbered in a tail call,; // force all the loads to happen before doing any other lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the return address and frame pointer so it can be move somewhere else; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Availability,avail,available,118,// Set up a copy of the stack pointer for use loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Performance,load,loading,46,// Set up a copy of the stack pointer for use loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:246,Availability,avail,available,246,"// Figure out which arguments are going to go in registers, and which in; // memory. Also, if this is a vararg function, floating point operations; // must be stored to our stack, and loaded into integer regs as well, if; // any integer regs are available for argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:184,Performance,load,loaded,184,"// Figure out which arguments are going to go in registers, and which in; // memory. Also, if this is a vararg function, floating point operations; // must be stored to our stack, and loaded into integer regs as well, if; // any integer regs are available for argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:287,Energy Efficiency,allocate,allocate,287,"// Copy the object to parameter save area if it can not be entirely passed ; // by registers.; // FIXME: we only need to copy the parts which need to be passed in; // parameter save area. For the parts passed by registers, we don't need; // to copy them to the stack although we need to allocate space for them; // in parameter save area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,avail,available,22,"// When a register is available, pass a small aggregate right-justified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:132,Modifiability,variab,variable,132,"// The easiest way to get this right-justified in a register; // is to copy the structure into the rightmost portion of a; // local variable slot, then load the whole slot into the; // register.; // FIXME: The memcpy seems to produce pretty awful code for; // small aggregates, particularly for packed ones.; // FIXME: It would be preferable to use the slot in the; // parameter save area instead of a new local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:412,Modifiability,variab,variable,412,"// The easiest way to get this right-justified in a register; // is to copy the structure into the rightmost portion of a; // local variable slot, then load the whole slot into the; // register.; // FIXME: The memcpy seems to produce pretty awful code for; // small aggregates, particularly for packed ones.; // FIXME: It would be preferable to use the slot in the; // parameter save area instead of a new local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:152,Performance,load,load,152,"// The easiest way to get this right-justified in a register; // is to copy the structure into the rightmost portion of a; // local variable slot, then load the whole slot into the; // register.; // FIXME: The memcpy seems to produce pretty awful code for; // small aggregates, particularly for packed ones.; // FIXME: It would be preferable to use the slot in the; // parameter save area instead of a new local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the slot into the register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Safety,avoid,avoid,153,"// These can be scalar arguments or elements of an integer array type; // passed directly. Clang may use those instead of ""byval"" aggregate; // types to avoid forcing arguments to memory unnecessarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:439,Integrability,rout,routines,439,"// These can be scalar arguments or elements of a float array type; // passed directly. The latter are used to implement ELFv2 homogenous; // float aggregates.; // Named arguments go into FPRs first, and once they overflow, the; // remaining arguments go into GPRs and then the parameter save area.; // Unnamed arguments for vararg functions always go to GPRs and; // then the parameter save area. For now, put all arguments to vararg; // routines always in both locations (FPR *and* GPR or stack slot).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:41,Availability,avail,available,41,// First load the argument into the next available FPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Performance,load,load,9,// First load the argument into the next available FPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Performance,load,load,9,"// Next, load the argument into GPR or stack slot if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:30,Modifiability,extend,extended,30,// Non-array float values are extended and passed in a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load r2 into a virtual register and store it to the TOC save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:88,Energy Efficiency,allocate,allocated,88,// Vectors passed on the stack do not shadow GPRs or FPRs even though they; // might be allocated in the portion of the PSA that is shadowed by the; // GPRs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,allocate,allocate,10,// Shadow allocate register and its stack shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:109,Availability,avail,available,109,// Vectors that are passed as fixed arguments are handled differently.; // They are passed in VRs if any are available (unlike arguments passed; // through ellipses) and shadow GPRs (unlike arguments to non-vaarg; // functions),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Energy Efficiency,allocate,allocate,10,// Shadow allocate GPRs and stack space even though we pass in a VR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:818,Modifiability,variab,variable,818,// AIX ABI Stack Frame Layout:; //; // Low Memory +--------------------------------------------+; // SP +---> | Back chain | ---+; // | +--------------------------------------------+ | ; // | | Saved Condition Register | |; // | +--------------------------------------------+ |; // | | Saved Linkage Register | |; // | +--------------------------------------------+ | Linkage Area; // | | Reserved for compilers | |; // | +--------------------------------------------+ |; // | | Reserved for binders | |; // | +--------------------------------------------+ |; // | | Saved TOC pointer | ---+; // | +--------------------------------------------+; // | | Parameter save area |; // | +--------------------------------------------+; // | | Alloca space |; // | +--------------------------------------------+; // | | Local variable space |; // | +--------------------------------------------+; // | | Float/int conversion temporary |; // | +--------------------------------------------+; // | | Save area for AltiVec registers |; // | +--------------------------------------------+; // | | AltiVec alignment padding |; // | +--------------------------------------------+; // | | Save area for VRSAVE register |; // | +--------------------------------------------+; // | | Save area for General Purpose registers |; // | +--------------------------------------------+; // | | Save area for Floating Point registers |; // | +--------------------------------------------+; // +---- | Back chain |; // High Memory +--------------------------------------------+; //; // Specifications:; // AIX 7.2 Assembler Language Reference; // Subroutine linkage convention,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:133,Availability,avail,available,133,"// For compatibility with the AIX XL compiler, the float args in the; // parameter save area are initialized even if the argument is available; // in register. The caller is required to initialize both the register; // and memory, however, the callee can choose to expect it in either.; // The memloc is dismissed here because the argument is retrieved from; // the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Availability,avail,available,84,"// Vector arguments to VaArg functions are passed both on the stack, and; // in any available GPRs. Load the value from the stack and add the GPRs; // as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:100,Performance,Load,Load,100,"// Vector arguments to VaArg functions are passed both on the stack, and; // in any available GPRs. Load the value from the stack and add the GPRs; // as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:87,Usability,simpl,simply,87,"// Since the callers side has left justified the aggregate in the; // register, we can simply store the entire register into the stack; // slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:110,Performance,load,load,110,"// The store to the fixedstack object is needed becuase accessing a; // field of the ByVal will use a gep and load. Ideally we will optimize; // to extracting the value from the register directly, and elide the; // stores when the arguments address is not taken, but that will need to; // be future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:132,Performance,optimiz,optimize,132,"// The store to the fixedstack object is needed becuase accessing a; // field of the ByVal will use a gep and load. Ideally we will optimize; // to extracting the value from the register directly, and elide the; // stores when the arguments address is not taken, but that will need to; // be future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Security,access,accessing,56,"// The store to the fixedstack object is needed becuase accessing a; // field of the ByVal will use a gep and load. Ideally we will optimize; // to extracting the value from the register directly, and elide the; // stores when the arguments address is not taken, but that will need to; // be future work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Performance,optimiz,optimized,84,// Set the size that is at least reserved in caller of this function. Tail; // call optimized function's reserved stack space needs to be aligned so; // that taking the difference between two stack areas will result in an; // aligned stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Performance,load,loaded,127,// The fixed integer arguments of a variadic function are stored to the; // VarArgsFrameIndex on the stack so that they may be loaded by; // dereferencing the result of va_next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,Availability,avail,available,114,// Set up a copy of the stack pointer for loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Performance,load,loading,42,// Set up a copy of the stack pointer for loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Energy Efficiency,power,power-of-,153,"// Initialize the final register residue.; // Any residue that occupies the final by-val arg register must be; // left-justified on AIX. Loads must be a power-of-2 size and cannot be; // larger than the ByValSize. For example: a 7 byte by-val arg requires 4,; // 2 and 1 byte loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:137,Performance,Load,Loads,137,"// Initialize the final register residue.; // Any residue that occupies the final by-val arg register must be; // left-justified on AIX. Loads must be a power-of-2 size and cannot be; // larger than the ByValSize. For example: a 7 byte by-val arg requires 4,; // 2 and 1 byte loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:276,Performance,load,loads,276,"// Initialize the final register residue.; // Any residue that occupies the final by-val arg register must be; // left-justified on AIX. Loads must be a power-of-2 size and cannot be; // larger than the ByValSize. For example: a 7 byte by-val arg requires 4,; // 2 and 1 byte loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Performance,load,load,68,"// By-val arguments are passed left-justfied in register.; // Every load here needs to be shifted, otherwise a full register load; // should have been used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:125,Performance,load,load,125,"// By-val arguments are passed left-justfied in register.; // Every load here needs to be shifted, otherwise a full register load; // should have been used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Performance,load,load,8,// Then load the GPRs from the stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Availability,avail,available,21,"// If only 1 GPR was available, there will only be one custom GPR and; // the argument will also pass in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the old link SP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the frame index for frame pointer save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the frame index for frame pointer save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Performance,load,load,10,"// First, load 8 bits into 32 bits, then truncate to 1 bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Modifiability,extend,extend,15,"// First, zero extend to 32 bits, then use a truncating store to 8 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Availability,down,down,118,"// Implements a vector truncate that fits in a vector register as a shuffle.; // We want to legalize vector truncates down to where the source fits in; // a vector register (and target is therefore smaller than vector register; // size). At that point legalization will try to custom lower the sub-legal; // result and get here - where we can contain the truncate as a single target; // operation.; // For example a trunc <2 x i16> to <2 x i8> could be visualized as follows:; // <MSB1|LSB1, MSB2|LSB2> to <LSB1, LSB2>; //; // We will implement it for big-endian ordering as this (where x denotes; // undefined):; // < MSB1|LSB1, MSB2|LSB2, uu, uu, uu, uu, uu, uu> to; // < LSB1, LSB2, u, u, u, u, u, u, u, u, u, u, u, u, u, u>; //; // The same operation in little-endian ordering will be:; // <uu, uu, uu, uu, uu, uu, LSB2|MSB2, LSB1|MSB1> to; // <u, u, u, u, u, u, u, u, u, u, u, u, u, u, LSB2, LSB1>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:141,Performance,optimiz,optimization,141,"// We might be able to do better than this under some circumstances, but in; // general, fsel-based lowering of select is a finite-math-only optimization.; // For more information, see section F.3 of the 2.06 ISA specification.; // With ISA 3.0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Performance,load,load,15,"// Result is a load from the stack slot. If loading 4 bytes, make sure to; // add in a bias on big endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:44,Performance,load,loading,44,"// Result is a load from the stack slot. If loading 4 bytes, make sure to; // add in a bias on big endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Availability,avail,available,97,/// Custom lowers floating point to integer conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:146,Performance,load,load,146,/// Custom lowers floating point to integer conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Safety,avoid,avoid,122,/// Custom lowers floating point to integer conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Availability,avail,available,102,// Expand ppcf128 to i32 by hand for the benefit of llvm-gcc bootstrap on; // PPC (the libcall is not available).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:57,Performance,load,load,57,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:101,Performance,load,load,101,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:141,Performance,load,load,141,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:262,Performance,load,load,262,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:329,Performance,load,load,329,"// We're trying to insert a regular store, S, and then a load, L. If the; // incoming value, O, is a load, we might just be able to have our load use the; // address used by O. However, we don't know if anything else will store to; // that address before we can load from it. To prevent this situation, we need; // to insert our load, L, into the chain as a peer of O. To do this, we give L; // the same chain operand as O, we create a token factor from the chain results; // of O and L, and we replace all uses of O's chain result with that token; // factor (see spliceIntoChain below for this last part).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Performance,load,load,24,"// If the result of the load is an illegal type, then we can't build a; // valid chain for reuse since the legalised loads and token factor node that; // ties the legalised loads together uses a different output chain then the; // illegal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:117,Performance,load,loads,117,"// If the result of the load is an illegal type, then we can't build a; // valid chain for reuse since the legalised loads and token factor node that; // ties the legalised loads together uses a different output chain then the; // illegal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:173,Performance,load,loads,173,"// If the result of the load is an illegal type, then we can't build a; // valid chain for reuse since the legalised loads and token factor node that; // ties the legalised loads together uses a different output chain then the; // illegal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:239,Performance,load,load,239,"// If the result of the load is an illegal type, then we can't build a; // valid chain for reuse since the legalised loads and token factor node that; // ties the legalised loads together uses a different output chain then the; // illegal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:59,Performance,load,load,59,/// Analyze profitability of direct move; /// prefer float load to int load plus direct move; /// when there is no integer use of int load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Performance,load,load,71,/// Analyze profitability of direct move; /// prefer float load to int load plus direct move; /// when there is no integer use of int load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Performance,load,load,134,/// Analyze profitability of direct move; /// prefer float load to int load plus direct move; /// when there is no integer use of int load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:33,Performance,load,loaded,33,// Only look at the users of the loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Availability,avail,available,97,/// Custom lowers integer to floating point conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:146,Performance,load,load,146,/// Custom lowers integer to floating point conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Safety,avoid,avoid,122,/// Custom lowers integer to floating point conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:73,Performance,load,load,73,"// If we have direct moves, we can do all the conversion, skip the store/load; // however, without FPCVT we can't do most conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:141,Safety,avoid,avoid,141,"// When converting to single-precision, we actually need to convert; // to double-precision first and then round to single-precision.; // To avoid double-rounding effects during that operation, we have; // to prepare the input operand. Bits that might be truncated when; // converting to double-precision are replaced by a bit that won't; // be lost at this stage, but is below the single-precision rounding; // position.; //; // However, if -enable-unsafe-fp-math is in effect, accept double; // rounding to avoid the extra overhead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:450,Safety,unsafe,unsafe-fp-math,450,"// When converting to single-precision, we actually need to convert; // to double-precision first and then round to single-precision.; // To avoid double-rounding effects during that operation, we have; // to prepare the input operand. Bits that might be truncated when; // converting to double-precision are replaced by a bit that won't; // be lost at this stage, but is below the single-precision rounding; // position.; //; // However, if -enable-unsafe-fp-math is in effect, accept double; // rounding to avoid the extra overhead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:509,Safety,avoid,avoid,509,"// When converting to single-precision, we actually need to convert; // to double-precision first and then round to single-precision.; // To avoid double-rounding effects during that operation, we have; // to prepare the input operand. Bits that might be truncated when; // converting to double-precision are replaced by a bit that won't; // be lost at this stage, but is below the single-precision rounding; // position.; //; // However, if -enable-unsafe-fp-math is in effect, accept double; // rounding to avoid the extra overhead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,Modifiability,extend,extend,114,"// Since we only generate this in 64-bit mode, we can take advantage of; // 64-bit registers. In particular, sign extend the input value into the; // 64-bit register with extsw, store the WHOLE 64-bit value into the stack; // then lfd it and fcfid it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Modifiability,extend,extended,11,// STD the extended value into the stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load the value as a double.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:296,Performance,perform,perform,296,"/*; The rounding mode is in bits 30:31 of FPSR, and has the following; settings:; 00 Round to nearest; 01 Round to 0; 10 Round to +inf; 11 Round to -inf. GET_ROUNDING, on the other hand, expects the following:; -1 Undefined; 0 Round to 0; 1 Round to nearest; 2 Round to +inf; 3 Round to -inf. To perform the conversion, we do:; ((FPSCR & 0x3) ^ ((~FPSCR & 0x3) >> 1)); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load FP Control Word from low 32 bits of stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:63,Integrability,depend,depend,63,// Expand into a bunch of logical ops. Note that these ops; // depend on the PPC behavior for oversized shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Testability,log,logical,26,// Expand into a bunch of logical ops. Note that these ops; // depend on the PPC behavior for oversized shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:63,Integrability,depend,depend,63,// Expand into a bunch of logical ops. Note that these ops; // depend on the PPC behavior for oversized shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Testability,log,logical,26,// Expand into a bunch of logical ops. Note that these ops; // depend on the PPC behavior for oversized shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Testability,log,logical,26,"// Expand into a bunch of logical ops, followed by a select_cc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:187,Energy Efficiency,Power,PowerPC,187,// fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW))); // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW)); // This is simpler than TargetLowering::expandFunnelShift because we can rely; // on PowerPC shift by BW being well defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:113,Usability,simpl,simpler,113,// fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW))); // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW)); // This is simpler than TargetLowering::expandFunnelShift because we can rely; // on PowerPC shift by BW being well defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Energy Efficiency,efficient,efficient,18,"/// Do we have an efficient pattern in a .td file for this node?; ///; /// \param V - pointer to the BuildVectorSDNode being matched; /// \param HasDirectMove - does this subtarget have VSR <-> GPR direct moves?; ///; /// There are some patterns where it is beneficial to keep a BUILD_VECTOR; /// node as a BUILD_VECTOR node rather than expanding it. The patterns where; /// the opposite is true (expansion is beneficial) are:; /// - The node builds a vector out of integers that are not 32 or 64-bits; /// - The node builds a vector out of constants; /// - The node is a ""load-and-splat""; /// In all other cases, we will choose to keep the BUILD_VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:573,Performance,load,load-and-splat,573,"/// Do we have an efficient pattern in a .td file for this node?; ///; /// \param V - pointer to the BuildVectorSDNode being matched; /// \param HasDirectMove - does this subtarget have VSR <-> GPR direct moves?; ///; /// There are some patterns where it is beneficial to keep a BUILD_VECTOR; /// node as a BUILD_VECTOR node rather than expanding it. The patterns where; /// the opposite is true (expansion is beneficial) are:; /// - The node builds a vector out of integers that are not 32 or 64-bits; /// - The node builds a vector out of constants; /// - The node is a ""load-and-splat""; /// In all other cases, we will choose to keep the BUILD_VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Performance,load,load-and-splat,42,// We want to expand nodes that represent load-and-splat even if the; // loaded value is a floating point truncation or conversion to int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:73,Performance,load,loaded,73,// We want to expand nodes that represent load-and-splat even if the; // loaded value is a floating point truncation or conversion to int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:55,Performance,load,load,55,"// If the operands are different or the input is not a load and has more; // uses than just this BV node, then it isn't a splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:67,Modifiability,extend,extending,67,"// For v2f64, v4f32 and v4i32 types, we require the load to be non-extending; // as we cannot handle extending loads for these types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:101,Modifiability,extend,extending,101,"// For v2f64, v4f32 and v4i32 types, we require the load to be non-extending; // as we cannot handle extending loads for these types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:52,Performance,load,load,52,"// For v2f64, v4f32 and v4i32 types, we require the load to be non-extending; // as we cannot handle extending loads for these types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:111,Performance,load,loads,111,"// For v2f64, v4f32 and v4i32 types, we require the load to be non-extending; // as we cannot handle extending loads for these types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:30,Modifiability,extend,extending,30,"// For v8i16 and v16i8 types, extending loads can be handled as long as the; // memory VT is the same vector element VT type.; // The loads feeding into the v8i16 and v16i8 types will be extending because; // scalar i8/i16 are not legal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:187,Modifiability,extend,extending,187,"// For v8i16 and v16i8 types, extending loads can be handled as long as the; // memory VT is the same vector element VT type.; // The loads feeding into the v8i16 and v16i8 types will be extending because; // scalar i8/i16 are not legal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:40,Performance,load,loads,40,"// For v8i16 and v16i8 types, extending loads can be handled as long as the; // memory VT is the same vector element VT type.; // The loads feeding into the v8i16 and v16i8 types will be extending because; // scalar i8/i16 are not legal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Performance,load,loads,134,"// For v8i16 and v16i8 types, extending loads can be handled as long as the; // memory VT is the same vector element VT type.; // The loads feeding into the v8i16 and v16i8 types will be extending because; // scalar i8/i16 are not legal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:13,Modifiability,extend,extend,13,"// Check the extend type, when the input type is i32, and the output vector; // type is v2i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:240,Energy Efficiency,efficient,efficiently,240,"// If this is a case we can't handle, return null and let the default; // expansion code take care of it. If we CAN select this case, and if it; // selects to a single instruction, return Op. Otherwise, if we can codegen; // this case more efficiently than a constant pool load, lower it to the; // sequence of ops that should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:273,Performance,load,load,273,"// If this is a case we can't handle, return null and let the default; // expansion code take care of it. If we CAN select this case, and if it; // selects to a single instruction, return Op. Otherwise, if we can codegen; // this case more efficiently than a constant pool load, lower it to the; // sequence of ops that should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:13,Performance,load,load,13,"// If either load is 0, then we should generate XXLXOR to set to 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Performance,load,load-and-splat,10,// Handle load-and-splat patterns as we have instructions that will do this; // in one go.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:115,Deployability,update,update,115,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:27,Modifiability,extend,extending,27,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:72,Modifiability,extend,extending,72,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Performance,load,load,16,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Performance,load,load,37,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:82,Performance,load,load,82,"// If the input load is an extending load, it will be an i32 -> i64; // extending load and isValidSplatLoad() will update NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Performance,load,load,37,"// Checking for a single use of this load, we have to check for vector; // width (128 bits) / ElementSize uses (since each operand of the; // BUILD_VECTOR is a separate use of the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:458,Modifiability,extend,extend,458,"// Exclude somes case where LD_SPLAT is worse than scalar_to_vector:; // Below cases should also happen for ""lfiwzx/lfiwax + LE target + index; // 1"" and ""lxvrhx + BE target + index 7"" and ""lxvrbx + BE target + index; // 15"", but function IsValidSplatLoad() now will only return true when; // the data at index 0 is not nullptr. So we will not get into trouble for; // these cases.; //; // case 1 - lfiwzx/lfiwax; // 1.1: load result is i32 and is sign/zero extend to i64;; // 1.2: build a v2i64 vector type with above loaded value;; // 1.3: the vector has only one value at index 0, others are all undef;; // 1.4: on BE target, so that lfiwzx/lfiwax does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:422,Performance,load,load,422,"// Exclude somes case where LD_SPLAT is worse than scalar_to_vector:; // Below cases should also happen for ""lfiwzx/lfiwax + LE target + index; // 1"" and ""lxvrhx + BE target + index 7"" and ""lxvrbx + BE target + index; // 15"", but function IsValidSplatLoad() now will only return true when; // the data at index 0 is not nullptr. So we will not get into trouble for; // these cases.; //; // case 1 - lfiwzx/lfiwax; // 1.1: load result is i32 and is sign/zero extend to i64;; // 1.2: build a v2i64 vector type with above loaded value;; // 1.3: the vector has only one value at index 0, others are all undef;; // 1.4: on BE target, so that lfiwzx/lfiwax does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:519,Performance,load,loaded,519,"// Exclude somes case where LD_SPLAT is worse than scalar_to_vector:; // Below cases should also happen for ""lfiwzx/lfiwax + LE target + index; // 1"" and ""lxvrhx + BE target + index 7"" and ""lxvrbx + BE target + index; // 15"", but function IsValidSplatLoad() now will only return true when; // the data at index 0 is not nullptr. So we will not get into trouble for; // these cases.; //; // case 1 - lfiwzx/lfiwax; // 1.1: load result is i32 and is sign/zero extend to i64;; // 1.2: build a v2i64 vector type with above loaded value;; // 1.3: the vector has only one value at index 0, others are all undef;; // 1.4: on BE target, so that lfiwzx/lfiwax does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:31,Performance,load,load,31,"// case 2 - lxvr[hb]x; // 2.1: load result is at most i16;; // 2.2: build a vector with above loaded value;; // 2.3: the vector has only one value at index 0, others are all undef;; // 2.4: on LE target, so that lxvr[hb]x does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:94,Performance,load,loaded,94,"// case 2 - lxvr[hb]x; // 2.1: load result is at most i16;; // 2.2: build a vector with above loaded value;; // 2.3: the vector has only one value at index 0, others are all undef;; // 2.4: on LE target, so that lxvr[hb]x does not need any permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Performance,load,load,56,// Replace all uses of the output chain of the original load with the; // output chain of the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:98,Performance,load,load,98,// Replace all uses of the output chain of the original load with the; // output chain of the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:189,Energy Efficiency,efficient,efficient,189,"// In 64BIT mode BUILD_VECTOR nodes that are not constant splats of up to; // 32-bits can be lowered to VSX instructions under certain conditions.; // Without VSX, there is no pattern more efficient than expanding the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Modifiability,extend,extended,15,"// If the sign extended value is in the range [-16,15], use VSPLTI[bhw].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Performance,optimiz,optimizations,25,"// To avoid having these optimizations undone by constant folding,; // we convert to a pseudo that will be expanded later into one of; // the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:6,Safety,avoid,avoid,6,"// To avoid having these optimizations undone by constant folding,; // we convert to a pseudo that will be expanded later into one of; // the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Usability,undo,undone,39,"// To avoid having these optimizations undone by constant folding,; // we convert to a pseudo that will be expanded later into one of; // the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:12,Availability,mask,mask,12,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa.; // Possible permutations inserting an element from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // 0, X, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // ...; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, X; // Inserting from V1 into V2 will be similar, except mask range will be; // [16,31].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:400,Availability,mask,mask,400,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa.; // Possible permutations inserting an element from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // 0, X, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // ...; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, X; // Inserting from V1 into V2 will be similar, except mask range will be; // [16,31].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask; // will contain only elements from the first one and the second one will be; // undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,// Go through the mask of half-words to find an element that's being moved; // from one vector to the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:77,Availability,Mask,Mask,77,"// If 2nd operand is undefined, we should only look for element 7 in the; // Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Availability,Mask,Mask,37,// Examine the other elements in the Mask to see if they're in original; // order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:64,Availability,Mask,Mask,64,"// If CurrentElement is from V1 [0,15], then we the rest of the Mask to be; // from V2 [16,31] and vice versa. Unless the 2nd operand is undefined,; // in which we always assume we're always picking from the 1st operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,"// Now we look at mask elements 0,2,4,6,8,10,12,14. Pack the mask into a; // 32-bit space, only need 4-bit nibbles per element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:61,Availability,mask,mask,61,"// Now we look at mask elements 0,2,4,6,8,10,12,14. Pack the mask into a; // 32-bit space, only need 4-bit nibbles per element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:12,Availability,mask,mask,12,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa. Possible permutations inserting an element; // from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7; // 0, X, 2, 3, 4, 5, 6, 7; // 0, 1, X, 3, 4, 5, 6, 7; // 0, 1, 2, X, 4, 5, 6, 7; // 0, 1, 2, 3, X, 5, 6, 7; // 0, 1, 2, 3, 4, X, 6, 7; // 0, 1, 2, 3, 4, 5, X, 7; // 0, 1, 2, 3, 4, 5, 6, X; // Inserting from V1 into V2 will be similar, except mask range will be [8,15].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:438,Availability,mask,mask,438,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa. Possible permutations inserting an element; // from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7; // 0, X, 2, 3, 4, 5, 6, 7; // 0, 1, X, 3, 4, 5, 6, 7; // 0, 1, 2, X, 4, 5, 6, 7; // 0, 1, 2, 3, X, 5, 6, 7; // 0, 1, 2, 3, 4, X, 6, 7; // 0, 1, 2, 3, 4, 5, X, 7; // 0, 1, 2, 3, 4, 5, 6, X; // Inserting from V1 into V2 will be similar, except mask range will be [8,15].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,mask,mask,18,// Go through the mask of half-words to find an element that's being moved; // from one vector to the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,Availability,mask,mask,68,"// If both vector operands for the shuffle are the same vector, the mask; // will contain only elements from the first one and the second one will be; // undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:38,Availability,mask,mask,38,// Skip if not the correct element or mask of other elements don't equal; // to our expected order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:75,Availability,mask,mask,75,"// If both operands are defined.; // Target order is [8,15] if the current mask is between [0,7].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Availability,mask,mask,11,// Skip if mask of other elements don't equal our expected order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Availability,mask,mask,26,"// Check that the shuffle mask matches the semantics of XXSPLTI32DX.; // The instruction splats a constant C into two words of the source vector; // producing { C, Unchanged, C, Unchanged } or { Unchanged, C, Unchanged, C }.; // Thus we check that the shuffle mask is the equivalent of; // <0, [4-7], 2, [4-7]> or <[4-7], 1, [4-7], 3> respectively.; // Note: the check above of isNByteElemShuffleMask() ensures that the bytes; // within each word are consecutive, so we only need to check the first byte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:260,Availability,mask,mask,260,"// Check that the shuffle mask matches the semantics of XXSPLTI32DX.; // The instruction splats a constant C into two words of the source vector; // producing { C, Unchanged, C, Unchanged } or { Unchanged, C, Unchanged, C }.; // Thus we check that the shuffle mask is the equivalent of; // <0, [4-7], 2, [4-7]> or <[4-7], 1, [4-7], 3> respectively.; // Note: the check above of isNByteElemShuffleMask() ensures that the bytes; // within each word are consecutive, so we only need to check the first byte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Performance,load,load-and-splat,16,"// If this is a load-and-splat, we can do that with a single instruction; // in some cases. However if the load has multiple uses, we don't want to; // combine it because that will just produce multiple loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:107,Performance,load,load,107,"// If this is a load-and-splat, we can do that with a single instruction; // in some cases. However if the load has multiple uses, we don't want to; // combine it because that will just produce multiple loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:203,Performance,load,loads,203,"// If this is a load-and-splat, we can do that with a single instruction; // in some cases. However if the load has multiple uses, we don't want to; // combine it because that will just produce multiple loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:32,Performance,load,loads,32,// The splat index for permuted loads will be in the left half of the vector; // which is strictly wider than the loaded value by 8 bytes. So we need to; // adjust the splat index to point to the correct address in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,Performance,load,loaded,114,// The splat index for permuted loads will be in the left half of the vector; // which is strictly wider than the loaded value by 8 bytes. So we need to; // adjust the splat index to point to the correct address in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Performance,load,load-and-splat,14,"// For 4-byte load-and-splat, we need Power9.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,load,23,"// If the width of the load is the same as the width of the splat,; // loading with an offset would load the wrong memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Performance,load,loading,71,"// If the width of the load is the same as the width of the splat,; // loading with an offset would load the wrong memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:100,Performance,load,load,100,"// If the width of the load is the same as the width of the splat,; // loading with an offset would load the wrong memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:125,Availability,mask,mask,125,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:181,Availability,mask,mask,181,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:309,Availability,mask,mask,309,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:374,Availability,mask,mask,374,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:579,Availability,avail,available,579,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:700,Performance,load,load,700,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Safety,avoid,avoid,23,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:632,Safety,avoid,avoid,632,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,mask,mask,22,"// The SHUFFLE_VECTOR mask is almost exactly what we want for vperm, except; // that it is in input element units, not in bytes. Convert now.; // For little endian, the order of the input vectors is reversed, and; // the permutation mask is complemented with respect to 31. This is; // necessary to produce proper semantics with the big-endian-based vperm; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:233,Availability,mask,mask,233,"// The SHUFFLE_VECTOR mask is almost exactly what we want for vperm, except; // that it is in input element units, not in bytes. Convert now.; // For little endian, the order of the input vectors is reversed, and; // the permutation mask is complemented with respect to 31. This is; // necessary to produce proper semantics with the big-endian-based vperm; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:53,Availability,mask,mask,53,"// Only need to place items backwards in LE,; // the mask was properly calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Deployability,toggle,toggle,26,"// If we are supposed to, toggle the bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Testability,Test,Testing,10,// FIXME: Testing one of two paired registers is sufficient to guarantee; // ordering?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:44,Modifiability,extend,extend,44,// ATOMIC_CMP_SWAP for i8/i16 needs to zero-extend its input since it will be; // compared to a value that is atomically loaded (atomic loads zero-extend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:147,Modifiability,extend,extend,147,// ATOMIC_CMP_SWAP for i8/i16 needs to zero-extend its input since it will be; // compared to a value that is atomically loaded (atomic loads zero-extend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:121,Performance,load,loaded,121,// ATOMIC_CMP_SWAP for i8/i16 needs to zero-extend its input since it will be; // compared to a value that is atomically loaded (atomic loads zero-extend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:136,Performance,load,loads,136,// ATOMIC_CMP_SWAP for i8/i16 needs to zero-extend its input since it will be; // compared to a value that is atomically loaded (atomic loads zero-extend).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Modifiability,extend,extended,37,"// If this is already correctly zero-extended, leave it alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear the high bits of the compare operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:63,Modifiability,extend,extended,63,// Replace the existing compare operand with the properly zero-extended one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Performance,load,load,25,// Lower quadword atomic load to int_ppc_atomic_load_i128 which will be; // lowered to ppc instructions by pattern matching instruction selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Testability,test,test,37,// When it's cheaper or necessary to test reverse flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,Power,3,"// Power doesn't support testing whether a value is 'normal'. Test the rest; // first, and test if it's 'not not-normal' with expected sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Testability,test,testing,25,"// Power doesn't support testing whether a value is 'normal'. Test the rest; // first, and test if it's 'not not-normal' with expected sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Testability,Test,Test,62,"// Power doesn't support testing whether a value is 'normal'. Test the rest; // first, and test if it's 'not not-normal' with expected sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:91,Testability,test,test,91,"// Power doesn't support testing whether a value is 'normal'. Test the rest; // first, and test if it's 'not not-normal' with expected sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:73,Testability,Test,Test,73,"// The instruction doesn't differentiate between signaling or quiet NaN. Test; // the rest first, and test if it 'is NaN and is signaling/quiet'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Testability,test,test,102,"// The instruction doesn't differentiate between signaling or quiet NaN. Test; // the rest first, and test if it 'is NaN and is signaling/quiet'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,// Load it out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:170,Modifiability,refactor,refactored,170,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Performance,load,load,9,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:138,Performance,load,load,138,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:181,Performance,load,load,181,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:244,Performance,load,loads,244,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:355,Performance,load,load,355,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:397,Performance,load,load,397,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:427,Performance,load,load,427,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:487,Performance,load,load,487,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:51,Modifiability,variab,variable,51,"// On P10, we have legal lowering for constant and variable indices for; // all vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:75,Modifiability,variab,variable,75,"// Before P10, we have legal lowering for constant indices but not for; // variable ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Performance,load,loads,102,// Type v256i1 is used for pairs and v512i1 is used for accumulators.; // Here we create 2 or 4 v16i8 loads to load the pair or accumulator value in; // 2 or 4 vsx registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:111,Performance,load,load,111,// Type v256i1 is used for pairs and v512i1 is used for accumulators.; // Here we create 2 or 4 v16i8 loads to load the pair or accumulator value in; // 2 or 4 vsx registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:17,Modifiability,extend,extends,17,// FIXME: handle extends from half precision float vectors on P9.; // We only want to custom lower an extend from v2f32 to v2f64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,Modifiability,extend,extend,102,// FIXME: handle extends from half precision float vectors on P9.; // We only want to custom lower an extend from v2f32 to v2f64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Performance,load,loads,25,// Ensure both input are loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Performance,load,load,16,// Generate new load node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Modifiability,Variab,Variable,3,// Variable argument lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:104,Performance,scalab,scalability,104,// See http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html and; // http://www.rdrop.com/users/paulmck/scalability/paper/N2745r.2011.03.04a.html; // and http://www.cl.cam.ac.uk/~pes20/cppppc/ for justification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Modifiability,extend,extended,62,// Signed comparisons of byte or halfword values must be sign-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:91,Modifiability,extend,extended,91,"// If this is a signed comparison and the value being compared is not known; // to be sign extended, sign extend it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:106,Modifiability,extend,extend,106,"// If this is a signed comparison and the value being compared is not known; // to be sign extended, sign extend it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:375,Availability,mask,mask,375,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw incr2, incr, shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // loopMBB:; // lwarx tmpDest, ptr; // add tmp, tmpDest, incr2; // andc tmp2, tmpDest, mask; // and tmp3, tmp, mask; // or tmp4, tmp3, tmp2; // stwcx. tmp4, ptr; // bne- loopMBB; // fallthrough --> exitMBB; // srw SrwDest, tmpDest, shift; // rlwinm SrwDest, SrwDest, 0, 24 [16], 31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:482,Availability,mask,mask,482,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw incr2, incr, shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // loopMBB:; // lwarx tmpDest, ptr; // add tmp, tmpDest, incr2; // andc tmp2, tmpDest, mask; // and tmp3, tmp, mask; // or tmp4, tmp3, tmp2; // stwcx. tmp4, ptr; // bne- loopMBB; // fallthrough --> exitMBB; // srw SrwDest, tmpDest, shift; // rlwinm SrwDest, SrwDest, 0, 24 [16], 31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:506,Availability,mask,mask,506,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw incr2, incr, shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // loopMBB:; // lwarx tmpDest, ptr; // add tmp, tmpDest, incr2; // andc tmp2, tmpDest, mask; // and tmp3, tmp, mask; // or tmp4, tmp3, tmp2; // stwcx. tmp4, ptr; // bne- loopMBB; // fallthrough --> exitMBB; // srw SrwDest, tmpDest, shift; // rlwinm SrwDest, SrwDest, 0, 24 [16], 31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Performance,load,load,14,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw incr2, incr, shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // loopMBB:; // lwarx tmpDest, ptr; // add tmp, tmpDest, incr2; // andc tmp2, tmpDest, mask; // and tmp3, tmp, mask; // or tmp4, tmp3, tmp2; // stwcx. tmp4, ptr; // bne- loopMBB; // fallthrough --> exitMBB; // srw SrwDest, tmpDest, shift; // rlwinm SrwDest, SrwDest, 0, 24 [16], 31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Safety,avoid,avoid,37,// We need use 32-bit subregister to avoid mismatch register class in 64-bit; // mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Modifiability,extend,extend,118,"// For unsigned comparisons, we can directly compare the shifted values.; // For signed comparisons we shift and sign extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Usability,clear,clear,56,"// Since the shift amount is not a constant, we need to clear; // the upper bits with a separate RLWINM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Deployability,update,updated,20,"// Since FP is only updated here but NOT referenced, it's treated as GPR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Availability,down,down,9,// Round down to the stack alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:444,Deployability,update,update,444,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:106,Testability,Test,TestMBB,106,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:350,Testability,Test,TestMBB,350,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:359,Testability,test,test,359,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:486,Testability,Test,TestMBB,486,"// The CFG of probing stack looks as; // +-----+; // | MBB |; // +--+--+; // |; // +----v----+; // +--->+ TestMBB +---+; // | +----+----+ |; // | | |; // | +-----v----+ |; // +---+ BlockMBB | |; // +----------+ |; // |; // +---------+ |; // | TailMBB +<--+; // +---------+; // In MBB, calculate previous frame pointer and final stack pointer.; // In TestMBB, test if sp is equal to final stack pointer, if so, jump to; // TailMBB. In BlockMBB, update the sp atomically and jump back to TestMBB.; // TailMBB is spliced via \p MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:139,Availability,redundant,redundant,139,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Energy Efficiency,allocate,allocated,97,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:129,Safety,avoid,avoid,129,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:139,Safety,redund,redundant,139,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:38,Deployability,update,update,38,// Materialize a scratch register for update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:63,Integrability,depend,dependence,63,"// Call lowering should have added an r2 operand to indicate a dependence; // on the TOC base pointer value. It can't however, because there is no; // way to mark the dependence as implicit there, and so the stackmap code; // will confuse it with a regular operand. Instead, add the dependence; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:167,Integrability,depend,dependence,167,"// Call lowering should have added an r2 operand to indicate a dependence; // on the TOC base pointer value. It can't however, because there is no; // way to mark the dependence as implicit there, and so the stackmap code; // will confuse it with a regular operand. Instead, add the dependence; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:283,Integrability,depend,dependence,283,"// Call lowering should have added an r2 operand to indicate a dependence; // on the TOC base pointer value. It can't however, because there is no; // way to mark the dependence as implicit there, and so the stackmap code; // will confuse it with a regular operand. Instead, add the dependence; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:113,Integrability,wrap,wrapped,113,"// To read the 64-bit time-base register on a 32-bit target, we read the; // two halves. Should the counter have wrapped while it was being read, we; // need to try again.; // ...; // readLoop:; // mfspr Rx,TBU # load from TBU; // mfspr Ry,TB # load from TB; // mfspr Rz,TBU # load from TBU; // cmpw crX,Rx,Rz # check if 'old'='new'; // bne readLoop # branch if they're not equal; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:213,Performance,load,load,213,"// To read the 64-bit time-base register on a 32-bit target, we read the; // two halves. Should the counter have wrapped while it was being read, we; // need to try again.; // ...; // readLoop:; // mfspr Rx,TBU # load from TBU; // mfspr Ry,TB # load from TB; // mfspr Rz,TBU # load from TBU; // cmpw crX,Rx,Rz # check if 'old'='new'; // bne readLoop # branch if they're not equal; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:245,Performance,load,load,245,"// To read the 64-bit time-base register on a 32-bit target, we read the; // two halves. Should the counter have wrapped while it was being read, we; // need to try again.; // ...; // readLoop:; // mfspr Rx,TBU # load from TBU; // mfspr Ry,TB # load from TB; // mfspr Rz,TBU # load from TBU; // cmpw crX,Rx,Rz # check if 'old'='new'; // bne readLoop # branch if they're not equal; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:277,Performance,load,load,277,"// To read the 64-bit time-base register on a 32-bit target, we read the; // two halves. Should the counter have wrapped while it was being read, we; // need to try again.; // ...; // readLoop:; // mfspr Rx,TBU # load from TBU; // mfspr Ry,TB # load from TB; // mfspr Rz,TBU # load from TBU; // cmpw crX,Rx,Rz # check if 'old'='new'; // bne readLoop # branch if they're not equal; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:409,Availability,mask,mask,409,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:454,Availability,mask,mask,454,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:485,Availability,mask,mask,485,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:549,Availability,mask,mask,549,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:630,Availability,mask,mask,630,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Performance,load,load,14,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Safety,avoid,avoid,37,// We need use 32-bit subregister to avoid mismatch register class in 64-bit; // mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Performance,perform,performs,15,// This pseudo performs an FADD with rounding mode temporarily forced; // to round-to-zero. We emit this via custom inserter since the FPSCR; // is not modeled at the SelectionDAG level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform addition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Performance,Load,Load,3,"// Load from the stack where SrcReg is stored, and save to DestReg,; // so we have done the RegClass conversion from RegClass::SrcReg to; // RegClass::DestReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,Availability,mask,mask,7,// The mask 255 means that put the 32:63 bits of NewFPSCRReg to the 32:63; // bits of FPSCR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:92,Performance,Optimiz,Optimization,92,//===----------------------------------------------------------------------===//; // Target Optimization Hooks; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:27,Testability,Test,Test,27,// We only have VSX Vector Test for software Square Root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:204,Availability,redundant,redundant,204,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:564,Deployability,pipeline,pipeline,564,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Safety,unsafe,unsafe-fp-math,46,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:137,Safety,unsafe,unsafe-fp-math,137,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:204,Safety,redund,redundant,204,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:244,Testability,log,logic,244,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,Availability,down,down,122,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Performance,load,load,49,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:181,Performance,load,loads,181,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:292,Performance,load,load,292,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:317,Performance,load,load,317,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:259,Safety,safe,safe,259,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:107,Performance,load,load,107,"// First, search up the chain, branching to follow all token-factor operands.; // If we find a consecutive load, then we're done, otherwise, record all; // nodes just above the top-level loads and token factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:187,Performance,load,loads,187,"// First, search up the chain, branching to follow all token-factor operands.; // If we find a consecutive load, then we're done, otherwise, record all; // nodes just above the top-level loads and token factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,Availability,down,down,18,"// Second, search down the chain, starting from the top-level nodes recorded; // in the first phase. These top-level nodes are the nodes just above all; // loads and token factors. Starting with their uses, recursively look though; // all loads (just the chain uses) and token factors to find a consecutive; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:156,Performance,load,loads,156,"// Second, search down the chain, starting from the top-level nodes recorded; // in the first phase. These top-level nodes are the nodes just above all; // loads and token factors. Starting with their uses, recursively look though; // all loads (just the chain uses) and token factors to find a consecutive; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:239,Performance,load,loads,239,"// Second, search down the chain, starting from the top-level nodes recorded; // in the first phase. These top-level nodes are the nodes just above all; // loads and token factors. Starting with their uses, recursively look though; // all loads (just the chain uses) and token factors to find a consecutive; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:311,Performance,load,load,311,"// Second, search down the chain, starting from the top-level nodes recorded; // in the first phase. These top-level nodes are the nodes just above all; // loads and token factors. Starting with their uses, recursively look though; // all loads (just the chain uses) and token factors to find a consecutive; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:280,Usability,guid,guide,280,/// This function is called when we have proved that a SETCC node can be replaced; /// by subtraction (and other supporting instructions) so that the result of; /// comparison is kept in a GPR instead of CR. This function is purely for; /// codegen purposes and has some flags to guide the codegen process.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Modifiability,extend,extend,8,"// Zero extend the operands to the largest legal integer. Originally, they; // must be of a strictly smaller size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Integrability,Depend,Depends,19,// Swap if needed. Depends on the condition code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:12,Modifiability,extend,extended,12,// Subtract extended integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Modifiability,extend,extend,25,// If all users of SETCC extend its value to a legal integer type; // then we replace SETCC with a subtraction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Safety,abort,abort,84,// We have an input that is not an extension or another binary; // operation; we'll abort this transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:112,Security,validat,validate,112,"// Replace all operations (these are all the same, but have a different; // (i1) return type). DAG.getNode will validate that the types of; // a binary operator match, so go through the list in reverse so that; // we've likely promoted both operands first. Any intermediate truncations or; // extensions disappear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:413,Availability,mask,masking,413,"// If we're tracking CR bits, we need to be careful that we don't have:; // zext(binary-ops(trunc(x), trunc(y))); // or; // zext(binary-ops(binary-ops(trunc(x), trunc(y)), ...); // such that we're unnecessarily moving things into CR bits that can more; // efficiently stay in GPRs. Note that if we're not certain that the high; // bits are set as required by the final extension, we still may need to do; // some masking to get the proper behavior.; // This same functionality is important on PPC64 when dealing with; // 32-to-64-bit extensions; these occur often when 32-bit values are used as; // the return values of functions. Because it is so similar, it is handled; // here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:256,Energy Efficiency,efficient,efficiently,256,"// If we're tracking CR bits, we need to be careful that we don't have:; // zext(binary-ops(trunc(x), trunc(y))); // or; // zext(binary-ops(binary-ops(trunc(x), trunc(y)), ...); // such that we're unnecessarily moving things into CR bits that can more; // efficiently stay in GPRs. Note that if we're not certain that the high; // bits are set as required by the final extension, we still may need to do; // some masking to get the proper behavior.; // This same functionality is important on PPC64 when dealing with; // 32-to-64-bit extensions; these occur often when 32-bit values are used as; // the return values of functions. Because it is so similar, it is handled; // here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Safety,abort,abort,84,// We have an input that is not a truncation or another binary; // operation; we'll abort this transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:50,Modifiability,extend,extended,50,"// If all of the inputs are not already sign/zero extended, then; // we'll still need to do that at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,Security,validat,validate,118,"// Replace all operations (these are all the same, but have a different; // (promoted) return type). DAG.getNode will validate that the types of; // a binary operator match, so go through the list in reverse so that; // we've likely promoted both operands first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Availability,mask,mask,24,"// To zero extend, just mask off everything except for the first bit (in the; // i1 case).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Modifiability,extend,extend,11,"// To zero extend, just mask off everything except for the first bit (in the; // i1 case).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Modifiability,extend,extending,14,// Is this an extending load from an f32 to an f64?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Performance,load,load,24,// Is this an extending load from an f32 to an f64?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:4,Energy Efficiency,Reduce,Reduces,4,"/// Reduces the number of fp-to-int conversion when building a vector.; ///; /// If this vector is built out of floating to integer conversions,; /// transform it to a vector built out of floating point values followed by a; /// single floating to integer conversion of the vector.; /// Namely (build_vector (fptosi $A), (fptosi $B), ...); /// becomes (fptosi (build_vector ($A, $B, ...)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:194,Modifiability,extend,extending,194,"// If we are converting to 32-bit integers, we need to add an FP_ROUND.; // This is not valid if the input was originally double precision. It is; // also not profitable to do unless this is an extending load in which; // case doing this combine will allow us to combine consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:204,Performance,load,load,204,"// If we are converting to 32-bit integers, we need to add an FP_ROUND.; // This is not valid if the input was originally double precision. It is; // also not profitable to do unless this is an extending load in which; // case doing this combine will allow us to combine consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:283,Performance,load,loads,283,"// If we are converting to 32-bit integers, we need to add an FP_ROUND.; // This is not valid if the input was originally double precision. It is; // also not profitable to do unless this is an extending load in which; // case doing this combine will allow us to combine consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:107,Modifiability,extend,extending,107,"// For 32-bit values, we need to add an FP_ROUND node (if we made it; // here, we know that all inputs are extending loads so this is safe).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:117,Performance,load,loads,117,"// For 32-bit values, we need to add an FP_ROUND node (if we made it; // here, we know that all inputs are extending loads so this is safe).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Safety,safe,safe,134,"// For 32-bit values, we need to add an FP_ROUND node (if we made it; // here, we know that all inputs are extending loads so this is safe).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:4,Energy Efficiency,Reduce,Reduce,4,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Performance,load,loads,25,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:99,Performance,load,loads,99,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Performance,load,load,127,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:163,Performance,load,loads,163,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:193,Performance,load,loads,193,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:47,Performance,load,loads,47,// Not a build vector of (possibly fp_rounded) loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:30,Performance,load,loads,30,// We only care about regular loads. The PPC-specific load intrinsics; // will not lead to a merge opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:54,Performance,load,load,54,// We only care about regular loads. The PPC-specific load intrinsics; // will not lead to a merge opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Performance,load,loads,21,// Exit early if the loads are neither consecutive nor reverse consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:74,Modifiability,extend,extended,74,"// Look for build vector patterns where input operands come from sign; // extended vector_extract elements of specific indices. If the correct indices; // aren't used, add a vector shuffle to fix up the indices and create; // SIGN_EXTEND_INREG node which selects the vector sign extend instructions; // during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:279,Modifiability,extend,extend,279,"// Look for build vector patterns where input operands come from sign; // extended vector_extract elements of specific indices. If the correct indices; // aren't used, add a vector shuffle to fix up the indices and create; // SIGN_EXTEND_INREG node which selects the vector sign extend instructions; // during instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:55,Modifiability,extend,extend,55,"// This array encodes the indices that the vector sign extend instructions; // extract from when extending from one type to another for both BE and LE.; // The right nibble of each byte corresponds to the LE incides.; // and the left nibble of each byte corresponds to the BE incides.; // For example: 0x3074B8FC byte->word; // For LE: the allowed indices are: 0x0,0x4,0x8,0xC; // For BE: the allowed indices are: 0x3,0x7,0xB,0xF; // For example: 0x000070F8 byte->double word; // For LE: the allowed indices are: 0x0,0x8; // For BE: the allowed indices are: 0x7,0xF",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Modifiability,extend,extending,97,"// This array encodes the indices that the vector sign extend instructions; // extract from when extending from one type to another for both BE and LE.; // The right nibble of each byte corresponds to the LE incides.; // and the left nibble of each byte corresponds to the BE incides.; // For example: 0x3074B8FC byte->word; // For LE: the allowed indices are: 0x0,0x4,0x8,0xC; // For BE: the allowed indices are: 0x3,0x7,0xB,0xF; // For example: 0x000070F8 byte->double word; // For LE: the allowed indices are: 0x0,0x8; // For BE: the allowed indices are: 0x7,0xF",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:44,Modifiability,extend,extended,44,"// If the build vector operands aren't sign extended vector extracts,; // of the same input vector, then return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:189,Modifiability,extend,extending,189,"// Look for the pattern of a load from a narrow width to i128, feeding; // into a BUILD_VECTOR of v1i128. Replace this sequence with a PPCISD node; // (LXVRZX). This node represents a zero extending load that will be matched; // to the Load VSX Vector Rightmost instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:29,Performance,load,load,29,"// Look for the pattern of a load from a narrow width to i128, feeding; // into a BUILD_VECTOR of v1i128. Replace this sequence with a PPCISD node; // (LXVRZX). This node represents a zero extending load that will be matched; // to the Load VSX Vector Rightmost instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:199,Performance,load,load,199,"// Look for the pattern of a load from a narrow width to i128, feeding; // into a BUILD_VECTOR of v1i128. Replace this sequence with a PPCISD node; // (LXVRZX). This node represents a zero extending load that will be matched; // to the Load VSX Vector Rightmost instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:236,Performance,Load,Load,236,"// Look for the pattern of a load from a narrow width to i128, feeding; // into a BUILD_VECTOR of v1i128. Replace this sequence with a PPCISD node; // (LXVRZX). This node represents a zero extending load that will be matched; // to the Load VSX Vector Rightmost instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:79,Performance,load,load,79,// Proceed with the transformation if the operand to the BUILD_VECTOR; // is a load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:51,Performance,load,loading,51,"// This transformation is only valid if the we are loading either a byte,; // halfword, word, or doubleword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:60,Modifiability,extend,extended,60,// Ensure that the load from the narrow width is being zero extended to i128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Performance,load,load,19,// Ensure that the load from the narrow width is being zero extended to i128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,Performance,load,loads,49,"// If we're building a vector out of consecutive loads, just load that; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:61,Performance,load,load,61,"// If we're building a vector out of consecutive loads, just load that; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Modifiability,extend,extended,37,// If we're building a vector out of extended elements from another vector; // we have P9 vector integer extend instructions. The code assumes legal; // input types (i.e. it can't handle things like v4i16) so do not run before; // legalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Modifiability,extend,extend,105,// If we're building a vector out of extended elements from another vector; // we have P9 vector integer extend instructions. The code assumes legal; // input types (i.e. it can't handle things like v4i16) so do not run before; // legalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Performance,Load,Load,19,"// On Power10, the Load VSX Vector Rightmost instructions can be utilized; // if this is a BUILD_VECTOR of v1i128, and if the operand to the BUILD_VECTOR; // is a load from <valid narrow width> to i128.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:163,Performance,load,load,163,"// On Power10, the Load VSX Vector Rightmost instructions can be utilized; // if this is a BUILD_VECTOR of v1i128, and if the operand to the BUILD_VECTOR; // is a load from <valid narrow width> to i128.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Modifiability,extend,extend,42,"// For signed conversion, we need to sign-extend the value in the VSR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:207,Modifiability,extend,extending,207,"// For i32 intermediate values, unfortunately, the conversion functions; // leave the upper 32 bits of the value are undefined. Within the set of; // scalar instructions, we have no method for zero- or sign-extending the; // value. Thus, we cannot handle i32 intermediate values here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:108,Performance,load,load,108,"// If we're converting from a float, to an int, and back to a float again,; // then we don't need the store/load pair at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Performance,load,loads,36,// expandVSXLoadForLE - Convert VSX loads (which may be intrinsics for; // builtins) into loads with swaps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:90,Performance,load,loads,90,// expandVSXLoadForLE - Convert VSX loads (which may be intrinsics for; // builtins) into loads with swaps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:13,Performance,load,load,13,// Delay VSX load for LE combine until after LegalizeOps to prioritize other; // load combines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:81,Performance,load,load,81,// Delay VSX load for LE combine until after LegalizeOps to prioritize other; // load combines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Performance,load,load,36,"// If the MMO suggests this isn't a load of a full vector, leave; // things alone. For a built-in, we have to make the change for; // correctness, so if there is a size problem that will be a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Performance,load,load,34,// Add a bitcast if the resulting load type doesn't match v2f64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:50,Performance,Load,Load,50,"// Package {bitcast value, swap's chain} to match Load's shape.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Performance,perform,perform,8,// Only perform combine for conversion to i64/i32 or power9 i16/i8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:65,Availability,Mask,Mask,65,// Check that the source of the element keeps flipping; // (i.e. Mask[i] < NumElts -> Mask[i+i] >= NumElts).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:86,Availability,Mask,Mask,86,// Check that the source of the element keeps flipping; // (i.e. Mask[i] < NumElts -> Mask[i+i] >= NumElts).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,mask,mask,22,"// Fix up the shuffle mask to account for the fact that the result of; // scalar_to_vector is not in lane zero. This just takes all values in; // the ranges specified by the min/max indices and adds the number of; // elements required to ensure each element comes from the respective; // position in the valid lane.; // On little endian, that's just the corresponding element in the other; // half of the vector. On big endian, it is in the same half but right; // justified rather than left justified in that half.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:206,Availability,mask,mask,206,"// Replace a SCALAR_TO_VECTOR with a SCALAR_TO_VECTOR_PERMUTED except if; // the original is:; // (<n x Ty> (scalar_to_vector (Ty (extract_elt <n x Ty> %a, C)))); // In such a case, just change the shuffle mask to extract the element; // from the permuted index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:420,Availability,mask,mask,420,"// On little endian subtargets, combine shuffles such as:; // vector_shuffle<16,1,17,3,18,5,19,7,20,9,21,11,22,13,23,15>, <zero>, %b; // into:; // vector_shuffle<16,0,17,1,18,2,19,3,20,4,21,5,22,6,23,7>, <zero>, %b; // because the latter can be matched to a single instruction merge.; // Furthermore, SCALAR_TO_VECTOR on little endian always involves a permute; // to put the value into element zero. Adjust the shuffle mask so that the; // vector can remain in permuted form (to prevent a swap prior to a shuffle).; // On big endian targets, this is still useful for SCALAR_TO_VECTOR; // nodes with elements smaller than doubleword because all the ways; // of getting scalar data into a vector register put the value in the; // rightmost element of the left half of the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,mask,mask,22,// Adjust the shuffle mask if either input vector comes from a; // SCALAR_TO_VECTOR and keep the respective input vector in permuted; // form (to prevent the need for a swap).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:299,Deployability,update,updated,299,"// FIXME: If both LHS and RHS are SCALAR_TO_VECTOR, but are not the; // same type and have differing element sizes, then do not perform; // the following transformation. The current transformation for; // SCALAR_TO_VECTOR assumes that both input vectors have the same; // element size. This will be updated in the future to account for; // differing sizes of the LHS and RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:128,Performance,perform,perform,128,"// FIXME: If both LHS and RHS are SCALAR_TO_VECTOR, but are not the; // same type and have differing element sizes, then do not perform; // the following transformation. The current transformation for; // SCALAR_TO_VECTOR assumes that both input vectors have the same; // element size. This will be updated in the future to account for; // differing sizes of the LHS and RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Availability,mask,mask,22,"// Fix up the shuffle mask to reflect where the desired element actually is.; // The minimum and maximum indices that correspond to element zero for both; // the LHS and RHS are computed and will control which shuffle mask entries; // are to be changed. For example, if the RHS is permuted, any shuffle mask; // entries in the range [RHSMinIdx,RHSMaxIdx) will be adjusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:218,Availability,mask,mask,218,"// Fix up the shuffle mask to reflect where the desired element actually is.; // The minimum and maximum indices that correspond to element zero for both; // the LHS and RHS are computed and will control which shuffle mask entries; // are to be changed. For example, if the RHS is permuted, any shuffle mask; // entries in the range [RHSMinIdx,RHSMaxIdx) will be adjusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:303,Availability,mask,mask,303,"// Fix up the shuffle mask to reflect where the desired element actually is.; // The minimum and maximum indices that correspond to element zero for both; // the LHS and RHS are computed and will control which shuffle mask entries; // are to be changed. For example, if the RHS is permuted, any shuffle mask; // entries in the range [RHSMinIdx,RHSMaxIdx) will be adjusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Usability,simpl,simplified,15,// We may have simplified away the shuffle. We won't be able to do anything; // further with it here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,Availability,mask,mask,24,// We are looking for a mask such that all even elements are from; // one vector and all odd elements from the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Availability,mask,mask,14,// Adjust the mask so we are pulling in the same index from the splat; // as the index from the interesting vector in consecutive elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Performance,load,load,10,"// If the load return value 0 has more than one user except the; // shufflevector instruction, it is not profitable to replace the; // shufflevector with a reverse load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:164,Performance,load,load,164,"// If the load return value 0 has more than one user except the; // shufflevector instruction, it is not profitable to replace the; // shufflevector with a reverse load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,Safety,avoid,avoided,62,"// If there are other uses of the shuffle, the swap cannot be avoided.; // Forcing the use of an X-Form (since swapped stores only have; // X-Forms) without removing the swap is unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,Modifiability,extend,extend,191,"// We don't want (and (zext (shift...)), C) if C fits in the width of the; // original input as that will prevent us from selecting optimal rotates.; // This only matters if the input to the extend is i32 widened to i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Usability,simpl,simple,25,// STBRX can only handle simple types and it makes no sense to store less; // two bytes in byte-reversed order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:13,Modifiability,extend,extend,13,// Do an any-extend to 32-bits if this is a half-word input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Modifiability,extend,extended,16,// Need to sign-extended to 64-bits to handle negative values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:131,Deployability,Update,UpdateNodeOperands,131,// DAG.getTruncStore() can't be used here because it doesn't accept; // the general (base + offset) addressing mode.; // So we use UpdateNodeOperands and setTruncatingStore instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Performance,load,loads,26,"// For little endian, VSX loads require generating lxvd2x/xxswapd.; // Not needed on ISA 3.0 based CPUs since we have a non-permuting load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Performance,load,load,134,"// For little endian, VSX loads require generating lxvd2x/xxswapd.; // Not needed on ISA 3.0 based CPUs since we have a non-permuting load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:45,Performance,load,load,45,"// We sometimes end up with a 64-bit integer load, from which we extract; // two single-precision floating-point numbers. This happens with; // std::complex<float>, and other similar structures, because of the way we; // canonicalize structure copies. However, if we lack direct moves,; // then the final bitcasts from the extracted integer values to the; // floating-point numbers turn into store/load pairs. Even with direct moves,; // just loading the two floating-point numbers is likely better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:398,Performance,load,load,398,"// We sometimes end up with a 64-bit integer load, from which we extract; // two single-precision floating-point numbers. This happens with; // std::complex<float>, and other similar structures, because of the way we; // canonicalize structure copies. However, if we lack direct moves,; // then the final bitcasts from the extracted integer values to the; // floating-point numbers turn into store/load pairs. Even with direct moves,; // just loading the two floating-point numbers is likely better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:443,Performance,load,loading,443,"// We sometimes end up with a 64-bit integer load, from which we extract; // two single-precision floating-point numbers. This happens with; // std::complex<float>, and other similar structures, because of the way we; // canonicalize structure copies. However, if we lack direct moves,; // then the final bitcasts from the extracted integer values to the; // floating-point numbers turn into store/load pairs. Even with direct moves,; // just loading the two floating-point numbers is likely better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:61,Performance,load,load,61,"// We're looking for a sequence like this:; // t13: i64,ch = load<LD8[%ref.tmp]> t0, t6, undef:i64; // t16: i64 = srl t13, Constant:i32<32>; // t17: i32 = truncate t16; // t18: f32 = bitcast t17; // t19: i32 = truncate t13; // t20: f32 = bitcast t19",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:57,Performance,load,load,57,// Note that DAGCombine should re-form any pre-increment load(s) from; // what is produced here if that makes sense.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:41,Performance,LOAD,LOAD,41,// P8 and later hardware should just use LOAD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:42,Performance,load,load,42,// This is a type-legal unaligned Altivec load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:901,Availability,fault,fault,901,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,loading,23,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:350,Performance,load,loads,350,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:459,Performance,load,loads,459,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:626,Performance,load,loaded,626,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:676,Performance,load,load,676,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:784,Performance,load,load,784,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1110,Performance,load,loaded,1110,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1394,Performance,perform,perform,1394,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1411,Performance,optimiz,optimization,1411,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:888,Safety,avoid,avoid,888,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Performance,load,load,39,"// Create the new MMO for the new base load. It is like the original MMO,; // but represents an area in memory almost twice the vector size centered; // on the original address. If the address is unaligned, we might start; // reading up to (sizeof(vector)-1) bytes below the address of the; // original unaligned load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:313,Performance,load,load,313,"// Create the new MMO for the new base load. It is like the original MMO,; // but represents an area in memory almost twice the vector size centered; // on the original address. If the address is unaligned, we might start; // reading up to (sizeof(vector)-1) bytes below the address of the; // original unaligned load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,load,23,// Create the new base load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Performance,load,load,71,"// Note that the value of IncOffset (which is provided to the next; // load's pointer info offset value, and thus used to calculate the; // alignment), and the value of IncValue (which is actually used to; // increment the pointer value) are different! This is because we; // require the next load to appear to be aligned, even though it; // is actually offset from the base pointer by a lesser amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:293,Performance,load,load,293,"// Note that the value of IncOffset (which is provided to the next; // load's pointer info offset value, and thus used to calculate the; // alignment), and the value of IncValue (which is actually used to; // increment the pointer value) are different! This is because we; // require the next load to appear to be aligned, even though it; // is actually offset from the base pointer by a lesser amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Availability,down,down,21,"// Walk (both up and down) the chain looking for another load at the real; // (aligned) offset (the alignment of the other load does not matter in; // this case). If found, then do not use the offset reduction trick, as; // that will prevent the loads from being later combined (as they would; // otherwise be duplicates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:57,Performance,load,load,57,"// Walk (both up and down) the chain looking for another load at the real; // (aligned) offset (the alignment of the other load does not matter in; // this case). If found, then do not use the offset reduction trick, as; // that will prevent the loads from being later combined (as they would; // otherwise be duplicates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:123,Performance,load,load,123,"// Walk (both up and down) the chain looking for another load at the real; // (aligned) offset (the alignment of the other load does not matter in; // this case). If found, then do not use the offset reduction trick, as; // that will prevent the loads from being later combined (as they would; // otherwise be duplicates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:246,Performance,load,loads,246,"// Walk (both up and down) the chain looking for another load at the real; // (aligned) offset (the alignment of the other load does not matter in; // this case). If found, then do not use the offset reduction trick, as; // that will prevent the loads from being later combined (as they would; // otherwise be duplicates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:108,Performance,load,loaded,108,"// second argument is 1 because this rounding; // is always exact.; // The output of the permutation is our loaded result, the TokenFactor is; // our new chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:92,Availability,down,down,92,"// Combine vmaxsw/h/b(a, a's negation) to abs(a); // Expose the vabsduw/h/b opportunity for down stream",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:53,Security,Expose,Expose,53,"// Combine vmaxsw/h/b(a, a's negation) to abs(a); // Expose the vabsduw/h/b opportunity for down stream",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,Performance,load,loads,26,"// For little endian, VSX loads require generating lxvd2x/xxswapd.; // Not needed on ISA 3.0 based CPUs since we have a non-permuting load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,Performance,load,load,134,"// For little endian, VSX loads require generating lxvd2x/xxswapd.; // Not needed on ISA 3.0 based CPUs since we have a non-permuting load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,Performance,LOAD,LOAD,15,"// Turn BSWAP (LOAD) -> lhbrx/lwbrx.; // For subtargets without LDBRX, we can still do better than the default; // expansion even for 64-bit BSWAP (LOAD).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:148,Performance,LOAD,LOAD,148,"// Turn BSWAP (LOAD) -> lhbrx/lwbrx.; // For subtargets without LDBRX, we can still do better than the default; // expansion even for 64-bit BSWAP (LOAD).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:28,Performance,load,load,28,// Create the byte-swapping load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Performance,load,load,21,"// If this is an i16 load, insert the truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:75,Performance,load,load,75,"// First, combine the bswap away. This makes the value produced by the; // load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Performance,load,load,21,"// Next, combine the load away, we give it a bogus result value but a real; // chain result. The result value is dead because the bswap is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:36,Performance,load,loads,36,// Convert this to two 32-bit bswap loads and a BUILD_PAIR. Do this only; // before legalization so that the BUILD_PAIR is handled correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Performance,load,loads,34,// Can't split volatile or atomic loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,Safety,safe,safe,56,"// If the user is a MFOCRF instruction, we know this is safe.; // Otherwise we give up for right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:240,Availability,down,down,240,"// If this is a branch on an altivec predicate comparison, lower this so; // that we don't have to do a MFOCRF: instead, branch directly on CR6. This; // lowering is done pre-legalize, because the legalizer lowers the predicate; // compare down to code that is difficult to reassemble.; // This code also handles branches that depend on the result of a store; // conditional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:327,Integrability,depend,depend,327,"// If this is a branch on an altivec predicate comparison, lower this so; // that we don't have to do a MFOCRF: instead, branch directly on CR6. This; // lowering is done pre-legalize, because the legalizer lowers the predicate; // compare down to code that is difficult to reassemble.; // This code also handles branches that depend on the result of a store; // conditional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Usability,clear,cleared,39,// lhbrx is known to have the top bits cleared out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,Usability,clear,cleared,16,// Top bits are cleared for load2r (which is the same as lhbrx).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:184,Integrability,depend,depend,184,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:103,Performance,cache,cache,103,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,Safety,predict,prediction,127,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:226,Testability,log,logic,226,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:131,Performance,cache,cache,131,"// For small loops (between 5 and 8 instructions), align to a 32-byte; // boundary so that the entire loop fits in one instruction-cache line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,Deployability,upgrade,upgrade,191,"// r[0-9]+ are used, on PPC64, to refer to the corresponding 64-bit registers; // (which we call X[0-9]+). If a 64-bit value has been requested, and a; // 32-bit GPR has been selected, then 'upgrade' it to the 64-bit parent; // register.; // FIXME: If TargetLowering::getRegForInlineAsmConstraint could somehow use; // the AsmName field from *RegisterInfo.td, then this would not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:47,Energy Efficiency,power,power,47,"// ""N"" is a positive constant that is an exact power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:116,Performance,load,load,116,"// isLegalAddressingMode - Return true if the addressing mode represented; // by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:148,Energy Efficiency,Power,PowerPC,148,"// Vector type r+i form is supported since power9 as DQ form. We don't check; // the offset matching DQ form requirement(off % 16 == 0), because on PowerPC,; // imm form is preferred and the offset can be adjusted to use imm form later; // in pass PPCLoopInstrFormPrep. Also in LSR, for one LSRUse, it uses min and; // max offset to check legal addressing mode, we should be a little aggressive; // to contain other offsets for that LSRUse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,Modifiability,extend,extended,21,// PPC allows a sign-extended 16-bit immediate field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,Integrability,depend,depending,22,"// ""r+i"" or just ""i"", depending on HasBaseReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:35,Performance,optimiz,optimize,35,// Make sure the function does not optimize away the store of the RA to; // the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,Performance,load,load,153,// The link register (return address) is saved in the caller's frame; // not the callee's stack frame. So we must get the caller's frame; // address and load the return address at the LR offset from there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:8,Performance,load,load,8,// Just load the return address off the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Security,access,access,19,// 32-bit SVR4 ABI access everything as got-indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,Security,access,accesses,7,"// AIX accesses everything indirectly through the TOC, which is similar to; // the GOT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,Performance,load,loading,84,"// If it is small or large code model, module locals are accessed; // indirectly by loading their address from .toc/.got.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:57,Security,access,accessed,57,"// If it is small or large code model, module locals are accessed; // indirectly by loading their address from .toc/.got.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,Security,access,accessed,34,// JumpTable and BlockAddress are accessed as got-indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,Energy Efficiency,Power,PowerPC,7,// The PowerPC target isn't yet aware of offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,Testability,log,logic,97,/// It returns EVT::Other if the type should be determined using generic; /// target-independent logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:51,Availability,avail,available,51,"// We should use Altivec/VSX loads and stores when available. For unaligned; // addresses, unaligned VSX loads are only fast starting with the P8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:29,Performance,load,loads,29,"// We should use Altivec/VSX loads and stores when available. For unaligned; // addresses, unaligned VSX loads are only fast starting with the P8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Performance,load,loads,105,"// We should use Altivec/VSX loads and stores when available. For unaligned; // addresses, unaligned VSX loads are only fast starting with the P8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:50,Performance,load,load,50,/// Returns true if it is beneficial to convert a load of a constant; /// to just the constant itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:138,Availability,mask,mask,138,"// FIXME: Add other cases...; // - 32-bit shifts with a zext to i64; // - zext after ctlz, bswap, etc.; // - zext after and by a constant mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Modifiability,Extend,Extending,3,// Extending to float128 is not free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:126,Energy Efficiency,efficient,efficient,126,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:193,Energy Efficiency,efficient,efficient,193,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Security,access,access,37,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:86,Security,access,accessing,86,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:139,Security,access,accessing,139,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:48,Usability,simpl,simple,48,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Energy Efficiency,Power,PowerPC,20,"// Don't break FMA, PowerPC prefers FMA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:179,Energy Efficiency,Power,PowerPC,179,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,Performance,load,load,23,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:91,Performance,load,load,91,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:188,Performance,load,loading,188,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:237,Performance,load,loading,237,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,Performance,load,loads,11,"// For the loads that combineLoadToOperationType does nothing, like; // ordered load, it should be profitable to hoist them.; // For swifterror load, it can only be used for pointer to pointer type, so; // later type check should get rid of this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:80,Performance,load,load,80,"// For the loads that combineLoadToOperationType does nothing, like; // ordered load, it should be profitable to hoist them.; // For swifterror load, it can only be used for pointer to pointer type, so; // later type check should get rid of this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:144,Performance,load,load,144,"// For the loads that combineLoadToOperationType does nothing, like; // ordered load, it should be profitable to hoist them.; // For swifterror load, it can only be used for pointer to pointer type, so; // later type check should get rid of this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:198,Deployability,patch,patchpoints,198,"// LR is a callee-save register, but we must treat it as clobbered by any call; // site. Hence we include LR in the scratch registers, which are in turn added; // as implicit-defs for stackmaps and patchpoints. The same reasoning applies; // to CTR, which is used by any indirect call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:71,Deployability,canary,canary,71,// Override to disable global variable loading on Linux and insert AIX canary; // word declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:30,Modifiability,variab,variable,30,// Override to disable global variable loading on Linux and insert AIX canary; // word declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Performance,load,loading,39,// Override to disable global variable loading on Linux and insert AIX canary; // word declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:59,Modifiability,extend,extended,59,"// We can't save an operation here if the value is already extended, and; // the existing shift is easier to combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:213,Usability,simpl,simplified,213,"// Transform (add X, (zext(setne Z, C))) -> (addze X, (addic (addi Z, -C), -1)); // Transform (add X, (zext(sete Z, C))) -> (addze X, (subfic (addi Z, -C), 0)); // When C is zero, the equation (addi Z, -C) can be simplified to Z; // Requirement: -C in [-32768, 32767], X and Z are MVT::i64 types",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:89,Deployability,update,updated,89,// The new global address is a copy of the old global address except; // that it has the updated Offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Safety,Detect,Detect,3,// Detect TRUNCATE operations on bitcasts of float128 values.; // What we are looking for here is the situtation where we extract a subset; // of bits from a 128 bit float.; // This can be of two forms:; // 1) BITCAST of f128 feeding TRUNCATE; // 2) BITCAST of f128 feeding SRL (a shift) feeding TRUNCATE; // The reason this is required is because we do not have a legal i128 type; // and so we want to prevent having to store the f128 and then reload part; // of it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Deployability,Update,Update,3,// Update Op0 past the SRL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,Modifiability,enhance,enhance,9,// TODO: enhance the condition for subtarget before pwr8,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Availability,mask,mask,10,// If the mask is suitable for andi. or andis. we should sink the and.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Availability,mask,masks,20,"// For non-constant masks, we can always use the record-form and.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:155,Performance,load,load,155,/// Set alignment flags based on whether or not the Frame Index is aligned.; /// Utilized when computing flags for address computation when selecting; /// load and store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,Usability,clear,clear,114,"// If this is (add $FI, $S16Imm), the alignment flags are already set; // based on the immediate. We just need to clear the alignment flags; // if the FI alignment is weaker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:90,Performance,load,load,90,"/// Given a node, compute flags that are used for address computation when; /// selecting load and store instructions. The flags computed are stored in; /// FlagSet. This function takes into account whether the node is a constant,; /// an ADD, OR, or a constant, and computes the address flags accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:40,Integrability,depend,depending,40,// Set the alignment flags for the node depending on if the node is; // 4-byte or 16-byte aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,Performance,load,load,105,"/// computeMOFlags - Given a node N and it's Parent (a MemSDNode), compute; /// the address flags of the load/store instruction that is to be matched.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:29,Performance,load,load,29,"// If the node is the paired load/store intrinsics, compute flags for; // address computation and return early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:174,Performance,load,loads,174,"// For integers, no extension is the same as zero extension.; // We set the extension mode to zero extension so we don't have; // to add separate entries in AddrModesMap for loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:143,Energy Efficiency,reduce,reduce,143,"// If the address is the result of an add, we will utilize the fact that the; // address calculation includes an implicit add. However, we can reduce; // register pressure if we do not materialize a constant just for use as the; // index register. We only get rid of the add if it is not an add of a; // value and a 16-bit signed constant and both have a single use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:125,Modifiability,extend,extend,125,"// If we are splitting a scalar integer into f64 parts (i.e. so they; // can be placed into VFRC registers), we need to zero extend and; // bitcast the values. This will ensure the value is placed into a; // VSR using direct moves or stack operations as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:95,Performance,load,load,95,"// If the address mode is DS-Form or DQ-Form, check if the FI is aligned.; // Select an X-Form load if it is not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:33,Integrability,depend,depending,33,// Set Base and Disp accordingly depending on the address mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:76,Performance,load,load-immediate-shifted,76,// This is a constant address at most 32 bits. The base will be; // zero or load-immediate-shifted and the displacement will be; // the low 16 bits of the address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,Availability,down,down,25,"// Otherwise, break this down into LIS + Disp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,Performance,Load,Load,46,"// Otherwise, the PPC:MOF_NotAdd flag is set. Load/Store is Non-foldable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:32,Availability,avail,available,32,"// By default, X-Form is always available to be selected.; // When a frame index is not aligned, we also match by XForm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:47,Integrability,Interface,Interface,47,"//===-- PPCISelLowering.h - PPC32 DAG Lowering Interface --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that PPC uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- PPCISelLowering.h - PPC32 DAG Lowering Interface --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that PPC uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:416,Performance,LOAD,LOAD,416,"// When adding a NEW PPCISD node please add it to the correct position in; // the enum. The order of elements in this enum matters!; // Values that are added after this entry:; // STBRX = ISD::FIRST_TARGET_MEMORY_OPCODE; // are considered memory opcodes and are treated differently than entries; // that come before it. For example, ADD or MUL should be placed before; // the ISD::FIRST_TARGET_MEMORY_OPCODE while a LOAD or STORE should come; // after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:97,Modifiability,extend,extended,97,"/// VEXTS, ByteWidth - takes an input in VSFRC and produces an output in; /// VSFRC that is sign-extended from ByteWidth to a 64-byte integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:4,Testability,Test,Test,4,/// Test instruction for software square root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:40,Performance,perform,performed,40,"/// To avoid stack clash, allocation is performed by block and each block is; /// probed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:7,Safety,avoid,avoid,7,"/// To avoid stack clash, allocation is performed by block and each block is; /// probed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:59,Modifiability,extend,extend-sign,59,"/// EXTSWSLI = The PPC extswsli instruction, which does an extend-sign; /// word and shift left immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:96,Energy Efficiency,power,power,96,"/// The combination of sra[wd]i and addze used to implemented signed; /// integer division by a power of 2. The first operand is the dividend,; /// and the second is the constant shift amount (representing the; /// divisor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:4,Energy Efficiency,Power,PowerPC,4,/// PowerPC instructions that have SCALAR_TO_VECTOR semantics tend to; /// place the value into the least significant element of the most; /// significant doubleword in the vector. This is not element zero for; /// anything smaller than a doubleword on either endianness. This node has; /// the same semantics as SCALAR_TO_VECTOR except that the value remains in; /// the aforementioned location in the vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:37,Deployability,Toggle,Toggle,37,"/// ch, gl = CR6[UN]SET ch, inglue - Toggle CR bit 6 for SVR4 vararg calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:176,Modifiability,variab,variable,176,"/// GPRC = TLSGD_AIX, TOC_ENTRY, TOC_ENTRY; /// G8RC = TLSGD_AIX, TOC_ENTRY, TOC_ENTRY; /// Op that combines two register copies of TOC entries; /// (region handle into R3 and variable offset into R4) followed by a; /// GET_TLS_ADDR node which will be expanded to a call to __get_tls_addr.; /// This node is used in 64-bit mode as well (in which case the result is; /// G8RC and inputs are X3/X4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:104,Performance,optimiz,optimize,104,"/// VRRC = VADD_SPLAT Elt, EltSize - Temporary node to be expanded; /// during instruction selection to optimize a BUILD_VECTOR into; /// operations on splats. This is necessary to avoid losing these; /// optimizations due to constant folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:205,Performance,optimiz,optimizations,205,"/// VRRC = VADD_SPLAT Elt, EltSize - Temporary node to be expanded; /// during instruction selection to optimize a BUILD_VECTOR into; /// operations on splats. This is necessary to avoid losing these; /// optimizations due to constant folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:181,Safety,avoid,avoid,181,"/// VRRC = VADD_SPLAT Elt, EltSize - Temporary node to be expanded; /// during instruction selection to optimize a BUILD_VECTOR into; /// operations on splats. This is necessary to avoid losing these; /// optimizations due to constant folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:49,Deployability,rolling,rolling,49,/// CHAIN = CLRBHRB CHAIN - Clear branch history rolling buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:28,Usability,Clear,Clear,28,/// CHAIN = CLRBHRB CHAIN - Clear branch history rolling buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:78,Deployability,rolling,rolling,78,"/// GPRC, CHAIN = MFBHRBE CHAIN, Entry, Dummy - Move from branch; /// history rolling buffer entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:220,Performance,load,load,220,"/// VSRC, CHAIN = XXSWAPD CHAIN, VSRC - Occurs only for little; /// endian. Maps to an xxswapd instruction that corrects an lxvd2x; /// or stxvd2x instruction. The chain is necessary because the; /// sequence replaces a load and needs to provide the same number; /// of outputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:57,Performance,load,loads,57,/// An SDNode for swaps that are not associated with any loads/stores; /// and thereby have no chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:41,Modifiability,extend,extend,41,"/// FP_EXTEND_HALF(VECTOR, IDX) - Custom extend upper (IDX=0) half or; /// lower (IDX=1) half of v4f32 to v2f64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:136,Performance,load,load,136,/// MAT_PCREL_ADDR = Materialize a PC Relative address. This can be done; /// either through an add like PADDI or through a PC Relative load like; /// PLD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:114,Security,access,access,114,/// TLS_DYNAMIC_MAT_PCREL_ADDR = Materialize a PC Relative address for; /// TLS global address when using dynamic access models. This can be done; /// through an add like PADDI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:158,Availability,avail,available,158,"/// TLS_LOCAL_EXEC_MAT_ADDR = Materialize an address for TLS global address; /// when using local exec access models, and when prefixed instructions are; /// available. This is used with ADD_TLS to produce an add like PADDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:103,Security,access,access,103,"/// TLS_LOCAL_EXEC_MAT_ADDR = Materialize an address for TLS global address; /// when using local exec access models, and when prefixed instructions are; /// available. This is used with ADD_TLS to produce an add like PADDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:246,Testability,test,tests,246,"// NOTE: The nodes below may require PC-Rel specific patterns if the; // address could be PC-Relative. When adding new nodes below, consider; // whether or not the address can be PC-Relative and add the corresponding; // PC-relative patterns and tests.; /// CHAIN = STBRX CHAIN, GPRC, Ptr, Type - This is a; /// byte-swapping store instruction. It byte-swaps the low ""Type"" bits of; /// the GPRC input, then stores it through Ptr. Type can be either i16 or; /// i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:71,Performance,load,load,71,"/// GPRC, CHAIN = LBRX CHAIN, Ptr, Type - This is a; /// byte-swapping load instruction. It loads ""Type"" bits, byte swaps it,; /// then puts it in the bottom bits of the GPRC. TYPE can be either i16; /// or i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:92,Performance,load,loads,92,"/// GPRC, CHAIN = LBRX CHAIN, Ptr, Type - This is a; /// byte-swapping load instruction. It loads ""Type"" bits, byte swaps it,; /// then puts it in the bottom bits of the GPRC. TYPE can be either i16; /// or i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:84,Modifiability,extend,extends,84,"/// GPRC, CHAIN = LFIWAX CHAIN, Ptr - This is a floating-point; /// load which sign-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:68,Performance,load,load,68,"/// GPRC, CHAIN = LFIWAX CHAIN, Ptr - This is a floating-point; /// load which sign-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:84,Modifiability,extend,extends,84,"/// GPRC, CHAIN = LFIWZX CHAIN, Ptr - This is a floating-point; /// load which zero-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:68,Performance,load,load,68,"/// GPRC, CHAIN = LFIWZX CHAIN, Ptr - This is a floating-point; /// load which zero-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:137,Modifiability,extend,extended,137,"/// GPRC, CHAIN = LXSIZX, CHAIN, Ptr, ByteWidth - This is a load of an; /// integer smaller than 64 bits into a VSR. The integer is zero-extended.; /// This can be used for converting loaded integers to floating point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:60,Performance,load,load,60,"/// GPRC, CHAIN = LXSIZX, CHAIN, Ptr, ByteWidth - This is a load of an; /// integer smaller than 64 bits into a VSR. The integer is zero-extended.; /// This can be used for converting loaded integers to floating point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:184,Performance,load,loaded,184,"/// GPRC, CHAIN = LXSIZX, CHAIN, Ptr, ByteWidth - This is a load of an; /// integer smaller than 64 bits into a VSR. The integer is zero-extended.; /// This can be used for converting loaded integers to floating point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:48,Modifiability,Extend,Extend,48,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:111,Modifiability,extend,extending,111,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:13,Performance,Load,Load,13,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:121,Performance,load,load,121,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:226,Performance,Load,Load,226,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:132,Integrability,depend,depending,132,"/// VSRC, CHAIN = LOAD_VEC_BE CHAIN, Ptr - Occurs only for little endian.; /// Maps directly to one of lxvd2x/lxvw4x/lxvh8x/lxvb16x depending on; /// the vector type to load vector in big-endian element order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:169,Performance,load,load,169,"/// VSRC, CHAIN = LOAD_VEC_BE CHAIN, Ptr - Occurs only for little endian.; /// Maps directly to one of lxvd2x/lxvw4x/lxvh8x/lxvb16x depending on; /// the vector type to load vector in big-endian element order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:66,Performance,load,load,66,"/// VSRC, CHAIN = LD_VSX_LH CHAIN, Ptr - This is a floating-point load of a; /// v2f32 value into the lower half of a VSR register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:53,Performance,load,load,53,"/// VSRC, CHAIN = LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// instructions such as LXVDSX, LXVWSX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:85,Modifiability,extend,extends,85,"/// VSRC, CHAIN = ZEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that zero-extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Performance,load,load,58,"/// VSRC, CHAIN = ZEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that zero-extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:85,Modifiability,extend,extends,85,"/// VSRC, CHAIN = SEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that sign-extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Performance,load,load,58,"/// VSRC, CHAIN = SEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that sign-extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:137,Integrability,depend,depending,137,"/// CHAIN = STORE_VEC_BE CHAIN, VSRC, Ptr - Occurs only for little endian.; /// Maps directly to one of stxvd2x/stxvw4x/stxvh8x/stxvb16x depending on; /// the vector type to store vector in big-endian element order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:124,Modifiability,extend,extended,124,/// ATOMIC_CMP_SWAP - the exact same as the target-independent nodes; /// except they ensure that the compare input is zero-extended for; /// sub-word versions because the atomic loads zero-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:190,Modifiability,extend,extend,190,/// ATOMIC_CMP_SWAP - the exact same as the target-independent nodes; /// except they ensure that the compare input is zero-extended for; /// sub-word versions because the atomic loads zero-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:179,Performance,load,loads,179,/// ATOMIC_CMP_SWAP - the exact same as the target-independent nodes; /// except they ensure that the compare input is zero-extended for; /// sub-word versions because the atomic loads zero-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:34,Performance,Load,Loads,34,"/// GPRC = TOC_ENTRY GA, TOC; /// Loads the entry for GA from the TOC, where the TOC base is given by; /// the last operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:62,Availability,mask,mask,62,/// isVPKUHUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUHUM instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:62,Availability,mask,mask,62,/// isVPKUWUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUWUM instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:62,Availability,mask,mask,62,/// isVPKUDUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUDUM instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,"/// isVMRGLShuffleMask - Return true if this is a shuffle mask suitable for; /// a VRGL* instruction with the specified unit size (1,2 or 4 bytes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,"/// isVMRGHShuffleMask - Return true if this is a shuffle mask suitable for; /// a VRGH* instruction with the specified unit size (1,2 or 4 bytes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:59,Availability,mask,mask,59,/// isVMRGEOShuffleMask - Return true if this is a shuffle mask suitable for; /// a VMRGEW or VMRGOW instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:60,Availability,mask,mask,60,/// isXXSLDWIShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXSLDWI instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,/// isXXBRHShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRH instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,/// isXXBRWShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRW instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,/// isXXBRDShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRD instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Availability,mask,mask,58,/// isXXBRQShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRQ instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:61,Availability,mask,mask,61,/// isXXPERMDIShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXPERMDI instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:54,Availability,mask,mask,54,"/// isVSLDOIShuffleMask - If this is a vsldoi shuffle mask, return the; /// shift amount, otherwise return -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:55,Performance,load,loads,55,// Flags for computing the optimal addressing mode for loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:30,Performance,load,loads,30,// Extension mode for integer loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:14,Modifiability,variab,variables,14,// Sum of two variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:5,Usability,simpl,simple,5,// A simple 32-bit constant.; // The in-memory type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:28,Performance,load,loads,28,// The addressing modes for loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:3,Energy Efficiency,Power,PowerPC,3,// PowerPC does not support scalar condition selects on vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:442,Modifiability,extend,extending,442,"/// getPreferredVectorAction - The code we generate when vector types are; /// legalized by promoting the integer element type is often much worse; /// than code we generate if we widen the type for applicable vector types.; /// The issue with promoting is that the vector is scalaraized, individual; /// elements promoted and then the vector is rebuilt. So say we load a pair; /// of v4i8's and shuffle them. This will turn into a mess of 8 extending; /// loads, moves back into VSR's (or memory ops if we don't have moves) and; /// then the VPERM for the shuffle. All in all a very slow sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:365,Performance,load,load,365,"/// getPreferredVectorAction - The code we generate when vector types are; /// legalized by promoting the integer element type is often much worse; /// than code we generate if we widen the type for applicable vector types.; /// The issue with promoting is that the vector is scalaraized, individual; /// elements promoted and then the vector is rebuilt. So say we load a pair; /// of v4i8's and shuffle them. This will turn into a mess of 8 extending; /// loads, moves back into VSR's (or memory ops if we don't have moves) and; /// then the VPERM for the shuffle. All in all a very slow sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:457,Performance,load,loads,457,"/// getPreferredVectorAction - The code we generate when vector types are; /// legalized by promoting the integer element type is often much worse; /// than code we generate if we widen the type for applicable vector types.; /// The issue with promoting is that the vector is scalaraized, individual; /// elements promoted and then the vector is rebuilt. So say we load a pair; /// of v4i8's and shuffle them. This will turn into a mess of 8 extending; /// loads, moves back into VSR's (or memory ops if we don't have moves) and; /// then the VPERM for the shuffle. All in all a very slow sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:24,Performance,scalab,scalable,24,// Default handling for scalable and single-element vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:194,Performance,load,load,194,"/// getPreIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if the node's address; /// can be legally represented as pre-indexed load / store address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:96,Energy Efficiency,efficient,efficiently,96,"/// SelectAddressEVXRegReg - Given the specified addressed, check to see if; /// it can be more efficiently represented as [r+imm].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:93,Energy Efficiency,efficient,efficiently,93,"/// SelectAddressRegReg - Given the specified addressed, check to see if it; /// can be more efficiently represented as [r+imm]. If \p EncodingAlignment; /// is non-zero, only accept displacement which is not suitable for [r+imm].; /// Returns false if it can be represented by [r+imm], which are preferred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:174,Testability,log,logarithm,174,"/// getByValTypeAlignment - Return the desired alignment for ByVal aggregate; /// function arguments in the caller parameter area. This is the actual; /// alignment, not its logarithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:50,Performance,load,load,50,/// Returns true if it is beneficial to convert a load of a constant; /// to just the constant itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:21,Performance,load,load,21,// Only handle float load/store pair because float(fpr) load/store; // instruction has more cycles than integer(gpr) load/store in PPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:56,Performance,load,load,56,// Only handle float load/store pair because float(fpr) load/store; // instruction has more cycles than integer(gpr) load/store in PPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:117,Performance,load,load,117,// Only handle float load/store pair because float(fpr) load/store; // instruction has more cycles than integer(gpr) load/store in PPC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:97,Testability,log,logic,97,/// It returns EVT::Other if the type should be determined using generic; /// target-independent logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:24,Security,access,access,24,"/// Is unaligned memory access allowed for the given type, and is it fast; /// relative to software emulation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:214,Energy Efficiency,Power,Powerpc,214,"/// isProfitableToHoist - Check if it is profitable to hoist instruction; /// \p I to its dominator block.; /// For example, it is not profitable if \p I and it's only user can form a; /// FMA instruction, because Powerpc prefers FMADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:199,Availability,avail,available,199,"// We support any array type as ""consecutive"" block in the parameter; // save area. The element type defines the alignment requirement and; // whether the argument should go in GPRs, FPRs, or VRs if available.; //; // Note that clang uses this capability both to implement the ELFv2; // homogeneous float/vector aggregate ABI, and to avoid having to use; // ""byval"" when passing aggregates that might fully fit in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:334,Safety,avoid,avoid,334,"// We support any array type as ""consecutive"" block in the parameter; // save area. The element type defines the alignment requirement and; // whether the argument should go in GPRs, FPRs, or VRs if available.; //; // Note that clang uses this capability both to implement the ELFv2; // homogeneous float/vector aggregate ABI, and to avoid having to use; // ""byval"" when passing aggregates that might fully fit in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:47,Performance,load,loading,47,/// Override to support customized stack guard loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:207,Performance,perform,performance,207,/// ConvertSETCCToSubtract - looks at SETCC that compares ints. It replaces; /// SETCC with integer subtraction when (1) there is a legal way of doing it; /// (2) keeping the result of comparison in GPR has performance benefit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,Performance,optimiz,optimized,58,"// Return whether the call instruction can potentially be optimized to a; // tail call. This will cause the optimizers to attempt to move, or; // duplicate return instructions to help enable tail call optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:108,Performance,optimiz,optimizers,108,"// Return whether the call instruction can potentially be optimized to a; // tail call. This will cause the optimizers to attempt to move, or; // duplicate return instructions to help enable tail call optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:201,Performance,optimiz,optimizations,201,"// Return whether the call instruction can potentially be optimized to a; // tail call. This will cause the optimizers to attempt to move, or; // duplicate return instructions to help enable tail call optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:105,Performance,load,load,105,"/// computeMOFlags - Given a node N and it's Parent (a MemSDNode), compute; /// the address flags of the load/store instruction that is to be matched.; /// The address flags are stored in a map, which is then searched; /// through to determine the optimal load/store instruction format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:256,Performance,load,load,256,"/// computeMOFlags - Given a node N and it's Parent (a MemSDNode), compute; /// the address flags of the load/store instruction that is to be matched.; /// The address flags are stored in a map, which is then searched; /// through to determine the optimal load/store instruction format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:543,Deployability,update,update,543,"//===------ PPCLoopInstrFormPrep.cpp - Loop Instr Form Prep Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1278,Deployability,update,update,1278,", under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1357,Deployability,update,update,1357,", under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1723,Energy Efficiency,reduce,reduce,1723,"ated for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offset; //; // for (int i = 0; i < n; i++); // unsigned long x1 = *(unsigned long *)(A1 + i);; // unsigned long x2 = *(unsigned long *)(A2 + i); // unsigned long x3 = *(unsigned long *)(B1 + i);; // unsigned long x4 = *(unsigned long *)(B2 + i);; // }; //; // to look like this:; //; // A1_new = p + base1 // chain 1; // B1_new = p + base2 // chain 2, now inside the loop, common offset is; // // reused.; //; // for (long long i = 0; i < n; i+=count) {; // unsigned lon",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:602,Modifiability,variab,variables,602,"//===------ PPCLoopInstrFormPrep.cpp - Loop Instr Form Prep Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:620,Performance,load,load,620,"//===------ PPCLoopInstrFormPrep.cpp - Loop Instr Form Prep Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:743,Performance,load,load,743,"//===------ PPCLoopInstrFormPrep.cpp - Loop Instr Form Prep Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1310,Performance,load,load,1310,", under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1639,Performance,load,load,1639,"ated for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offset; //; // for (int i = 0; i < n; i++); // unsigned long x1 = *(unsigned long *)(A1 + i);; // unsigned long x2 = *(unsigned long *)(A2 + i); // unsigned long x3 = *(unsigned long *)(B1 + i);; // unsigned long x4 = *(unsigned long *)(B2 + i);; // }; //; // to look like this:; //; // A1_new = p + base1 // chain 1; // B1_new = p + base2 // chain 2, now inside the loop, common offset is; // // reused.; //; // for (long long i = 0; i < n; i+=count) {; // unsigned lon",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:24,Energy Efficiency,reduce,reduce,24,"// Commoning chain will reduce the register pressure, so we don't consider about; // the PHI nodes number.; // But commoning chain will increase the addi/add number in the loop and also; // increase loop ILP. Maximum chain number should be same with hardware; // IssueWidth, because we won't benefit from ILP if the parallel chains number; // is bigger than IssueWidth. We assume there are 2 chains in one bucket, so; // there would be 4 buckets at most on P9(IssueWidth is 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:62,Performance,load,load,62,"// If would not be profitable if the common base has only one load/store, ISEL; // should already be able to choose best load/store form based on offset for; // single load/store. Set minimal profitable value default to 2 and make it as; // an option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:121,Performance,load,load,121,"// If would not be profitable if the common base has only one load/store, ISEL; // should already be able to choose best load/store form based on offset for; // single load/store. Set minimal profitable value default to 2 and make it as; // an option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:168,Performance,load,load,168,"// If would not be profitable if the common base has only one load/store, ISEL; // should already be able to choose best load/store form based on offset for; // single load/store. Set minimal profitable value default to 2 and make it as; // an option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Deployability,Update,UpdateForm,4,"// ""UpdateForm"" is not a real PPC instruction form, it stands for dform; // load/store with update like ldu/stdu, or Prefetch intrinsic.; // For DS form instructions, their displacements must be multiple of 4.; // For DQ form instructions, their displacements must be multiple of 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:92,Deployability,update,update,92,"// ""UpdateForm"" is not a real PPC instruction form, it stands for dform; // load/store with update like ldu/stdu, or Prefetch intrinsic.; // For DS form instructions, their displacements must be multiple of 4.; // For DQ form instructions, their displacements must be multiple of 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:76,Performance,load,load,76,"// ""UpdateForm"" is not a real PPC instruction form, it stands for dform; // load/store with update like ldu/stdu, or Prefetch intrinsic.; // For DS form instructions, their displacements must be multiple of 4.; // For DQ form instructions, their displacements must be multiple of 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:38,Deployability,Update,Update,38,"/// Successful preparation number for Update/DS/DQ form in all inner most; /// loops. One successful preparation will put one common base out of loop,; /// this may leads to register presure like LICM does.; /// Make sure total preparation number can be controlled by option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:49,Energy Efficiency,reduce,reduce,49,/// Common chains to reuse offsets for a loop to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite load/store according to the common chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:12,Performance,load,load,12,/// Rewrite load/store according to the common chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:45,Deployability,update,update,45,/// Prepare all candidates in \p Buckets for update form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:78,Deployability,update,update,78,"/// Prepare for one chain \p BucketChain, find the best base element and; /// update all other elements in \p BucketChain accordingly.; /// \p Form is used to find the best base element.; /// If success, best base element must be stored as the first element of; /// \p BucketChain.; /// Return false if no base element found, otherwise return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:78,Deployability,update,update,78,"/// Prepare for one chain \p BucketChain, find the best base element and; /// update all other elements in \p BucketChain accordingly.; /// If success, best base element must be stored as the first element of; /// \p BucketChain.; /// Return false if no base element found, otherwise return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite load/store instructions in \p BucketChain according to; /// preparation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:12,Performance,load,load,12,/// Rewrite load/store instructions in \p BucketChain according to; /// preparation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite for the base load/store of a chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:25,Performance,load,load,25,/// Rewrite for the base load/store of a chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite for the other load/stores of a chain according to the new \p; /// Base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:26,Performance,load,load,26,/// Rewrite for the other load/stores of a chain according to the new \p; /// Base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:235,Energy Efficiency,power,powerful,235,"// Finding the minimal(chain_number + reusable_offset_number) is a complicated; // algorithmic problem.; // For now, the algorithm used here is simply adjusted to handle the case for; // manually unrolling cases.; // FIXME: use a more powerful algorithm to find minimal sum of chain_number and; // reusable_offset_number for one base with multiple offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:144,Usability,simpl,simply,144,"// Finding the minimal(chain_number + reusable_offset_number) is a complicated; // algorithmic problem.; // For now, the algorithm used here is simply adjusted to handle the case for; // manually unrolling cases.; // FIXME: use a more powerful algorithm to find minimal sum of chain_number and; // reusable_offset_number for one base with multiple offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:6,Usability,simpl,simply,6,// We simply select the FirstOffset as the first reusable offset between each; // chain element 1 and element 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:13,Modifiability,rewrite,rewriter,13,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:60,Modifiability,rewrite,rewriter,60,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:22,Performance,cache,cache,22,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:71,Performance,cache,cache,71,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:134,Performance,cache,cache,134,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:115,Testability,Assert,AssertingVH,115,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:3,Usability,Clear,Clear,3,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:345,Modifiability,rewrite,rewrite,345,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:458,Modifiability,rewrite,rewrite,458,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:359,Performance,load,load,359,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:476,Performance,load,load,476,"// Rewrite the new base according to BasePtrSCEV.; // bb.loop.preheader:; // %newstart = ...; // bb.loop.body:; // %phinode = phi [ %newstart, %bb.loop.preheader ], [ %add, %bb.loop.body ]; // ...; // %add = getelementptr %phinode, %inc; //; // First returned instruciton is %phinode (or a type cast to %phinode), caller; // needs this value to rewrite other load/stores in the same chain.; // Second returned instruction is %add, caller needs this value to rewrite other; // load/stores in the same chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:266,Performance,load,load,266,"// RemainderOffsetInfo details:; // key: value of (Offset urem DispConstraint). For DSForm, it can; // be [0, 4).; // first of pair: the index of first BucketElement whose remainder is equal; // to key. For key 0, this value must be 0.; // second of pair: number of load/stores with the same remainder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:91,Performance,load,load,91,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:182,Performance,load,load,182,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:320,Performance,load,load,320,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:369,Performance,load,load,369,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:411,Performance,load,load,411,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:525,Performance,load,load,525,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:590,Performance,load,load,590,"// Currently we choose the most profitable base as the one which has the max; // number of load/store with same remainder.; // FIXME: adjust the base selection strategy according to load/store offset; // distribution.; // For example, if we have one candidate chain for DS form preparation, which; // contains following load/stores with different remainders:; // 1: 10 load/store whose remainder is 1;; // 2: 9 load/store whose remainder is 2;; // 3: 1 for remainder 3 and 0 for remainder 0;; // Now we will choose the first load/store whose remainder is 1 as base and; // adjust all other load/stores according to new base, so we will get 10 DS; // form and 10 X form.; // But we should be more clever, for this case we could use two bases, one for; // remainder 1 and the other for remainder 2, thus we could get 19 DS form and; // 1 X form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:3,Safety,Abort,Abort,3,// Abort when there are too few insts with common base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:10,Performance,load,load,10,// Adjust load/store to the new chosen base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:96,Performance,load,load,96,"// FIXME: implement a more clever base choosing policy.; // Currently we always choose an exist load/store offset. This maybe lead to; // suboptimal code sequences. For example, for one DS chain with offsets; // {-32769, 2003, 2007, 2011}, we choose -32769 as base offset, and left disp; // for load/stores are {0, 34772, 34776, 34780}. Though each offset now is a; // multipler of 4, it cannot be represented by sint16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:295,Performance,load,load,295,"// FIXME: implement a more clever base choosing policy.; // Currently we always choose an exist load/store offset. This maybe lead to; // suboptimal code sequences. For example, for one DS chain with offsets; // {-32769, 2003, 2007, 2011}, we choose -32769 as base offset, and left disp; // for load/stores are {0, 34772, 34776, 34780}. Though each offset now is a; // multipler of 4, it cannot be represented by sint16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:63,Deployability,update,update,63,"// For some DS form load/store instructions, it can also be an update form,; // if the stride is constant and is a multipler of 4. Use update form if; // prefer it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:135,Deployability,update,update,135,"// For some DS form load/store instructions, it can also be an update form,; // if the stride is constant and is a multipler of 4. Use update form if; // prefer it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:20,Performance,load,load,20,"// For some DS form load/store instructions, it can also be an update form,; // if the stride is constant and is a multipler of 4. Use update form if; // prefer it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:13,Modifiability,rewrite,rewriter,13,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:60,Modifiability,rewrite,rewriter,60,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:22,Performance,cache,cache,22,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:71,Performance,cache,cache,71,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:134,Performance,cache,cache,134,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:115,Testability,Assert,AssertingVH,115,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:3,Usability,Clear,Clear,3,"// Clear the rewriter cache, because values that are in the rewriter's cache; // can be deleted below, causing the AssertingVH in the cache to trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:29,Deployability,update,update,29,// Check if a load/store has update form. This lambda is used by function; // collectCandidates which can collect candidates for types defined by lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,Performance,load,load,14,// Check if a load/store has update form. This lambda is used by function; // collectCandidates which can collect candidates for types defined by lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:16,Deployability,update,update,16,// There are no update forms for Altivec vector load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:48,Performance,load,load,48,// There are no update forms for Altivec vector load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:16,Deployability,update,update,16,// There are no update forms for P10 lxvp/stxvp intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:110,Performance,load,loads,110,"// See getPreIndexedAddressParts, the displacement for LDU/STDU has to; // be 4's multiple (DS-form). For i64 loads/stores when the displacement; // fits in a 16-bit signed field but isn't a multiple of 4, it will be; // useless and possible to break some original well-form addressing mode; // to make this pre-inc prep for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,Performance,load,load,14,// Check if a load/store has DS form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,Performance,load,load,14,// Check if a load/store has DQ form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:30,Performance,load,load,30,// Check if it is a P9 vector load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,Performance,load,load,14,"// Check if a load/store is candidate for chain commoning.; // If the SCEV is only with one ptr operand in its start, we can use that; // start as a chain separator. Mark this load/store as a candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:176,Performance,load,load,176,"// Check if a load/store is candidate for chain commoning.; // If the SCEV is only with one ptr operand in its start, we can use that; // start as a chain separator. Mark this load/store as a candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:58,Deployability,update,update,58,// Check if the diff is a constant type. This is used for update/DS/DQ form; // preparation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:72,Deployability,update,update,72,// Collect buckets of comparable addresses used by loads and stores for update; // form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:51,Performance,load,loads,51,// Collect buckets of comparable addresses used by loads and stores for update; // form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:15,Deployability,update,update,15,// Prepare for update form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:51,Performance,load,loads,51,// Collect buckets of comparable addresses used by loads and stores for DS; // form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:51,Performance,load,loads,51,// Collect buckets of comparable addresses used by loads and stores for DQ; // form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:189,Energy Efficiency,reduce,reduced,189,"// Collect buckets of comparable addresses used by loads and stores for chain; // commoning. With chain commoning, we reuse offsets between the chains, so; // the register pressure will be reduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:51,Performance,load,loads,51,"// Collect buckets of comparable addresses used by loads and stores for chain; // commoning. With chain commoning, we reuse offsets between the chains, so; // the register pressure will be reduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:450,Energy Efficiency,Power,PowerPC,450,"//===-- PPCLowerMASSVEntries.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements lowering of MASSV (SIMD) entries for specific PowerPC; // subtargets.; // Following is an example of a conversion specific to Power9 subtarget:; // __sind2_massv ---> __sind2_P9; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:63,Energy Efficiency,Power,PowerPC,63,"// FIXME:; /// Returns a string corresponding to the specified PowerPC subtarget. e.g.:; /// ""_P8"" for Power8, ""_P9"" for Power9. The string is used as a suffix while; /// generating subtarget-specific MASSV library functions. Current support; /// includes minimum subtarget Power8 for Linux and Power7 for AIX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:12,Energy Efficiency,Power,PowerPC,12,"/// Creates PowerPC subtarget-specific name corresponding to the specified; /// generic MASSV function, and the PowerPC subtarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:112,Energy Efficiency,Power,PowerPC,112,"/// Creates PowerPC subtarget-specific name corresponding to the specified; /// generic MASSV function, and the PowerPC subtarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:196,Deployability,update,updated,196,/// Lowers generic MASSV entries to PowerPC subtarget-specific MASSV entries.; /// e.g.: __sind2_massv --> __sind2_P9 for a Power9 subtarget.; /// Both function prototypes and their callsites are updated during lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:36,Energy Efficiency,Power,PowerPC,36,/// Lowers generic MASSV entries to PowerPC subtarget-specific MASSV entries.; /// e.g.: __sind2_massv --> __sind2_P9 for a Power9 subtarget.; /// Both function prototypes and their callsites are updated during lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.cpp:59,Energy Efficiency,Power,PowerPC,59,"//===-- PPCMachineFunctionInfo.cpp - Private data used for PowerPC --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:57,Energy Efficiency,Power,PowerPC,57,"//===-- PPCMachineFunctionInfo.h - Private data used for PowerPC --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of MachineFunctionInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCMachineFunctionInfo.h - Private data used for PowerPC --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of MachineFunctionInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:78,Energy Efficiency,Power,PowerPC,78,/// PPCFunctionInfo - This class is derived from MachineFunction private; /// PowerPC target-specific information for each MachineFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:41,Security,Hash,Hash,41,/// Frame index where the ROP Protection Hash is stored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:58,Performance,perform,performed,58,/// MustSaveTOC - Indicates that the TOC save needs to be performed in the; /// prologue of the function. This is typically the case when there are; /// indirect calls in the function and it is more profitable to save the; /// TOC pointer in the prologue than in the block(s) containing the call(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:33,Integrability,wrap,wrapping,33,/// Do we have to disable shrink-wrapping? This has to be set if we emit any; /// instructions that clobber LR in the entry block because discovering this; /// in PEI is too late (happens after shrink-wrapping);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:201,Integrability,wrap,wrapping,201,/// Do we have to disable shrink-wrapping? This has to be set if we emit any; /// instructions that clobber LR in the entry block because discovering this; /// in PEI is too late (happens after shrink-wrapping);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:101,Performance,optimiz,optimization,101,/// We keep track attributes for each live-in virtual registers; /// to use SExt/ZExt flags in later optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:38,Integrability,wrap,wrap,38,"/// We certainly don't want to shrink wrap functions if we've emitted a; /// MovePCtoLR8 as that has to go into the entry, so the prologue definitely; /// has to go into the entry block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:89,Modifiability,extend,extended,89,/// This function returns true if the specified vreg is; /// a live-in register and sign-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:89,Modifiability,extend,extended,89,/// This function returns true if the specified vreg is; /// a live-in register and zero-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:36,Energy Efficiency,Schedul,Scheduler,36,"//===- PPCMachineScheduler.cpp - MI Scheduler for PowerPC -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:50,Energy Efficiency,Power,PowerPC,50,"//===- PPCMachineScheduler.cpp - MI Scheduler for PowerPC -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid exceeding the target's limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:53,Energy Efficiency,schedul,scheduled,53,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:118,Usability,simpl,simply,118,"// We only compare a subset of features when comparing nodes between; // Top and Bottom boundary. Some properties are simply incomparable, in many; // other instances we should only override the other boundary if something; // is a clear good pick on one boundary. Skip heuristics that are more; // ""tie-breaking"" in nature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:232,Usability,clear,clear,232,"// We only compare a subset of features when comparing nodes between; // Top and Bottom boundary. Some properties are simply incomparable, in many; // other instances we should only override the other boundary if something; // is a clear good pick on one boundary. Skip heuristics that are more; // ""tie-breaking"" in nature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:57,Energy Efficiency,schedul,schedule,57,"// For loops that are acyclic path limited, aggressively schedule for; // latency. Within an single cycle, whenever CurrMOps > 0, allow normal; // heuristics to take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:74,Performance,latency,latency,74,"// For loops that are acyclic path limited, aggressively schedule for; // latency. Within an single cycle, whenever CurrMOps > 0, allow normal; // heuristics to take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:46,Availability,down,downstream,46,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:94,Energy Efficiency,reduce,reduce,94,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:291,Energy Efficiency,schedul,scheduler,291,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:70,Performance,optimiz,optimizations,70,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:191,Performance,Optimiz,Optimizations,191,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:225,Performance,load,loads,225,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:323,Performance,load,loads,323,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing the max pressure of the entire region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:27,Energy Efficiency,consumption,consumption,27,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:55,Energy Efficiency,schedul,schedule,55,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:34,Integrability,depend,dependence,34,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:26,Performance,latency,latency,26,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:89,Performance,latency,latency,89,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:46,Energy Efficiency,power,powerpc,46,// GenericScheduler::tryCandidate end; // Add powerpc specific heuristic only when TryCand isn't selected or; // selected as node order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:30,Energy Efficiency,schedul,schedule,30,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:113,Integrability,depend,dependency,113,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:59,Performance,load,load,59,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:80,Performance,latency,latency,80,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:136,Performance,load,load,136,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:27,Energy Efficiency,consumption,consumption,27,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:55,Energy Efficiency,schedul,schedule,55,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:34,Integrability,depend,dependence,34,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:26,Performance,latency,latency,26,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:50,Energy Efficiency,power,powerpc,50,// PostGenericScheduler::tryCandidate end; // Add powerpc post ra specific heuristic only when TryCand isn't selected or; // selected as node order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:30,Energy Efficiency,schedul,schedule,30,"// There are some benefits to schedule the ADDI as early as possible post ra; // to avoid stalled by vector instructions which take up all the hw units.; // And ADDI is usually used to post inc the loop indvar, which matters the; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:233,Performance,perform,performance,233,"// There are some benefits to schedule the ADDI as early as possible post ra; // to avoid stalled by vector instructions which take up all the hw units.; // And ADDI is usually used to post inc the loop indvar, which matters the; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:84,Safety,avoid,avoid,84,"// There are some benefits to schedule the ADDI as early as possible post ra; // to avoid stalled by vector instructions which take up all the hw units.; // And ADDI is usually used to post inc the loop indvar, which matters the; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:30,Energy Efficiency,schedul,scheduling,30,// Custom PPC PostRA specific scheduling here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:38,Energy Efficiency,Power,PowerPC,38,"//===- PPCMachineScheduler.h - Custom PowerPC MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom PowerPC MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:49,Energy Efficiency,schedul,scheduler,49,"//===- PPCMachineScheduler.h - Custom PowerPC MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom PowerPC MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:386,Energy Efficiency,Power,PowerPC,386,"//===- PPCMachineScheduler.h - Custom PowerPC MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom PowerPC MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:397,Energy Efficiency,schedul,scheduler,397,"//===- PPCMachineScheduler.h - Custom PowerPC MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom PowerPC MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:46,Energy Efficiency,Power,PowerPC,46,/// A MachineSchedStrategy implementation for PowerPC pre RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:61,Energy Efficiency,schedul,scheduling,61,/// A MachineSchedStrategy implementation for PowerPC pre RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:46,Energy Efficiency,Power,PowerPC,46,/// A MachineSchedStrategy implementation for PowerPC post RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:62,Energy Efficiency,schedul,scheduling,62,/// A MachineSchedStrategy implementation for PowerPC post RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:28,Energy Efficiency,Power,PowerPC,28,"//===- PPCMacroFusion.cpp - PowerPC Macro Fusion --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC implementation of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:413,Energy Efficiency,Power,PowerPC,413,"//===- PPCMacroFusion.cpp - PowerPC Macro Fusion --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC implementation of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:447,Energy Efficiency,schedul,scheduling,447,"//===- PPCMacroFusion.cpp - PowerPC Macro Fusion --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC implementation of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:41,Integrability,depend,dependent,41,"// li rx, si; // load rt, ra, rx; // The dependent operand index in the second op(load). And the negative means; // it could be any one. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:17,Performance,load,load,17,"// li rx, si; // load rt, ra, rx; // The dependent operand index in the second op(load). And the negative means; // it could be any one. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:82,Performance,load,load,82,"// li rx, si; // load rt, ra, rx; // The dependent operand index in the second op(load). And the negative means; // it could be any one. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:65,Performance,load,load,65,"// If si = 1111111111110000 and the msb of the d/ds field of the load equals; // 1, then fusion does not occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:31,Safety,avoid,avoid,31,// We use the PPC namespace to avoid the need to prefix opcodes with PPC:: in; // the def file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h:26,Energy Efficiency,Power,PowerPC,26,"//===- PPCMacroFusion.h - PowerPC Macro Fusion ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC definition of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h:413,Energy Efficiency,Power,PowerPC,413,"//===- PPCMacroFusion.h - PowerPC Macro Fusion ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC definition of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h:443,Energy Efficiency,schedul,scheduling,443,"//===- PPCMacroFusion.h - PowerPC Macro Fusion ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the PowerPC definition of the DAG scheduling; /// mutation to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:488,Energy Efficiency,reduce,reduce,488,"//===-- PPCMergeStringPool.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation tries to merge the strings in the module into one pool; // of strings. The idea is to reduce the number of TOC entries in the module so; // that instead of having one TOC entry for each string there is only one global; // TOC entry and all of the strings are referenced off of that one entry plus; // an offset.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:29,Modifiability,Variab,Variables,29,// Combine all of the Global Variables marked as used into a SmallPtrSet for; // faster lookup inside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:187,Deployability,patch,patch,187,// TODO: At this point do not allow over-aligned types. Adding a type; // with larger alignment may lose the larger alignment once it is; // added to the struct.; // Fix this in a future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:49,Energy Efficiency,efficient,efficient,49,// Sort the global constants to make access more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:37,Security,access,access,37,// Sort the global constants to make access more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:151,Performance,perform,performance,151,"// Use an anonymous struct to pool the strings.; // TODO: This pass uses a single anonymous struct for all of the pooled; // entries. This may cause a performance issue in the situation where; // computing the offset requires two instructions (addis, addi). For the; // future we may want to split this into multiple structs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:3,Security,Access,Access,3,// Access to the pooled constant strings require an offset. Add a GEP; // before every use in order to compute this offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:1106,Availability,error,errors,1106,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:1137,Integrability,contract,contract,1137,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:391,Performance,perform,performs,391,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:409,Performance,optimiz,optimizations,409,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:816,Performance,optimiz,optimization,816,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:995,Testability,Assert,Asserts,995,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:3,Performance,Perform,Perform,3,// Perform peepholes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:3,Performance,Perform,Perform,3,// Perform peepholes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:301,Usability,simpl,simply,301,"// A number of transformations will eliminate the definition of a register; // as all of its uses will be removed. However, this leaves a register; // without a definition for LiveVariables. Such transformations should; // use this function to provide a dummy definition of the register that; // will simply be removed by DCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:20,Modifiability,variab,variables,20,// Initialize class variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:227,Availability,redundant,redundant,227,"// This function maintains a map for the pairs <TOC Save Instr, Keep>; // Each time a new TOC save is encountered, it checks if any of the existing; // ones are dominated by the new one. If so, it marks the existing one as; // redundant by setting it's entry in the map as false. It then adds the new; // instruction to the map with either true or false depending on if any; // existing instructions dominated the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:354,Integrability,depend,depending,354,"// This function maintains a map for the pairs <TOC Save Instr, Keep>; // Each time a new TOC save is encountered, it checks if any of the existing; // ones are dominated by the new one. If so, it marks the existing one as; // redundant by setting it's entry in the map as false. It then adds the new; // instruction to the map with either true or false depending on if any; // existing instructions dominated the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:227,Safety,redund,redundant,227,"// This function maintains a map for the pairs <TOC Save Instr, Keep>; // Each time a new TOC save is encountered, it checks if any of the existing; // ones are dominated by the new one. If so, it marks the existing one as; // redundant by setting it's entry in the map as false. It then adds the new; // instruction to the map with either true or false depending on if any; // existing instructions dominated the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:74,Availability,redundant,redundant,74,"// If new instruction dominates an existing one, mark existing one as; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:74,Safety,redund,redundant,74,"// If new instruction dominates an existing one, mark existing one as; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:35,Availability,redundant,redundant,35,// Check if the new instruction is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:35,Safety,redund,redundant,35,// Check if the new instruction is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:100,Performance,perform,perform,100,"// This function returns a list of all PHI nodes in the tree starting from; // the RootPHI node. We perform a BFS traversal to get an ordered list of nodes.; // The list initially only contains the root PHI. When we visit a PHI node, we; // add it to the list. We continue to look for other PHI node operands while; // there are nodes to visit in the list. The function returns false if the; // optimization cannot be applied on this tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:395,Performance,optimiz,optimization,395,"// This function returns a list of all PHI nodes in the tree starting from; // the RootPHI node. We perform a BFS traversal to get an ordered list of nodes.; // The list initially only contains the root PHI. When we visit a PHI node, we; // add it to the list. We continue to look for other PHI node operands while; // there are nodes to visit in the list. The function returns false if the; // optimization cannot be applied on this tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:9,Safety,detect,detect,9,"// If we detect a cycle in the PHI nodes, we exit. It would be; // possible to change cycles as well, but that would add a lot; // of complexity for a case that is unlikely to occur with MMA; // code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:3,Performance,Perform,Perform,3,// Perform peephole optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:20,Performance,optimiz,optimizations,20,// Perform peephole optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:57,Performance,load,load-immediate,57,"// Fixed-point conversion of reg/reg instructions fed by load-immediate; // into reg/imm instructions. FIXME: This is expensive, control it with; // an option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:7,Deployability,update,updated,7,// The updated instruction may now have new register operands.; // Conservatively add them to recompute the flags as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:132,Deployability,update,update,132,"// Since we are deleting this instruction, we need to run LiveVariables; // on any of its definitions that are marked as needing an update since; // we can't run LiveVariables on a deleted register. This only needs; // to be done for defs since uses will have their own defining; // instructions so we won't be running LiveVariables on a deleted reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:110,Safety,safe,safely,110,"// If some transformation has introduced an additional definition of; // this register (breaking SSA), we can safely convert this def to; // a def of an invalid register as the instruction is going away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:41,Performance,optimiz,optimized,41,"// If a conditional trap instruction got optimized to an; // unconditional trap, eliminate all the instructions after; // the trap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:370,Safety,detect,detect,370,"// We are copying an unprimed accumulator to a primed accumulator.; // If the input to the copy is a PHI that is fed only by (i) copies in; // the other direction (ii) implicitly defined unprimed accumulators or; // (iii) other PHI nodes satisfying (i) and (ii), we can change; // the PHI to a PHI on primed accumulators (as long as we also change; // its operands). To detect and change such copies, we first get a list; // of all the PHI nodes starting from the root PHI node in BFS order.; // We then visit all these PHI nodes to check if they can be changed to; // primed accumulator PHI nodes and if so, we change them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:151,Availability,redundant,redundant,151,"// When encountering a TOC save instruction, call UpdateTOCSaves; // to add it to the TOCSaves map and mark any existing TOC saves; // it dominates as redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:50,Deployability,Update,UpdateTOCSaves,50,"// When encountering a TOC save instruction, call UpdateTOCSaves; // to add it to the TOCSaves map and mark any existing TOC saves; // it dominates as redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:151,Safety,redund,redundant,151,"// When encountering a TOC save instruction, call UpdateTOCSaves; // to add it to the TOCSaves map and mark any existing TOC saves; // it dominates as redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:3,Performance,Perform,Perform,3,"// Perform simplifications of 2x64 vector swaps and splats.; // A swap is identified by an immediate value of 2, and a splat; // is identified by an immediate value of 0 or 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:11,Usability,simpl,simplifications,11,"// Perform simplifications of 2x64 vector swaps and splats.; // A swap is identified by an immediate value of 2, and a splat; // is identified by an immediate value of 0 or 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:21,Usability,simpl,simplifications,21,"// For each of these simplifications, we need the two source; // regs to match. Unfortunately, MachineCSE ignores COPY and; // SUBREG_TO_REG, so for example we can see; // XXPERMDI t, SUBREG_TO_REG(s), SUBREG_TO_REG(s), immed.; // We have to look through chains of COPY and SUBREG_TO_REG; // to find the real source values for comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:64,Availability,redundant,redundant,64,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:41,Performance,load,load,41,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:205,Performance,load,load,205,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:64,Safety,redund,redundant,64,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:44,Usability,simpl,simplify,44,"// If this is a splat fed by a swap, we can simplify modify; // the splat to splat the other value from the swap's input; // parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,Availability,redundant,redundant,94,"// If the instruction[s] that feed this splat have already splat; // the value, this splat is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,Safety,redund,redundant,94,"// If the instruction[s] that feed this splat have already splat; // the value, this splat is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:62,Availability,redundant,redundant,62,"// If this is a DP->SP conversion fed by an FRSP, the FRSP is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:62,Safety,redund,redundant,62,"// If this is a DP->SP conversion fed by an FRSP, the FRSP is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:152,Performance,perform,performs,152,"// If the input to XVCVDPSP is a vector that was built (even; // partially) out of FRSP's, the FRSP(s) can safely be removed; // since this instruction performs the same operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:107,Safety,safe,safely,107,"// If the input to XVCVDPSP is a vector that was built (even; // partially) out of FRSP's, the FRSP(s) can safely be removed; // since this instruction performs the same operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:24,Modifiability,extend,extending,24,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:57,Modifiability,extend,extend,57,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:84,Modifiability,extend,extending,84,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:34,Performance,load,load,34,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,Performance,load,load,94,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:78,Availability,Alive,AliveBlocks,78,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:144,Availability,Alive,AliveBlocks,144,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:160,Deployability,update,updated,160,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:24,Modifiability,extend,extending,24,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:57,Modifiability,extend,extend,57,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:84,Modifiability,extend,extending,84,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:34,Performance,load,load,34,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,Performance,load,load,94,"// If we've used a zero-extending load that we will sign-extend,; // just do a sign-extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:34,Modifiability,extend,extending,34,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:59,Modifiability,extend,extending,59,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:44,Performance,load,load,44,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:73,Performance,load,load,73,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:196,Performance,perform,perform,196,"// The transformation from a zero-extending load to a sign-extending; // load is only legal when the displacement is a multiple of 4.; // If the displacement is not at least 4 byte aligned, don't perform; // the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:78,Availability,Alive,AliveBlocks,78,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:144,Availability,Alive,AliveBlocks,144,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:160,Deployability,update,updated,160,// We are removing a definition of NarrowReg which will cause; // problems in AliveBlocks. Add an implicit def that will be; // removed so that AliveBlocks are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:71,Modifiability,extend,extended,71,// We can eliminate EXTSW if the input is known to be already; // sign-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:72,Usability,clear,clear,72,"// We can eliminate RLDICL (e.g. for zero-extension); // if all bits to clear are already zero in the input.; // This code assume following code sequence for zero-extension.; // %6 = COPY %5:sub_32; (optional); // %8 = IMPLICIT_DEF;; // %7<def,tied1> = INSERT_SUBREG %8<tied0>, %6, sub_32;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:97,Performance,load,load,97,"// TODO: Any instruction that has an immediate form fed only by a PHI; // whose operands are all load immediate can be folded away. We currently; // do this for ADD instructions, but should expand it to arithmetic and; // binary instructions with immediate forms in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:50,Usability,clear,clear,50,// We can eliminate RLDICL/RLDICR if it's used to clear bits and all; // bits cleared will be ANDed with 0 by ANDI_rec/ANDIS_rec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:78,Usability,clear,cleared,78,// We can eliminate RLDICL/RLDICR if it's used to clear bits and all; // bits cleared will be ANDed with 0 by ANDI_rec/ANDIS_rec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:22,Performance,optimiz,optimization,22,// We can only do the optimization if we can get immediates; // from both operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:53,Availability,redundant,redundant,53,// Eliminate all the TOC save instructions which are redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:53,Safety,redund,redundant,53,// Eliminate all the TOC save instructions which are redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:23,Availability,redundant,redundant,23,// We try to eliminate redundant compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:23,Safety,redund,redundant,23,// We try to eliminate redundant compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:110,Deployability,update,update,110,"// If we have made any modifications and added any registers to the set of; // registers for which we need to update the kill flags, do so by recomputing; // LiveVariables for those registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:37,Safety,avoid,avoid,37,// We track through PHI only once to avoid infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:147,Deployability,pipeline,pipeline,147,"// We optimize BBs ending with a conditional branch.; // We check only for BCC here, not BCCLR, because BCCLR; // will be formed only later in the pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:6,Performance,optimiz,optimize,6,"// We optimize BBs ending with a conditional branch.; // We check only for BCC here, not BCCLR, because BCCLR; // will be formed only later in the pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:6,Performance,optimiz,optimize,6,// We optimize only if the condition code is used only by one BCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:207,Safety,avoid,avoid,207,"// If this BB has more than one successor, we can create a new BB and; // move the compare instruction in the new BB.; // So far, we do not move compare instruction to a BB having multiple; // successors to avoid potentially increasing code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:26,Availability,redundant,redundant,26,"// We check for partially redundant case.; // So far, we support cases with only two predecessors; // to avoid increasing the number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:26,Safety,redund,redundant,26,"// We check for partially redundant case.; // So far, we support cases with only two predecessors; // to avoid increasing the number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:105,Safety,avoid,avoid,105,"// We check for partially redundant case.; // So far, we support cases with only two predecessors; // to avoid increasing the number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:134,Availability,avail,available,134,"// Here, Pred2MBB is the BB to which we need to append a compare inst.; // We cannot move the compare instruction if operands are not available; // in Pred2MBB (i.e. defined in MBB by an instruction other than PHI).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:167,Availability,redundant,redundant,167,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:256,Availability,redundant,redundant,256,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:167,Safety,redund,redundant,167,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:256,Safety,redund,redundant,256,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:13,Availability,redundant,redundant,13,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:369,Availability,redundant,redundant,369,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:596,Availability,redundant,redundant,596,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:762,Availability,redundant,redundant,762,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:787,Availability,redundant,redundant,787,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:80,Performance,optimiz,optimization,80,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:13,Safety,redund,redundant,13,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:369,Safety,redund,redundant,369,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:596,Safety,redund,redundant,596,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:762,Safety,redund,redundant,762,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:787,Safety,redund,redundant,787,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:13,Performance,optimiz,optimize,13,// We cannot optimize an unsupported compare opcode or; // a mix of 32-bit and 64-bit comparisons,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:217,Performance,optimiz,optimize,217,"// Typically, unsigned comparison is used for equality check, but; // we replace it with a signed comparison if the comparison; // to be merged is a signed comparison.; // In other cases of opcode mismatch, we cannot optimize this.; // We cannot change opcode when comparing against an immediate; // if the most significant bit of the immediate is one; // due to the difference in sign extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:22,Safety,redund,redundancy,22,"// In case of partial redundancy, we need to swap operands; // in another compare instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:100,Availability,redundant,redundant,100,// We touch up the compare instruction in MBB2 and move it to; // a previous BB to handle partially redundant case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:100,Safety,redund,redundant,100,// We touch up the compare instruction in MBB2 and move it to; // a previous BB to handle partially redundant case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:136,Modifiability,variab,variables,136,"// We finally eliminate compare instruction in MBB2.; // We do not need to treat CMPI2 specially here in terms of re-computing; // live variables even though it is being deleted because:; // - It defines a register that has a single use (already checked in; // eligibleForCompareElimination()); // - The only user (BI2) is no longer using it so the register is dead (no; // def, no uses); // - We do not attempt to recompute live variables for dead registers",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:430,Modifiability,variab,variables,430,"// We finally eliminate compare instruction in MBB2.; // We do not need to treat CMPI2 specially here in terms of re-computing; // live variables even though it is being deleted because:; // - It defines a register that has a single use (already checked in; // eligibleForCompareElimination()); // - The only user (BI2) is no longer using it so the register is dead (no; // def, no uses); // - We do not attempt to recompute live variables for dead registers",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:137,Usability,clear,clear,137,"// We miss the opportunity to emit an RLDIC when lowering jump tables; // since ISEL sees only a single basic block. When selecting, the clear; // and shift left will be in different blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:12,Usability,clear,cleared,12,"// The bits cleared with RLDICL are [0, MBSrc).; // The bits cleared with RLDICR are (MEMI, 63].; // After the sequence, the bits cleared are:; // [0, MBSrc-SHMI) and (MEMI, 63).; //; // The bits cleared with RLDIC are [0, NewMB) and (63-NewSH, 63].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:61,Usability,clear,cleared,61,"// The bits cleared with RLDICL are [0, MBSrc).; // The bits cleared with RLDICR are (MEMI, 63].; // After the sequence, the bits cleared are:; // [0, MBSrc-SHMI) and (MEMI, 63).; //; // The bits cleared with RLDIC are [0, NewMB) and (63-NewSH, 63].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:130,Usability,clear,cleared,130,"// The bits cleared with RLDICL are [0, MBSrc).; // The bits cleared with RLDICR are (MEMI, 63].; // After the sequence, the bits cleared are:; // [0, MBSrc-SHMI) and (MEMI, 63).; //; // The bits cleared with RLDIC are [0, NewMB) and (63-NewSH, 63].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:196,Usability,clear,cleared,196,"// The bits cleared with RLDICL are [0, MBSrc).; // The bits cleared with RLDICR are (MEMI, 63].; // After the sequence, the bits cleared are:; // [0, MBSrc-SHMI) and (MEMI, 63).; //; // The bits cleared with RLDIC are [0, NewMB) and (63-NewSH, 63].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:39,Safety,safe,safe,39,// If SrcReg has no non-debug use it's safe to delete its def SrcMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:351,Performance,optimiz,optimization,351,"// For case in LLVM IR; // entry:; // %iconv = sext i32 %index to i64; // br i1 undef label %true, label %false; // true:; // %ptr = getelementptr inbounds i32, i32* null, i64 %iconv; // ...; // PPCISelLowering::combineSHL fails to combine, because sext and shl are in; // different BBs when conducting instruction selection. We can do a peephole; // optimization to combine these two instructions into extswsli after; // instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:54,Performance,optimiz,optimizations,54,"//===--------- PPCPreEmitPeephole.cpp - Late peephole optimizations -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A pre-emit peephole for catching opportunities introduced by late passes such; // as MachineBlockPlacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:29,Availability,redundant,redundant,29,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:340,Availability,redundant,redundant,340,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:262,Deployability,update,update,262,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:39,Performance,load,load,39,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:110,Performance,load,load,110,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:29,Safety,redund,redundant,29,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:174,Safety,redund,redundancy,174,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:247,Safety,redund,redundancy,247,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:340,Safety,redund,redundant,340,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:8,Performance,load,load,8,// Skip load immediate that is marked to be erased later because it; // cannot be used to replace any other instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:12,Performance,load,load,12,// Skip non-load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:8,Performance,load,load,8,"// Skip load immediate, where the operand is a relocation (e.g., $r3 =; // LI target-flags(ppc-lo) %const.0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:69,Availability,redundant,redundant,69,// This loop scans instructions after BBI to see if there is any; // redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:79,Performance,load,load,79,// This loop scans instructions after BBI to see if there is any; // redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:69,Safety,redund,redundant,69,// This loop scans instructions after BBI to see if there is any; // redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:108,Availability,redundant,redundant,108,// Track the operand that kill Reg. We would unset the kill flag of; // the operand if there is a following redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:118,Performance,load,load,118,// Track the operand that kill Reg. We would unset the kill flag of; // the operand if there is a following redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:108,Safety,redund,redundant,108,// Track the operand that kill Reg. We would unset the kill flag of; // the operand if there is a following redundant load immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:17,Usability,clear,clear,17,"// We can't just clear implicit kills, so if we encounter one, stop; // looking further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:55,Performance,load,load,55,// Finish scanning because Reg is overwritten by a non-load; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:59,Availability,redundant,redundant,59,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:124,Modifiability,extend,extend,124,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:6,Performance,load,loads,6,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:59,Safety,redund,redundant,59,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:176,Safety,redund,redundancy,176,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:75,Security,access,access,75,// Check if this instruction is a PLDpc that is part of a GOT indirect; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:63,Security,access,access,63,// Struct to keep track of one def/use pair for a GOT indirect access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:113,Security,access,access,113,// Run through all of the instructions in the basic block and try to; // collect potential pairs of GOT indirect access instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:37,Performance,load,load,37,// Look for the initial GOT indirect load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:7,Performance,load,load,7,// The load/store instruction that uses the address from the PLD will; // either use a register (for a store) or define a register (for the; // load). That register will be added as an implicit def to the PLD; // and as an implicit use on the second memory op. This is a precaution; // to prevent future passes from using that register between the two; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:144,Performance,load,load,144,// The load/store instruction that uses the address from the PLD will; // either use a register (for a store) or define a register (for the; // load). That register will be added as an implicit def to the PLD; // and as an implicit use on the second memory op. This is a precaution; // to prevent future passes from using that register between the two; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:25,Availability,redundant,redundant,25,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:393,Availability,redundant,redundant,393,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:25,Safety,redund,redundant,25,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:393,Safety,redund,redundant,393,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:69,Performance,load,load,69,"// If the user wants to set the DSCR using command-line options,; // load in the specified value at the start of main.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:15,Availability,mask,mask,15,// 25-bit DSCR mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:330,Testability,log,logic,330,"// Insert Point; // Copy the 32-bit DSCRValue integer into the GPR InDSCR using LIS and; // ORI, then move to DSCR. If the requested DSCR value is contained; // in a 16-bit signed number, we can emit a single `LI`, but the; // impact of saving one instruction in one function does not warrant; // any additional complexity in the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:3,Safety,Detect,Detect,3,// Detect self copies - these can result from running AADB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:540,Deployability,pipeline,pipeline,540,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:36,Energy Efficiency,Reduce,Reduce,36,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:400,Energy Efficiency,reduce,reduce,400,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:510,Performance,latency,latency,510,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:707,Performance,latency,latency,707,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:50,Testability,Log,Logical,50,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:421,Testability,log,logical,421,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:730,Testability,log,logical,730,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:260,Deployability,update,updated,260,"/// Given a basic block \p Successor that potentially contains PHIs, this; /// function will look for any incoming values in the PHIs that are supposed to; /// be coming from \p OrigMBB but whose definition is actually in \p NewMBB.; /// Any such PHIs will be updated to reflect reality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:114,Deployability,update,updated,114,"// If any of the PHIs in the successors of NewMBB reference values that; // now come from NewMBB, they need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:15,Testability,log,logical,15,"/// Given a CR logical operation \p CROp, branch opcode \p BROp as well as; /// a flag to indicate if the first operand of \p CROp is used as the; /// SplitBefore operand, determines whether either of the branches are to be; /// inverted as well as whether the new target should be the original; /// fall-through block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:209,Usability,clear,clearer,209,"// The conditions under which each of the output operands should be [un]set; // can certainly be written much more concisely with just 3 if statements or; // ternary expressions. However, this provides a much clearer overview to the; // reader as to what is set for each <CROp, BROp, OpUsed> combination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:34,Testability,log,logical,34,// A vector to contain all the CR logical operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:46,Testability,log,logical,46,// We now know whether all the uses of the CR logical are in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:55,Testability,log,logical,55,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:105,Testability,log,logical,105,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:173,Testability,log,logical,173,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:270,Testability,log,logical,270,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:284,Usability,simpl,simply,284,"/// Contains all the implemented transformations on CR logical operations.; /// For example, a binary CR logical can be used to split a block on its inputs,; /// a unary CR logical might be used to change the condition code on a; /// comparison feeding it. A nullary CR logical might simply be removable; /// if the user of the bit it [un]sets can be transformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:38,Testability,log,logical,38,"/// Splits a block that contains a CR-logical operation that feeds a branch; /// and whose operands are produced within the block.; /// Example:; /// %vr5<def> = CMPDI %vr2, 0; CRRC:%vr5 G8RC:%vr2; /// %vr6<def> = COPY %vr5:sub_eq; CRBITRC:%vr6 CRRC:%vr5; /// %vr7<def> = CMPDI %vr3, 0; CRRC:%vr7 G8RC:%vr3; /// %vr8<def> = COPY %vr7:sub_eq; CRBITRC:%vr8 CRRC:%vr7; /// %vr9<def> = CROR %vr6<kill>, %vr8<kill>; CRBITRC:%vr9,%vr6,%vr8; /// BC %vr9<kill>, <BB#2>; CRBITRC:%vr9; /// Becomes:; /// %vr5<def> = CMPDI %vr2, 0; CRRC:%vr5 G8RC:%vr2; /// %vr6<def> = COPY %vr5:sub_eq; CRBITRC:%vr6 CRRC:%vr5; /// BC %vr6<kill>, <BB#2>; CRBITRC:%vr6; ///; /// %vr7<def> = CMPDI %vr3, 0; CRRC:%vr7 G8RC:%vr3; /// %vr8<def> = COPY %vr7:sub_eq; CRBITRC:%vr8 CRRC:%vr7; /// BC %vr9<kill>, <BB#2>; CRBITRC:%vr9",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:100,Testability,log,logical,100,// We want the new block to have no code in it other than the definition; // of the input to the CR logical and the CR logical itself. So we move; // those to the bottom of the block (just before the branch). Then we; // will split before the CR logical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:119,Testability,log,logical,119,// We want the new block to have no code in it other than the definition; // of the input to the CR logical and the CR logical itself. So we move; // those to the bottom of the block (just before the branch). Then we; // will split before the CR logical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:246,Testability,log,logical,246,// We want the new block to have no code in it other than the definition; // of the input to the CR logical and the CR logical itself. So we move; // those to the bottom of the block (just before the branch). Then we; // will split before the CR logical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:26,Testability,log,logical,26,"// If we've split on a CR logical that is fed by a CR logical,; // recompute the source CR logical as it may be usable for splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:54,Testability,log,logical,54,"// If we've split on a CR logical that is fed by a CR logical,; // recompute the source CR logical as it may be usable for splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:91,Testability,log,logical,91,"// If we've split on a CR logical that is fed by a CR logical,; // recompute the source CR logical as it may be usable for splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:112,Usability,usab,usable,112,"// If we've split on a CR logical that is fed by a CR logical,; // recompute the source CR logical as it may be usable for splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:30,Energy Efficiency,Power,PowerPC,30,"//===-- PPCRegisterInfo.cpp - PowerPC Register Information ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetRegisterInfo; // class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCRegisterInfo.cpp - PowerPC Register Information ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetRegisterInfo; // class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:157,Performance,perform,performance-sensitive,157,"// Copies/moves of physical accumulators are expensive operations; // that should be avoided whenever possible. MMA instructions are; // meant to be used in performance-sensitive computational kernels.; // This option is provided, at least for the time being, to give the; // user a tool to detect this expensive operation and either rework; // their code or report a compiler bug if that turns out to be the; // cause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:85,Safety,avoid,avoided,85,"// Copies/moves of physical accumulators are expensive operations; // that should be avoided whenever possible. MMA instructions are; // meant to be used in performance-sensitive computational kernels.; // This option is provided, at least for the time being, to give the; // user a tool to detect this expensive operation and either rework; // their code or report a compiler bug if that turns out to be the; // cause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:291,Safety,detect,detect,291,"// Copies/moves of physical accumulators are expensive operations; // that should be avoided whenever possible. MMA instructions are; // meant to be used in performance-sensitive computational kernels.; // This option is provided, at least for the time being, to give the; // user a tool to detect this expensive operation and either rework; // their code or report a compiler bug if that turns out to be the; // cause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:165,Performance,load,loads,165,"// We only reserve r2 if we need to use the TOC pointer. If we have no; // explicit uses of the TOC pointer (meaning we're a leaf function with; // no constant-pool loads, etc.) and we have no potential uses inside an; // inline asm block, then we can treat r2 has an ordinary callee-saved; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:75,Energy Efficiency,allocate,allocate,75,"// System-reserved register; // On PPC64, r13 is the thread pointer. Never allocate this register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:70,Safety,safe,safety,70,// If the callee saved info is invalid we have to default to true for safety.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:119,Performance,load,load,119,// The callee saved info is valid so it can be traversed.; // Checking for registers that need saving that do not have load or store; // forms where the address offset is an immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:128,Modifiability,variab,variable,128,// Do not use virtual base registers when ROP protection is turned on.; // Virtual base registers break the layout of the local variable space and may; // push the ROP Hash location past the 512 byte range of the ROP store; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:168,Security,Hash,Hash,168,// Do not use virtual base registers when ROP protection is turned on.; // Virtual base registers break the layout of the local variable space and may; // push the ROP Hash location past the 512 byte range of the ROP store; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:245,Security,access,access,245,"// X2/R2 is guaranteed to be preserved within a function if it is reserved.; // The reason it's reserved is that it's the TOC pointer (and the function; // uses the TOC). In functions where it isn't reserved (i.e. leaf functions; // with no TOC access), we can't claim that it is preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:126,Energy Efficiency,Power,Power,126,// Don't use the allocation hints for ISAFuture.; // The WACC registers used in ISAFuture are unlike the ACC registers on; // Power 10 and so this logic to register allocation hints does not apply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:147,Testability,log,logic,147,// Don't use the allocation hints for ISAFuture.; // The WACC registers used in ISAFuture are unlike the ACC registers on; // Power 10 and so this logic to register allocation hints does not apply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:142,Energy Efficiency,allocate,allocate,142,// We are interested in instructions that copy values to ACC/UACC.; // The copy into UACC will be simply a COPY to a subreg so we; // want to allocate the corresponding physical subreg for the source.; // The copy into ACC will be a BUILD_UACC so we want to allocate; // the same number UACC for the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:258,Energy Efficiency,allocate,allocate,258,// We are interested in instructions that copy values to ACC/UACC.; // The copy into UACC will be simply a COPY to a subreg so we; // want to allocate the corresponding physical subreg for the source.; // The copy into ACC will be a BUILD_UACC so we want to allocate; // the same number UACC for the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:98,Usability,simpl,simply,98,// We are interested in instructions that copy values to ACC/UACC.; // The copy into UACC will be simply a COPY to a subreg so we; // want to allocate the corresponding physical subreg for the source.; // The copy into ACC will be a BUILD_UACC so we want to allocate; // the same number UACC for the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:216,Deployability,patch,patch,216,"// With VSX, we can inflate various sub-register classes to the full VSX; // register set.; // For Power9 we allow the user to enable GPR to vector spills.; // FIXME: Currently limited to spilling GP8RC. A follow on patch will add; // support to spill GPRC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:455,Deployability,update,update,455,"//===----------------------------------------------------------------------===//; // Stack Frame Processing methods; //===----------------------------------------------------------------------===//; /// lowerDynamicAlloc - Generate the code for allocating an object in the; /// current frame. The sequence of code will be in the general form; ///; /// addi R0, SP, \#frameSize ; get the address of the previous frame; /// stwxu R0, SP, Rnegsize ; add and update the SP with the negated size; /// addi Rnew, SP, \#maxCalFrameSize ; get the top of the allocation; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:22,Deployability,update,update,22,"// Grow the stack and update the stack pointer link, then determine the; // address of new allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:91,Energy Efficiency,allocate,allocated,91,"// Grow the stack and update the stack pointer link, then determine the; // address of new allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:130,Performance,load,load,130,"// Determine the previous frame's address. If FrameSize can't be; // represented as 16 bits or we need special alignment, then we load the; // previous frame's address from 0(SP). Why not do an addis of the hi?; // Because R0 is our only safe tmp register and addi/addis treat R0 as zero.; // Constructing the constant and adding would take 3 instructions.; // Fortunately, a frame greater than 32K is rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:238,Safety,safe,safe,238,"// Determine the previous frame's address. If FrameSize can't be; // represented as 16 bits or we need special alignment, then we load the; // previous frame's address from 0(SP). Why not do an addis of the hi?; // Because R0 is our only safe tmp register and addi/addis treat R0 as zero.; // Constructing the constant and adding would take 3 instructions.; // Fortunately, a frame greater than 32K is rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:22,Energy Efficiency,allocate,allocate,22,// RegAllocator might allocate FramePointer and NegSizeReg in the same phyreg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:132,Safety,avoid,avoid,132,"// FramePointer is clobbered earlier than the use of NegSizeReg in; // prepareDynamicAlloca, save NegSizeReg in ActualNegSizeReg to avoid; // misuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:23,Deployability,update,updated,23,// NegSizeReg might be updated in prepareDynamicAlloca if MaxAlign >; // TargetAlign.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:163,Testability,log,logical,163,"// We need to move the CR field that contains the CR bit we are spilling.; // The super register may not be explicitly defined (i.e. it can be defined; // by a CR-logical that only defines the subreg) so we state that the CR; // field is undef. Also, in order to preserve the kill flag on the CR bit,; // we add it as an implicit use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:106,Availability,Mask,Mask,106,"// If the saved register wasn't CR0LT, shift the bits left so that the bit; // to store is the first one. Mask all but that bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:27,Integrability,depend,dependency,27,// Make sure we have a use dependency all the way through this; // sequence of instructions. We can't have the other bits in the CR; // modified in between the mfocrf and the mtocrf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:227,Usability,simpl,simply,227,"/// lowerACCSpilling - Generate the code for spilling the accumulator register.; /// Similarly to other spills/reloads that use pseudo-ops, we do not actually; /// eliminate the FrameIndex here nor compute the stack offset. We simply; /// create a real instruction with an FI and rely on eliminateFrameIndex to; /// handle the FI elimination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:14,Performance,load,loads,14,// Create two loads for the pair subregisters accounting for endianness and; // then prime the accumulator register being restored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:133,Safety,safe,safely,133,"// If we can, encode the offset directly into the instruction. If this is a; // normal PPC ""ri"" instruction, any 16-bit value can be safely encoded. If; // this is a PPC64 ""ix"" instruction, only a 16-bit value with the low two bits; // clear can be encoded. This is extremely uncommon, because normally you; // only ""std"" to a stack slot that is at least 4-byte aligned, but it can; // happen in invalid code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:236,Usability,clear,clear,236,"// If we can, encode the offset directly into the instruction. If this is a; // normal PPC ""ri"" instruction, any 16-bit value can be safely encoded. If; // this is a PPC64 ""ix"" instruction, only a 16-bit value with the low two bits; // clear can be encoded. This is extremely uncommon, because normally you; // only ""std"" to a stack slot that is at least 4-byte aligned, but it can; // happen in invalid code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:83,Security,access,access,83,"// Since these are not real X-Form instructions, we must; // add the registers and access 0(NewReg) rather than; // emitting the X-Form pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:12,Performance,load,load,12,"// It's the load/store FI references that cause issues, as it can be difficult; // to materialize the offset if it won't fit in the literal field. Estimate; // based on the size of the local frame and some conservative assumptions; // about the rest of the stack frame (note, this is pre-regalloc, so; // we don't know everything for certain yet) whether this offset is likely; // to be out of range of the immediate. Return true if so.; // We only generate virtual base registers for loads and stores that have; // an r+i form. Return false for everything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:485,Performance,load,loads,485,"// It's the load/store FI references that cause issues, as it can be difficult; // to materialize the offset if it won't fit in the literal field. Estimate; // based on the size of the local frame and some conservative assumptions; // about the rest of the stack frame (note, this is pre-regalloc, so; // we don't know everything for certain yet) whether this offset is likely; // to be out of range of the immediate. Return true if so.; // We only generate virtual base registers for loads and stores that have; // an r+i form. Return false for everything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:138,Security,access,access,138,"// Estimate an offset from the stack pointer.; // The incoming offset is relating to the SP at the start of the function,; // but when we access the local it'll be relative to the SP after local; // allocation, so adjust our SP-relative offset by that allocation size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h:28,Energy Efficiency,Power,PowerPC,28,"//===-- PPCRegisterInfo.h - PowerPC Register Information Impl ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetRegisterInfo; // class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCRegisterInfo.h - PowerPC Register Information Impl ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetRegisterInfo; // class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h:60,Performance,load,load,60,/// getMappedIdxOpcForImmOpc - Return the mapped index form load/store opcode; /// for a given imm form load/store opcode \p ImmFormOpcode.; /// FIXME: move this to PPCInstrInfo class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h:104,Performance,load,load,104,/// getMappedIdxOpcForImmOpc - Return the mapped index form load/store opcode; /// for a given imm form load/store opcode \p ImmFormOpcode.; /// FIXME: move this to PPCInstrInfo class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:8,Energy Efficiency,Power,PowerPCSubtarget,8,"//===-- PowerPCSubtarget.cpp - PPC Subtarget Information ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the PPC specific subclass of TargetSubtargetInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:24,Energy Efficiency,schedul,schedule,24,// Determine the CPU to schedule for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:14,Energy Efficiency,schedul,scheduling,14,// Initialize scheduling itinerary for the specified CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:48,Energy Efficiency,schedul,scheduling,48,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:90,Energy Efficiency,schedul,schedule,90,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:206,Energy Efficiency,schedul,scheduling,206,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:255,Energy Efficiency,schedul,schedule,255,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:282,Performance,perform,performance,282,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCSubtarget.h - Define Subtarget for the PPC ----------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of TargetSubtargetInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:65,Performance,Tune,TuneCPU,65,"/// initializeSubtargetDependencies - Initializes using a CPU, a TuneCPU, and; /// feature string so that we can use initializer lists for subtarget; /// initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:4,Energy Efficiency,Schedul,Scheduling,4,/// Scheduling customization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:4,Deployability,Pipeline,Pipeliner,4,/// Pipeliner customization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:12,Deployability,Pipeline,Pipeliner,12,/// Machine Pipeliner customization,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:27,Security,access,accessed,27,/// True if the GV will be accessed via an indirect symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:56,Energy Efficiency,Power,PowerPC,56,"//===-- PPCTargetMachine.cpp - Define TargetMachine for PowerPC -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Top-level implementation for the PowerPC target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:416,Energy Efficiency,Power,PowerPC,416,"//===-- PPCTargetMachine.cpp - Define TargetMachine for PowerPC -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Top-level implementation for the PowerPC target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:92,Integrability,depend,depends,92,"// If the target ABI uses function descriptors, then the alignment of function; // pointers depends on the alignment used to emit the descriptor. Otherwise,; // function pointers are aligned to 32 bits because the instructions must be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:33,Availability,avail,available,33,// Make sure 64-bit features are available when CPUname is generic,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:90,Deployability,Pipeline,Pipeline,90,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:99,Deployability,Configurat,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:99,Modifiability,Config,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:28,Deployability,Configurat,Configuration,28,/// PPC Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:28,Modifiability,Config,Configuration,28,/// PPC Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:58,Energy Efficiency,Schedul,Scheduler,58,// At any optimization level above -O0 we use the Machine Scheduler and not; // the default Post RA List Scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:105,Energy Efficiency,Schedul,Scheduler,105,// At any optimization level above -O0 we use the Machine Scheduler and not; // the default Post RA List Scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:10,Performance,optimiz,optimization,10,// At any optimization level above -O0 we use the Machine Scheduler and not; // the default Post RA List Scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:35,Energy Efficiency,Power,PowerPC,35,// Lower generic MASSV routines to PowerPC subtarget-specific entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:23,Integrability,rout,routines,23,// Lower generic MASSV routines to PowerPC subtarget-specific entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:83,Availability,avail,available,83,// Generate PowerPC target-specific entries for scalar math functions; // that are available in IBM MASS (scalar) library.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:12,Energy Efficiency,Power,PowerPC,12,// Generate PowerPC target-specific entries for scalar math functions; // that are available in IBM MASS (scalar) library.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the number of cr-logical ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:27,Testability,log,logical,27,// Reduce the number of cr-logical ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:37,Performance,perform,performed,37,// Target-specific peephole cleanups performed after instruction; // selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:116,Integrability,depend,dependent,116,"// FIXME: LiveVariables should not be necessary here!; // PPCTLSDynamicCallPass uses LiveIntervals which previously dependent on; // LiveVariables. This (unnecessary) dependency has been removed now,; // however a stage-2 clang build fails without LiveVariables computed here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:167,Integrability,depend,dependency,167,"// FIXME: LiveVariables should not be necessary here!; // PPCTLSDynamicCallPass uses LiveIntervals which previously dependent on; // LiveVariables. This (unnecessary) dependency has been removed now,; // however a stage-2 clang build fails without LiveVariables computed here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LL/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:63,Safety,avoid,avoiding,63,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LL/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:54,Energy Efficiency,Power,PowerPC,54,"//===-- PPCTargetMachine.h - Define TargetMachine for PowerPC ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of TargetMachine.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCTargetMachine.h - Define TargetMachine for PowerPC ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the PowerPC specific subclass of TargetMachine.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:42,Energy Efficiency,Power,PowerPC,42,/// Common code between 32-bit and 64-bit PowerPC targets.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h:77,Energy Efficiency,Power,PowerPC,77,/// PPC64LinuxTargetObjectFile - This implementation is used for; /// 64-bit PowerPC Linux.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h:19,Modifiability,variab,variable,19,/// Describe a TLS variable address within debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:7,Performance,latency,latency,7,// The latency of mtctr is only justified if there are more than 4; // comparisons that will be removed as a result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:19,Performance,load,load,19,// Turn PPC lvx -> load if the pointer is known aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:16,Performance,load,loads,16,// Turn PPC VSX loads into normal loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:34,Performance,load,loads,34,// Turn PPC VSX loads into normal loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:20,Availability,mask,mask,20,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:43,Availability,mask,mask,43,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:52,Availability,mask,mask,52,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:303,Availability,mask,mask,303,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:219,Performance,perform,performed,219,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:191,Usability,undo,undo,191,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:23,Availability,mask,mask,23,// (for the rotate-and-mask instructions),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:70,Performance,perform,perform,70,// We already implement getCastInstrCost and getMemoryOpCost where we perform; // the vector adjustment there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:23,Performance,latency,latency,23,// 6 is an approximate latency for the mtctr instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:34,Deployability,pipeline,pipeline,34,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:137,Energy Efficiency,schedul,scheduler,137,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:89,Performance,latency,latency-hiding,89,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:82,Security,expose,expose,82,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:30,Performance,cache,cache,30,// Starting with P7 we have a cache line size of 128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:39,Performance,cache,cache,39,// Assume that Future CPU has the same cache line size as the others.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:83,Performance,latency,latency,83,"// The 440 has no SIMD support, but floating-point instructions; // have a 5-cycle latency, so unroll by 5x for latency hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:112,Performance,latency,latency,112,"// The 440 has no SIMD support, but floating-point instructions; // have a 5-cycle latency, so unroll by 5x for latency hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:82,Performance,latency,latency,82,"// The A2 has no SIMD support, but floating-point instructions; // have a 6-cycle latency, so unroll by 6x for latency hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:111,Performance,latency,latency,111,"// The A2 has no SIMD support, but floating-point instructions; // have a 6-cycle latency, so unroll by 6x for latency hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:201,Energy Efficiency,schedul,scheduling,201,"// For P7 and P8, floating-point instructions have a 6-cycle latency and; // there are two execution units, so unroll by 12x for latency hiding.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready; // FIXME: the same for P10 as previous gen until POWER10 scheduling is ready; // Assume that future is the same as the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:279,Energy Efficiency,schedul,scheduling,279,"// For P7 and P8, floating-point instructions have a 6-cycle latency and; // there are two execution units, so unroll by 12x for latency hiding.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready; // FIXME: the same for P10 as previous gen until POWER10 scheduling is ready; // Assume that future is the same as the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:61,Performance,latency,latency,61,"// For P7 and P8, floating-point instructions have a 6-cycle latency and; // there are two execution units, so unroll by 12x for latency hiding.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready; // FIXME: the same for P10 as previous gen until POWER10 scheduling is ready; // Assume that future is the same as the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:129,Performance,latency,latency,129,"// For P7 and P8, floating-point instructions have a 6-cycle latency and; // there are two execution units, so unroll by 12x for latency hiding.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready; // FIXME: the same for P10 as previous gen until POWER10 scheduling is ready; // Assume that future is the same as the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:186,Performance,throughput,throughput,186,"// Returns a cost adjustment factor to adjust the cost of vector instructions; // on targets which there is overlap between the vector and scalar units,; // thereby reducing the overall throughput of vector code wrt. scalar code.; // An invalid instruction cost is returned if the type is an MMA vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:249,Performance,optimiz,optimizer,249,"// If the vector type is of an MMA type (v256i1, v512i1), an invalid; // instruction cost is returned. This is to signify to other cost computing; // functions to return the maximum instruction cost in order to prevent any; // opportunities for the optimizer to produce MMA types within the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:30,Safety,predict,predicted,30,// Branches are assumed to be predicted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:19,Performance,throughput,throughput,19,// TODO: Allow non-throughput costs that aren't binary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:44,Availability,mask,mask,44,// Computing on 1 bit values requires extra mask or compare operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:165,Energy Efficiency,schedul,schedulable,165,"// We need a vector extract (or mfvsrld). Assume vector operation cost.; // The cost of the load constant for a vector extract is disregarded; // (invariant, easily schedulable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:92,Performance,load,load,92,"// We need a vector extract (or mfvsrld). Assume vector operation cost.; // The cost of the load constant for a vector extract is disregarded; // (invariant, easily schedulable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:23,Performance,load,load-hit-store,23,// Estimated cost of a load-hit-store delay. This was obtained; // experimentally as a minimum needed to prevent unprofitable; // vectorization for the paq8p benchmark. It may need to be; // raised further if other unprofitable cases remain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:158,Testability,benchmark,benchmark,158,// Estimated cost of a load-hit-store delay. This was obtained; // experimentally as a minimum needed to prevent unprofitable; // vectorization for the paq8p benchmark. It may need to be; // raised further if other unprofitable cases remain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:179,Availability,avail,available,179,"// Vector element insert/extract with Altivec is very expensive,; // because they require store and reload with the attendant; // processor stall for load-hit-store. Until VSX is available,; // these need to be estimated as very costly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:150,Performance,load,load-hit-store,150,"// Vector element insert/extract with Altivec is very expensive,; // because they require store and reload with the attendant; // processor stall for load-hit-store. Until VSX is available,; // these need to be estimated as very costly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:19,Performance,load,load,19,// VSX has 32b/64b load instructions. Legalization can handle loading of; // 32b/64b to VSR correctly and cheaply. But BaseT::getMemoryOpCost and; // PPCTargetLowering can't compute the cost appropriately. So here we; // explicitly check this case. There are also corresponding store; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:62,Performance,load,loading,62,// VSX has 32b/64b load instructions. Legalization can handle loading of; // 32b/64b to VSR correctly and cheaply. But BaseT::getMemoryOpCost and; // PPCTargetLowering can't compute the cost appropriately. So here we; // explicitly check this case. There are also corresponding store; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:11,Performance,load,loads,11,// Aligned loads and stores are easy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:39,Performance,load,load,39,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:141,Performance,load,load,141,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:177,Performance,load,load,177,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:290,Performance,load,loads,290,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:409,Performance,load,load,409,"// If we can use the permutation-based load sequence, then this is also; // relatively cheap (not counting loop-invariant instructions): one load plus; // one permute (the last load in a series has extra cost, but we're; // neglecting that here). Note that on the P7, we could do unaligned loads; // for Altivec types using the VSX instructions, but that's more expensive; // than using the permutation-based load sequence. On the P8, that's no; // longer true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:70,Performance,load,loads,70,"// Add the cost of the permutations.; // For VSX, we can do unaligned loads and stores on Altivec/VSX types. On the; // P7, unaligned vector loads are more expensive than the permutation-based; // load sequence, so that might be used instead, but regardless, the net cost; // is about the same (not counting loop-invariant instructions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:141,Performance,load,loads,141,"// Add the cost of the permutations.; // For VSX, we can do unaligned loads and stores on Altivec/VSX types. On the; // P7, unaligned vector loads are more expensive than the permutation-based; // load sequence, so that might be used instead, but regardless, the net cost; // is about the same (not counting loop-invariant instructions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:197,Performance,load,load,197,"// Add the cost of the permutations.; // For VSX, we can do unaligned loads and stores on Altivec/VSX types. On the; // P7, unaligned vector loads are more expensive than the permutation-based; // load sequence, so that might be used instead, but regardless, the net cost; // is about the same (not counting loop-invariant instructions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:39,Security,access,access,39,// Newer PPC supports unaligned memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:45,Performance,load,loads,45,// PPC in general does not support unaligned loads and stores. They'll need; // to be decomposed based on the alignment factor.; // Add the cost of each scalar load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:160,Performance,load,load,160,// PPC in general does not support unaligned loads and stores. They'll need; // to be decomposed based on the alignment factor.; // Add the cost of each scalar load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:81,Performance,load,loads,81,"// For a vector type, there is also scalarization overhead (only for; // stores, loads are expanded using the vector-load + permutation sequence,; // which is much less expensive).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:117,Performance,load,load,117,"// For a vector type, there is also scalarization overhead (only for; // stores, loads are expanded using the vector-load + permutation sequence,; // which is much less expensive).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:24,Performance,load,load,24,"// Firstly, the cost of load/store operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC default behaviour here is ""instruction number 1st priority"".; // If LsrNoInsnsCost is set, call default implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:72,Energy Efficiency,Power,Power,72,// Only load and stores instructions can have variable vector length on Power.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:46,Modifiability,variab,variable,46,// Only load and stores instructions can have variable vector length on Power.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:8,Performance,load,load,8,// Only load and stores instructions can have variable vector length on Power.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:3,Performance,Load,Loads,3,// Loads/stores with length instructions use bits 0-7 of the GPR operand and; // therefore cannot be used in 32-bit mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:108,Availability,mask,masked,108,"// On P9 but not on P10, if the op is misaligned then it will cause a; // pipeline flush. Otherwise the VSX masked memops cost the same as unmasked; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:74,Deployability,pipeline,pipeline,74,"// On P9 but not on P10, if the op is misaligned then it will cause a; // pipeline flush. Otherwise the VSX masked memops cost the same as unmasked; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:175,Performance,load,load,175,"// Since alignment may be under estimated, we try to compute the probability; // that the actual address is aligned to the desired boundary. For example; // an 8-byte aligned load is assumed to be actually 16-byte aligned half the; // time, while a 4-byte aligned load has a 25% chance of being 16-byte; // aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:264,Performance,load,load,264,"// Since alignment may be under estimated, we try to compute the probability; // that the actual address is aligned to the desired boundary. For example; // an 8-byte aligned load is assumed to be actually 16-byte aligned half the; // time, while a 4-byte aligned load has a 25% chance of being 16-byte; // aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:174,Availability,mask,mask,174,"// Usually we should not get to this point, but the following is an attempt to; // model the cost of legalization. Currently we can only lower intrinsics with; // evl but no mask, on Power 9/10. Otherwise, we must scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:183,Energy Efficiency,Power,Power,183,"// Usually we should not get to this point, but the following is an attempt to; // model the cost of legalization. Currently we can only lower intrinsics with; // evl but no mask, on Power 9/10. Otherwise, we must scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:991,Modifiability,variab,variable,991,"//===---------- PPCTLSDynamicCall.cpp - TLS Dynamic Call Fixup ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands ADDItls{ld,gd}LADDR[32] machine instructions into; // separate ADDItls[gd]L[32] and GETtlsADDR[32] instructions, both of; // which define GPR3. A copy is added from GPR3 to the target virtual; // register of the original instruction. The GETtlsADDR[32] is really; // a call instruction, so its target register is constrained to be GPR3.; // This is not true of ADDItls[gd]L[32], but there is a legacy linker; // optimization bug that requires the target register of the addi of; // a local- or general-dynamic TLS access sequence to be GPR3.; //; // This is done in a late pass so that TLS variable accesses can be; // fully commoned by MachineCSE.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:813,Performance,optimiz,optimization,813,"//===---------- PPCTLSDynamicCall.cpp - TLS Dynamic Call Fixup ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands ADDItls{ld,gd}LADDR[32] machine instructions into; // separate ADDItls[gd]L[32] and GETtlsADDR[32] instructions, both of; // which define GPR3. A copy is added from GPR3 to the target virtual; // register of the original instruction. The GETtlsADDR[32] is really; // a call instruction, so its target register is constrained to be GPR3.; // This is not true of ADDItls[gd]L[32], but there is a legacy linker; // optimization bug that requires the target register of the addi of; // a local- or general-dynamic TLS access sequence to be GPR3.; //; // This is done in a late pass so that TLS variable accesses can be; // fully commoned by MachineCSE.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:915,Security,access,access,915,"//===---------- PPCTLSDynamicCall.cpp - TLS Dynamic Call Fixup ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands ADDItls{ld,gd}LADDR[32] machine instructions into; // separate ADDItls[gd]L[32] and GETtlsADDR[32] instructions, both of; // which define GPR3. A copy is added from GPR3 to the target virtual; // register of the original instruction. The GETtlsADDR[32] is really; // a call instruction, so its target register is constrained to be GPR3.; // This is not true of ADDItls[gd]L[32], but there is a legacy linker; // optimization bug that requires the target register of the addi of; // a local- or general-dynamic TLS access sequence to be GPR3.; //; // This is done in a late pass so that TLS variable accesses can be; // fully commoned by MachineCSE.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:1000,Security,access,accesses,1000,"//===---------- PPCTLSDynamicCall.cpp - TLS Dynamic Call Fixup ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands ADDItls{ld,gd}LADDR[32] machine instructions into; // separate ADDItls[gd]L[32] and GETtlsADDR[32] instructions, both of; // which define GPR3. A copy is added from GPR3 to the target virtual; // register of the original instruction. The GETtlsADDR[32] is really; // a call instruction, so its target register is constrained to be GPR3.; // This is not true of ADDItls[gd]L[32], but there is a legacy linker; // optimization bug that requires the target register of the addi of; // a local- or general-dynamic TLS access sequence to be GPR3.; //; // This is done in a late pass so that TLS variable accesses can be; // fully commoned by MachineCSE.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:208,Availability,error,error,208,"// Although we create ADJCALLSTACKDOWN and ADJCALLSTACKUP; // as scheduling fences, we skip creating fences if we already; // have existing ADJCALLSTACKDOWN/UP to avoid nesting,; // which causes verification error with -verify-machineinstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:65,Energy Efficiency,schedul,scheduling,65,"// Although we create ADJCALLSTACKDOWN and ADJCALLSTACKUP; // as scheduling fences, we skip creating fences if we already; // have existing ADJCALLSTACKDOWN/UP to avoid nesting,; // which causes verification error with -verify-machineinstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:163,Safety,avoid,avoid,163,"// Although we create ADJCALLSTACKDOWN and ADJCALLSTACKUP; // as scheduling fences, we skip creating fences if we already; // have existing ADJCALLSTACKDOWN/UP to avoid nesting,; // which causes verification error with -verify-machineinstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:77,Energy Efficiency,schedul,scheduling,77,// We create ADJCALLSTACKUP and ADJCALLSTACKDOWN around _tls_get_addr; // as scheduling fence to avoid it is scheduled before; // mflr in the prologue and the address in LR is clobbered (PR25839).; // We don't really need to save data to the stack - the clobbered; // registers are already saved when the SDNode (e.g. PPCaddiTlsgdLAddr); // gets translated to the pseudo instruction (e.g. ADDItlsgdLADDR).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:109,Energy Efficiency,schedul,scheduled,109,// We create ADJCALLSTACKUP and ADJCALLSTACKDOWN around _tls_get_addr; // as scheduling fence to avoid it is scheduled before; // mflr in the prologue and the address in LR is clobbered (PR25839).; // We don't really need to save data to the stack - the clobbered; // registers are already saved when the SDNode (e.g. PPCaddiTlsgdLAddr); // gets translated to the pseudo instruction (e.g. ADDItlsgdLADDR).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:97,Safety,avoid,avoid,97,// We create ADJCALLSTACKUP and ADJCALLSTACKDOWN around _tls_get_addr; // as scheduling fence to avoid it is scheduled before; // mflr in the prologue and the address in LR is clobbered (PR25839).; // We don't really need to save data to the stack - the clobbered; // registers are already saved when the SDNode (e.g. PPCaddiTlsgdLAddr); // gets translated to the pseudo instruction (e.g. ADDItlsgdLADDR).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:7,Modifiability,variab,variable,7,// The variable offset and region handle are copied in r4 and r3. The; // copies are followed by GETtlsADDR32AIX/GETtlsADDR64AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1779,Deployability,update,updated,1779,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:51,Integrability,Depend,Dependencies,51,"//===-- PPCTOCRegDeps.cpp - Add Extra TOC Register Dependencies -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When resolving an address using the ELF ABI TOC pointer, two relocations are; // generally required: one for the high part and one for the low part. Only; // the high part generally explicitly depends on r2 (the TOC pointer). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencie",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:576,Integrability,depend,depends,576,"//===-- PPCTOCRegDeps.cpp - Add Extra TOC Register Dependencies -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When resolving an address using the ELF ABI TOC pointer, two relocations are; // generally required: one for the high part and one for the low part. Only; // the high part generally explicitly depends on r2 (the TOC pointer). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencie",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1800,Integrability,depend,dependencies,1800,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1990,Integrability,depend,dependencies,1990,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:2405,Integrability,depend,dependencies,2405,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:2306,Performance,optimiz,optimizations,2306,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1630,Safety,detect,detect,1630,"plicitly depends on r2 (the TOC pointer). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1871,Safety,avoid,avoid,1871,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1588,Testability,assert,asserted,1588,"plicitly depends on r2 (the TOC pointer). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:2209,Testability,log,logic,2209,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:124,Safety,avoid,avoid,124,"// PPCTOCRegDeps pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:28,Usability,simpl,simple,28,"// PPCTOCRegDeps pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXCopy.cpp:46,Usability,clear,clearing,46,"// add 1, not 0, because there is no implicit clearing; // of the high bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXCopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXCopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:437,Safety,avoid,avoid,437,"//===--------------- PPCVSXFMAMutate.cpp - VSX FMA Mutation ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mutates the form of VSX FMA instructions to avoid unnecessary; // copies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:111,Deployability,update,updated,111,"// The default (A-type) VSX FMA form kills the addend (it is taken from; // the target register, which is then updated to reflect the result of; // the FMA). If the instruction, however, kills one of the registers; // used for the product, then we can use the M-form instruction (which; // will take that value from the to-be-defined register).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:143,Testability,log,logic,143,"// In theory, there could be other uses of the addend copy before this; // fma. We could deal with this, but that would require additional; // logic below and I suspect it will not occur in any relevant; // situations. Additionally, check whether the copy source is killed; // prior to the fma. In order to replace the addend here with the; // source of the copy, it must still be live here. We can't use; // interval testing for a physical register, so as long as we're; // walking the MIs we may as well test liveness here.; //; // FIXME: There is a case that occurs in practice, like this:; // %9 = COPY %f1; VSSRC:%9; // ...; // %6 = COPY %9; VSSRC:%6,%9; // %7 = COPY %9; VSSRC:%7,%9; // %9<def,tied1> = XSMADDASP %9<tied0>, %1, %4; VSSRC:; // %6<def,tied1> = XSMADDASP %6<tied0>, %1, %2; VSSRC:; // %7<def,tied1> = XSMADDASP %7<tied0>, %1, %3; VSSRC:; // which prevents an otherwise-profitable transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:418,Testability,test,testing,418,"// In theory, there could be other uses of the addend copy before this; // fma. We could deal with this, but that would require additional; // logic below and I suspect it will not occur in any relevant; // situations. Additionally, check whether the copy source is killed; // prior to the fma. In order to replace the addend here with the; // source of the copy, it must still be live here. We can't use; // interval testing for a physical register, so as long as we're; // walking the MIs we may as well test liveness here.; //; // FIXME: There is a case that occurs in practice, like this:; // %9 = COPY %f1; VSSRC:%9; // ...; // %6 = COPY %9; VSSRC:%6,%9; // %7 = COPY %9; VSSRC:%7,%9; // %9<def,tied1> = XSMADDASP %9<tied0>, %1, %4; VSSRC:; // %6<def,tied1> = XSMADDASP %6<tied0>, %1, %2; VSSRC:; // %7<def,tied1> = XSMADDASP %7<tied0>, %1, %3; VSSRC:; // which prevents an otherwise-profitable transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:506,Testability,test,test,506,"// In theory, there could be other uses of the addend copy before this; // fma. We could deal with this, but that would require additional; // logic below and I suspect it will not occur in any relevant; // situations. Additionally, check whether the copy source is killed; // prior to the fma. In order to replace the addend here with the; // source of the copy, it must still be live here. We can't use; // interval testing for a physical register, so as long as we're; // walking the MIs we may as well test liveness here.; //; // FIXME: There is a case that occurs in practice, like this:; // %9 = COPY %f1; VSSRC:%9; // ...; // %6 = COPY %9; VSSRC:%6,%9; // %7 = COPY %9; VSSRC:%7,%9; // %9<def,tied1> = XSMADDASP %9<tied0>, %1, %4; VSSRC:; // %6<def,tied1> = XSMADDASP %6<tied0>, %1, %2; VSSRC:; // %7<def,tied1> = XSMADDASP %7<tied0>, %1, %3; VSSRC:; // which prevents an otherwise-profitable transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:19,Usability,usab,usable,19,"// If there are no usable killed product operands, then this; // transformation is likely not profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:228,Modifiability,extend,extended,228,"// If the addend copy is used only by this MI, then the addend source; // register is likely not live here. This could be fixed (based on the; // legality checks above, the live range for the addend source register; // could be extended), but it seems likely that such a trivial copy can; // be coalesced away later, and thus is not worth the effort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:46,Performance,perform,perform,46,"// If there isn't a class that fits, we can't perform the transform.; // This is needed for correctness with a mixture of VSX and Altivec; // instructions to make sure that a low VSX register is not assigned to; // the Altivec instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:3,Modifiability,Extend,Extend,3,// Extend the live intervals of the killed product operand to hold the; // fma result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:3,Modifiability,Extend,Extend,3,"// Extend the live interval of the addend source (it might end at the; // copy to be removed, or somewhere in between there and here). This; // is necessary only if it is a physical register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:940,Energy Efficiency,reduce,reduce,940,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:995,Energy Efficiency,reduce,reduce,995,"---- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly. Such operat",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:502,Performance,perform,performed,502,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:592,Performance,load,loads,592,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:865,Performance,load,load,865,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:947,Performance,perform,performance,947,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:1544,Performance,load,loads,1544," See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly. Such operations are identified as using ""special; // handling"" within this module.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:1784,Performance,optimiz,optimized,1784," See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly. Such operations are identified as using ""special; // handling"" within this module.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:1935,Performance,optimiz,optimization,1935," See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly. Such operations are identified as using ""special; // handling"" within this module.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:20,Energy Efficiency,allocate,allocated,20,// Swap entries are allocated in a vector for better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:53,Performance,perform,performance,53,// Swap entries are allocated in a vector for better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:51,Performance,optimiz,optimized,51,// Analyze webs and determine those that cannot be optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:41,Safety,safe,safely,41,// Record which swap instructions can be safely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:20,Deployability,update,update,20,// Remove swaps and update other instructions requiring special; // handling. Return true iff any changes are made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:3,Deployability,Update,Update,3,// Update instructions requiring special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:74,Energy Efficiency,Power,Power,74,"// If we don't have VSX on the subtarget, don't do anything.; // Also, on Power 9 the load and store ops preserve element order and so; // the swaps are not required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:86,Performance,load,load,86,"// If we don't have VSX on the subtarget, don't do anything.; // Also, on Power 9 the load and store ops preserve element order and so; // the swaps are not required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:90,Energy Efficiency,allocate,allocate,90,"// Initialize data structures for this pass. In particular, clear the; // swap vector and allocate the equivalence class mapping before; // processing each function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:60,Usability,clear,clear,60,"// Initialize data structures for this pass. In particular, clear the; // swap vector and allocate the equivalence class mapping before; // processing each function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:185,Testability,test,tests,185,"// An initial vector size of 256 appears to work well in practice.; // Small/medium functions with vector content tend not to incur a; // reallocation at this size. Three of the vector tests in; // projects/test-suite reallocate, which seems like a reasonable rate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:207,Testability,test,test-suite,207,"// An initial vector size of 256 appears to work well in practice.; // Small/medium functions with vector content tend not to incur a; // reallocation at this size. Three of the vector tests in; // projects/test-suite reallocate, which seems like a reasonable rate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:23,Energy Efficiency,allocate,allocate,23,// FIXME: Currently we allocate EC each time because we don't have; // access to the set representation on which to call clear(). Should; // consider adding a clear() method to the EquivalenceClasses class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:71,Security,access,access,71,// FIXME: Currently we allocate EC each time because we don't have; // access to the set representation on which to call clear(). Should; // consider adding a clear() method to the EquivalenceClasses class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:121,Usability,clear,clear,121,// FIXME: Currently we allocate EC each time because we don't have; // access to the set representation on which to call clear(). Should; // consider adding a clear() method to the EquivalenceClasses class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:159,Usability,clear,clear,159,// FIXME: Currently we allocate EC each time because we don't have; // access to the set representation on which to call clear(). Should; // consider adding a clear() method to the EquivalenceClasses class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:73,Performance,optimiz,optimization,73,"// Unless noted otherwise, an instruction is considered; // safe for the optimization. There are a large number of; // such true-SIMD instructions (all vector math, logical,; // select, compare, etc.). However, if the instruction; // mentions a partial vector register and does not have; // special handling defined, it is not swappable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:60,Safety,safe,safe,60,"// Unless noted otherwise, an instruction is considered; // safe for the optimization. There are a large number of; // such true-SIMD instructions (all vector math, logical,; // select, compare, etc.). However, if the instruction; // mentions a partial vector register and does not have; // special handling defined, it is not swappable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:165,Testability,log,logical,165,"// Unless noted otherwise, an instruction is considered; // safe for the optimization. There are a large number of; // such true-SIMD instructions (all vector math, logical,; // select, compare, etc.). However, if the instruction; // mentions a partial vector register and does not have; // special handling defined, it is not swappable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:285,Performance,optimiz,optimization,285,"// This is a doubleword splat if it is of the form; // XXPERMDI t, s, s, 0 or XXPERMDI t, s, s, 3. As above we; // must look through chains of copy-likes to find the source; // register. We turn off the marking for mention of a physical; // register, because splatting it is safe; the optimization; // will not swap the value in the physical register. Whether; // or not the two input registers are identical, we can handle; // these by adjusting the form of the XXPERMDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:275,Safety,safe,safe,275,"// This is a doubleword splat if it is of the form; // XXPERMDI t, s, s, 0 or XXPERMDI t, s, s, 3. As above we; // must look through chains of copy-likes to find the source; // register. We turn off the marking for mention of a physical; // register, because splatting it is safe; the optimization; // will not swap the value in the physical register. Whether; // or not the two input registers are identical, we can handle; // these by adjusting the form of the XXPERMDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:17,Performance,load,loads,17,"// Non-permuting loads are currently unsafe. We can use special; // handling for this in the future. By not marking these as; // IsSwap, we ensure computations containing them will be rejected; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:37,Safety,unsafe,unsafe,37,"// Non-permuting loads are currently unsafe. We can use special; // handling for this in the future. By not marking these as; // IsSwap, we ensure computations containing them will be rejected; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:13,Performance,load,loads,13,"// Permuting loads are marked as both load and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:38,Performance,load,load,38,"// Permuting loads are marked as both load and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:74,Performance,optimiz,optimization,74,"// Permuting loads are marked as both load and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:65,Safety,safe,safe,65,"// Permuting loads are marked as both load and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:5,Performance,load,load,5,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:147,Performance,load,load,147,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:89,Safety,safe,safe,89,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:228,Safety,safe,safe,228,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:38,Safety,unsafe,unsafe,38,"// Non-permuting stores are currently unsafe. We can use special; // handling for this in the future. By not marking these as; // IsSwap, we ensure computations containing them will be rejected; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:76,Performance,optimiz,optimization,76,"// Permuting stores are marked as both store and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:67,Safety,safe,safe,67,"// Permuting stores are marked as both store and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:325,Modifiability,maintainab,maintainable,325,"// The presence of the following lane-sensitive operations in a; // web will kill the optimization, at least for now. For these; // we do nothing, causing the optimization to fail.; // FIXME: Some of these could be permitted with special handling,; // and will be phased in as time permits.; // FIXME: There is no simple and maintainable way to express a set; // of opcodes having a common attribute in TableGen. Should this; // change, this is a prime candidate to use such a mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:86,Performance,optimiz,optimization,86,"// The presence of the following lane-sensitive operations in a; // web will kill the optimization, at least for now. For these; // we do nothing, causing the optimization to fail.; // FIXME: Some of these could be permitted with special handling,; // and will be phased in as time permits.; // FIXME: There is no simple and maintainable way to express a set; // of opcodes having a common attribute in TableGen. Should this; // change, this is a prime candidate to use such a mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:159,Performance,optimiz,optimization,159,"// The presence of the following lane-sensitive operations in a; // web will kill the optimization, at least for now. For these; // we do nothing, causing the optimization to fail.; // FIXME: Some of these could be permitted with special handling,; // and will be phased in as time permits.; // FIXME: There is no simple and maintainable way to express a set; // of opcodes having a common attribute in TableGen. Should this; // change, this is a prime candidate to use such a mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:314,Usability,simpl,simple,314,"// The presence of the following lane-sensitive operations in a; // web will kill the optimization, at least for now. For these; // we do nothing, causing the optimization to fail.; // FIXME: Some of these could be permitted with special handling,; // and will be phased in as time permits.; // FIXME: There is no simple and maintainable way to express a set; // of opcodes having a common attribute in TableGen. Should this; // change, this is a prime candidate to use such a mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:343,Testability,test,test,343,"// We can handle STXSDX and STXSSPX similarly to LXSDX and LXSSPX,; // by adding special handling for narrowing copies as well as; // widening ones. However, I've experimented with this, and in; // practice we currently do not appear to use STXSDX fed by; // a narrowing copy from a full vector register. Since I can't; // generate any useful test cases, I've left this alone for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:464,Performance,optimiz,optimized,464,"// Generate equivalence classes for related computations (webs) by; // def-use relationships of virtual registers. Mention of a physical; // register terminates the generation of equivalence classes as this; // indicates a use of a parameter, definition of a return value, use; // of a value returned from a call, or definition of a parameter to a; // call. Computations with physical register mentions are flagged; // as such so their containing webs will not be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:113,Performance,optimiz,optimized,113,"// Walk the swap vector entries looking for conditions that prevent their; // containing computations from being optimized. When such conditions are; // found, mark the representative of the computation's equivalence class; // as rejected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:37,Performance,load,loads,37,// Reject webs than contain swapping loads that feed something other; // than a swap instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:117,Performance,optimiz,optimization,117,// We skip debug instructions in the analysis. (Note that debug; // location information is still maintained by this optimization; // because it remains on the LXVD2X and STXVD2X instructions after; // the XXPERMDIs are removed.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:27,Performance,load,load,27,"// It is possible that the load feeds a swap and that swap feeds a; // store. In such a case, the code is actually trying to store a swapped; // vector. We must reject such webs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:67,Performance,load,loads,67,"// Walk the swap vector entries looking for swaps fed by permuting loads; // and swaps that feed permuting stores. If the containing computation; // has not been marked rejected, mark each such swap for removal.; // (Removal is delayed in case optimization has disturbed the pattern,; // such that multiple loads feed the same swap, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:244,Performance,optimiz,optimization,244,"// Walk the swap vector entries looking for swaps fed by permuting loads; // and swaps that feed permuting stores. If the containing computation; // has not been marked rejected, mark each such swap for removal.; // (Removal is delayed in case optimization has disturbed the pattern,; // such that multiple loads feed the same swap, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:307,Performance,load,loads,307,"// Walk the swap vector entries looking for swaps fed by permuting loads; // and swaps that feed permuting stores. If the containing computation; // has not been marked rejected, mark each such swap for removal.; // (Removal is delayed in case optimization has disturbed the pattern,; // such that multiple loads feed the same swap, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:218,Deployability,patch,patches,218,// The identified swap entry requires special handling to allow its; // containing computation to be optimized. Perform that handling; // here.; // FIXME: Additional opportunities will be phased in with subsequent; // patches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:101,Performance,optimiz,optimized,101,// The identified swap entry requires special handling to allow its; // containing computation to be optimized. Perform that handling; // here.; // FIXME: Additional opportunities will be phased in with subsequent; // patches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:112,Performance,Perform,Perform,112,// The identified swap entry requires special handling to allow its; // containing computation to be optimized. Perform that handling; // here.; // FIXME: Additional opportunities will be phased in with subsequent; // patches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:117,Safety,avoid,avoid,117,"// Note that an XXPERMDI requires a VSRC, so if the SUBREG_TO_REG; // is copying to a VRRC, we need to be careful to avoid a register; // assignment problem. In this case we must copy from VRRC to VSRC; // prior to the swap, and from VSRC to VRRC following the swap.; // Coalescing will usually remove all this mess.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:10,Testability,assert,asserts,10,// For no-asserts builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:33,Energy Efficiency,Power,PowerPC,33,"//===-- PPCAsmParser.cpp - Parse PowerPC asm to MCInst instructions -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:145,Availability,error,error,145,"// Evaluate an expression containing condition register; // or condition register field symbols. Returns positive; // value on success, or -1 on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:60,Energy Efficiency,Power,PowerPC,60,/// PPCOperand - Instances of this class represent a parsed PowerPC machine; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:3,Performance,Cache,Cached,3,// Cached result of EvaluateCRExpr(Val),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:7,Security,Hash,Hash,7,// The Hash Imm form is used for instructions that check or store a hash.; // These instructions have a small immediate range that spans between; // -8 and -512.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:68,Security,hash,hash,68,// The Hash Imm form is used for instructions that check or store a hash.; // These instructions have a small immediate range that spans between; // -8 and -512.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:43,Integrability,wrap,wrap,43,"// In 32-bit mode, large 32-bit quantities wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate extra memory for the string and copy it.; // FIXME: This is incorrect, Operands are owned by unique_ptr with a default; // deleter which will destroy them by simply using ""delete"", not correctly; // calling operator delete on this extra memory after calling the dtor; // explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:170,Usability,simpl,simply,170,"// Allocate extra memory for the string and copy it.; // FIXME: This is incorrect, Operands are owned by unique_ptr with a default; // deleter which will destroy them by simply using ""delete"", not correctly; // calling operator delete on this extra memory after calling the dtor; // explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:40,Modifiability,extend,extended,40,// Post-process instructions (typically extended mnemonics),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:136,Safety,avoid,avoid,136,/// Find all VK_TLSGD/VK_TLSLD symbol references in expression and replace; /// them by VK_PPC_TLSGD/VK_PPC_TLSLD. This is necessary to avoid having; /// _GLOBAL_OFFSET_TABLE_ created via ELFObjectWriter::RelocNeedsGOT.; /// FIXME: This is a hack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:35,Performance,load,loads,35,// Handle base mnemonic for atomic loads where the EH bit is zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:50,Availability,avail,available,50,"// FIXME: Right now, the parser always allows any available; // instruction, so the .machine directive is not useful.; // In the wild, any/push/pop/ppc64/altivec/power[4-9] are seen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:162,Energy Efficiency,power,power,162,"// FIXME: Right now, the parser always allows any available; // instruction, so the .machine directive is not useful.; // In the wild, any/push/pop/ppc64/altivec/power[4-9] are seen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp:51,Energy Efficiency,Power,PowerPC,51,"//===------ PPCDisassembler.cpp - Disassembler for PowerPC ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp:243,Modifiability,extend,extend,243,// Decode the disp field for a hash store or hash check operation.; // The field is composed of an immediate value that is 6 bits; // and covers the range -8 to -512. The immediate is always negative and 2s; // complement which is why we sign extend a 7 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp:31,Security,hash,hash,31,// Decode the disp field for a hash store or hash check operation.; // The field is composed of an immediate value that is 6 bits; // and covers the range -8 to -512. The immediate is always negative and 2s; // complement which is why we sign extend a 7 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp:45,Security,hash,hash,45,// Decode the disp field for a hash store or hash check operation.; // The field is composed of an immediate value that is 6 bits; // and covers the range -8 to -512. The immediate is always negative and 2s; // complement which is why we sign extend a 7 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/Disassembler/PPCDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCCallLowering.cpp:33,Performance,load,load,33,// define a lambda expression to load value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:468,Energy Efficiency,Power,PowerPC,468,"//===- PPCInstructionSelector.cpp --------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the targeting of the InstructionSelector class for; /// PowerPC.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:262,Availability,mask,mask,262,"// 2-2) Patterns : {zeros}{ones}{15-bit value}{zeros}; // {zeros}{15-bit value}{zeros}; // {zeros}{ones}{15-bit value}; // {ones}{15-bit value}{zeros}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDIC to mask off the ones in both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:209,Availability,mask,mask,209,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:502,Usability,clear,clear,502,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:725,Usability,clear,clear,725,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:196,Availability,mask,mask,196,"// 2-4) Patterns : {zeros}{ones}{15-bit value}{ones}; // {ones}{15-bit value}{ones}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDICL to mask off the ones in left sides (if required); // after rotation.; //; // +-LZ-FO||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00011110bbbbbbbbb1111111| -> |000000000011110bbbbbbbbb|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> TO) & 0xffff; // +----sext-----|--16-bit--+ +LZ|---------------------+; // |111111111111110bbbbbbbbb| -> |00011110bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left TO, clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:734,Usability,clear,clear,734,"// 2-4) Patterns : {zeros}{ones}{15-bit value}{ones}; // {ones}{15-bit value}{ones}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDICL to mask off the ones in left sides (if required); // after rotation.; //; // +-LZ-FO||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00011110bbbbbbbbb1111111| -> |000000000011110bbbbbbbbb|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> TO) & 0xffff; // +----sext-----|--16-bit--+ +LZ|---------------------+; // |111111111111110bbbbbbbbb| -> |00011110bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left TO, clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:295,Availability,mask,mask,295,"// 2-6) Patterns : {******}{49 zeros}{******}; // {******}{49 ones}{******}; // If the Imm contains 49 consecutive zeros/ones, it means that a total of 15; // bits remain on both sides. Rotate right the Imm to construct an int<16>; // value, use LI for int<16> value and then use RLDICL without mask to rotate; // it back.; //; // 1) findContiguousZerosAtLeast(Imm, 49); // +------|--zeros-|------+ +---ones--||---15 bit--+; // |bbbbbb0000000000aaaaaa| -> |0000000000aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0; //; // 2) findContiguousZerosAtLeast(~Imm, 49); // +------|--ones--|------+ +---ones--||---15 bit--+; // |bbbbbb1111111111aaaaaa| -> |1111111111aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:362,Availability,mask,mask,362,"// Following patterns use 3 instructions to materialize the Imm.; // 3-1) Patterns : {zeros}{ones}{31-bit value}{zeros}; // {zeros}{31-bit value}{zeros}; // {zeros}{ones}{31-bit value}; // {ones}{31-bit value}{zeros}; // We can take advantage of LIS's sign-extension semantics to generate leading; // ones, add the remaining bits with ORI, and then use RLDIC to mask off the; // ones in both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:244,Availability,mask,mask,244,"// 3-2) Pattern : {zeros}{31-bit value}{ones}; // Shift right the Imm by (32 - LZ) bits to construct a negative 32 bits; // value, therefore we can take advantage of LIS's sign-extension semantics,; // add the remaining bits with ORI, and then mask them off after rotation.; // This is similar to Pattern 2-3, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:230,Availability,mask,mask,230,"// 3-3) Patterns : {zeros}{ones}{31-bit value}{ones}; // {ones}{31-bit value}{ones}; // We can take advantage of LIS's sign-extension semantics to generate leading; // ones, add the remaining bits with ORI, and then use RLDICL to mask off the; // ones in left sides (if required) after rotation.; // This is similar to Pattern 2-4, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:302,Availability,mask,mask,302,"// 3-5) Patterns : {******}{33 zeros}{******}; // {******}{33 ones}{******}; // If the Imm contains 33 consecutive zeros/ones, it means that a total of 31; // bits remain on both sides. Rotate right the Imm to construct an int<32>; // value, use LIS + ORI for int<32> value and then use RLDICL without mask to; // rotate it back.; // This is similar to Pattern 2-6, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:146,Energy Efficiency,Power,PowerPC,146,"// Address stored in the TOC entry. This is related to code model and the ABI; // we are currently using. For now we only handle 64-bit Linux LE. PowerPC; // only supports small, medium and large code model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:34,Performance,load,load,34,"// For now, simply use DForm with load/store addr as base and 0 as imm.; // FIXME: optimize load/store with some specific address patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:83,Performance,optimiz,optimize,83,"// For now, simply use DForm with load/store addr as base and 0 as imm.; // FIXME: optimize load/store with some specific address patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:92,Performance,load,load,92,"// For now, simply use DForm with load/store addr as base and 0 as imm.; // FIXME: optimize load/store with some specific address patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:12,Usability,simpl,simply,12,"// For now, simply use DForm with load/store addr as base and 0 as imm.; // FIXME: optimize load/store with some specific address patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp:460,Energy Efficiency,Power,PowerPC,460,"//===- PPCLegalizerInfo.h ----------------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the targeting of the Machinelegalizer class for PowerPC; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp:28,Energy Efficiency,Power,PowerPC,28,// Check if this is a legal PowerPC vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h:458,Energy Efficiency,Power,PowerPC,458,"//===- PPCLegalizerInfo.h ----------------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares the targeting of the Machinelegalizer class for PowerPC; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h:48,Energy Efficiency,Power,PowerPC,48,/// This class provides the information for the PowerPC target legalizer for; /// GlobalISel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:465,Energy Efficiency,Power,PowerPC,465,"//===- PPCRegisterBankInfo.cpp --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the targeting of the RegisterBankInfo class for; /// PowerPC.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:19,Testability,log,logic,19,// Try the default logic for non-generic instructions that are either copies; // or already have some operands assigned to banks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:17,Performance,load,load,17,// Check if that load feeds fp instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:96,Performance,load,load,96,"// If we have at least one direct use in a FP instruction,; // assume this was a floating point load in the IR. If it was; // not, we would have had a bitcast before reaching that; // instruction.; //; // Int->FP conversion operations are also captured in; // onlyDefinesFP().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:89,Modifiability,extend,extended,89,"// TODO: Currently, only vector and GPR register banks are handled.; // This needs to be extended to handle floating point register; // banks in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:185,Modifiability,refactor,refactor,185,"/// Returns whether opcode \p Opc is a pre-isel generic floating-point opcode,; /// having only floating-point operands.; /// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in GlobalISel/Utils.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:63,Modifiability,refactor,refactor,63,/// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in class RegisterBankInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:63,Modifiability,refactor,refactor,63,/// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in class RegisterBankInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:63,Modifiability,refactor,refactor,63,/// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in class RegisterBankInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.h:463,Energy Efficiency,Power,PowerPC,463,"//===-- PPCRegisterBankInfo.h -----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file declares the targeting of the RegisterBankInfo class for PowerPC.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the bits; // from the fixup value. The Value has been ""split up"" into the appropriate; // bitfields above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:417,Energy Efficiency,Power,PowerPC,417,"//===-------- PPCELFStreamer.cpp - ELF Object Output ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a custom MCELFStreamer for PowerPC.; //; // The purpose of the custom ELF streamer is to allow us to intercept; // instructions as they are being emitted and align all 8 byte instructions; // to a 64 byte boundary if required (by adding a 4 byte nop). This is important; // because 8 byte instructions are not allowed to cross 64 byte boundaries; // and by aliging anything that is within 4 bytes of the boundary we can; // guarantee that the 8 byte instructions do not cross that boundary.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:63,Performance,optimiz,optimization,63,"// If the instruction is a part of the GOT to PC-Rel link time optimization; // instruction pair, return a value, otherwise return std::nullopt. A true; // returned value means the instruction is the PLDpc and a false value means; // it is the user instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:58,Performance,load,load,58,"// User of the GOT-indirect address.; // For example, the load that will get the relocation as follows:; // .reloc .Lpcrel1-8,R_PPC64_PCREL_OPT,.-(.Lpcrel1-8); // lwa 3, 4(3)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:71,Performance,load,load,71,"// Producer of the GOT-indirect address.; // For example, the prefixed load from the got that will get the label as; // follows:; // pld 3, vec@got@pcrel(0), 1; // .Lpcrel1:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:36,Performance,optimiz,optimization,36,"// This linker time GOT PC Relative optimization relocation will look like this:; // pld <reg> symbol@got@pcrel; // <Label###>:; // .reloc Label###-8,R_PPC64_PCREL_OPT,.-(Label###-8); // load <loadedreg>, 0(<reg>); // The reason we place the label after the PLDpc instruction is that there; // may be an alignment nop before it since prefixed instructions must not; // cross a 64-byte boundary (please see; // PPCELFStreamer::emitPrefixedInstruction()). When referring to the; // label, we subtract the width of a prefixed instruction (8 bytes) to ensure; // we refer to the PLDpc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:187,Performance,load,load,187,"// This linker time GOT PC Relative optimization relocation will look like this:; // pld <reg> symbol@got@pcrel; // <Label###>:; // .reloc Label###-8,R_PPC64_PCREL_OPT,.-(Label###-8); // load <loadedreg>, 0(<reg>); // The reason we place the label after the PLDpc instruction is that there; // may be an alignment nop before it since prefixed instructions must not; // cross a 64-byte boundary (please see; // PPCELFStreamer::emitPrefixedInstruction()). When referring to the; // label, we subtract the width of a prefixed instruction (8 bytes) to ensure; // we refer to the PLDpc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:193,Performance,load,loadedreg,193,"// This linker time GOT PC Relative optimization relocation will look like this:; // pld <reg> symbol@got@pcrel; // <Label###>:; // .reloc Label###-8,R_PPC64_PCREL_OPT,.-(Label###-8); // load <loadedreg>, 0(<reg>); // The reason we place the label after the PLDpc instruction is that there; // may be an alignment nop before it since prefixed instructions must not; // cross a 64-byte boundary (please see; // PPCELFStreamer::emitPrefixedInstruction()). When referring to the; // label, we subtract the width of a prefixed instruction (8 bytes) to ensure; // we refer to the PLDpc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:84,Performance,optimiz,optimization,84,// Emit the label that immediately follows the PLDpc for a link time GOT PC Rel; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:103,Performance,optimiz,optimization,103,// This function checks if the parameter Inst is part of the setup for a link; // time GOT PC Relative optimization. For example in this situation:; // <MCInst PLDpc <MCOperand Reg:282> <MCOperand Expr:(glob_double@got@pcrel)>; // <MCOperand Imm:0> <MCOperand Expr:(.Lpcrel@<<invalid>>)>>; // <MCInst SOME_LOAD <MCOperand Reg:22> <MCOperand Imm:0> <MCOperand Reg:282>; // <MCOperand Expr:(.Lpcrel@<<invalid>>)>>; // The above is a pair of such instructions and this function will not return; // std::nullopt for either one of them. In both cases we are looking for the; // last operand <MCOperand Expr:(.Lpcrel@<<invalid>>)> which needs to be an; // MCExpr and has the flag MCSymbolRefExpr::VK_PPC_PCREL_OPT. After that we just; // look at the opcode and in the case of PLDpc we will return true. For the load; // (or store) this function will return false indicating it has found the second; // instruciton in the pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp:805,Performance,load,load,805,// This function checks if the parameter Inst is part of the setup for a link; // time GOT PC Relative optimization. For example in this situation:; // <MCInst PLDpc <MCOperand Reg:282> <MCOperand Expr:(glob_double@got@pcrel)>; // <MCOperand Imm:0> <MCOperand Expr:(.Lpcrel@<<invalid>>)>>; // <MCInst SOME_LOAD <MCOperand Reg:22> <MCOperand Imm:0> <MCOperand Reg:282>; // <MCOperand Expr:(.Lpcrel@<<invalid>>)>>; // The above is a pair of such instructions and this function will not return; // std::nullopt for either one of them. In both cases we are looking for the; // last operand <MCOperand Expr:(.Lpcrel@<<invalid>>)> which needs to be an; // MCExpr and has the flag MCSymbolRefExpr::VK_PPC_PCREL_OPT. After that we just; // look at the opcode and in the case of PLDpc we will return true. For the load; // (or store) this function will return false indicating it has found the second; // instruciton in the pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:417,Energy Efficiency,Power,PowerPC,417,"//===- PPCELFStreamer.h - ELF Object Output --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a custom MCELFStreamer for PowerPC.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:77,Integrability,depend,depending,77,"// We need to keep track of the last label we emitted (only one) because; // depending on whether the label is on the same line as an aligned; // instruction or not, the label may refer to the instruction or the nop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:13,Deployability,update,updates,13,// EmitLabel updates LastLabel and LastLabelLoc when a new label is emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:107,Performance,optimiz,optimization,107,// Check if the instruction Inst is part of a pair of instructions that make up; // a link time GOT PC Rel optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:19,Deployability,integrat,integrated,19,"// FIXME: Once the integrated assembler supports full register names, tie this; // to the verbose-asm setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:19,Integrability,integrat,integrated,19,"// FIXME: Once the integrated assembler supports full register names, tie this; // to the verbose-asm setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:14,Testability,test,testing,14,// Useful for testing purposes. Prints vs{31-63} as v{0-31} respectively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:147,Performance,load,load,147,"// Customize printing of the addis instruction on AIX. When an operand is a; // symbol reference, the instruction syntax is changed to look like a load; // operation, i.e:; // Transform: addis $rD, $rA, $src --> addis $rD, $src($rA).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:132,Performance,optimiz,optimization,132,// Check if the last operand is an expression with the variant kind; // VK_PPC_PCREL_OPT. If this is the case then this is a linker optimization; // relocation and the .reloc directive needs to be added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:507,Availability,avail,available,507,"// dcbt[st] is printed manually here because:; // 1. The assembly syntax is different between embedded and server targets; // 2. We must print the short mnemonics for TH == 0 because the; // embedded/server syntax default will not be stable across assemblers; // The syntax for dcbt is:; // dcbt ra, rb, th [server]; // dcbt th, ra, rb [embedded]; // where th can be omitted when it is 0. dcbtst is the same.; // On AIX, only emit the extended mnemonics for dcbt and dcbtst if; // the ""modern assembler"" is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:435,Modifiability,extend,extended,435,"// dcbt[st] is printed manually here because:; // 1. The assembly syntax is different between embedded and server targets; // 2. We must print the short mnemonics for TH == 0 because the; // embedded/server syntax default will not be stable across assemblers; // The syntax for dcbt is:; // dcbt ra, rb, th [server]; // dcbt th, ra, rb [embedded]; // where th can be omitted when it is 0. dcbtst is the same.; // On AIX, only emit the extended mnemonics for dcbt and dcbtst if; // the ""modern assembler"" is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:115,Usability,simpl,simply,115,// Operands of BUILD_VECTOR are signed and we use this to print operands; // of XXSPLTIB which are unsigned. So we simply truncate to 8 bits and; // print as unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h:426,Energy Efficiency,Power,PowerPC,426,"//===-- PPCMCAsmInfo.h - PPC asm properties --------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declarations of the PowerPC MCAsmInfo classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCAsmInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp:27,Performance,load,load,27,// Encode imm for the hash load/store to stack for the ROP Protection; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp:22,Security,hash,hash,22,// Encode imm for the hash load/store to stack for the ROP Protection; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp:43,Usability,simpl,simply,43,"// Add a fixup for the TLS register, which simply provides a relocation; // hint to the linker that this statement is part of a relocation sequence.; // Return the thread-pointer register's encoding. Add a one byte displacement; // if using PC relative memops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:30,Energy Efficiency,Power,PowerPC,30,"//===-- PPCMCTargetDesc.cpp - PowerPC Target Descriptions -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides PowerPC specific target descriptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:402,Energy Efficiency,Power,PowerPC,402,"//===-- PPCMCTargetDesc.cpp - PowerPC Target Descriptions -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides PowerPC specific target descriptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:162,Energy Efficiency,allocate,allocated,162,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:234,Energy Efficiency,allocate,allocated,234,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:434,Modifiability,extend,extend,434,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:113,Integrability,depend,depending,113,"// On AIX, we have a region handle (symbol@m) and the variable offset; // (symbol@{gd|ie|le}) for TLS variables, depending on the TLS model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:54,Modifiability,variab,variable,54,"// On AIX, we have a region handle (symbol@m) and the variable offset; // (symbol@{gd|ie|le}) for TLS variables, depending on the TLS model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:102,Modifiability,variab,variables,102,"// On AIX, we have a region handle (symbol@m) and the variable offset; // (symbol@{gd|ie|le}) for TLS variables, depending on the TLS model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:46,Availability,error,error,46,// encodePPC64LocalEntryOffset will report an error if it cannot; // encode LocalOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:45,Deployability,update,updated,45,// Clear the set of symbols that needs to be updated so the streamer can; // be reused without issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:3,Usability,Clear,Clear,3,// Clear the set of symbols that needs to be updated so the streamer can; // be reused without issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:20,Deployability,update,update,20,"// FIXME: We should update the CPUType, CPUSubType in the Object file if; // the new values are different from the defaults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:28,Energy Efficiency,Power,PowerPC,28,"//===-- PPCMCTargetDesc.h - PowerPC Target Descriptions ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides PowerPC specific target descriptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:402,Energy Efficiency,Power,PowerPC,402,"//===-- PPCMCTargetDesc.h - PowerPC Target Descriptions ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides PowerPC specific target descriptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:162,Energy Efficiency,allocate,allocated,162,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:234,Energy Efficiency,allocate,allocated,234,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:434,Modifiability,extend,extend,434,"/// getRegNumForOperand - some operands use different numbering schemes; /// for the same registers. For example, a VSX instruction may have any of; /// vs0-vs63 allocated whereas an Altivec instruction could only have; /// vs32-vs63 allocated (numbered as v0-v31). This function returns the actual; /// register number needed for the opcode/operand number combination.; /// The operand number argument will be useful when we need to extend this; /// to instructions that use both Altivec and VSX numbering (for different; /// operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:127,Integrability,wrap,wrap,127,"/// Returns true iff Val consists of one contiguous run of 1s with any number of; /// 0s on either side. The 1s are allowed to wrap from LSB to MSB, so; /// 0x000FFF0, 0x0000FFFF, and 0xFF0000FF are all runs. 0x0F0F0000 is not,; /// since all 1s are not contiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:10,Availability,mask,mask,10,// invert mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:10,Availability,mask,mask,10,// invert mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:44,Energy Efficiency,Power,PowerPC,44,/// PPCII - This namespace holds all of the PowerPC target-specific; /// per-instruction flags. These must match the corresponding definitions in; /// PPC.td and PPCInstrFormats.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:81,Energy Efficiency,Power,PowerPC,81,"// PPC970 Instruction Flags. These flags describe the characteristics of the; // PowerPC 970 (aka G5) dispatch groups and how they are formed out of; // raw machine instructions.; /// PPC970_First - This instruction starts a new dispatch group, so it will; /// always be the first one in the group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:106,Availability,avail,available,106,"/// PPC970_Cracked - This instruction is cracked into two pieces, requiring; /// two dispatch pipes to be available to issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:59,Deployability,pipeline,pipeline,59,/// PPC970_Mask/Shift - This is a bitmask that selects the pipeline type that; /// an instruction is issued to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:48,Deployability,pipeline,pipelines,48,/// These are the various PPC970 execution unit pipelines. Each instruction; /// is one of these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:3,Performance,Load,Load,3,// Load Store Unit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:37,Modifiability,extend,extended,37,/// This instruction produced a sign extended result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:37,Modifiability,extend,extended,37,/// This instruction produced a zero extended result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:53,Energy Efficiency,Power,PowerPC,53,// end namespace llvm; // Defines symbolic names for PowerPC registers. This defines a mapping from; // register name to register number.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:34,Energy Efficiency,Power,PowerPC,34,// Defines symbolic names for the PowerPC instructions.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp:408,Energy Efficiency,Power,PowerPC,408,"//===-- PPCPredicates.cpp - PPC Branch Predicate Information --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the PowerPC branch predicates.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp:3,Usability,Simpl,Simple,3,// Simple predicates for single condition-register bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h:407,Energy Efficiency,Power,PowerPC,407,"//===-- PPCPredicates.h - PPC Branch Predicate Information ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file describes the PowerPC branch predicates.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h:48,Safety,avoid,avoid,48,"// Generated files will use ""namespace PPC"". To avoid symbol clash,; // undefine PPC here. PPC may be predefined on some hosts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h:65,Usability,simpl,simple,65,"// When dealing with individual condition-register bits, we have simple set; // and unset predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFObjectWriter.cpp:35,Energy Efficiency,Power,PowerPC,35,"//===-- PPCXCOFFObjectWriter.cpp - PowerPC XCOFF Writer -------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.cpp:420,Energy Efficiency,Power,PowerPC,420,"//===-------- PPCXCOFFStreamer.cpp - XCOFF Object Output ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a custom MCXCOFFStreamer for PowerPC.; //; // The purpose of the custom XCOFF streamer is to allow us to intercept; // instructions as they are being emitted and align all 8 byte instructions; // to a 64 byte boundary if required (by adding a 4 byte nop). This is important; // because 8 byte instructions are not allowed to cross 64 byte boundaries; // and by aligning anything that is within 4 bytes of the boundary we can; // guarantee that the 8 byte instructions do not cross that boundary.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.h:420,Energy Efficiency,Power,PowerPC,420,"//===- PPCXCOFFStreamer.h - XCOFF Object Output -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a custom MCXCOFFStreamer for PowerPC.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCXCOFFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp:8,Energy Efficiency,Power,PowerPCTargetInfo,8,"//===-- PowerPCTargetInfo.cpp - PowerPC Target Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp:32,Energy Efficiency,Power,PowerPC,32,"//===-- PowerPCTargetInfo.cpp - PowerPC Target Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h:8,Energy Efficiency,Power,PowerPCTargetInfo,8,"//===-- PowerPCTargetInfo.h - PowerPC Target Implementation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h:30,Energy Efficiency,Power,PowerPC,30,"//===-- PowerPCTargetInfo.h - PowerPC Target Implementation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCV.h:28,Integrability,interface,interface,28,"//===-- RISCV.h - Top-level interface for RISC-V ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // RISC-V back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCV.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCV.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- RISCVAsmPrinter.cpp - RISC-V LLVM assembly writer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the RISC-V assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Integrability,Wrap,Wrapper,3,// Wrapper needed for tblgenned pseudo lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:11,Deployability,patch,patchpoint,11,"// Lower a patchpoint of the form:; // [<def>], <id>, <numBytes>, <target>, <numArgs>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Usability,Simpl,Simple,3,// Simple pseudo-instructions have their lowering (with expansion to real; // instructions) auto-generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:22,Deployability,update,update,22,// Use module flag to update feature bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:41,Security,hash,hashes,41,"// Temporary registers for comparing the hashes. If a register is used; // for the call target, or reserved by the user, we can clobber another; // temporary register as the check is immediately followed by the; // call. The check defaults to X6/X7, but can fall back to X28-X31 if; // needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:53,Performance,load,load,53,"// Checking X0 makes no sense. Instead of emitting a load, zero; // ScratchRegs[0].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:25,Deployability,patch,patchable-function-prefix,25,// Adjust the offset for patchable-function-prefix. This assumes that; // patchable-function-prefix is the same for all functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:74,Deployability,patch,patchable-function-prefix,74,// Adjust the offset for patchable-function-prefix. This assumes that; // patchable-function-prefix is the same for all functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Performance,Load,Load,3,// Load the target function type hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:33,Security,hash,hash,33,// Load the target function type hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Performance,Load,Load,3,// Load the expected 32-bit type hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:33,Security,hash,hash,33,// Load the expected 32-bit type hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:15,Security,hash,hashes,15,// Compare the hashes and trap if there's a mismatch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:3,Performance,load,load,3,"// load shadow tag in X6, X5 contains shadow base",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:43,Performance,load,loaded,43,// Extract tag from X5 and compare it with loaded tag from shadow,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:53,Availability,mask,mask,53,// Unmasked pseudo instructions need to append dummy mask operand to; // V instructions. All V instructions are modeled as the masked version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:127,Availability,mask,masked,127,// Unmasked pseudo instructions need to append dummy mask operand to; // V instructions. All V instructions are modeled as the masked version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:38,Performance,optimiz,optimize,38,"// end anonymous namespace; // Try to optimize (i64 (and (zext/sext (i32 X), C1))) if C1 has bit 31 set,; // but bits 63:32 are zero. If we know that bit 31 of X is 0, we can fill; // the upper 32 bits with ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:98,Modifiability,extend,extending,98,"// Look for constants that fit in 32 bits but not simm12, and can be made; // into simm12 by sign extending bit 31. This will allow use of ANDI.; // TODO: Is worth making simm32?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:8,Modifiability,extend,extend,8,// Sign extend the constant and replace the And operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:681,Energy Efficiency,reduce,reduce,681,"// LLVM vector reduction intrinsics return a scalar result, but on RISC-V vector; // reduction instructions write the result in the first element of a vector; // register. So when a reduction in a loop uses a scalar phi, we end up with; // unnecessary scalar moves:; //; // loop:; // vfmv.s.f v10, fa0; // vfredosum.vs v8, v8, v10; // vfmv.f.s fa0, v8; //; // This mainly affects ordered fadd reductions, since other types of reduction; // typically use element-wise vectorisation in the loop body. This tries to; // vectorize any scalar phis that feed into a fadd reduction:; //; // loop:; // %phi = phi <float> [ ..., %entry ], [ %acc, %loop ]; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %phi, <vscale x 2 x float> %vec); //; // ->; //; // loop:; // %phi = phi <vscale x 2 x float> [ ..., %entry ], [ %acc.vec, %loop ]; // %phi.scalar = extractelement <vscale x 2 x float> %phi, i64 0; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %x, <vscale x 2 x float> %vec); // %acc.vec = insertelement <vscale x 2 x float> poison, float %acc.next, i64 0; //; // Which eliminates the scalar -> vector -> scalar crossing during instruction; // selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:939,Energy Efficiency,reduce,reduce,939,"// LLVM vector reduction intrinsics return a scalar result, but on RISC-V vector; // reduction instructions write the result in the first element of a vector; // register. So when a reduction in a loop uses a scalar phi, we end up with; // unnecessary scalar moves:; //; // loop:; // vfmv.s.f v10, fa0; // vfredosum.vs v8, v8, v10; // vfmv.f.s fa0, v8; //; // This mainly affects ordered fadd reductions, since other types of reduction; // typically use element-wise vectorisation in the loop body. This tries to; // vectorize any scalar phis that feed into a fadd reduction:; //; // loop:; // %phi = phi <float> [ ..., %entry ], [ %acc, %loop ]; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %phi, <vscale x 2 x float> %vec); //; // ->; //; // loop:; // %phi = phi <vscale x 2 x float> [ ..., %entry ], [ %acc.vec, %loop ]; // %phi.scalar = extractelement <vscale x 2 x float> %phi, i64 0; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %x, <vscale x 2 x float> %vec); // %acc.vec = insertelement <vscale x 2 x float> poison, float %acc.next, i64 0; //; // Which eliminates the scalar -> vector -> scalar crossing during instruction; // selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVDeadRegisterDefinitions.cpp:391,Modifiability,rewrite,rewrites,391,"//===- RISCVDeadRegisterDefinitions.cpp - Replace dead defs w/ zero reg --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass rewrites Rd to x0 for instrs whose return values are unused.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVDeadRegisterDefinitions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVDeadRegisterDefinitions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:536,Safety,avoid,avoiding,536,"//===-- RISCVExpandAtomicPseudoInsts.cpp - Expand atomic pseudo instrs. ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands atomic pseudo instructions into; // target instructions. This pass should be run at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LR/SC block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:105,Availability,Mask,MaskedMerge,105,// We select bits from newval and oldval using:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // r = oldval ^ ((oldval ^ newval) & masktargetdata);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:155,Availability,mask,masktargetdata,155,// We select bits from newval and oldval using:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // r = oldval ^ ((oldval ^ newval) & masktargetdata);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:135,Availability,mask,masktargetdata,135,"// .loop:; // lr.w destreg, (alignedaddr); // binop scratch, destreg, incr; // xor scratch, destreg, scratch; // and scratch, scratch, masktargetdata; // xor scratch, destreg, scratch; // sc.w scratch, scratch, (alignedaddr); // bnez scratch, loop",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:77,Availability,mask,mask,77,"//; // .loophead:; // lr.w destreg, (alignedaddr); // and scratch2, destreg, mask; // mv scratch1, destreg; // [sext scratch2 if signed min/max]; // ifnochangeneeded scratch2, incr, .looptail",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:76,Availability,mask,mask,76,"// .loopifbody:; // xor scratch1, destreg, incr; // and scratch1, scratch1, mask; // xor scratch1, destreg, scratch1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:356,Availability,redundant,redundant,356,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:403,Availability,mask,masked,403,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:189,Performance,perform,performs,189,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:356,Safety,redund,redundant,356,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:16,Availability,mask,masked,16,"// If we have a masked cmpxchg, match AND dst, DestReg, MaskReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:56,Availability,Mask,MaskReg,56,"// If we have a masked cmpxchg, match AND dst, DestReg, MaskReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:22,Availability,Mask,MaskReg,22,"// Match BNE DestReg, MaskReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:59,Availability,mask,mask,59,"// .loophead:; // lr.w dest, (addr); // and scratch, dest, mask; // bne scratch, cmpval, done",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:70,Availability,mask,mask,70,"// .looptail:; // xor scratch, dest, newval; // and scratch, scratch, mask; // xor scratch, dest, scratch; // sc.w scratch, scratch, (adrr); // bnez scratch, loophead",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp:555,Energy Efficiency,schedul,scheduling,555,"//===-- RISCVExpandPseudoInsts.cpp - Expand pseudo instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp:49,Performance,load,loading,49,// This function expands PseudoRV32ZdinxLoad for loading a double-precision; // floating-point value from memory into an equivalent instruction sequence for; // RV32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp:88,Performance,load,loading,88,"// If the register of operand 1 is equal to the Lo register, then swap the; // order of loading the Lo and Hi statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:45,Availability,Mask,Mask,45,"//===- RISCVFoldMasks.cpp - MI Vector Pseudo Mask Peepholes ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs various peephole optimisations that fold masks into vector; // pseudo instructions after instruction selection.; //; // Currently it converts; // PseudoVMERGE_VVM %false, %false, %true, %allonesmask, %vl, %sew; // ->; // PseudoVMV_V_V %false, %true, %vl, %sew; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:442,Availability,mask,masks,442,"//===- RISCVFoldMasks.cpp - MI Vector Pseudo Mask Peepholes ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs various peephole optimisations that fold masks into vector; // pseudo instructions after instruction selection.; //; // Currently it converts; // PseudoVMERGE_VVM %false, %false, %true, %allonesmask, %vl, %sew; // ->; // PseudoVMV_V_V %false, %true, %vl, %sew; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:392,Performance,perform,performs,392,"//===- RISCVFoldMasks.cpp - MI Vector Pseudo Mask Peepholes ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs various peephole optimisations that fold masks into vector; // pseudo instructions after instruction selection.; //; // Currently it converts; // PseudoVMERGE_VVM %false, %false, %true, %allonesmask, %vl, %sew; // ->; // PseudoVMV_V_V %false, %true, %vl, %sew; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:3,Availability,Mask,Mask,3,// Mask operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:26,Availability,mask,mask,26,"// vmv.v.v doesn't have a mask operand, so we may be able to inflate the; // register class for the destination and merge operands e.g. VRNoV0 -> VR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:23,Availability,Mask,MaskOpIdxs,23,// TODO: Increment all MaskOpIdxs in tablegen by num of explicit defs?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:3,Availability,Mask,Masked,3,"// Masked pseudos coming out of isel will have their mask operand in the form:; //; // $v0:vr = COPY %mask:vr; // %x:vr = Pseudo_MASK %a:vr, %b:br, $v0:vr; //; // Because $v0 isn't in SSA, keep track of it so we can check the mask operand; // on each pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:53,Availability,mask,mask,53,"// Masked pseudos coming out of isel will have their mask operand in the form:; //; // $v0:vr = COPY %mask:vr; // %x:vr = Pseudo_MASK %a:vr, %b:br, $v0:vr; //; // Because $v0 isn't in SSA, keep track of it so we can check the mask operand; // on each pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:102,Availability,mask,mask,102,"// Masked pseudos coming out of isel will have their mask operand in the form:; //; // $v0:vr = COPY %mask:vr; // %x:vr = Pseudo_MASK %a:vr, %b:br, $v0:vr; //; // Because $v0 isn't in SSA, keep track of it so we can check the mask operand; // on each pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:226,Availability,mask,mask,226,"// Masked pseudos coming out of isel will have their mask operand in the form:; //; // $v0:vr = COPY %mask:vr; // %x:vr = Pseudo_MASK %a:vr, %b:br, $v0:vr; //; // Because $v0 isn't in SSA, keep track of it so we can check the mask operand; // on each pseudo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:91,Safety,risk,risk,91,"// Do not save RA to the SCS if it's not saved to the regular stack,; // i.e. RA is not at risk of being overwritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Performance,Load,Load,3,"// Load return address from shadow call stack; // l[w|d] ra, -[4|8](gp); // addi gp, gp, -[4|8]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:105,Performance,load,load,105,"// Return encoded value and register count for PUSH/POP instruction,; // representing registers to store/load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:215,Modifiability,variab,variable,215,"// Return true if the specified function should have a dedicated frame; // pointer register. This is true if frame pointer elimination is; // disabled, if it needs dynamic stack realignment, if the function has; // variable sized allocas, or if the frame address is taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:181,Security,access,access,181,"// If we do not reserve stack space for outgoing arguments in prologue,; // we will adjust the stack pointer before call instruction. After the; // adjustment, we can not use SP to access the stack objects for the; // arguments. Instead, use BP to access these stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:248,Security,access,access,248,"// If we do not reserve stack space for outgoing arguments in prologue,; // we will adjust the stack pointer before call instruction. After the; // adjustment, we can not use SP to access the stack objects for the; // arguments. Instead, use BP to access these stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Deployability,Update,Update,3,// Update frame info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:238,Modifiability,variab,variable,238,"// When using SP or BP to access stack objects, we may require extra padding; // to ensure the bottom of the RVV stack is correctly aligned within the main; // stack. We calculate this as the amount required to align the scalar local; // variable section up to the RVV alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:26,Security,access,access,26,"// When using SP or BP to access stack objects, we may require extra padding; // to ensure the bottom of the RVV stack is correctly aligned within the main; // stack. We calculate this as the amount required to align the scalar local; // variable section up to the RVV alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize compile time offset case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:71,Deployability,update,updates,71,// We must keep the stack pointer aligned through any intermediate; // updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:48,Performance,Scalab,ScalableOffset,48,// Build up the expression (Reg + FixedOffset + ScalableOffset * VLENB).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:701,Integrability,depend,depending,701,"// If libcalls are used to spill and restore callee-saved registers, the frame; // has two sections; the opaque section managed by the libcalls, and the; // section managed by MachineFrameInfo which can also hold callee saved; // registers in fixed stack slots, both of which have negative frame indices.; // This gets even more complicated when incoming arguments are passed via the; // stack, as these too have negative frame indices. An example is detailed; // below:; //; // | incoming arg | <- FI[-3]; // | libcallspill |; // | calleespill | <- FI[-2]; // | calleespill | <- FI[-1]; // | this_frame | <- FI[0]; //; // For negative frame indices, the offset from the frame pointer will differ; // depending on which of these groups the frame index applies to.; // The following calculates the correct offset knowing the number of callee; // saved registers spilt by the two methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:122,Energy Efficiency,allocate,allocate,122,// FIXME (note copied from Lanai): This appears to be overallocating. Needs; // investigation. Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:37,Energy Efficiency,allocate,allocate,37,// Early exit if there is no need to allocate on the stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:69,Availability,error,error,69,"// If the stack pointer has been marked as reserved, then produce an error if; // the frame requires stack allocation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:30,Energy Efficiency,reduce,reduce,30,// Split the SP adjustment to reduce the offsets of callee saved spill.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:7,Availability,avail,available,7,// Use available stack adjustment in push instruction to allocate additional; // stack space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:57,Energy Efficiency,allocate,allocate,57,// Use available stack adjustment in push instruction to allocate additional; // stack space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space on the stack if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:81,Usability,simpl,simply,81,// Offsets for objects with fixed locations (IE: those saved by libcall) are; // simply calculated from the frame index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:183,Modifiability,variab,variable,183,"// FP will be used to restore the frame in the epilogue, so we need; // another base register BP to record SP after re-alignment. SP will; // track the current stack after allocating variable sized objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:378,Modifiability,variab,variables,378,"// Restore the stack pointer using the value of the frame pointer. Only; // necessary if the stack pointer was modified, meaning the stack size is; // unknown.; //; // In order to make sure the stack point is right through the EH region,; // we also need to restore stack pointer from the frame pointer if we; // don't preserve stack space within prologue/epilogue for outgoing variables,; // normally it's just checking the variable sized object is present or not; // is enough, but we also don't preserve that at prologue/epilogue when; // have vector objects in stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:425,Modifiability,variab,variable,425,"// Restore the stack pointer using the value of the frame pointer. Only; // necessary if the stack pointer was modified, meaning the stack size is; // unknown.; //; // In order to make sure the stack point is right through the EH region,; // we also need to restore stack pointer from the frame pointer if we; // don't preserve stack space within prologue/epilogue for outgoing variables,; // normally it's just checking the variable sized object is present or not; // is enough, but we also don't preserve that at prologue/epilogue when; // have vector objects in stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:7,Availability,avail,available,7,// Use available stack adjustment in pop instruction to deallocate stack; // space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:229,Energy Efficiency,allocate,allocated,229,"// If the stack was realigned, the frame pointer is set in order to allow; // SP to be restored, so we need another base register to record the stack; // after realignment.; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | realignment (the size of | | |; // | this area is not counted | | |; // | in MFI.getStackSize()) | | |; // |--------------------------| -- |-- MFI.getStackSize(); // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize() or in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:1075,Modifiability,variab,variables,1075,"// If the stack was realigned, the frame pointer is set in order to allow; // SP to be restored, so we need another base register to record the stack; // after realignment.; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | realignment (the size of | | |; // | this area is not counted | | |; // | in MFI.getStackSize()) | | |; // |--------------------------| -- |-- MFI.getStackSize(); // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize() or in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:149,Energy Efficiency,allocate,allocated,149,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:344,Modifiability,variab,variables,344,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:27,Performance,scalab,scalable,27,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:20,Security,access,access,20,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:133,Energy Efficiency,allocate,allocated,133,"// When using SP to access frame objects, we need to add RVV stack size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |-- MFI.getStackSize(); // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP; //; // The total amount of padding surrounding RVV objects is described by; // RVV->getRVVPadding() and it can be zero. It allows us to align the RVV; // objects to the required alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:791,Modifiability,variab,variables,791,"// When using SP to access frame objects, we need to add RVV stack size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |-- MFI.getStackSize(); // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP; //; // The total amount of padding surrounding RVV objects is described by; // RVV->getRVVPadding() and it can be zero. It allows us to align the RVV; // objects to the required alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:20,Security,access,access,20,"// When using SP to access frame objects, we need to add RVV stack size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |-- MFI.getStackSize(); // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP; //; // The total amount of padding surrounding RVV objects is described by; // RVV->getRVVPadding() and it can be zero. It allows us to align the RVV; // objects to the required alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:37,Energy Efficiency,allocate,allocate,37,// Create a buffer of RVV objects to allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate all RVV locals and spills,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Deployability,Update,Update,3,// Update the maximum alignment of the RVV stack section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:178,Availability,down,down,178,"// Ensure the alignment of the RVV stack. Since we want the most-aligned; // object right at the bottom (i.e., any padding at the top of the frame),; // readjust all RVV objects down by the alignment padding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:18,Performance,scalab,scalable,18,"// For RVV spill, scalable stack offsets computing requires up to two scratch; // registers",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:22,Performance,scalab,scalable,22,"// For RVV spill, non-scalable stack offsets computing requires up to one; // scratch register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:85,Performance,Scalab,Scalable,85,// ADDI instruction's destination register can be used for computing; // offsets. So Scalable stack offsets require up to one scratch register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:164,Availability,error,errors,164,"// Originally, the function will scan all the stack objects to check whether; // if there is any scalable vector object on the stack or not. However, it; // causes errors in the register allocator. In issue 53016, it returns false; // before RA because there is no RVV stack objects. After RA, it returns true; // because there are spilling slots for RVV values during RA. It will not; // reserve BP during register allocation and generate BP access in the PEI; // pass due to the inconsistent behavior of the function.; //; // The function is changed to use hasVInstructions() as the return value. It; // is not precise, but it can make the register allocation correct.; //; // FIXME: Find a better way to make the decision or revisit the solution in; // D103622.; //; // Refer to https://github.com/llvm/llvm-project/issues/53016.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:97,Performance,scalab,scalable,97,"// Originally, the function will scan all the stack objects to check whether; // if there is any scalable vector object on the stack or not. However, it; // causes errors in the register allocator. In issue 53016, it returns false; // before RA because there is no RVV stack objects. After RA, it returns true; // because there are spilling slots for RVV values during RA. It will not; // reserve BP during register allocation and generate BP access in the PEI; // pass due to the inconsistent behavior of the function.; //; // The function is changed to use hasVInstructions() as the return value. It; // is not precise, but it can make the register allocation correct.; //; // FIXME: Find a better way to make the decision or revisit the solution in; // D103622.; //; // Refer to https://github.com/llvm/llvm-project/issues/53016.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:443,Security,access,access,443,"// Originally, the function will scan all the stack objects to check whether; // if there is any scalable vector object on the stack or not. However, it; // causes errors in the register allocator. In issue 53016, it returns false; // before RA because there is no RVV stack objects. After RA, it returns true; // because there are spilling slots for RVV values during RA. It will not; // reserve BP during register allocation and generate BP access in the PEI; // pass due to the inconsistent behavior of the function.; //; // The function is changed to use hasVInstructions() as the return value. It; // is not precise, but it can make the register allocation correct.; //; // FIXME: Find a better way to make the decision or revisit the solution in; // D103622.; //; // Refer to https://github.com/llvm/llvm-project/issues/53016.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:80,Performance,scalab,scalable-vector,80,// Ensure the entire stack is aligned to at least the RVV requirement: some; // scalable-vector object alignments are not considered by the; // target-independent code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:7,Performance,load,loads,7,// RVV loads & stores have no capacity to hold the immediate address offsets; // so we must always reserve an emergency spill slot if the MachineFunction; // contains any RVV spills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:57,Modifiability,variab,variables,57,// Not preserve stack space within prologue for outgoing variables when the; // function contains variable size objects or there are vector objects accessed; // by the frame pointer.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:98,Modifiability,variab,variable,98,// Not preserve stack space within prologue for outgoing variables when the; // function contains variable size objects or there are vector objects accessed; // by the frame pointer.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:148,Security,access,accessed,148,// Not preserve stack space within prologue for outgoing variables when the; // function contains variable size objects or there are vector objects accessed; // by the frame pointer.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:281,Energy Efficiency,allocate,allocate,281,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:196,Modifiability,variab,variable,196,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:47,Energy Efficiency,reduce,reduce,47,"// We would like to split the SP adjustment to reduce prologue/epilogue; // as following instructions. In this way, the offset of the callee saved; // register could fit in a single store. Supposed that the first sp adjust; // amount is 2032.; // add sp,sp,-2032; // sw ra,2028(sp); // sw s0,2024(sp); // sw s1,2020(sp); // sw s3,2012(sp); // sw s4,2008(sp); // add sp,sp,-64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:213,Performance,load,load,213,"// FirstSPAdjustAmount is chosen at most as (2048 - StackAlign) because; // 2048 will cause sp = sp + 2048 in the epilogue to be split into multiple; // instructions. Offsets smaller than 2048 can fit in a single load/store; // instruction, and we have to stick with the stack alignment. 2048 has; // 16-byte alignment. The stack alignment for RV32 and RV64 is 16 and for; // RV32E it is 4. So (2048 - StackAlign) will satisfy the stack alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:104,Safety,avoid,avoid,104,"// Compared with amount (2048 - StackAlign), StackSize needs to; // satisfy the following conditions to avoid using more instructions; // to adjust the sp after adjusting the amount, such as; // StackSize meets the condition (StackSize <= 2048 + RVCompressLen),; // case1: Amount is 2048 - StackAlign: use addi + addi to adjust sp.; // case2: Amount is RVCompressLen: use addi + addi to adjust sp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:48,Availability,recover,recover,48,"// In the epilogue, addi sp, sp, 496 is used to recover the sp and it; // can be compressed(C.ADDI16SP, offset can be [-512, 496]), but; // addi sp, sp, 512 can not be compressed. So try to use 496 first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:48,Safety,recover,recover,48,"// In the epilogue, addi sp, sp, 496 is used to recover the sp and it; // can be compressed(C.ADDI16SP, offset can be [-512, 496]), but; // addi sp, sp, 512 can not be compressed. So try to use 496 first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:288,Performance,load,load-to-use,288,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:320,Performance,load,loading,320,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:353,Performance,load,loadRegFromStackSlot,353,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:274,Safety,avoid,avoid,274,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:305,Safety,hazard,hazard,305,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:44,Performance,optimiz,optimizing,44,// Keep the conventional code flow when not optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:31,Safety,safe,safe,31,"// Doing a tail call should be safe if there are no successors, because either; // we have a returning block or the end of the block is unreachable, so the; // restore will be eliminated regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.h:63,Energy Efficiency,allocate,allocated,63,// We don't support putting RISC-V Vector objects into the pre-allocated; // local frame block at the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:3,Performance,Cache,Cache,3,"// Cache of the BasePtr and Stride determined from this GEP. When a GEP is; // used by multiple gathers/scatters, this allow us to reuse the scalar; // instructions we created for the first gather/scatter for the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:32,Availability,mask,mask,32,// TODO: Should we consider the mask when looking for a stride?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:107,Deployability,update,update,107,"// Recursively, walk about the use-def chain until we find a Phi with a strided; // start value. Build and update a scalar recurrence as we unwind the recursion.; // We also update the Stride as we unwind. Our goal is to move all of the; // arithmetic out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:174,Deployability,update,update,174,"// Recursively, walk about the use-def chain until we find a Phi with a strided; // start value. Build and update a scalar recurrence as we unwind the recursion.; // We also update the Stride as we unwind. Our goal is to move all of the; // arithmetic out of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:25,Performance,perform,perform,25,// A phi node we want to perform this function on should be from the; // loop header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:49,Performance,load,load,49,// A gather/scatter of a splat is a zero strided load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:37,Usability,simpl,simplify,37,// We need to find a vector index to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:136,Integrability,wrap,wrap,136,"// We can't extract the stride if the arithmetic is done at a different size; // than the pointer type. Adding the stride later may not wrap correctly.; // Technically we could handle wider indices, but I don't expect that in; // practice. Handle one special case here - constants. This simplifies; // writing test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:310,Testability,test,test,310,"// We can't extract the stride if the arithmetic is done at a different size; // than the pointer type. Adding the stride later may not wrap correctly.; // Technically we could handle wider indices, but I don't expect that in; // practice. Handle one special case here - constants. This simplifies; // writing test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:287,Usability,simpl,simplifies,287,"// We can't extract the stride if the arithmetic is done at a different size; // than the pointer type. Adding the stride later may not wrap correctly.; // Technically we could handle wider indices, but I don't expect that in; // practice. Handle one special case here - constants. This simplifies; // writing test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite gather/scatter to form strided load/store if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:42,Performance,load,load,42,// Rewrite gather/scatter to form strided load/store if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:22,Performance,load,load,22,/// Get the EEW for a load or store instruction. Return std::nullopt if MI is; /// not a load or store which ignores SEW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:89,Performance,load,load,89,/// Get the EEW for a load or store instruction. Return std::nullopt if MI is; /// not a load or store which ignores SEW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:43,Availability,mask,mask,43,/// Return true if this is an operation on mask registers. Note that; /// this includes both arithmetic/logical ops and load/store (vlm/vsm).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:120,Performance,load,load,120,/// Return true if this is an operation on mask registers. Note that; /// this includes both arithmetic/logical ops and load/store (vlm/vsm).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:104,Testability,log,logical,104,/// Return true if this is an operation on mask registers. Note that; /// this includes both arithmetic/logical ops and load/store (vlm/vsm).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:37,Availability,mask,mask,37,// A Log2SEW of 0 is an operation on mask registers only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:30,Availability,mask,mask,30,// Behavior is independent of mask policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:3,Performance,Load,Loads,3,"// Loads and stores with implicit EEW do not demand SEW or LMUL directly.; // They instead demand the ratio of the two which is used in computing; // EMUL, but which allows us the flexibility to change SEW and LMUL; // provided we don't change the ratio.; // Note: We assume that the instructions initial SEW is the EEW encoded; // in the opcode. This is asserted when constructing the VSETVLIInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:355,Testability,assert,asserted,355,"// Loads and stores with implicit EEW do not demand SEW or LMUL directly.; // They instead demand the ratio of the two which is used in computing; // EMUL, but which allows us the flexibility to change SEW and LMUL; // provided we don't change the ratio.; // Note: We assume that the instructions initial SEW is the EEW encoded; // in the opcode. This is asserted when constructing the VSETVLIInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:16,Availability,mask,mask,16,"// If this is a mask reg operation, it only cares about VLMAX.; // TODO: Possible extensions to this logic; // * Probably ok if available VLMax is larger than demanded; // * The policy bits can probably be ignored..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:128,Availability,avail,available,128,"// If this is a mask reg operation, it only cares about VLMAX.; // TODO: Possible extensions to this logic; // * Probably ok if available VLMax is larger than demanded; // * The policy bits can probably be ignored..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:101,Testability,log,logic,101,"// If this is a mask reg operation, it only cares about VLMAX.; // TODO: Possible extensions to this logic; // * Probably ok if available VLMax is larger than demanded; // * The policy bits can probably be ignored..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:54,Performance,queue,queue,54,// Keeps track of whether the block is already in the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:37,Availability,mask,mask,37,// A Log2SEW of 0 is an operation on mask registers only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:102,Energy Efficiency,reduce,reduces,102,"// If we know the exact VLEN, see if we can use the constant encoding; // for the VLMAX instead. This reduces register pressure slightly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:172,Modifiability,extend,extending,172,"// If AVL is defined by a vsetvli with the same VLMAX, we can replace the; // AVL operand with the AVL of the defining vsetvli. We avoid general; // register AVLs to avoid extending live ranges without being sure we can; // kill the original source reg entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:131,Safety,avoid,avoid,131,"// If AVL is defined by a vsetvli with the same VLMAX, we can replace the; // AVL operand with the AVL of the defining vsetvli. We avoid general; // register AVLs to avoid extending live ranges without being sure we can; // kill the original source reg entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:166,Safety,avoid,avoid,166,"// If AVL is defined by a vsetvli with the same VLMAX, we can replace the; // AVL operand with the AVL of the defining vsetvli. We avoid general; // register AVLs to avoid extending live ranges without being sure we can; // kill the original source reg entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:38,Integrability,depend,depending,38,// Otherwise use an AVL of 1 to avoid depending on previous vl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:32,Safety,avoid,avoid,32,// Otherwise use an AVL of 1 to avoid depending on previous vl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:124,Availability,mask,masked,124,"// A slidedown/slideup with an *undefined* merge op can freely clobber; // elements not copied from the source vector (e.g. masked off, tail, or; // slideup's prefix). Notes:; // * We can't modify SEW here since the slide amount is in units of SEW.; // * VL=1 is special only because we have existing support for zero vs; // non-zero VL. We could generalize this if we had a VL > C predicate.; // * The LMUL1 restriction is for machines whose latency may depend on VL.; // * As above, this is only legal for tail ""undefined"" not ""agnostic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:455,Integrability,depend,depend,455,"// A slidedown/slideup with an *undefined* merge op can freely clobber; // elements not copied from the source vector (e.g. masked off, tail, or; // slideup's prefix). Notes:; // * We can't modify SEW here since the slide amount is in units of SEW.; // * VL=1 is special only because we have existing support for zero vs; // non-zero VL. We could generalize this if we had a VL > C predicate.; // * The LMUL1 restriction is for machines whose latency may depend on VL.; // * As above, this is only legal for tail ""undefined"" not ""agnostic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:443,Performance,latency,latency,443,"// A slidedown/slideup with an *undefined* merge op can freely clobber; // elements not copied from the source vector (e.g. masked off, tail, or; // slideup's prefix). Notes:; // * We can't modify SEW here since the slide amount is in units of SEW.; // * VL=1 is special only because we have existing support for zero vs; // non-zero VL. We could generalize this if we had a VL > C predicate.; // * The LMUL1 restriction is for machines whose latency may depend on VL.; // * As above, this is only legal for tail ""undefined"" not ""agnostic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:139,Deployability,toggle,toggles,139,"// If we don't use LMUL or the SEW/LMUL ratio, then adjust LMUL so that we; // maintain the SEW/LMUL ratio. This allows us to eliminate VL toggles in more; // places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:359,Modifiability,extend,extending,359,"// If MI only demands that VL has the same zeroness, we only need to set the; // AVL if the zeroness differs. This removes a vsetvli entirely if the types; // match or allows use of cheaper avl preserving variant if VLMAX doesn't; // change. If VLMAX might change, we couldn't use the 'vsetvli x0, x0, vtype""; // variant, so we avoid the transform to prevent extending live range of an; // avl register operand.; // TODO: We can probably relax this for immediates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:328,Safety,avoid,avoid,328,"// If MI only demands that VL has the same zeroness, we only need to set the; // AVL if the zeroness differs. This removes a vsetvli entirely if the types; // match or allows use of cheaper avl preserving variant if VLMAX doesn't; // change. If VLMAX might change, we couldn't use the 'vsetvli x0, x0, vtype""; // variant, so we avoid the transform to prevent extending live range of an; // avl register operand.; // TODO: We can probably relax this for immediates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:15,Availability,mask,mask,15,// Prefer tail/mask agnostic since it can be relaxed to undisturbed later; // if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:34,Availability,fault,fault,34,// Update AVL to vl-output of the fault first load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:3,Deployability,Update,Update,3,// Update AVL to vl-output of the fault first load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:46,Performance,load,load,46,// Update AVL to vl-output of the fault first load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:29,Deployability,update,updates,29,"// If this is something that updates VL/VTYPE that we don't know about, set; // the state to unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:26,Performance,cache,cache,26,"// Note: It's tempting to cache the state changes here, but due to the; // compatibility checks performed a blocks output state can change based on; // the input state. To cache, we'd have to add logic for finding; // never-compatible state changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:96,Performance,perform,performed,96,"// Note: It's tempting to cache the state changes here, but due to the; // compatibility checks performed a blocks output state can change based on; // the input state. To cache, we'd have to add logic for finding; // never-compatible state changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:172,Performance,cache,cache,172,"// Note: It's tempting to cache the state changes here, but due to the; // compatibility checks performed a blocks output state can change based on; // the input state. To cache, we'd have to add logic for finding; // never-compatible state changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:196,Testability,log,logic,196,"// Note: It's tempting to cache the state changes here, but due to the; // compatibility checks performed a blocks output state can change based on; // the input state. To cache, we'd have to add logic for finding; // never-compatible state changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:93,Safety,avoid,avoid,93,// If the exit from the predecessor has the VTYPE we are looking for; // we might be able to avoid a VSETVLI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:47,Deployability,update,update,47,"// If this is an explicit VSETVLI or VSETIVLI, update our state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:4,Performance,Perform,Perform,4,"/// Perform simple partial redundancy elimination of the VSETVLI instructions; /// we're about to insert by looking for cases where we can PRE from the; /// beginning of one block to the end of one of its predecessors. Specifically,; /// this is geared to catch the common case of a fixed length vsetvl in a single; /// block loop when it could execute once in the preheader instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:27,Safety,redund,redundancy,27,"/// Perform simple partial redundancy elimination of the VSETVLI instructions; /// we're about to insert by looking for cases where we can PRE from the; /// beginning of one block to the end of one of its predecessors. Specifically,; /// this is geared to catch the common case of a fixed length vsetvl in a single; /// block loop when it could execute once in the preheader instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:12,Usability,simpl,simple,12,"/// Perform simple partial redundancy elimination of the VSETVLI instructions; /// we're about to insert by looking for cases where we can PRE from the; /// beginning of one block to the end of one of its predecessors. Specifically,; /// this is geared to catch the common case of a fixed length vsetvl in a single; /// block loop when it could execute once in the preheader instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:37,Safety,redund,redundancy,37,"// Unreachable, single pred, or full redundancy. Note that FRE is handled by; // phase 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:101,Availability,avail,available,101,"// If the AVL value is a register (other than our VLMAX sentinel),; // we need to prove the value is available at the point we're going; // to insert the vsetvli at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:72,Availability,Avail,AvailableInfo,72,"// Model the effect of changing the input state of the block MBB to; // AvailableInfo. We're looking for two issues here; one legality,; // one profitability.; // 1) If the block doesn't use some of the fields from VL or VTYPE, we; // may hit the end of the block with a different end state. We can; // not make this change without reflowing later blocks as well.; // 2) If we don't actually remove a transition, inserting a vsetvli; // into the predecessor block would be correct, but unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:12,Deployability,update,update,12,"// Finally, update both data flow state and insert the actual vsetvli.; // Doing both keeps the code in sync with the dataflow results, which; // is critical for correctness of phase 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:103,Modifiability,rewrite,rewrite,103,"// If the VL values aren't equal, return false if either a) the former is; // demanded, or b) we can't rewrite the former to be the later for; // implementation reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:3,Performance,Perform,Perform,3,// Perform partial redundancy elimination of vsetvli transitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:19,Safety,redund,redundancy,19,// Perform partial redundancy elimination of vsetvli transitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:98,Safety,avoid,avoid,98,// Phase 3 - add any vsetvli instructions needed in the block. Use the; // Phase 2 information to avoid adding vsetvlis before the first vector; // instruction in the block if the VL/VTYPE is satisfied by its; // predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:603,Availability,redundant,redundant,603,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:755,Availability,avail,available,755,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:976,Availability,avail,available,976,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:1174,Energy Efficiency,reduce,reduce,1174,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:575,Performance,optimiz,optimize,575,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:597,Safety,avoid,avoid,597,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:603,Safety,redund,redundant,603,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:1074,Safety,redund,redundancy,1074,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:22,Availability,avail,available,22,// Keeps track of the available VXRM value at the start of the basic bloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:22,Availability,avail,available,22,// Keeps track of the available VXRM value at the end of the basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:54,Performance,queue,queue,54,// Keeps track of whether the block is already in the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:30,Availability,avail,available,30,"// If we don't have any valid available info, wait until we do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:44,Availability,avail,available,44,// Insert VXRM write if anticipated and not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:11,Availability,avail,available,11,"// If it's available out of the predecessor, then we're ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:289,Availability,redundant,redundant,289,"// If all our successors anticipate a value, do the insert.; // NOTE: It's possible that not all predecessors of our successor provide the; // correct value. This can occur on critical edges. If we don't split the; // critical edge we'll also have a write vxrm in the succesor that is; // redundant with this one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:289,Safety,redund,redundant,289,"// If all our successors anticipate a value, do the insert.; // NOTE: It's possible that not all predecessors of our successor provide the; // correct value. This can occur on critical edges. If we don't split the; // critical edge we'll also have a write vxrm in the succesor that is; // redundant with this one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:21,Availability,avail,available,21,// Phase 2 - Compute available VXRM using a forward walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:41,Integrability,depend,depend,41,"// If the producing instruction does not depend on vsetvli, do not; // convert COPY to vmv.v.v. For example, VL1R_V or PseudoVRELOAD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:13,Performance,optimiz,optimizations,13,// The below optimizations narrow the load so they are only valid for little; // endian.; // TODO: Support big endian by adding an offset into the frame object?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:38,Performance,load,load,38,// The below optimizations narrow the load so they are only valid for little; // endian.; // TODO: Support big endian by adding an offset into the frame object?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:8,Performance,load,load,8,// Fold load from stack followed by sext.b/sext.h/sext.w/zext.b/zext.h/zext.w.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:15,Deployability,update,update,15,// We may also update the jump target to RestoreBB later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:302,Performance,optimiz,optimization,302,"// For two constants C0 and C1 from; // ```; // li Y, C0; // li Z, C1; // ```; // 1. if C1 = C0 + 1; // we can turn:; // (a) blt Y, X -> bge X, Z; // (b) bge Y, X -> blt X, Z; //; // 2. if C1 = C0 - 1; // we can turn:; // (a) blt X, Y -> bge Z, X; // (b) bge X, Y -> blt Z, X; //; // To make sure this optimization is really beneficial, we only; // optimize for cases where Y had only one use (i.e. only used by the branch).; // Right now we only care about LI (i.e. ADDI x0, imm)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:349,Performance,optimiz,optimize,349,"// For two constants C0 and C1 from; // ```; // li Y, C0; // li Z, C1; // ```; // 1. if C1 = C0 + 1; // we can turn:; // (a) blt Y, X -> bge X, Z; // (b) bge Y, X -> blt X, Z; //; // 2. if C1 = C0 - 1; // we can turn:; // (a) blt X, Y -> bge Z, X; // (b) bge X, Y -> blt Z, X; //; // To make sure this optimization is really beneficial, we only; // optimize for cases where Y had only one use (i.e. only used by the branch).; // Right now we only care about LI (i.e. ADDI x0, imm)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:12,Performance,load,load,12,// Either a load from immediate instruction or X0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:12,Modifiability,extend,extend,12,"// We might extend the live range of Z, clear its kill flag to; // account for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:40,Usability,clear,clear,40,"// We might extend the live range of Z, clear its kill flag to; // account for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:64,Integrability,wrap,wrap,64,"// Might be case 2.; // For unsigned cases, we don't want C1 to wrap back to UINT64_MAX; // when C0 is zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:12,Modifiability,extend,extend,12,"// We might extend the live range of Z, clear its kill flag to; // account for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:40,Usability,clear,clear,40,"// We might extend the live range of Z, clear its kill flag to; // account for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:3,Deployability,Update,Update,3,// Update SeenMIs set: register newly created MI and erase removed DefMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:17,Performance,load,load,17,// c.ntl.all + c.load/c.store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:15,Performance,load,load,15,// c.ntl.all + load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:13,Performance,load,load,13,// ntl.all + load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:19,Deployability,patch,patchpoint,19,// The size of the patchpoint intrinsic is the number of bytes requested,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:81,Energy Efficiency,schedul,scheduling,81,"// The option is unused. Choose Local strategy only for in-order cores. When; // scheduling model is unspecified, use MinInstrCount strategy as more; // generic one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:382,Performance,perform,performing,382,"// From RISC-V ISA spec, if both the high and low bits of the same product; // are required, then the recommended code sequence is:; //; // MULH[[S]U] rdh, rs1, rs2; // MUL rdl, rs1, rs2; // (source register specifiers must be in same order and rdh cannot be the; // same as rs1 or rs2); //; // Microarchitectures can then fuse these into a single multiply operation; // instead of performing two separate multiplies.; // MachineCombiner may reassociate MUL operands and lose the fusion; // opportunity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:73,Integrability,depend,dependency,73,"// Try combining even if fmul has more than one use as it eliminates; // dependency between fadd(fsub) and fmul. However, it can extend liveranges; // for fmul operands, so reject the transformation in register pressure; // reduction mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:129,Modifiability,extend,extend,129,"// Try combining even if fmul has more than one use as it eliminates; // dependency between fadd(fsub) and fmul. However, it can extend liveranges; // for fmul operands, so reject the transformation in register pressure; // reduction mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:47,Modifiability,extend,extending,47,"// We need to clear kill flags since we may be extending the live range past; // a kill. If the mul had kill flags, we can preserve those since we know; // where the previous range stopped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:14,Usability,clear,clear,14,"// We need to clear kill flags since we may be extending the live range past; // a kill. If the mul had kill flags, we can preserve those since we know; // where the previous range stopped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:38,Performance,load,loads,38,"// Conservatively, only handle scalar loads/stores for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:139,Security,access,access,139,"// Only examine the first ""base"" operand of each instruction, on the; // assumption that it represents the real base address of the memory access.; // Other operands are typically offsets or indices from this base address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:12,Performance,cache,cache,12,// Assume a cache line size of 64 bytes if no size is set in RISCVSubtarget.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:70,Performance,cache,cache,70,"// Cluster if the memory operations are on the same or a neighbouring cache; // line, but limit the maximum ClusterSize to avoid creating too much; // additional register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:123,Safety,avoid,avoid,123,"// Cluster if the memory operations are on the same or a neighbouring cache; // line, but limit the maximum ClusterSize to avoid creating too much; // additional register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:78,Security,access,accessed,78,"// Set BaseReg (the base register operand), Offset (the byte offset being; // accessed) and the access Width of the passed instruction that reads/writes; // memory. Returns false if the instruction does not read/write memory or the; // BaseReg/Offset/Width can't be determined. Is not guaranteed to always; // recognise base operands and offsets in all cases.; // TODO: Add an IsScalable bool ref argument (like the equivalent AArch64; // function) and set it as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:96,Security,access,access,96,"// Set BaseReg (the base register operand), Offset (the byte offset being; // accessed) and the access Width of the passed instruction that reads/writes; // memory. Returns false if the instruction does not read/write memory or the; // BaseReg/Offset/Width can't be determined. Is not guaranteed to always; // recognise base operands and offsets in all cases.; // TODO: Add an IsScalable bool ref argument (like the equivalent AArch64; // function) and set it as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:149,Performance,load,load,149,"// Here we assume the standard RISC-V ISA, which uses a base+offset; // addressing mode. You'll need to relax these conditions to support custom; // load/store instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:118,Performance,load,loaded,118,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:218,Security,access,access,218,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:287,Security,access,access,287,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:315,Security,access,accesses,315,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:8,Safety,safe,safe,8,// It's safe to outline from MF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:17,Safety,safe,safety,17,// More accurate safety checking is done in getOutliningCandidateInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:52,Safety,unsafe,unsafe,52,// Make sure the operands don't reference something unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:25,Deployability,toggle,toggle,25,// It only make sense to toggle these between clobbering the; // addend/subtrahend/minuend one of the multiplicands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:163,Deployability,update,update,163,"// Use operand 1 was tied to early-clobber def operand 0, so its live; // interval could have ended at an early-clobber slot. Now they are not; // tied we need to update it to the normal register slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:23,Testability,Log,Logical,23,// 11.5 Vector Bitwise Logical Instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h:35,Safety,safe,safely,35,// Return true if the function can safely be outlined from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h:25,Safety,safe,safe,25,"// Return true if MBB is safe to outline from, and return any target-specific; // information in Flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h:3,Availability,Mask,Mask,3,// Mask assignments for floating-point,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:100,Energy Efficiency,reduce,reduce,100,// Convert integer SPLAT_VECTOR to VMV_V_X_VL and floating-point; // SPLAT_VECTOR to VFMV_V_F_VL to reduce isel burden.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:79,Performance,load,load,79,// Lower SPLAT_VECTOR_SPLIT_I64 to two scalar stores and a stride 0 vector; // load. Done after lowering and combining so that we have a chance to; // optimize this to VMV_V_X_VL when the upper bits aren't needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:151,Performance,optimiz,optimize,151,// Lower SPLAT_VECTOR_SPLIT_I64 to two scalar stores and a stride 0 vector; // load. Done after lowering and combining so that we have a chance to; // optimize this to VMV_V_X_VL when the upper bits aren't needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:88,Availability,mask,masked,88,"// FIXME: This is here only because the VMerge transform doesn't; // know how to handle masked true inputs. Once that has been moved; // to post-ISEL, this can be deleted as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:138,Performance,optimiz,optimization,138,"// After we're done with everything else, convert IMPLICIT_DEF; // passthru operands to NoRegister. This is required to workaround; // an optimization deficiency in MachineCSE. This really should; // be merged back into each of the patterns (i.e. there's no good; // reason not to go directly to NoReg), but is being done this way; // to allow easy backporting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:141,Safety,avoid,avoids,141,"// See if we can create this constant as (ADD (SLLI X, C), X) where X is at; // worst an LUI+ADDIW. This will require an extra register, but avoids a; // constant pool.; // If we have Zba we can use (ADD_UW X, (SLLI X, 32)) to handle cases where; // low and high 32 bits are the same and bit 31 and 63 are set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Availability,Mask,Mask,3,// Mask needs to be copied to V0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:28,Availability,mask,masked,28,"// At the IR layer, all the masked load intrinsics have policy operands,; // none of the others do. All have passthru operands. For our pseudos,; // all loads have policy operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Performance,load,load,35,"// At the IR layer, all the masked load intrinsics have policy operands,; // none of the others do. All have passthru operands. For our pseudos,; // all loads have policy operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:153,Performance,load,loads,153,"// At the IR layer, all the masked load intrinsics have policy operands,; // none of the others do. All have passthru operands. For our pseudos,; // all loads have policy operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:2,Availability,Mask,MaskAgnostic,2,/*MaskAgnostic*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Performance,load,loads,35,// Target does not support indexed loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:87,Modifiability,extend,extending,87,"// If the upper XLen-16 bits are not used, try to convert this to a simm12; // by sign extending bit 15.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:83,Modifiability,extend,extending,83,// If the upper 32-bits are not used try to convert this into a simm32 by; // sign extending bit 32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (shl (and X, C2), C) -> (slli (srliw X, C3), C3+C) where C2 has; // 32 leading zeros and C3 trailing zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (srl (and X, C2), C) -> (slli (srliw X, C3), C3-C) where C2 has; // 32 leading zeros and C3 trailing zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:99,Availability,mask,mask,99,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:227,Safety,avoid,avoids,227,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:200,Usability,Simpl,SimplifyDemandedBits,200,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:10,Availability,mask,mask,10,"// If the mask has 32 trailing ones, use SRLI on RV32 or SRLIW on RV64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (sra (sext_inreg X, i16), C) ->; // (srai (slli X, (XLen-16), (XLen-16) + C); // And (sra (sext_inreg X, i8), C) ->; // (srai (slli X, (XLen-8), (XLen-8) + C); // This can occur when Zbb is enabled, which makes sext_inreg i16/i8 legal.; // This transform matches the code we get without Zbb. The shifts are more; // compressible, and this can help expose CSE opportunities in the sdiv by; // constant optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:413,Performance,optimiz,optimization,413,"// Optimize (sra (sext_inreg X, i16), C) ->; // (srai (slli X, (XLen-16), (XLen-16) + C); // And (sra (sext_inreg X, i8), C) ->; // (srai (slli X, (XLen-8), (XLen-8) + C); // This can occur when Zbb is enabled, which makes sext_inreg i16/i8 legal.; // This transform matches the code we get without Zbb. The shifts are more; // compressible, and this can help expose CSE opportunities in the sdiv by; // constant optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:360,Security,expose,expose,360,"// Optimize (sra (sext_inreg X, i16), C) ->; // (srai (slli X, (XLen-16), (XLen-16) + C); // And (sra (sext_inreg X, i8), C) ->; // (srai (slli X, (XLen-8), (XLen-8) + C); // This can occur when Zbb is enabled, which makes sext_inreg i16/i8 legal.; // This transform matches the code we get without Zbb. The shifts are more; // compressible, and this can help expose CSE opportunities in the sdiv by; // constant optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:208,Testability,test,tests,208,"// Keep track of whether this is a c.andi. If we can't use c.andi, the; // shift pair might offer more compression opportunities.; // TODO: We could check for C extension here, but we don't have many lit; // tests with the C extension enabled so not checking gets better; // coverage.; // TODO: What if ANDI faster than shift?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:32,Availability,mask,mask,32,// Clear irrelevant bits in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Usability,Clear,Clear,3,// Clear irrelevant bits in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:70,Availability,mask,mask,70,"// Turn (and (srl x, c2) c1) -> (srli (slli x, c3-c2), c3) if c1 is a mask; // with c3 leading zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:84,Availability,mask,mask,84,"// (and (srl (sexti32 Y), c2), c1) -> (srliw (sraiw Y, 31), c3 - 32); // if c1 is a mask with c3 leading zeros and c2 >= 32 and c3-c2==1.; //; // This pattern occurs when (i32 (srl (sra 31), c3 - 32)) is type; // legalized and goes through DAG combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:66,Availability,avail,available,66,"// Try to use an unsigned bitfield extract (e.g., th.extu) if; // available.; // Transform (and (srl x, C2), C1); // -> (<bfextract> x, msb, lsb); //; // Make sure to keep this below the SRLIW cases, as we always want to; // prefer the more common instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:68,Availability,mask,mask,68,"// Turn (and (shl x, c2), c1) -> (srli (slli c2+c3), c3) if c1 is a mask; // shifted by c2 bits with c3 leading zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:83,Availability,mask,mask,83,"// Turn (and (shr x, c2), c1) -> (slli (srli x, c2+c3), c3) if c1 is a; // shifted mask with c2 leading zeros and c3 trailing zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:83,Availability,mask,mask,83,"// Turn (and (shl x, c2), c1) -> (slli (srli x, c3-c2), c3) if c1 is a; // shifted mask with no leading zeros and c3 trailing zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:9,Availability,mask,masks,9,"// If C1 masks off the upper bits only (but can't be formed as an; // ANDI), use an unsigned bitfield extract (e.g., th.extu), if; // available.; // Transform (and x, C1); // -> (<bfextract> x, msb, lsb)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:134,Availability,avail,available,134,"// If C1 masks off the upper bits only (but can't be formed as an; // ANDI), use an unsigned bitfield extract (e.g., th.extu), if; // available.; // Transform (and x, C1); // -> (<bfextract> x, msb, lsb)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:310,Safety,avoid,avoid,310,"// Special case for calculating (mul (and X, C2), C1) where the full product; // fits in XLen bits. We can shift X left by the number of leading zeros in; // C2 and shift C1 left by XLen-lzcnt(C2). This will ensure the final; // product has XLen trailing zeros, putting it in the output of MULHU. This; // can avoid materializing a constant in a register for C2.; // RHS should be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:24,Availability,mask,mask,24,// Constant should be a mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:33,Modifiability,extend,extend,33,"// If this RV32, we need to sign extend the constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Availability,Mask,Mask,3,// Mask operations use the LMUL from the mask type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:41,Availability,mask,mask,41,// Mask operations use the LMUL from the mask type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:54,Availability,mask,mask,54,"// If vmsgeu_mask with 0 immediate, expand it to vmor mask, maskedoff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:60,Availability,mask,maskedoff,60,"// If vmsgeu_mask with 0 immediate, expand it to vmor mask, maskedoff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:29,Availability,Mask,MaskedOff,29,// We don't need vmor if the MaskedOff and the Mask are the same; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:47,Availability,Mask,Mask,47,// We don't need vmor if the MaskedOff and the Mask are the same; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:10,Availability,Mask,MaskedOff,10,"// If the MaskedOff value and the Mask are the same value use; // vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt; // This avoids needing to copy v0 to vd before starting the next sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:34,Availability,Mask,Mask,34,"// If the MaskedOff value and the Mask are the same value use; // vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt; // This avoids needing to copy v0 to vd before starting the next sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:119,Safety,avoid,avoids,119,"// If the MaskedOff value and the Mask are the same value use; // vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt; // This avoids needing to copy v0 to vd before starting the next sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Availability,Mask,Mask,3,// Mask needs to be copied to V0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:88,Availability,mask,mask,88,"// Otherwise use; // vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0; // The result is mask undisturbed.; // We use the same instructions to emulate mask agnostic behavior, because; // the agnostic result can be either undisturbed or all 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:150,Availability,mask,mask,150,"// Otherwise use; // vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0; // The result is mask undisturbed.; // We use the same instructions to emulate mask agnostic behavior, because; // the agnostic result can be either undisturbed or all 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:34,Deployability,update,update,34,"// vmxor.mm vd, vd, v0 is used to update active value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:72,Performance,scalab,scalable,72,// Just drop bitcasts between vectors if both are fixed or both are; // scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Performance,scalab,scalable-vector,25,// Establish the correct scalable-vector types for any fixed-length type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:18,Modifiability,variab,variable,18,// Silence unused variable warning without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:43,Testability,assert,asserts,43,// Silence unused variable warning without asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Performance,scalab,scalable-vector,25,// Establish the correct scalable-vector types for any fixed-length type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:34,Performance,load,load,34,// Try to match splat of a scalar load to a strided load with stride of x0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:52,Performance,load,load,52,// Try to match splat of a scalar load to a strided load with stride of x0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:19,Deployability,update,update,19,// Can't fold load update node because the second; // output is used so that load update node can't be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:82,Deployability,update,update,82,// Can't fold load update node because the second; // output is used so that load update node can't be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:14,Performance,load,load,14,// Can't fold load update node because the second; // output is used so that load update node can't be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:77,Performance,load,load,77,// Can't fold load update node because the second; // output is used so that load update node can't be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:36,Deployability,update,update,36,// We could deal with more VL if we update the VSETVLI insert pass to; // avoid introducing more VSETVLI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:74,Safety,avoid,avoid,74,// We could deal with more VL if we update the VSETVLI insert pass to; // avoid introducing more VSETVLI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:47,Performance,load,load,47,"// If VL=1, then we don't need to do a strided load and can just do a; // regular load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:82,Performance,load,load,82,"// If VL=1, then we don't need to do a strided load and can just do a; // regular load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:21,Performance,load,load,21,// Only do a strided load if we have optimized zero-stride vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:37,Performance,optimiz,optimized,37,// Only do a strided load if we have optimized zero-stride vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:66,Performance,load,load,66,// Only do a strided load if we have optimized zero-stride vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:67,Performance,load,loads,67,// Is this ADD instruction only used as the base pointer of scalar loads and; // stores?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:44,Modifiability,variab,variable,44,"// If the Lo in (ADD_LO hi, lo) is a global variable's address; // (its low part, really), then we can rely on the alignment of that; // variable to provide a margin of safety before low part can overflow; // the 12 bits of the load/store offset. Check if CVal falls within; // that margin; if so (low part + CVal) can't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:137,Modifiability,variab,variable,137,"// If the Lo in (ADD_LO hi, lo) is a global variable's address; // (its low part, really), then we can rely on the alignment of that; // variable to provide a margin of safety before low part can overflow; // the 12 bits of the load/store offset. Check if CVal falls within; // that margin; if so (low part + CVal) can't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:228,Performance,load,load,228,"// If the Lo in (ADD_LO hi, lo) is a global variable's address; // (its low part, really), then we can rely on the alignment of that; // variable to provide a margin of safety before low part can overflow; // the 12 bits of the load/store offset. Check if CVal falls within; // that margin; if so (low part + CVal) can't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:169,Safety,safe,safety,169,"// If the Lo in (ADD_LO hi, lo) is a global variable's address; // (its low part, really), then we can rely on the alignment of that; // variable to provide a margin of safety before low part can overflow; // the 12 bits of the load/store offset. Check if CVal falls within; // that margin; if so (low part + CVal) can't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:138,Performance,load,load,138,"// Handle immediates in the range [-4096,-2049] or [2048, 4094]. We can use; // an ADDI for part of the offset and fold the rest into the load/store.; // This mirrors the AddiPair PatFrag in RISCVInstrInfo.td.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:215,Performance,load,loads,215,"// For larger immediates, we might be able to save one instruction from; // constant materialization by folding the Lo12 bits of the immediate into; // the address. We should only do this if the ADD is only used by loads and; // stores that can fold the lo12 bits. Otherwise, the ADD will get iseled; // separately with the full materialized immediate creating extra; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:78,Availability,mask,mask,78,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Energy Efficiency,power,power,35,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:47,Availability,mask,mask,47,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:33,Performance,optimiz,optimized,33,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Usability,Simpl,SimplifyDemandedBits,3,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:80,Safety,avoid,avoid,80,"// If we are shifting by X+N where N == 0 mod Size, then just shift by X; // to avoid the ADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,"// Look for (and (shl y, c2), c1) where c1 is a shifted mask with no; // leading zeros and c3 trailing zeros. We can use an SRLI by c2+c3; // followed by a SHXADD with c3 for the X amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,"// Look for (and (shr y, c2), c1) where c1 is a shifted mask with c2; // leading zeros and c3 trailing zeros. We can use an SRLI by C3; // followed by a SHXADD using c3 for the X amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Availability,Mask,Mask,25,"// Look for (shl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C1+C3==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:42,Availability,Mask,Mask,42,"// Look for (shl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C1+C3==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Availability,Mask,Mask,25,"// Look for (srl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C3-C1==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:42,Availability,Mask,Mask,42,"// Look for (srl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C3-C1==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,"// Look for (and (shl y, c2), c1) where c1 is a shifted mask with; // 32-ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2-ShAmt followed by SHXADD_UW with ShAmt for the X amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:582,Safety,detect,detect,582,"// Return true if all users of this SDNode* only consume the lower \p Bits.; // This can be used to form W instructions for add/sub/mul/shl even when the; // root isn't a sext_inreg. This can allow the ADDW/SUBW/MULW/SLLIW to CSE if; // SimplifyDemandedBits has made it so some users see a sext_inreg and some; // don't. The sext_inreg+add/sub/mul/shl will get selected, but still leave; // the add/sub/mul/shl to become non-W instructions. By checking the users we; // may be able to use a W instruction and CSE with the other instruction if; // this has happened. We could try to detect that the CSE opportunity exists; // before doing this, but that would be more complicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:237,Usability,Simpl,SimplifyDemandedBits,237,"// Return true if all users of this SDNode* only consume the lower \p Bits.; // This can be used to form W instructions for add/sub/mul/shl even when the; // root isn't a sext_inreg. This can allow the ADDW/SUBW/MULW/SLLIW to CSE if; // SimplifyDemandedBits has made it so some users see a sext_inreg and some; // don't. The sext_inreg+add/sub/mul/shl will get selected, but still leave; // the add/sub/mul/shl to become non-W instructions. By checking the users we; // may be able to use a W instruction and CSE with the other instruction if; // this has happened. We could try to detect that the CSE opportunity exists; // before doing this, but that would be more complicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:119,Safety,avoid,avoid,119,// The PatFrags that call this may run before RISCVGenDAGISel.inc has checked; // the VT. Ensure the type is scalar to avoid wasting time on vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:60,Modifiability,extend,extended,60,// The first operand to add.uw/shXadd.uw is implicitly zero extended from; // 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:289,Modifiability,extend,extended,289,"// The semantics of RISCVISD::VMV_V_X_VL is that when the operand; // type is wider than the resulting vector element type: an implicit; // truncation first takes place. Therefore, perform a manual; // truncation/sign-extension in order to ignore any truncated bits and catch; // any zero-extended immediate.; // For example, we wish to match (i8 -1) -> (XLenVT 255) as a simm5 by first; // sign-extending to (XLenVT -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:396,Modifiability,extend,extending,396,"// The semantics of RISCVISD::VMV_V_X_VL is that when the operand; // type is wider than the resulting vector element type: an implicit; // truncation first takes place. Therefore, perform a manual; // truncation/sign-extension in order to ignore any truncated bits and catch; // any zero-extended immediate.; // For example, we wish to match (i8 -1) -> (XLenVT 255) as a simm5 by first; // sign-extending to (XLenVT -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:181,Performance,perform,perform,181,"// The semantics of RISCVISD::VMV_V_X_VL is that when the operand; // type is wider than the resulting vector element type: an implicit; // truncation first takes place. Therefore, perform a manual; // truncation/sign-extension in order to ignore any truncated bits and catch; // any zero-extended immediate.; // For example, we wish to match (i8 -1) -> (XLenVT 255) as a simm5 by first; // sign-extending to (XLenVT -1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:121,Performance,latency,latency,121,// Convert sext.w+add/sub/mul to their W instructions. This will create; // a new independent instruction. This improves latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:26,Modifiability,extend,extended,26,// Result is already sign extended just remove the sext.w.; // NOTE: We only handle the nodes that are selected with hasAllWUsers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:34,Availability,mask,mask,34,// Check that we're using V0 as a mask register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:37,Availability,mask,mask,37,// Check that we're defining V0 as a mask register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:69,Availability,mask,mask,69,"// Sometimes the VMSET is wrapped in a COPY_TO_REGCLASS, e.g. if the mask came; // from an extract_subvector or insert_subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:26,Integrability,wrap,wrapped,26,"// Sometimes the VMSET is wrapped in a COPY_TO_REGCLASS, e.g. if the mask came; // from an extract_subvector or insert_subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Availability,mask,mask,35,// Return true if we can make sure mask of N is all-ones mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:57,Availability,mask,mask,57,// Return true if we can make sure mask of N is all-ones mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:12,Availability,mask,masked,12,"// Optimize masked RVV pseudo instructions with a known all-ones mask to their; // corresponding ""unmasked"" pseudo versions. The mask we're interested in will; // take the form of a V0 physical register operand, with a glued; // register-setting instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:65,Availability,mask,mask,65,"// Optimize masked RVV pseudo instructions with a known all-ones mask to their; // corresponding ""unmasked"" pseudo versions. The mask we're interested in will; // take the form of a V0 physical register operand, with a glued; // register-setting instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:129,Availability,mask,mask,129,"// Optimize masked RVV pseudo instructions with a known all-ones mask to their; // corresponding ""unmasked"" pseudo versions. The mask we're interested in will; // take the form of a V0 physical register operand, with a glued; // register-setting instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize masked RVV pseudo instructions with a known all-ones mask to their; // corresponding ""unmasked"" pseudo versions. The mask we're interested in will; // take the form of a V0 physical register operand, with a glued; // register-setting instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:12,Availability,mask,mask,12,"// Skip the mask, and the Glue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:73,Availability,Mask,Masked,73,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:162,Availability,mask,masked,162,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:257,Availability,Mask,Masked,257,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:333,Availability,mask,masked,333,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:400,Availability,mask,masked,400,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:438,Availability,mask,masked,438,"// Try to fold away VMERGE_VVM instructions. We handle these cases:; // -Masked TU VMERGE_VVM combined with an unmasked TA instruction instruction; // folds to a masked TU instruction. VMERGE_VVM must have have merge operand; // same as false operand.; // -Masked TA VMERGE_VVM combined with an unmasked TA instruction fold to a; // masked TA instruction.; // -Unmasked TU VMERGE_VVM combined with a masked MU TA instruction folds to; // masked TU instruction. Both instructions must have the same merge operand.; // VMERGE_VVM must have have merge operand same as false operand.; // Note: The VMERGE_VVM forms above (TA, and TU) refer to the policy implied,; // not the pseudo name. That is, a TA VMERGE_VVM can be either the _TU pseudo; // form with an IMPLICIT_DEF passthrough operand or the unsuffixed (TA) pseudo; // form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,// A vmv.v.v is equivalent to a vmerge with an all-ones mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:26,Availability,Mask,Mask,26,"// A vmv.v.v won't have a Mask or Glue, instead we'll construct an all-ones; // mask later below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:80,Availability,mask,mask,80,"// A vmv.v.v won't have a Mask or Glue, instead we'll construct an all-ones; // mask later below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:38,Availability,mask,mask,38,// We always have a glue node for the mask at v0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:8,Availability,Mask,Mask,8,"// When Mask is not a true mask, this transformation is illegal for some; // operations whose results are affected by mask, like viota.m.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:27,Availability,mask,mask,27,"// When Mask is not a true mask, this transformation is illegal for some; // operations whose results are affected by mask, like viota.m.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:118,Availability,mask,mask,118,"// When Mask is not a true mask, this transformation is illegal for some; // operations whose results are affected by mask, like viota.m.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:46,Availability,mask,mask,46,// The vmerge instruction must have an all 1s mask since we're going to keep; // the mask from the True instruction.; // FIXME: Support mask agnostic True instruction which would have an; // undef merge operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:85,Availability,mask,mask,85,// The vmerge instruction must have an all 1s mask since we're going to keep; // the mask from the True instruction.; // FIXME: Support mask agnostic True instruction which would have an; // undef merge operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:136,Availability,mask,mask,136,// The vmerge instruction must have an all 1s mask since we're going to keep; // the mask from the True instruction.; // FIXME: Support mask agnostic True instruction which would have an; // undef merge operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Availability,mask,masked,25,// The last operand of a masked instruction may be glued.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:88,Integrability,depend,depend,88,// Avoid creating cycles in the DAG. We must ensure that none of the other; // operands depend on True through it's Chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating cycles in the DAG. We must ensure that none of the other; // operands depend on True through it's Chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:48,Availability,mask,masked,48,// The vector policy operand may be present for masked intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,Availability,mask,mask,35,"// If we end up changing the VL or mask of True, then we need to make sure it; // doesn't raise any observable fp exceptions, since changing the active; // elements will affect how fflags is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,Availability,mask,mask,56,"// From the preconditions we checked above, we know the mask and thus glue; // for the result node will be taken from True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:33,Availability,mask,mask,33,"// If we end up using the vmerge mask the vmerge is actually a vmv.v.v, create; // an all-ones mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:95,Availability,mask,mask,95,"// If we end up using the vmerge mask the vmerge is actually a vmv.v.v, create; // an all-ones mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:126,Availability,mask,masked,126,"// For unmasked ""VOp"" with rounding mode operand, that is interfaces like; // (..., rm, vl) or (..., rm, vl, policy).; // Its masked version is (..., vm, rm, vl, policy).; // Check the rounding mode pseudo nodes under RISCVInstrInfoVPseudos.td",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:58,Integrability,interface,interfaces,58,"// For unmasked ""VOp"" with rounding mode operand, that is interfaces like; // (..., rm, vl) or (..., rm, vl, policy).; // Its masked version is (..., vm, rm, vl, policy).; // Check the rounding mode pseudo nodes under RISCVInstrInfoVPseudos.td",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:37,Availability,mask,mask,37,// Add the glue for the CopyToReg of mask->v0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:283,Performance,perform,performed,283,"/// If our passthru is an implicit_def, use noreg instead. This side; /// steps issues with MachineCSE not being able to CSE expressions with; /// IMPLICIT_DEF operands while preserving the semantic intent. See; /// pr64282 for context. Note that this transform is the last one; /// performed at ISEL DAG to DAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:91,Energy Efficiency,schedul,scheduling,91,"// This pass converts a legalized DAG into a RISCV-specific DAG, ready; // for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.h:45,Modifiability,extend,extended,45,"// Matches the splat of a value which can be extended or truncated, such that; // only the bottom 8 bits are preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:404,Integrability,interface,interfaces,404,"//===-- RISCVISelLowering.cpp - RISC-V DAG Lowering Implementation -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that RISC-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:98,Energy Efficiency,efficient,efficient,98,// We need the custom lowering to make sure that the resulting sequence; // for the 32bit case is efficient on 64bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Availability,Mask,Mask,3,// Mask VTs are custom-expanded into a series of standard nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,Energy Efficiency,power,power-of-two,102,// RVV has native int->float & float->int conversions where the; // element type sizes are within one power-of-two of each other. Any; // wider distances between type sizes have to be lowered as sequences; // which progressively narrow the gap in stages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Modifiability,extend,extending,14,"// Expand all extending loads to types larger than this, and truncating; // stores from types larger than this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Performance,load,loads,24,"// Expand all extending loads to types larger than this, and truncating; // stores from types larger than this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Availability,mask,mask,51,// Custom-lower extensions and truncations from/to mask types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,Energy Efficiency,power,power-of-two,102,// RVV has native int->float & float->int conversions where the; // element type sizes are within one power-of-two of each other. Any; // wider distances between type sizes have to be lowered as sequences; // which progressively narrow the gap in stages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:105,Energy Efficiency,power,power,105,"// Integer VTs are lowered as a series of ""RISCVISD::TRUNCATE_VECTOR_VL""; // nodes which truncate by one power of two at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Usability,simpl,simplify,45,// Custom-lower insert/extract operations to simplify patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:212,Performance,optimiz,optimization,212,"// Expand various CCs to best match the RVV ISA, which natively supports UNE; // but no other unordered comparisons, and supports all ordered comparisons; // except ONE. Additionally, we expand GT,OGT,GE,OGE for optimization; // purposes; they are expanded to their swapped-operand CCs (LT,OLT,LE,OLE),; // and we pattern-match those back to the ""original"", swapping operands once; // more. This way we catch both operations and both ""vf"" and ""fv"" forms with; // fewer patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:99,Energy Efficiency,power,power-of-two,99,// RVV has native FP_ROUND & FP_EXTEND conversions where the element type; // sizes are within one power-of-two of each other. Therefore conversions; // between vXf16 and vXf64 must be lowered as sequences which convert via; // vXf32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Usability,simpl,simplify,45,// Custom-lower insert/extract operations to simplify patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,load,load,3,// load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Performance,scalab,scalable,39,// Custom lower fixed vector undefs to scalable vector undefs to avoid; // expansion to a build_vector of 0s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,Safety,avoid,avoid,65,// Custom lower fixed vector undefs to scalable vector undefs to avoid; // expansion to a build_vector of 0s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Performance,scalab,scalable,45,"// We use EXTRACT_SUBVECTOR as a ""cast"" from scalable to fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:46,Availability,mask,masks,46,// Operations below are different for between masks and other vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Modifiability,extend,extending,16,// There are no extending loads or truncating stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:26,Performance,load,loads,26,// There are no extending loads or truncating stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Performance,scalab,scalable,39,// Custom lower fixed vector undefs to scalable vector undefs to avoid; // expansion to a build_vector of 0s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,Safety,avoid,avoid,65,// Custom lower fixed vector undefs to scalable vector undefs to avoid; // expansion to a build_vector of 0s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Performance,scalab,scalable,45,"// We use EXTRACT_SUBVECTOR as a ""cast"" from scalable to fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Energy Efficiency,power,power,82,// The maximum VF is for the smallest element width with LMUL=8.; // VF must be a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:36,Performance,load,load,36,"// Use return type. If it's segment load, return type is a struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Integrability,depend,depending,22,"// ""r+i"" or just ""i"", depending on HasBaseReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:49,Performance,load,load,49,// Zexts are free if they can be combined with a load.; // Don't advertise i32->i64 zextload as being free for RV64. It interacts; // poorly with type legalization of compares preferring sext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:108,Availability,mask,mask,108,"// We expect to be able to match a bit extraction instruction if the Zbs; // extension is supported and the mask is a power of two. However, we; // conservatively return false if the mask would fit in an ANDI instruction,; // on the basis that it's possible the sinking+duplication of the AND in; // CodeGenPrepare triggered by this hook wouldn't decrease the instruction; // count and would increase code size (e.g. ANDI+BNEZ => BEXTI+BNEZ).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:183,Availability,mask,mask,183,"// We expect to be able to match a bit extraction instruction if the Zbs; // extension is supported and the mask is a power of two. However, we; // conservatively return false if the mask would fit in an ANDI instruction,; // on the basis that it's possible the sinking+duplication of the AND in; // CodeGenPrepare triggered by this hook wouldn't decrease the instruction; // count and would increase code size (e.g. ANDI+BNEZ => BEXTI+BNEZ).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Energy Efficiency,power,power,118,"// We expect to be able to match a bit extraction instruction if the Zbs; // extension is supported and the mask is a power of two. However, we; // conservatively return false if the mask would fit in an ANDI instruction,; // on the basis that it's possible the sinking+duplication of the AND in; // CodeGenPrepare triggered by this hook wouldn't decrease the instruction; // count and would increase code size (e.g. ANDI+BNEZ => BEXTI+BNEZ).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Testability,test,tests,39,// FIXME: Support vectors once we have tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:68,Testability,test,test,68,"// Zbs provides BEXT[_I], which can be used with SEQZ/SNEZ as a bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Testability,test,test,38,// We can use ANDI+SEQZ/SNEZ as a bit test. Y contains the bit position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:190,Availability,down,down,190,"// A constant pool entry may be more aligned thant he load we're trying to; // replace. If we don't support unaligned scalar mem, prefer the constant; // pool.; // TODO: Can the caller pass down the alignment?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Performance,load,load,54,"// A constant pool entry may be more aligned thant he load we're trying to; // replace. If we don't support unaligned scalar mem, prefer the constant; // pool.; // TODO: Can the caller pass down the alignment?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Performance,load,load,22,// Prefer to keep the load if it would require many instructions.; // This uses the same threshold we use for constant pools but doesn't; // check useConstantPoolForLargeInts.; // TODO: Should we keep the load only when we're definitely going to emit a; // constant pool?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:205,Performance,load,load,205,// Prefer to keep the load if it would require many instructions.; // This uses the same threshold we use for constant pools but doesn't; // check useConstantPoolForLargeInts.; // TODO: Should we keep the load only when we're definitely going to emit a; // constant pool?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Usability,undo,undo,118,"// Do form the 'bit extract' pattern.; // If 'X' is a constant, and we transform, then we will immediately; // try to undo the fold, thus causing endless combine loop.; // So only do the transform if X is not a constant. This matches the default; // implementation of this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Safety,avoid,avoid,45,// All uses of the shuffle should be sunk to avoid duplicating it across gpr; // and vector registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:73,Availability,avail,available,73,"// Return one of the followings:; // (1) `{0-31 value, false}` if FLI is available for Imm's type and FP value.; // (2) `{0-31 value, true}` if Imm is negative and FLI is available for its; // positive counterpart, which will be materialized from the first returned; // element. The second returned element indicated that there should be a FNEG; // followed.; // (3) `{-1, _}` if there is no way FLI can be used to materialize Imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:171,Availability,avail,available,171,"// Return one of the followings:; // (1) `{0-31 value, false}` if FLI is available for Imm's type and FP value.; // (2) `{0-31 value, true}` if Imm is negative and FLI is available for its; // positive counterpart, which will be materialized from the first returned; // element. The second returned element indicated that there should be a FNEG; // followed.; // (3) `{-1, _}` if there is no way FLI can be used to materialize Imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:81,Availability,mask,mask,81,// The smallest type we can slide is i8.; // TODO: We can extract index 0 from a mask vector without a slide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Testability,test,test,127,"// TODO: We can do arbitrary slidedowns, but for now only support extracting; // the upper half of a vector until we have more test coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:109,Performance,perform,perform,109,"// If this is a single bit test that can't be handled by ANDI, shift the; // bit to be tested to the MSB and perform a signed compare with 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Testability,test,test,27,"// If this is a single bit test that can't be handled by ANDI, shift the; // bit to be tested to the MSB and perform a signed compare with 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:87,Testability,test,tested,87,"// If this is a single bit test that can't be handled by ANDI, shift the; // bit to be tested to the MSB and perform a signed compare with 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:150,Performance,perform,perform,150,"// Attempt to decompose a subvector insert/extract between VecVT and; // SubVecVT via subregister indices. Returns the subregister index that; // can perform the subvector insert/extract with the given element index, as; // well as the index corresponding to any leftover subvectors that must be; // further inserted/extracted within the register class for SubVecVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,Availability,down,down,96,"// Try to compose a subregister index that takes us from the incoming; // LMUL>1 register class down to the outgoing one. At each step we half; // the LMUL:; // nxv16i32@12 -> nxv2i32: sub_vrm4_1_then_sub_vrm2_1_then_sub_vrm1_0; // Note that this is not guaranteed to find a subregister index, such as; // when we are extracting from one VR type to another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Availability,mask,mask,23,// Permit combining of mask vectors as BUILD_VECTOR never expands to scalar; // stores for those types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Safety,avoid,avoid,127,// We only support a set of vector types with a consistent maximum fixed size; // across all supported vector element types to avoid legalization issues.; // Therefore -- since the largest is v1024i8/v512i16/etc -- the largest; // fixed-length vector type we support is 1024 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Availability,Mask,Masks,3,// Masks can only use a single register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Performance,scalab,scalable,28,// Return the largest legal scalable vector type that matches VT's element type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Availability,mask,mask,27,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,Availability,mask,masking,50,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:157,Performance,scalab,scalable,157,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Usability,simpl,simply,97,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Availability,mask,mask,24,/// Creates an all ones mask suitable for masking a vector of type VecTy with; /// vector length VL. .,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:42,Availability,mask,masking,42,/// Creates an all ones mask suitable for masking a vector of type VecTy with; /// vector length VL. .,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,Availability,mask,mask,50,"// Gets the two common ""VL"" operands: an all-ones mask and the vector length.; // VecVT is a vector type, either fixed-length or scalable, and ContainerVT is; // the vector type that the fixed-length vector is contained in. Otherwise if; // VecVT is scalable, then ContainerVT should be the same as VecVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:129,Performance,scalab,scalable,129,"// Gets the two common ""VL"" operands: an all-ones mask and the vector length.; // VecVT is a vector type, either fixed-length or scalable, and ContainerVT is; // the vector type that the fixed-length vector is contained in. Otherwise if; // VecVT is scalable, then ContainerVT should be the same as VecVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:250,Performance,scalab,scalable,250,"// Gets the two common ""VL"" operands: an all-ones mask and the vector length.; // VecVT is a vector type, either fixed-length or scalable, and ContainerVT is; // the vector type that the fixed-length vector is contained in. Otherwise if; // VecVT is scalable, then ContainerVT should be the same as VecVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:294,Availability,reliab,reliably,294,"// The state of RVV BUILD_VECTOR and VECTOR_SHUFFLE lowering is that very few; // of either is (currently) supported. This can get us into an infinite loop; // where we try to lower a BUILD_VECTOR as a VECTOR_SHUFFLE as a BUILD_VECTOR; // as a ..., etc.; // Until either (or both) of these can reliably lower any node, reporting that; // we don't want to expand BUILD_VECTORs via VECTOR_SHUFFLEs at least breaks; // the infinite loop. Note that this lowers BUILD_VECTOR through the stack,; // which is not desirable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Performance,throughput,throughput,32,"// TODO: Here assume reciprocal throughput is 1 for LMUL_1, it is; // implementation-defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:188,Availability,mask,mask,188,/// Return the cost of a vrgather.vv instruction for the type VT. vrgather.vv; /// is generally quadratic in the number of vreg implied by LMUL. Note that; /// operand (index and possibly mask) are handled separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:209,Integrability,depend,dependent,209,"/// Return the cost of a vrgather.vi (or vx) instruction for the type VT.; /// vrgather.vi/vx may be linear in the number of vregs implied by LMUL,; /// or may track the vrgather.vv cost. It is implementation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:276,Integrability,depend,dependent,276,"/// Return the cost of a vslidedown.vx or vslideup.vx instruction; /// for the type VT. (This does not cover the vslide1up or vslide1down; /// variants.) Slides may be linear in the number of vregs implied by LMUL,; /// or may track the vrgather.vv cost. It is implementation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:276,Integrability,depend,dependent,276,"/// Return the cost of a vslidedown.vi or vslideup.vi instruction; /// for the type VT. (This does not cover the vslide1up or vslide1down; /// variants.) Slides may be linear in the number of vregs implied by LMUL,; /// or may track the vrgather.vv cost. It is implementation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:207,Safety,avoid,avoid,207,"// Expand vector FTRUNC, FCEIL, FFLOOR, FROUND, VP_FCEIL, VP_FFLOOR, VP_FROUND; // VP_FROUNDEVEN, VP_FROUNDTOZERO, VP_FRINT and VP_FNEARBYINT by converting to; // the integer domain and back. Taking care to avoid converting values that are; // nan or already correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:445,Safety,detect,detect,445,"// Try to match an arithmetic-sequence BUILD_VECTOR [X,X+S,X+2*S,...,X+(N-1)*S]; // to the (non-zero) step S and start value X. This can be then lowered as the; // RVV sequence (VID * S) + X, for example.; // The step S is represented as an integer numerator divided by a positive; // denominator. Note that the implementation currently only identifies; // sequences in which either the numerator is +/- 1 or the denominator is 1. It; // cannot detect 2/3, for example.; // Note that this method will also match potentially unappealing index; // sequences, like <i32 0, i32 50939494>, however it is left to the caller to; // determine whether this is worth generating code for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Testability,log,logged,19,// We need to have logged a step for this to count as a legal index sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Security,validat,validate,38,"// Loop back through the sequence and validate elements we might have skipped; // while waiting for a valid step. While doing this, log any sequence addend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:132,Testability,log,log,132,"// Loop back through the sequence and validate elements we might have skipped; // while waiting for a valid step. While doing this, log any sequence addend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Performance,perform,perform,8,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Performance,optimiz,optimization,21,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:88,Performance,perform,perform,88,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Performance,optimiz,optimization,101,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:66,Usability,simpl,simplicity,66,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:12,Performance,optimiz,optimize,12,"/// Try and optimize BUILD_VECTORs with ""dominant values"" - these are values; /// which constitute a large proportion of the elements. In such cases we can; /// splat a vector with the dominant element and make up the shortfall with; /// INSERT_VECTOR_ELTs. Returns SDValue if not profitable.; /// Note that this includes vectors of 2 elements by association. The; /// upper-most element is the ""dominant"" one, allowing us to use a splat to; /// ""insert"" the upper element, and an insert of the lower element at position; /// 0, which improves codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:30,Performance,load,loads,30,"// Track the number of scalar loads we know we'd be inserting, estimated as; // any non-zero floating-point constant. Other kinds of element are either; // already in registers or are materialized on demand. The threshold at which; // a vector load is more desirable than several scalar materializion and; // vector-insertion instructions is not known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:244,Performance,load,load,244,"// Track the number of scalar loads we know we'd be inserting, estimated as; // any non-zero floating-point constant. Other kinds of element are either; // already in registers or are materialized on demand. The threshold at which; // a vector load is more desirable than several scalar materializion and; // vector-insertion instructions is not known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Performance,perform,perform,9,"// Don't perform this optimization when optimizing for size, since; // materializing elements and inserting them tends to cause code bloat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Performance,optimiz,optimization,22,"// Don't perform this optimization when optimizing for size, since; // materializing elements and inserting them tends to cause code bloat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimizing,40,"// Don't perform this optimization when optimizing for size, since; // materializing elements and inserting them tends to cause code bloat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:288,Availability,mask,mask,288,// We can handle an insert into the last element (of a splat) via; // v(f)slide1down. This is slightly better than the vslideup insert; // lowering as it avoids the need for a vector group temporary. It; // is also better than using vmerge.vx as it avoids the need to; // materialize the mask in a vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:154,Safety,avoid,avoids,154,// We can handle an insert into the last element (of a splat) via; // v(f)slide1down. This is slightly better than the vslideup insert; // lowering as it avoids the need for a vector group temporary. It; // is also better than using vmerge.vx as it avoids the need to; // materialize the mask in a vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:249,Safety,avoid,avoids,249,// We can handle an insert into the last element (of a splat) via; // v(f)slide1down. This is slightly better than the vslideup insert; // lowering as it avoids the need for a vector group temporary. It; // is also better than using vmerge.vx as it avoids the need to; // materialize the mask in a vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:69,Availability,mask,mask,69,"// Blend in all instances of this value using a VSELECT, using a; // mask where each bit signals whether that element is the one; // we're after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Availability,mask,mask,18,"// Lower constant mask BUILD_VECTORs via an integer vector type, in; // scalar integer chunks whose bit-width depends on the number of mask; // bits and XLEN.; // First, determine the most appropriate scalar integer type to use. This; // is at most XLenVT, but may be shrunk to a smaller vector element type; // according to the size of the final vector - use i8 chunks rather than; // XLenVT if we're producing a v8i1. This results in more consistent; // codegen across RV32 and RV64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:135,Availability,mask,mask,135,"// Lower constant mask BUILD_VECTORs via an integer vector type, in; // scalar integer chunks whose bit-width depends on the number of mask; // bits and XLEN.; // First, determine the most appropriate scalar integer type to use. This; // is at most XLenVT, but may be shrunk to a smaller vector element type; // according to the size of the final vector - use i8 chunks rather than; // XLenVT if we're producing a v8i1. This results in more consistent; // codegen across RV32 and RV64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:110,Integrability,depend,depends,110,"// Lower constant mask BUILD_VECTORs via an integer vector type, in; // scalar integer chunks whose bit-width depends on the number of mask; // bits and XLEN.; // First, determine the most appropriate scalar integer type to use. This; // is at most XLenVT, but may be shrunk to a smaller vector element type; // according to the size of the final vector - use i8 chunks rather than; // XLenVT if we're producing a v8i1. This results in more consistent; // codegen across RV32 and RV64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:67,Performance,optimiz,optimization,67,// If we have to use more than one INSERT_VECTOR_ELT then this; // optimization is likely to increase code size; avoid peforming it in; // such a case. We can use a load from a constant pool in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:165,Performance,load,load,165,// If we have to use more than one INSERT_VECTOR_ELT then this; // optimization is likely to increase code size; avoid peforming it in; // such a case. We can use a load from a constant pool in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:113,Safety,avoid,avoid,113,// If we have to use more than one INSERT_VECTOR_ELT then this; // optimization is likely to increase code size; avoid peforming it in; // such a case. We can use a load from a constant pool in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,Availability,mask,mask,96,// Now we can create our integer vector type. Note that it may be larger; // than the resulting mask type: v4i1 would use v1i8 as its integer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Usability,clear,clear,118,"// Once we accumulate enough bits to fill our scalar type or process the; // last element, insert into our vector and clear our accumulated data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:120,Availability,mask,mask,120,"// If we're producing a smaller vector than our minimum legal integer; // type, bitcast to the equivalent (known-legal) mask type, and extract; // our final mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:157,Availability,mask,mask,157,"// If we're producing a smaller vector than our minimum legal integer; // type, bitcast to the equivalent (known-legal) mask type, and extract; // our final mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Availability,mask,mask,76,// Else we must have produced an integer type with the same size as the; // mask type; bitcast for the final result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Performance,optimiz,optimize,63,// Exclude INT64_MIN to avoid passing it to std::abs. We won't optimize it; // anyway as the shift of 63 won't fit in uimm5.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Safety,avoid,avoid,24,// Exclude INT64_MIN to avoid passing it to std::abs. We won't optimize it; // anyway as the shift of 63 won't fit in uimm5.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Performance,scalab,scalable,28,"// Convert right out of the scalable type so we can use standard ISD; // nodes for the rest of the computation. If we used scalable types with; // these, we'd lose the fixed-length vector info and generate worse; // vsetvli code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:123,Performance,scalab,scalable,123,"// Convert right out of the scalable type so we can use standard ISD; // nodes for the rest of the computation. If we used scalable types with; // these, we'd lose the fixed-length vector info and generate worse; // vsetvli code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Energy Efficiency,reduce,reduce,23,// TODO: Use vfwcvt to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Deployability,toggle,toggle,101,"// If we can use the original VL with the modified element type, this; // means we only have a VTYPE toggle, not a VL toggle. TODO: Should this; // be moved into InsertVSETVLI?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Deployability,toggle,toggle,118,"// If we can use the original VL with the modified element type, this; // means we only have a VTYPE toggle, not a VL toggle. TODO: Should this; // be moved into InsertVSETVLI?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Modifiability,extend,extend,17,"// On RV64, sign-extend from 32 to 64 bits where possible in order to; // achieve better constant materializion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:307,Performance,optimiz,optimization,307,"// Attempt to detect ""hidden"" splats, which only reveal themselves as splats; // when re-interpreted as a vector with a larger element type. For example,; // v4i16 = build_vector i16 0, i16 1, i16 0, i16 1; // could be instead splat as; // v2i32 = build_vector i32 0x00010000, i32 0x00010000; // TODO: This optimization could also work on non-constant splats, but it; // would require bit-manipulation instructions to construct the splat value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Safety,detect,detect,14,"// Attempt to detect ""hidden"" splats, which only reveal themselves as splats; // when re-interpreted as a vector with a larger element type. For example,; // v4i16 = build_vector i16 0, i16 1, i16 0, i16 1; // could be instead splat as; // v2i32 = build_vector i32 0x00010000, i32 0x00010000; // TODO: This optimization could also work on non-constant splats, but it; // would require bit-manipulation instructions to construct the splat value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Deployability,toggle,toggle,101,"// If we can use the original VL with the modified element type, this; // means we only have a VTYPE toggle, not a VL toggle. TODO: Should this; // be moved into InsertVSETVLI?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,Deployability,toggle,toggle,118,"// If we can use the original VL with the modified element type, this; // means we only have a VTYPE toggle, not a VL toggle. TODO: Should this; // be moved into InsertVSETVLI?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Modifiability,extend,extend,17,"// On RV64, sign-extend from 32 to 64 bits where possible in order to; // achieve better constant materializion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:128,Modifiability,extend,extended,128,"// Since we can't introduce illegal i64 types at this stage, we can only; // perform an i64 splat on RV32 if it is its own sign-extended value. That; // way we can use RVV instructions to splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:77,Performance,perform,perform,77,"// Since we can't introduce illegal i64 types at this stage, we can only; // perform an i64 splat on RV32 if it is its own sign-extended value. That; // way we can use RVV instructions to splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Energy Efficiency,reduce,reduce,101,"// If the number of signbits allows, see if we can lower as a <N x i8>.; // Our main goal here is to reduce LMUL (and thus work) required to; // build the constant, but we will also narrow if the resulting; // narrow vector is known to materialize cheaply.; // TODO: We really should be costing the smaller vector. There are; // profitable cases this misses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:67,Availability,mask,mask,67,"// A BUILD_VECTOR can be lowered as a SETCC. For each fixed-length mask; // vector type, we have a legal equivalently-sized i8 type, so we can use; // that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Performance,perform,perform,16,"// For a splat, perform a scalar truncate before creating the wider; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:125,Performance,scalab,scalable,125,// The following semantically builds up a fixed length concat_vector; // of the component build_vectors. We eagerly lower to scalable and; // insert_subvector here to avoid DAG combining it back to a large; // build_vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:167,Safety,avoid,avoid,167,// The following semantically builds up a fixed length concat_vector; // of the component build_vectors. We eagerly lower to scalable and; // insert_subvector here to avoid DAG combining it back to a large; // build_vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:147,Performance,load,loads,147,"// Cap the cost at a value linear to the number of elements in the vector.; // The default lowering is to use the stack. The vector store + scalar loads; // is linear in VL. However, at high lmuls vslide1down and vslidedown end up; // being (at least) linear in LMUL. As a result, using the vslidedown; // lowering for every element ends up being VL*LMUL..; // TODO: Should we be directly costing the stack alternative? Doing so might; // give us a more accurate upper bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,Integrability,depend,dependency,101,// Start our sequence with a TA splat in the hopes that hardware is able to; // recognize there's no dependency on the prior value of our temporary; // register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:67,Modifiability,extend,extended,67,"// Detect cases where Hi is (SRA Lo, 31) which means Hi is Lo sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Detect,Detect,3,"// Detect cases where Hi is (SRA Lo, 31) which means Hi is Lo sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Modifiability,extend,extended,107,"// If the hi bits of the splat are undefined, then it's fine to just splat Lo; // even if it might be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Performance,load,load,51,// Fall back to a stack store and stride x0 vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:81,Performance,optimiz,optimize,81,// Called by type legalization to handle splat of i64 on RV32.; // FIXME: We can optimize this when the type has sign or zero bits in one; // of the halves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Simpl,Simplest,3,// Simplest case is that the operand needs to be promoted to XLenVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extend,38,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:150,Modifiability,extend,extend,150,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid the tricky legalization cases by falling back to using the; // splat code which already handles it gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extend,38,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:150,Modifiability,extend,extend,150,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Safety,detect,detect,14,"// We need to detect various ways of spelling a rotation:; // [11, 12, 13, 14, 15, 0, 1, 2]; // [-1, 12, 13, 14, -1, -1, 1, -1]; // [-1, -1, -1, -1, -1, -1, 1, 2]; // [ 3, 4, 5, 6, 7, 8, 9, 10]; // [-1, 4, 5, 6, -1, -1, 9, -1]; // [-1, 4, 5, 6, -1, -1, -1, -1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Availability,mask,mask,53,"// The rotations don't match, so we can't match this mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Availability,mask,mask,28,// Compute which value this mask is pointing at.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:43,Availability,mask,mask,43,"// Check that we successfully analyzed the mask, and normalize the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Performance,scalab,scalable,28,// Convert fixed vectors to scalable if needed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Performance,scalab,scalable,76,// EXTRACT_SUBVECTOR can be used to extract a fixed-width vector from; // a scalable vector. But we don't want to match the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Availability,mask,mask,11,// Rebuild mask because Src may be from multiple EXTRACT_SUBVECTORs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Deployability,continuous,continuous,19,// NewMask is also continuous.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,Performance,perform,perform,94,"// Because vslideup leaves the destination elements at the start intact, we can; // use it to perform shuffles that insert subvectors:; //; // vector_shuffle v8:v8i8, v9:v8i8, <0, 1, 2, 3, 8, 9, 10, 11>; // ->; // vsetvli zero, 8, e8, mf2, ta, ma; // vslideup.vi v8, v9, 4; //; // vector_shuffle v8:v8i8, v9:v8i8 <0, 1, 8, 9, 10, 5, 6, 7>; // ->; // vsetvli zero, 5, e8, mf2, tu, ma; // vslideup.v1 v8, v9, 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Availability,down,down,23,/// Match v(f)slide1up/down idioms. These operations involve sliding; /// N-1 elements to make room for an inserted scalar at one end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Availability,mask,mask,22,"// Return true if the mask could describe a slide of Mask.size() - 1; // elements from concat_vector(V1, V2)[Base:] to [Offset:].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Availability,Mask,Mask,53,"// Return true if the mask could describe a slide of Mask.size() - 1; // elements from concat_vector(V1, V2)[Base:] to [Offset:].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,Performance,scalab,scalable,50,// <vscale x n x ty>; // Convert fixed vectors to scalable if needed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Availability,mask,mask,19,"// Given a shuffle mask like <3, 0, 1, 2, 7, 4, 5, 6> for v8i8, we can; // reinterpret it as a v2i32 and rotate it right by 8 instead. We can lower this; // as a vror.vi if we have Zvkb, or otherwise as a vsll, vsrl and vor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,mask,mask,16,// Check if our mask can be done as a 1-to-1 mapping from source; // to destination registers in the group without needing to; // write each destination more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Performance,scalab,scalable,127,// The following semantically builds up a fixed length concat_vector; // of the component shuffle_vectors. We eagerly lower to scalable here; // to avoid DAG combining it back to a large shuffle_vector again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:148,Safety,avoid,avoid,148,// The following semantically builds up a fixed length concat_vector; // of the component shuffle_vectors. We eagerly lower to scalable here; // to avoid DAG combining it back to a large shuffle_vector again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Performance,load,load,24,// Turn splatted vector load into a strided load with an X0 stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:44,Performance,load,load,44,// Turn splatted vector load into a strided load with an X0 stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:25,Performance,load,load,25,// We need to ensure the load isn't atomic or volatile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:44,Performance,load,load,44,"// If this is SEW=64 on RV32, use a strided load with a stride of x0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:26,Performance,load,load,26,// Otherwise use a scalar load and splat. This will give the best; // opportunity to fold a splat into the operation. ISel can turn it into; // the x0 strided load if we aren't able to fold away the select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:159,Performance,load,load,159,// Otherwise use a scalar load and splat. This will give the best; // opportunity to fold a splat into the operation. ISel can turn it into; // the x0 strided load if we aren't able to fold away the select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:83,Availability,avail,available,83,"// A bitrotate will be one instruction on Zvkb, so try to lower to it first if; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Availability,down,down,45,// We found a rotation. We need to slide HiV down by Rotation. Then we need; // to slide LoV up by (NumElts - Rotation).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:72,Deployability,toggle,toggle,72,"// Even though we could use a smaller VL, don't to avoid a vsetivli; // toggle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Safety,avoid,avoid,51,"// Even though we could use a smaller VL, don't to avoid a vsetivli; // toggle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Detect,Detect,3,"// Detect an interleave shuffle and lower to; // (vmaccu.vx (vwaddu.vx lohalf(V1), lohalf(V2)), lohalf(V2), (2^eltbits - 1))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Detect,Detect,3,// Detect shuffles which can be re-expressed as vector selects; these are; // shuffles in which each element in the destination is taken from an element; // at the corresponding index in either source vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:64,Availability,mask,mask,64,"// By default we preserve the original operand order, and use a mask to; // select LHS as true and RHS as false. However, since RVV vector selects may; // feature splats but only on the LHS, we may choose to invert our mask and; // instead select between RHS and LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:219,Availability,mask,mask,219,"// By default we preserve the original operand order, and use a mask to; // select LHS as true and RHS as false. However, since RVV vector selects may; // feature splats but only on the LHS, we may choose to invert our mask and; // instead select between RHS and LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Availability,mask,mask,21,// Now construct the mask that will be used by the vselect operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:189,Performance,throughput,throughput,189,"// We might be able to express the shuffle as a bitrotate. But even if we; // don't have Zvkb and have to expand, the expanded sequence of approx. 2; // shifts and a vor will have a higher throughput than a vrgather.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Availability,mask,mask,21,// Now construct the mask that will be used by the blended vrgather operation.; // Cconstruct the appropriate indices into each vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask allows, we can do all the index computation in 16 bits. This; // requires less work and less register pressure at high LMUL, and creates; // smaller constants which may be cheaper to materialize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Safety,avoid,avoid,14,// Use RTZ to avoid rounding influencing exponent of FloatVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:69,Performance,load,load,69,"// While RVV has alignment restrictions, we should always be able to load as a; // legal equivalently-sized byte-typed vector instead. This method is; // responsible for re-expressing a ISD::LOAD via a correctly-aligned type. If; // the load is already correctly-aligned, it returns SDValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:191,Performance,LOAD,LOAD,191,"// While RVV has alignment restrictions, we should always be able to load as a; // legal equivalently-sized byte-typed vector instead. This method is; // responsible for re-expressing a ISD::LOAD via a correctly-aligned type. If; // the load is already correctly-aligned, it returns SDValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:237,Performance,load,load,237,"// While RVV has alignment restrictions, we should always be able to load as a; // legal equivalently-sized byte-typed vector instead. This method is; // responsible for re-expressing a ISD::LOAD via a correctly-aligned type. If; // the load is already correctly-aligned, it returns SDValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:145,Availability,redundant,redundant,145,"// All simm32 constants should be handled by isel.; // NOTE: The getMaxBuildIntsCost call below should return a value >= 2 making; // this check redundant, but small immediates are common so this check; // should have better compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:145,Safety,redund,redundant,145,"// All simm32 constants should be handled by isel.; // NOTE: The getMaxBuildIntsCost call below should return a value >= 2 making; // this check redundant, but small immediates are common so this check; // should have better compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Optimiz,Optimizations,3,"// Optimizations below are disabled for opt size. If we're optimizing for; // size, use a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:59,Performance,optimiz,optimizing,59,"// Optimizations below are disabled for opt size. If we're optimizing for; // size, use a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Safety,avoid,avoid,97,"// Special case. See if we can build the constant as (ADD (SLLI X, C), X) do; // that if it will avoid a constant pool.; // It will require an extra temporary register though.; // If we have Zba we can use (ADD_UW X, (SLLI X, 32)) to handle cases where; // low and high 32 bits are the same and bit 31 and 63 are set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Integrability,synchroniz,synchronize,28,"// singlethread fences only synchronize with signal handlers on the same; // thread and thus only need to preserve instruction order, not actually; // enforce memory ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Performance,scalab,scalable,51,// Check no NaNs before converting to fixed vector scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Availability,mask,mask,54,/// Return true if a RISC-V target specified op has a mask operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Usability,simpl,simple,53,// We can handle fixed length vector bitcasts with a simple replacement; // in isel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Performance,perform,perform,127,"// When bitcasting from scalar to fixed-length vector, insert the scalar; // into a one-element vector of the result type, and perform a vector; // bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Performance,scalab,scalable,17,// We define our scalable vector types for lmul=1 to use a 64 bit known; // minimum size. e.g. <vscale x 2 x i32>. VLENB is in bytes so we calculate; // vscale as VLENB / 8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:90,Usability,Simpl,SimplifyDemandedBits,90,// We assume VLENB is a multiple of 8. We manually choose the best shift; // here because SimplifyDemandedBits isn't always able to simplify it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:132,Usability,simpl,simplify,132,// We assume VLENB is a multiple of 8. We manually choose the best shift; // here because SimplifyDemandedBits isn't always able to simplify it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,Availability,down,down,50,"// If the multiplier is a multiple of 8, scale it down to avoid needing; // to shift the VLENB value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Safety,avoid,avoid,58,"// If the multiplier is a multiple of 8, scale it down to avoid needing; // to shift the VLENB value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Scalab,Scalable,3,// Scalable vectors can exit here. Patterns will handle equally-sized; // conversions halving/doubling ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:175,Safety,avoid,avoids,175,"// If the RHS is a constant in the range [-2049, 0) or (0, 2046], we can; // convert this to the equivalent of (set(u)ge X, C+1) by using; // (xori (slti(u) X, C+1), 1). This avoids materializing a small constant; // in a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Modifiability,variab,variables,45,"// When HWASAN is used and tagging of global variables is enabled; // they should be accessed via the GOT, since the tagged address of a global; // is incompatible with existing code models. This also applies to non-pic; // mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:85,Security,access,accessed,85,"// When HWASAN is used and tagging of global variables is enabled; // they should be accessed via the GOT, since the tagged address of a global; // is incompatible with existing code models. This also applies to non-pic; // mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the symbol. This generates the; // pattern (PseudoLLA sym), which expands to (addi (auipc %pcrel_hi(sym)); // %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:70,Performance,load,load,70,"// Use PC-relative addressing to access the GOT for this symbol, then load; // the address from the GOT. This generates the pattern (PseudoLGA sym),; // which expands to (ld (addi (auipc %got_pcrel_hi(sym)) %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the GOT for this symbol, then load; // the address from the GOT. This generates the pattern (PseudoLGA sym),; // which expands to (ld (addi (auipc %got_pcrel_hi(sym)) %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Security,access,accessing,27,// Generate a sequence for accessing addresses within the first 2 GiB of; // address space. This generates the pattern (addi (lui %hi(sym)) %lo(sym)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:136,Security,access,access,136,"// An extern weak symbol may be undefined, i.e. have value 0, which may; // not be within 2GiB of PC, so use GOT-indirect addressing to access the; // symbol. This generates the pattern (PseudoLGA sym), which expands to; // (ld (addi (auipc %got_pcrel_hi(sym)) %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Security,access,accessing,27,"// Generate a sequence for accessing addresses within any 2GiB range within; // the address space. This generates the pattern (PseudoLLA sym), which; // expands to (addi (auipc %pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:78,Performance,load,load,78,"// Use PC-relative addressing to access the GOT for this TLS symbol, then; // load the address from the GOT and add the thread pointer. This generates; // the pattern (PseudoLA_TLS_IE sym), which expands to; // (ld (auipc %tls_ie_pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the GOT for this TLS symbol, then; // load the address from the GOT and add the thread pointer. This generates; // the pattern (PseudoLA_TLS_IE sym), which expands to; // (ld (auipc %tls_ie_pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Security,access,accessing,27,"// Generate a sequence for accessing the address relative to the thread; // pointer, with the appropriate adjustment for the thread pointer offset.; // This generates the pattern; // (add (add_tprel (lui %tprel_hi(sym)) tp %tprel_add(sym)) %tprel_lo(sym))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Security,access,access,40,"// Use a PC-relative addressing mode to access the global dynamic GOT address.; // This generates the pattern (PseudoLA_TLS_GD sym), which expands to; // (addi (auipc %tls_gd_pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Security,access,access,40,"// Use a PC-relative addressing mode to access the global dynamic GOT address.; // This generates the pattern (PseudoLA_TLSDESC sym), which expands to; //; // auipc tX, %tlsdesc_hi(symbol) // R_RISCV_TLSDESC_HI20(symbol); // lw tY, tX, %tlsdesc_lo_load(label) // R_RISCV_TLSDESC_LOAD_LO12_I(label); // addi a0, tX, %tlsdesc_lo_add(label) // R_RISCV_TLSDESC_ADD_LO12_I(label); // jalr t0, tY // R_RISCV_TLSDESC_CALL(label)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:110,Performance,Perform,Performing,110,"// When Zicond or XVentanaCondOps is present, emit CZERO_EQZ and CZERO_NEZ; // nodes to implement the SELECT. Performing the lowering here allows for; // greater control over when CZERO_{EQZ/NEZ} are used vs another branchless; // sequence or RISCVISD::SELECT_CC node (branch-based select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Performance,optimiz,optimizations,18,// Try some other optimizations before falling back to generic lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Performance,optimiz,optimization,107,"// (select c, t, f) -> (or (czero_eqz t, c), (czero_nez f, c)); // Unless we have the short forward branch optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:460,Safety,avoid,avoid,460,"// Special case for a select of 2 constants that have a diffence of 1.; // Normally this is done by DAGCombine, but if the select is introduced by; // type legalization or op legalization, we miss it. Restricting to SETLT; // case for now because that is what signed saturating add/sub need.; // FIXME: We don't need the condition to be SETLT or even a SETCC,; // but we would probably want to swap the true/false values if the condition; // is SETGE/SETLE to avoid an XORI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Availability,mask,mask,47,"// Lower splats of i1 types to SETCC. For each mask vector type, we have a; // legal equivalently-sized i8 type, so we can use that as a go-between.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:170,Modifiability,extend,extended,170,"// Custom-lower a SPLAT_VECTOR_PARTS where XLEN<SEW, as the SEW element type is; // illegal (currently only vXi64 RV32).; // FIXME: We could also catch non-constant sign-extended i32 values and lower; // them to VMV_V_X_VL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Availability,mask,mask,32,"// Custom-lower extensions from mask vectors by using a vselect either with 1; // for zero/any-extension or -1 for sign-extension:; // (vXiN = (s|z)ext vXi1:vmask) -> (vXiN = vselect vmask, (-1 or 1), 0); // Note that any-extension is lowered identically to zero-extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:37,Availability,mask,mask,37,// Only custom-lower extensions from mask types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Modifiability,extend,extended,45,"// Grab the canonical container type for the extended type. Infer the smaller; // type from that to ensure the same number of vector elements, as we know; // the LMUL will be sufficient to hold the smaller type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Modifiability,extend,extended,11,// Get the extended container type manually to ensure the same number of; // vector elements between source and dest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:44,Availability,mask,mask,44,"// Custom-lower truncations from vectors to mask vectors by using a mask and a; // setcc operation:; // (vXi1 = trunc vXiN vec) -> (vXi1 = setcc (and vec, 1), 0, ne)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:68,Availability,mask,mask,68,"// Custom-lower truncations from vectors to mask vectors by using a mask and a; // setcc operation:; // (vXi1 = trunc vXiN vec) -> (vXi1 = setcc (and vec, 1), 0, ne)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:46,Availability,mask,mask,46,// Only expect to custom-lower truncations to mask types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable,57,"// If this is a fixed vector, we need to convert it to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,mask,mask,16,// Truncates to mask types are handled differently,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:168,Energy Efficiency,power,power,168,"// RVV only has truncates which operate from SEW*2->SEW, so lower arbitrary; // truncates as a series of ""RISCVISD::TRUNCATE_VECTOR_VL"" nodes which; // truncate by one power of two at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:146,Energy Efficiency,reduce,reduce,146,"// Given a scalable vector type and an index into it, returns the type for the; // smallest subvector that the index fits in. This can be used to reduce LMUL; // for operations like vslidedown.; //; // E.g. With Zvl128b, index 3 in a nxv4i32 fits within the first nxv2i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Performance,scalab,scalable,11,"// Given a scalable vector type and an index into it, returns the type for the; // smallest subvector that the index fits in. This can be used to reduce LMUL; // for operations like vslidedown.; //; // E.g. With Zvl128b, index 3 in a nxv4i32 fits within the first nxv2i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable,57,"// If the operand is a fixed-length vector, convert to a scalable one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:86,Performance,perform,performing,86,"// If we know the index we're going to insert at, we can shrink Vec so that; // we're performing the scalar inserts and slideup on a smaller LMUL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:61,Performance,perform,perform,61,"// If we're compiling for an exact VLEN value, we can always perform; // the insert in m1 as we can determine the register corresponding to; // the index in the register group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Safety,avoid,avoid,82,"// First slide in the lo value, then the hi in above it. We use slide1down; // to avoid the register group overlap constraint of vslide1up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Safety,avoid,avoid,82,"// First slide in the lo value, then the hi in above it. We use slide1down; // to avoid the register group overlap constraint of vslide1up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:66,Availability,down,down,66,"// Custom-lower EXTRACT_VECTOR_ELT operations to slide the vector down, then; // extract the first element: (extractelt (slidedown vec, idx), 0). For integer; // types this is done using VMV_X_S to allow us to glean information about the; // sign bits of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Availability,mask,mask,3,// mask bit index = index % element width,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable,57,"// If this is a fixed vector, we need to convert it to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Performance,perform,perform,100,"// If we're compiling for an exact VLEN value and we have a known; // constant index, we can always perform the extract in m1 (or; // smaller) as we can determine the register corresponding to; // the index in the register group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the LMUL of our slidedown and vmv.x.s to the smallest LMUL which; // contains our index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:309,Performance,perform,performing,309,"// If after narrowing, the required slide is still greater than LMUL2,; // fallback to generic expansion and go through the stack. This is done; // for a subtle reason: extracting *all* elements out of a vector is; // widely expected to be linear in vector size, but because vslidedown; // is linear in LMUL, performing N extracts using vslidedown becomes; // O(n^2) / (VLEN/ETYPE) work. On the surface, going through the stack; // seems to have the same problem (the store is linear in LMUL), but the; // generic expansion *memoizes* the store, and thus for many extracts of; // the same vector we end up with one store and a bunch of loads.; // TODO: We don't have the same code for insert_vector_elt because we; // have BUILD_VECTOR and handle the degenerate case there. Should we; // consider adding an inverse BUILD_VECTOR node?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:636,Performance,load,loads,636,"// If after narrowing, the required slide is still greater than LMUL2,; // fallback to generic expansion and go through the stack. This is done; // for a subtle reason: extracting *all* elements out of a vector is; // widely expected to be linear in vector size, but because vslidedown; // is linear in LMUL, performing N extracts using vslidedown becomes; // O(n^2) / (VLEN/ETYPE) work. On the surface, going through the stack; // seems to have the same problem (the store is linear in LMUL), but the; // generic expansion *memoizes* the store, and thus for many extracts of; // the same vector we end up with one store and a bunch of loads.; // TODO: We don't have the same code for insert_vector_elt because we; // have BUILD_VECTOR and handle the degenerate case there. Should we; // consider adding an inverse BUILD_VECTOR node?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:20,Safety,avoid,avoid,20,// Use a VL of 1 to avoid processing more elements than we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Simpl,Simplest,3,// Simplest case is that the operand needs to be promoted to XLenVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extend,38,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:150,Modifiability,extend,extend,150,"// If the operand is a constant, sign extend to increase our chances; // of being able to use a .vi instruction. ANY_EXTEND would become a; // a zero extend and the simm5 check in isel would fail.; // FIXME: Should we ignore the upper bits in isel instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:71,Availability,mask,mask,71,"// Use the previous operand to get the vXi64 VT. The result might be a mask; // VT for compares. Using the previous operand assumes that the previous; // operand will never have a smaller element size than a scalar operand and; // that a widening operation never uses SEW=64.; // NOTE: If this fails the below assert, we can probably just find the; // element count from any operand or result and use it to construct the VT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:310,Testability,assert,assert,310,"// Use the previous operand to get the vXi64 VT. The result might be a mask; // VT for compares. Using the previous operand assumes that the previous; // operand will never have a smaller element size than a scalar operand and; // that a widening operation never uses SEW=64.; // NOTE: If this fails the below assert, we can probably just find the; // element count from any operand or result and use it to construct the VT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Modifiability,extend,extended,21,"// If this is a sign-extended 32-bit value, we can truncate it and rely on the; // instruction to sign-extend since SEW>XLEN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:103,Modifiability,extend,extend,103,"// If this is a sign-extended 32-bit value, we can truncate it and rely on the; // instruction to sign-extend since SEW>XLEN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize for constant AVL,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Availability,mask,mask,9,// Apply mask after the operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Availability,mask,maskedoff,27,// We don't need to select maskedoff if it's undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:117,Availability,mask,mask,117,// TUMA or TUMU: Currently we always emit tumu policy regardless of tuma.; // It's fine because vmerge does not care mask policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:78,Performance,scalab,scalable,78,// Lower the llvm.get.vector.length intrinsic to vsetvli. We only support; // scalable vector llvm.get.vector.length for now.; //; // We need to convert from a scalable VF to a vsetvli with VLMax equal to; // (vscale * VF). The vscale and VF are independent of element width. We use; // SEW=8 for the vsetvli because it is the only element width that supports all; // fractional LMULs. The LMUL is choosen so that with SEW=8 the VLMax is; // (vscale * VF). Where vscale is defined as VLEN/RVVBitsPerBlock. The; // InsertVSETVLI pass can fix up the vtype of the vsetvli if a different; // SEW and LMUL are better for the surrounding vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:160,Performance,scalab,scalable,160,// Lower the llvm.get.vector.length intrinsic to vsetvli. We only support; // scalable vector llvm.get.vector.length for now.; //; // We need to convert from a scalable VF to a vsetvli with VLMax equal to; // (vscale * VF). The vscale and VF are independent of element width. We use; // SEW=8 for the vsetvli because it is the only element width that supports all; // fractional LMULs. The LMUL is choosen so that with SEW=8 the VLMax is; // (vscale * VF). Where vscale is defined as VLEN/RVVBitsPerBlock. The; // InsertVSETVLI pass can fix up the vtype of the vsetvli if a different; // SEW and LMUL are better for the surrounding vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:249,Availability,mask,mask,249,"// This is an i64 value that lives in two scalar registers. We have to; // insert this in a convoluted way. First we build vXi64 splat containing; // the two values that we assemble using some bit math. Next we'll use; // vid.v and vmseq to build a mask with bit 0 set. Then we'll use that mask; // to merge element 0 from our splat into the source vector.; // FIXME: This is probably not the best way to do this, but it is; // consistent with INSERT_VECTOR_ELT lowering so it is a good starting; // point.; // sw lo, (a0); // sw hi, 4(a0); // vlse vX, (a0); //; // vid.v vVid; // vmseq.vx mMask, vVid, 0; // vmerge.vvm vDest, vSrc, vVal, mMask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:290,Availability,mask,mask,290,"// This is an i64 value that lives in two scalar registers. We have to; // insert this in a convoluted way. First we build vXi64 splat containing; // the two values that we assemble using some bit math. Next we'll use; // vid.v and vmseq to build a mask with bit 0 set. Then we'll use that mask; // to merge element 0 from our splat into the source vector.; // FIXME: This is probably not the best way to do this, but it is; // consistent with INSERT_VECTOR_ELT lowering so it is a good starting; // point.; // sw lo, (a0); // sw hi, 4(a0); // vlse vX, (a0); //; // vid.v vVid; // vmseq.vx mMask, vVid, 0; // vmerge.vvm vDest, vSrc, vVal, mMask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Availability,mask,masked,100,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimize,40,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:116,Availability,mask,masks,116,// TODO: We restrict this to unmasked loads currently in consideration of; // the complexity of hanlding all falses masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Performance,load,loads,38,// TODO: We restrict this to unmasked loads currently in consideration of; // the complexity of hanlding all falses masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Availability,mask,masked,100,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimize,40,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:367,Usability,simpl,simply,367,"// Now include the start value in the operation.; // Note that we must return the start value when no elements are operated; // upon. The vcpop instructions we've emitted in each case above will return; // 0 for an inactive vector, and so we've already received the neutral value:; // AND gives us (0 == 0) -> 1 and OR/XOR give us (0 != 0) -> 0. Therefore we; // can simply include the start value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Deployability,toggle,toggles,54,"// We reuse the VL of the reduction to reduce vsetvli toggles if we can; // prove it is non-zero. For the AVL=0 case, we need the scalar to; // be the result of the reduction operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Energy Efficiency,reduce,reduce,39,"// We reuse the VL of the reduction to reduce vsetvli toggles if we can; // prove it is non-zero. For the AVL=0 case, we need the scalar to; // be the result of the reduction operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:122,Availability,down,down,122,// Due to ordering in legalize types we may have a vector type that needs to; // be split. Do that manually so we can get down to a legal type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Availability,mask,mask,38,"// We don't have the ability to slide mask vectors up indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when inserting a fixed-length vector; // into a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: nxv1i1 = insert nxv1i1, v4i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:235,Performance,scalab,scalable,235,"// We don't have the ability to slide mask vectors up indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when inserting a fixed-length vector; // into a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: nxv1i1 = insert nxv1i1, v4i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:286,Performance,scalab,scalable,286,"// We don't have the ability to slide mask vectors up indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when inserting a fixed-length vector; // into a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: nxv1i1 = insert nxv1i1, v4i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:311,Safety,safe,safely,311,"// We don't have the ability to slide mask vectors up indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when inserting a fixed-length vector; // into a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: nxv1i1 = insert nxv1i1, v4i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Availability,mask,mask,23,"// We can't slide this mask vector up indexed by its i1 elements.; // This poses a problem when we wish to insert a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:260,Availability,down,down,260,"// We can't slide this mask vector up indexed by its i1 elements.; // This poses a problem when we wish to insert a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:216,Modifiability,extend,extend,216,"// We can't slide this mask vector up indexed by its i1 elements.; // This poses a problem when we wish to insert a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:116,Performance,scalab,scalable,116,"// We can't slide this mask vector up indexed by its i1 elements.; // This poses a problem when we wish to insert a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Usability,simpl,simplify,97,"// If the subvector vector is a fixed-length type, we cannot use subregister; // manipulation to simplify the codegen; we don't know which register of a; // LMUL group contains the specific subvector as we only know the minimum; // register size. Therefore we must slide the vector group up the full; // amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:579,Performance,perform,performing,579,"// 1. If the Idx has been completely eliminated and this subvector's size is; // a vector register or a multiple thereof, or the surrounding elements are; // undef, then this is a subvector insert which naturally aligns to a vector; // register. These can easily be handled using subregister manipulation.; // 2. If the subvector is smaller than a vector register, then the insertion; // must preserve the undisturbed elements of the register. We do this by; // lowering to an EXTRACT_SUBVECTOR grabbing the nearest LMUL=1 vector type; // (which resolves to a subregister copy), performing a VSLIDEUP to place the; // subvector within the vector register, and an INSERT_SUBVECTOR of that; // LMUL=1 type back into the larger vector (resolving to another subregister; // operation). See below for how our VSLIDEUP works. We go via a LMUL=1 type; // to avoid allocating a large register group to hold our subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:851,Safety,avoid,avoid,851,"// 1. If the Idx has been completely eliminated and this subvector's size is; // a vector register or a multiple thereof, or the surrounding elements are; // undef, then this is a subvector insert which naturally aligns to a vector; // register. These can easily be handled using subregister manipulation.; // 2. If the subvector is smaller than a vector register, then the insertion; // must preserve the undisturbed elements of the register. We do this by; // lowering to an EXTRACT_SUBVECTOR grabbing the nearest LMUL=1 vector type; // (which resolves to a subregister copy), performing a VSLIDEUP to place the; // subvector within the vector register, and an INSERT_SUBVECTOR of that; // LMUL=1 type back into the larger vector (resolving to another subregister; // operation). See below for how our VSLIDEUP works. We go via a LMUL=1 type; // to avoid allocating a large register group to hold our subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Availability,mask,mask,32,// We might have bitcast from a mask type: cast back to the original type if; // required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Availability,mask,mask,38,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Availability,down,down,51,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:238,Performance,scalab,scalable,238,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:289,Performance,scalab,scalable,289,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:314,Safety,safe,safely,314,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Availability,mask,mask,23,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Availability,down,down,35,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:264,Availability,down,down,264,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:220,Modifiability,extend,extend,220,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:120,Performance,scalab,scalable,120,"// We can't slide this mask vector down, indexed by its i1 elements.; // This poses a problem when we wish to extract a scalable vector which; // can't be re-expressed as a larger type. Just choose the slow path and; // extend to a larger type, then truncate back down.; // TODO: We could probably improve this when extracting certain fixed; // from fixed, where we can extract as i8 and shift the correct element; // right to reach the desired subvector?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:66,Performance,perform,performed,66,"// With an index of 0 this is a cast-like subvector, which can be performed; // with subregister operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:288,Availability,down,down,288,"// If the subvector vector is a fixed-length type, we cannot use subregister; // manipulation to simplify the codegen; we don't know which register of a; // LMUL group contains the specific subvector as we only know the minimum; // register size. Therefore we must slide the vector group down the full; // amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Usability,simpl,simplify,97,"// If the subvector vector is a fixed-length type, we cannot use subregister; // manipulation to simplify the codegen; we don't know which register of a; // LMUL group contains the specific subvector as we only know the minimum; // register size. Therefore we must slide the vector group down the full; // amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,down,down,10,// Shrink down Vec so we're performing the slidedown on a smaller LMUL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,Performance,perform,performing,28,// Shrink down Vec so we're performing the slidedown on a smaller LMUL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:95,Availability,down,down,95,// Set the vector length to only the number of elements we care about. This; // avoids sliding down elements we're going to discard straight away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:80,Safety,avoid,avoids,80,// Set the vector length to only the number of elements we care about. This; // avoids sliding down elements we're going to discard straight away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:62,Availability,down,down,62,// Else SubVecVT is a fractional LMUL and may need to be slid down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:30,Availability,down,down,30,// Slide this vector register down by the desired number of elements in order; // to place the desired subvector starting at element 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Availability,mask,mask,32,// We might have bitcast from a mask type: cast back to the original type if; // required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Availability,mask,mask,47,"// We want to operate on all lanes, so get the mask and VL and mask for it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Availability,mask,mask,63,"// We want to operate on all lanes, so get the mask and VL and mask for it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Safety,avoid,avoid,40,"// For the indices, use the same SEW to avoid an extra vsetvli",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Performance,perform,perform,8,// Then perform the interleave; // v[0] v[n] v[1] v[n+1] v[2] v[n+2] v[3] v[n+3] ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:114,Performance,load,load,114,"// If we know the exact VLEN and our fixed length vector completely fills; // the container, use a whole register load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:64,Availability,mask,mask,64,// VMFLT/VMFLE/VMFGT/VMFGE raise exception for qNan. Generate a mask to only; // active when both input elements are ordered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:7,Availability,Mask,Mask,7,// Use Mask as the merge operand to let the result be 0 if either of the; // inputs is unordered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Performance,scalab,scalable,58,// Create list of operands by converting existing ones to scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Performance,scalab,scalable,35,"// ""cast"" fixed length vector to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:241,Performance,scalab,scalable-vector,241,// Lower a VP_* ISD node to the corresponding RISCVISD::*_VL node:; // * Operands of each node are assumed to be in the same order.; // * The EVL operand is promoted from i32 to i64 on RV64.; // * Fixed-length vectors are converted to their scalable-vector container; // types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:36,Availability,mask,mask,36,"// Add dummy merge value before the mask. Or if there isn't a mask, before; // EVL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:62,Availability,mask,mask,62,"// Add dummy merge value before the mask. Or if there isn't a mask, before; // EVL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Performance,scalab,scalable,35,"// ""cast"" fixed length vector to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Availability,Mask,Mask,9,// NOTE: Mask is dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Availability,Mask,Mask,9,// NOTE: Mask is dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:59,Availability,mask,mask,59,"// First convert to the same size integer, then convert to mask using; // setcc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Availability,mask,mask,29,// Truncate Result back to a mask vector (Result has same EVL as Op2),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Availability,mask,mask,32,// Check if we are working with mask vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:106,Availability,mask,masks,106,"// Reassemble the low and high pieces reversed.; // NOTE: this Result is unmasked (because we do not need masks for; // shuffles). If in the future this has to change, we can use a SELECT_VL; // between Result and UNDEF using the mask originally passed to VP_REVERSE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:230,Availability,mask,mask,230,"// Reassemble the low and high pieces reversed.; // NOTE: this Result is unmasked (because we do not need masks for; // shuffles). If in the future this has to change, we can use a SELECT_VL; // between Result and UNDEF using the mask originally passed to VP_REVERSE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Availability,mask,mask,29,// Truncate Result back to a mask vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Availability,mask,mask,29,// Truncate Result back to a mask vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Availability,mask,mask,22,// It is safe to drop mask parameter as masked-off elements are undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Availability,mask,masked-off,40,// It is safe to drop mask parameter as masked-off elements are undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Safety,safe,safe,9,// It is safe to drop mask parameter as masked-off elements are undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,mask,mask,16,// Check if the mask is known to be all ones,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,mask,mask,16,// Check if the mask is known to be all ones,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:238,Modifiability,extend,extended,238,"// Custom lower MGATHER/VP_GATHER to a legalized form for RVV. It will then be; // matched to a RVV indexed load. The RVV indexed load instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:338,Modifiability,extend,extended,338,"// Custom lower MGATHER/VP_GATHER to a legalized form for RVV. It will then be; // matched to a RVV indexed load. The RVV indexed load instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:108,Performance,load,load,108,"// Custom lower MGATHER/VP_GATHER to a legalized form for RVV. It will then be; // matched to a RVV indexed load. The RVV indexed load instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:130,Performance,load,load,130,"// Custom lower MGATHER/VP_GATHER to a legalized form for RVV. It will then be; // matched to a RVV indexed load. The RVV indexed load instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Modifiability,extend,extending,22,// VP doesn't support extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,Performance,load,loads,32,// VP doesn't support extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:41,Modifiability,extend,extending,41,// Targets have to explicitly opt-in for extending vector loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Performance,load,loads,58,// Targets have to explicitly opt-in for extending vector loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Availability,mask,masked,100,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimize,40,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:242,Modifiability,extend,extended,242,"// Custom lower MSCATTER/VP_SCATTER to a legalized form for RVV. It will then be; // matched to a RVV indexed store. The RVV indexed store instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:342,Modifiability,extend,extended,342,"// Custom lower MSCATTER/VP_SCATTER to a legalized form for RVV. It will then be; // matched to a RVV indexed store. The RVV indexed store instructions only; // support the ""unsigned unscaled"" addressing mode; indices are implicitly; // zero-extended or truncated to XLEN and are treated as byte offsets. Any; // signed or scaled indexing is extended to the XLEN value type and scaled; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:41,Modifiability,extend,extending,41,// Targets have to explicitly opt-in for extending vector loads and; // truncating vector stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Performance,load,loads,58,// Targets have to explicitly opt-in for extending vector loads and; // truncating vector stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Availability,mask,masked,100,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,Performance,optimiz,optimize,40,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,Energy Efficiency,reduce,reduce,96,// Converts the given 32-bit operation to a i64 operation with signed extension; // semantic to reduce the signed extension instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:138,Modifiability,extend,extend,138,"// If the input is i32, use ANY_EXTEND since the W instructions don't read; // the upper 32 bits. For other types we need to sign or zero extend; // based on the opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:36,Usability,simpl,simplify,36,"// If the RHS is a constant, we can simplify ConditionRHS below. Otherwise; // use the default legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:147,Energy Efficiency,reduce,reduce,147,"// Special case uaddo X, 1 overflowed if the addition result is 0.; // The general case (X + C) < C is not necessarily beneficial. Although we; // reduce the live range of X, we may introduce the materialization of; // constant C, especially when the setcc result is used by branch. We have; // no compare with constant and branch instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Modifiability,extend,extend,8,"// Sign extend the LHS and perform an unsigned compare with the ADDW; // result. Since the inputs are sign extended from i32, this is equivalent; // to comparing the lower 32 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Modifiability,extend,extended,107,"// Sign extend the LHS and perform an unsigned compare with the ADDW; // result. Since the inputs are sign extended from i32, this is equivalent; // to comparing the lower 32 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Performance,perform,perform,27,"// Sign extend the LHS and perform an unsigned compare with the ADDW; // result. Since the inputs are sign extended from i32, this is equivalent; // to comparing the lower 32 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Modifiability,extend,extend,24,// With Zbb we can sign extend and let LegalizeDAG use minu/maxu. Using; // sign extend allows overflow of the lower 32 bits to be detected on; // the promoted size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:81,Modifiability,extend,extend,81,// With Zbb we can sign extend and let LegalizeDAG use minu/maxu. Using; // sign extend allows overflow of the lower 32 bits to be detected on; // the promoted size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:131,Safety,detect,detected,131,// With Zbb we can sign extend and let LegalizeDAG use minu/maxu. Using; // sign extend allows overflow of the lower 32 bits to be detected on; // the promoted size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:126,Modifiability,extend,extended,126,// Emit a special ABSW node that will be expanded to NEGW+MAX at isel.; // This allows us to remember that the result is sign extended. Expanding; // to NEGW+MAX here requires a Freeze which breaks ComputeNumSignBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:342,Availability,down,down,342,"// Custom-legalize an EXTRACT_VECTOR_ELT where XLEN<SEW, as the SEW element; // type is illegal (currently only vXi64 RV32).; // With vmv.x.s, when SEW > XLEN, only the least-significant XLEN bits are; // transferred to the destination register. We issue two of these from the; // upper- and lower- halves of the SEW-bit vector element, slid down to the; // first element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable,57,"// If this is a fixed vector, we need to convert it to a scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:20,Safety,avoid,avoid,20,// Use a VL of 1 to avoid processing more elements than we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Availability,down,down,63,"// Unless the index is known to be 0, we must slide the vector down to get; // the desired element into index 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:266,Availability,mask,mask,266,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:344,Availability,mask,mask,344,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:467,Availability,mask,mask,467,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Modifiability,Extend,Extend,3,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:416,Modifiability,extend,extended,416,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:453,Modifiability,extend,extended,453,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:148,Performance,Perform,Perform,148,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Simpl,Simple,3,// Simple case just extract using vmv.x.s and truncate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:179,Availability,recover,recover,179,"/// Perform two related transforms whose purpose is to incrementally recognize; /// an explode_vector followed by scalar reduction as a vector reduction node.; /// This exists to recover from a deficiency in SLP which can't handle; /// forests with multiple roots sharing common nodes. In some cases, one; /// of the trees will be vectorized, and the other will remain (unprofitably); /// scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:4,Performance,Perform,Perform,4,"/// Perform two related transforms whose purpose is to incrementally recognize; /// an explode_vector followed by scalar reduction as a vector reduction node.; /// This exists to recover from a deficiency in SLP which can't handle; /// forests with multiple roots sharing common nodes. In some cases, one; /// of the trees will be vectorized, and the other will remain (unprofitably); /// scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:179,Safety,recover,recover,179,"/// Perform two related transforms whose purpose is to incrementally recognize; /// an explode_vector followed by scalar reduction as a vector reduction node.; /// This exists to recover from a deficiency in SLP which can't handle; /// forests with multiple roots sharing common nodes. In some cases, one; /// of the trees will be vectorized, and the other will remain (unprofitably); /// scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:162,Safety,safe,safe,162,"// This transforms need to run before all integer types have been legalized; // to i64 (so that the vector element type matches the add type), and while; // it's safe to introduce odd sized vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:188,Modifiability,extend,extend,188,"// match binop (extract_vector_elt V, 0), (extract_vector_elt V, 1) to; // reduce_op (extract_subvector [2 x VT] from V). This will form the; // root of our reduction tree. TODO: We could extend this to any two; // adjacent aligned constant indices if desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Energy Efficiency,reduce,reduce,17,"// Match (binop (reduce (extract_subvector V, 0),; // (extract_vector_elt V, sizeof(SubVec)))); // into a reduction of one more element from the original vector V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Safety,safe,safe,63,"// If the AVL is zero, operand 0 will be returned. So it's not safe to fold.; // FIXME: We might be able to improve this if operand 0 is undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize (add (shl x, c0), (shl y, c1)) ->; // (SLLI (SH*ADD x, y), c0), if c1-c0 equals to [1|2|3].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform this optimization only in the zba extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Performance,optimiz,optimization,16,// Perform this optimization only in the zba extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Performance,optimiz,optimizations,11,// All our optimizations involve subtracting 1 from the immediate and forming; // an ADDI. Make sure the new immediate is valid for an ADDI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:151,Energy Efficiency,reduce,reduces,151,"// Apply DeMorgan's law to (and/or (xor X, 1), (xor Y, 1)) if X and Y are 0/1.; // Legalizing setcc can introduce xors like this. Doing this transform reduces; // the number of xors and may allow the xor to fold into a branch condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:12,Usability,Simpl,SimplifyDemandedBits,12,"// For AND, SimplifyDemandedBits may have turned one of the (xor X, 1) into; // (xor X, -1) based on the upper bits of the other operand being 0. If the; // operation is And, allow one of the Xors to use -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:285,Availability,recover,recover,285,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Modifiability,extend,extending,76,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,Safety,safe,safe,97,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:285,Safety,recover,recover,285,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:170,Performance,optimiz,optimization,170,"// Combines two comparison operation and logic operation to one selection; // operation(min, max) and logic operation. Returns new constructed Node if; // conditions for optimization are satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:41,Testability,log,logic,41,"// Combines two comparison operation and logic operation to one selection; // operation(min, max) and logic operation. Returns new constructed Node if; // conditions for optimization are satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,Testability,log,logic,102,"// Combines two comparison operation and logic operation to one selection; // operation(min, max) and logic operation. Returns new constructed Node if; // conditions for optimization are satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:284,Availability,recover,recover,284,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,Modifiability,extend,extending,75,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,Safety,safe,safe,96,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:284,Safety,recover,recover,284,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:186,Availability,recover,recover,186,"// Pre-promote (i32 (xor (shl -1, X), ~0)) on RV64 with Zbs so we can use; // (ADDI (BSET X0, X), -1). If we wait until/ type legalization, we'll create; // RISCVISD:::SLLW and we can't recover it to use a BSET instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:186,Safety,recover,recover,186,"// Pre-promote (i32 (xor (shl -1, X), ~0)) on RV64 with Zbs so we can use; // (ADDI (BSET X0, X), -1). If we wait until/ type legalization, we'll create; // RISCVISD:::SLLW and we can't recover it to use a BSET instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:72,Modifiability,extend,extend,72,"/// According to the property that indexed load/store instructions zero-extend; /// their indices, try to narrow the type of index operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:43,Performance,load,load,43,"/// According to the property that indexed load/store instructions zero-extend; /// their indices, try to narrow the type of index operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Modifiability,extend,extended,53,// Skip if NewElen is not narrower than the original extended type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:120,Modifiability,extend,extended,120,"// Replace (seteq (i64 (and X, 0xffffffff)), C1) with; // (seteq (i64 (sext_inreg (X, i32)), C1')) where C1' is C1 sign extended from; // bit 31. Same for setne. C1' may be cheaper to materialize and the sext_inreg; // can become a sext.w instead of a shift pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:558,Availability,Mask,Mask,558,"/// Helper class for folding sign/zero extensions.; /// In particular, this class is used for the following combines:; /// add | add_vl -> vwadd(u) | vwadd(u)_w; /// sub | sub_vl -> vwsub(u) | vwsub(u)_w; /// mul | mul_vl -> vwmul(u) | vwmul_su; ///; /// An object of this class represents an operand of the operation we want to; /// combine.; /// E.g., when trying to combine `mul_vl a, b`, we will have one instance of; /// NodeExtensionHelper for `a` and one for `b`.; ///; /// This class abstracts away how the extension is materialized and; /// how its Mask, VL, number of users affect the combines.; ///; /// In particular:; /// - VWADD_W is conceptually == add(op0, sext(op1)); /// - VWADDU_W == add(op0, zext(op1)); /// - VWSUB_W == sub(op0, sext(op1)); /// - VWSUBU_W == sub(op0, zext(op1)); ///; /// And VMV_V_X_VL, depending on the value, is conceptually equivalent to; /// zext|sext(smaller_value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:826,Integrability,depend,depending,826,"/// Helper class for folding sign/zero extensions.; /// In particular, this class is used for the following combines:; /// add | add_vl -> vwadd(u) | vwadd(u)_w; /// sub | sub_vl -> vwsub(u) | vwsub(u)_w; /// mul | mul_vl -> vwmul(u) | vwmul_su; ///; /// An object of this class represents an operand of the operation we want to; /// combine.; /// E.g., when trying to combine `mul_vl a, b`, we will have one instance of; /// NodeExtensionHelper for `a` and one for `b`.; ///; /// This class abstracts away how the extension is materialized and; /// how its Mask, VL, number of users affect the combines.; ///; /// In particular:; /// - VWADD_W is conceptually == add(op0, sext(op1)); /// - VWADDU_W == add(op0, zext(op1)); /// - VWSUB_W == sub(op0, sext(op1)); /// - VWSUBU_W == sub(op0, zext(op1)); ///; /// And VMV_V_X_VL, depending on the value, is conceptually equivalent to; /// zext|sext(smaller_value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Modifiability,extend,extended,47,/// Records if this operand is like being zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Modifiability,extend,extended,47,"/// Records if this operand is like being sign extended.; /// Note: SupportsZExt and SupportsSExt are not mutually exclusive. For; /// instance, a splat constant (e.g., 3), would support being both sign and; /// zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:217,Modifiability,extend,extended,217,"/// Records if this operand is like being sign extended.; /// Note: SupportsZExt and SupportsSExt are not mutually exclusive. For; /// instance, a splat constant (e.g., 3), would support being both sign and; /// zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:30,Availability,mask,mask,30,/// Records if this operand's mask needs to match the mask of the operation; /// that it will fold into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Availability,mask,mask,54,/// Records if this operand's mask needs to match the mask of the operation; /// that it will fold into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,Mask,Mask,17,/// Value of the Mask for this operand.; /// It may be SDValue().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,Modifiability,extend,extended,51,/// Check if this node needs to be fully folded or extended for all users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,Availability,Mask,Mask,58,/// Check if this operand is compatible with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Availability,Mask,Mask,31,/// Helper function to get the Mask and VL from \p Root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,Mask,Mask,17,/// Check if the Mask and VL of this operand are compatible with \p Root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:113,Modifiability,extend,extended,113,"// No value means no extension is needed. If extension is needed, the value; // indicates if it needs to be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:158,Testability,test,testing,158,// FIXME: Is it useful to form a vwadd.wx or vwsub.wx if it removes a scalar; // sext/zext?; // Control this behavior behind an option (AllowSplatInVW_W) for testing; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Modifiability,extend,extended,27,"// All the inputs that are extended need to be folded, otherwise; // we would be leaving the old input (since it is may still be used),; // and the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Performance,perform,performMemPairCombine,23,// Helper function for performMemPairCombine.; // Try to combine the memory loads/stores LSNode1 and LSNode2; // into a single memory pair operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Performance,load,loads,76,// Helper function for performMemPairCombine.; // Try to combine the memory loads/stores LSNode1 and LSNode2; // into a single memory pair operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Performance,load,loads,31,// Try to combine two adjacent loads/stores to a single pair instruction from; // the XTHeadMemPair vendor extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Performance,load,load,27,// Target does not support load/store pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:34,Performance,load,loads,34,"// No volatile, indexed or atomic loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:34,Performance,load,loads,34,"// No volatile, indexed or atomic loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Performance,scalab,scalable,29,// Make fixed-length vectors scalable first,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:37,Performance,scalab,scalable,37,"// If converted from fixed-length to scalable, convert back",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Modifiability,extend,extends,18,// fcvt.wu.* sign extends bit 31 on RV64. FP_TO_UINT_SAT expects to zero; // extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:77,Modifiability,extend,extend,77,// fcvt.wu.* sign extends bit 31 on RV64. FP_TO_UINT_SAT expects to zero; // extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,Deployability,toggle,toggles,54,// Negating the multiply result changes ADD<->SUB and toggles 'N'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Modifiability,Refactor,Refactor,9,// TODO: Refactor to handle more complex cases similar to; // combineBinOp_VLToVWBinOp_VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:13,Availability,mask,mask,13,// Check the mask and VL are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Modifiability,Refactor,Refactor,9,// TODO: Refactor to handle more complex cases similar to; // combineBinOp_VLToVWBinOp_VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:13,Availability,mask,mask,13,// Check the mask and VL are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:13,Availability,mask,mask,13,// Check the mask and VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:44,Modifiability,extend,extend,44,// Sub requires at least operand 1 to be an extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Modifiability,extend,extend,21,// Op1 is a foldable extend. Op0 might be foldable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Performance,optimiz,optimization,100,// All users should be a shift by constant less than or equal to 32. This; // ensures we'll do this optimization for each of them to produce an; // add/sub+sext_inreg they can all share.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Usability,Simpl,SimplifyDemandedBits,31,"// If the condition is an And, SimplifyDemandedBits may have changed; // (xor Z, 1) to (not Z).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform common combines for BR_CC and SELECT_CC condtions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:95,Energy Efficiency,power,power,95,"// Replace (setcc eq (and x, C)) with (setcc ne (and x, C))) to generate; // BEXTI, where C is power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:311,Performance,perform,performing,311,"/// If we have a build_vector where each lane is binop X, C, where C; /// is a constant (but not necessarily the same constant on all lanes),; /// form binop (build_vector x1, x2, ...), (build_vector c1, c2, c3, ..).; /// We assume that materializing a constant build vector will be no more; /// expensive that performing O(n) binops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,failure,failure,17,// FIXME: Return failure if the RHS type doesn't match the LHS. Shifts may; // have different LHS and RHS types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,failure,failure,17,// FIXME: Return failure if the RHS type doesn't match the LHS. Shifts may; // have different LHS and RHS types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Performance,load,loads,45,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Performance,load,load,76,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,Performance,load,load,94,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:112,Performance,load,load,112,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:175,Performance,load,load,175,"// If we're concatenating a series of vector loads like; // concat_vectors (load v4i8, p+0), (load v4i8, p+n), (load v4i8, p+n*2) ...; // Then we can turn this into a strided load by widening the vector elements; // vlse32 p, stride=n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Performance,perform,perform,8,// Only perform this combine on legal MVTs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Modifiability,extend,extend,21,// TODO: Potentially extend this to scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:36,Performance,scalab,scalable,36,// TODO: Potentially extend this to scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Performance,load,loads,18,// Go through the loads and check that they're strided,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:70,Performance,load,loads,70,// The common alignment is the most restrictive (smallest) of all the loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,Performance,load,load,10,"// If the load ptrs can be decomposed into a common (Base + Index) with a; // common constant stride, then return the constant stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:49,Performance,load,loads,49,// Get the distance between the first and second loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Performance,load,loads,17,// Check all the loads are the same distance apart,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,Performance,load,load,76,"// TODO: At this point, we've successfully matched a generalized gather; // load. Maybe we should emit that, and then move the specialized; // matchers above and below into a DAG combine?; // Get the widened scalar type, e.g. v4i8 -> i64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Performance,load,load,39,"// Get the vector type for the strided load, e.g. 4 x v4i8 -> v4i64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,Performance,load,load,65,"// If Stride isn't constant, then we can't know how much it will load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Performance,load,loads,18,"// RISC-V indexed loads only support the ""unsigned unscaled"" addressing; // mode, so anything else must be manually legalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:70,Availability,mask,mask,70,"/// Match the index vector of a scatter or gather node as the shuffle mask; /// which performs the rearrangement if possible. Will only match if; /// all lanes are touched, and thus replacing the scatter or gather with; /// a unit strided access and shuffle is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:86,Performance,perform,performs,86,"/// Match the index vector of a scatter or gather node as the shuffle mask; /// which performs the rearrangement if possible. Will only match if; /// all lanes are touched, and thus replacing the scatter or gather with; /// a unit strided access and shuffle is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:239,Security,access,access,239,"/// Match the index vector of a scatter or gather node as the shuffle mask; /// which performs the rearrangement if possible. Will only match if; /// all lanes are touched, and thus replacing the scatter or gather with; /// a unit strided access and shuffle is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Availability,mask,mask,22,// Create the shuffle mask and check all bits active,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:271,Deployability,toggle,toggles,271,"/// Match the index of a gather or scatter operation as an operation; /// with twice the element width and half the number of elements. This is; /// generally profitable (if legal) because these operations are linear; /// in VL, so even if we cause some extract VTYPE/VL toggles, we still; /// come out ahead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Usability,Simpl,SimplifyDemandedBits,18,"// Helper to call SimplifyDemandedBits on an operand of N where only some low; // bits are demanded. N will be added to the Worklist if it was not deleted.; // Caller should return SDValue(N, 0) if this returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,Availability,redundant,redundant,75,"// If the input to SplitF64 is just BuildPairF64 then the operation is; // redundant. Instead, use BuildPairF64's operands directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,Safety,redund,redundant,75,"// If the input to SplitF64 is just BuildPairF64 then the operation is; // redundant. Instead, use BuildPairF64's operands directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:59,Performance,load,load,59,// It's cheaper to materialise two 32-bit integers than to load a double; // from the constant pool and transfer it to integer registers through the; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Performance,perform,performed,53,"// This is a target-specific version of a DAGCombine performed in; // DAGCombiner::visitBITCAST. It performs the equivalent of:; // fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Performance,perform,performs,100,"// This is a target-specific version of a DAGCombine performed in; // DAGCombiner::visitBITCAST. It performs the equivalent of:; // fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,Performance,perform,performed,53,"// This is a target-specific version of a DAGCombine performed in; // DAGCombiner::visitBITCAST. It performs the equivalent of:; // fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,Performance,perform,performs,100,"// This is a target-specific version of a DAGCombine performed in; // DAGCombiner::visitBITCAST. It performs the equivalent of:; // fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Safety,safe,safe,107,// Fold (zero_extend (fp_to_uint X)) to prevent forming fcvt+zexti32 during; // type legalization. This is safe because fp_to_uint produces poison if; // it overflows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Safety,safe,safe,19,// freeze it to be safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Integrability,inject,injects,35,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:124,Modifiability,extend,extend,124,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:157,Performance,optimiz,optimized,157,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:176,Safety,Avoid,Avoid,176,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Security,inject,injects,35,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:25,Modifiability,extend,extend,25,"// Avoid cases where the extend/round has multiple uses, as duplicating; // those is typically more expensive than removing a fneg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Safety,Avoid,Avoid,3,"// Avoid cases where the extend/round has multiple uses, as duplicating; // those is typically more expensive than removing a fneg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:95,Safety,avoid,avoid,95,"// The sequence will be XLenVT, not the type of Index. Tell; // isSimpleVIDSequence this so we avoid overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Energy Efficiency,power,power-of-two,82,"// If sufficiently aligned we can scalarize stores of constant vectors of; // any power-of-two size up to XLen bits, provided that they aren't too; // expensive to materialize.; // vsetivli zero, 2, e8, m1, ta, ma; // vmv.v.i v8, 4; // vse64.v v8, (a0); // ->; // li a1, 1028; // sh a1, 0(a0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:130,Safety,avoid,avoid,130,// Combine store of vmv.x.s/vfmv.f.s to vse with VL of 1.; // vfmv.f.s is represented as extract element from 0. Match it late to avoid; // any illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Performance,scalab,scalable,19,// VecVT should be scalable and memory VT should match the element type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:8,Performance,perform,perform,8,// Only perform this combine on legal MVT types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Safety,avoid,avoid,24,// Use M1 or smaller to avoid over constraining register allocation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:73,Availability,mask,masked,73,"// If the stride is equal to the element size in bytes, we can use; // a masked.load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:80,Performance,load,load,80,"// If the stride is equal to the element size in bytes, we can use; // a masked.load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:73,Availability,mask,masked,73,"// If the stride is equal to the element size in bytes, we can use; // a masked.store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,Safety,avoid,avoid,107,"// If this is a bitcast between a MVT::v4i1/v2i1/v1i1 and an illegal integer; // type, widen both sides to avoid a trip through memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Performance,optimiz,optimization,14,// Delay this optimization as late as possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear all non-demanded bits initially.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Availability,mask,mask,17,"// If the shrunk mask fits in sign extended 12 bits, let the target; // independent code apply it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Modifiability,extend,extended,35,"// If the shrunk mask fits in sign extended 12 bits, let the target; // independent code apply it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:110,Availability,mask,mask,110,"// For the remaining optimizations, we need to be able to make a negative; // number through a combination of mask and undemanded bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Performance,optimiz,optimizations,21,"// For the remaining optimizations, we need to be able to make a negative; // number through a combination of mask and undemanded bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,Availability,mask,mask,22,// Check that our new mask is a subset of the demanded mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:55,Availability,mask,mask,55,// Check that our new mask is a subset of the demanded mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extending,38,// Restore the original width by sign extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extending,38,// Restore the original width by sign extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,Modifiability,extend,extending,38,// Restore the original width by sign extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:93,Energy Efficiency,power,power,93,// We can use the minimum and maximum VLEN values to bound VLENB. We; // know VLEN must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:128,Integrability,depend,depending,128,"// TODO: As the result is sign-extended, this is conservatively correct. A; // more precise answer could be calculated for SRAW depending on known; // bits in the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Modifiability,extend,extended,31,"// TODO: As the result is sign-extended, this is conservatively correct. A; // more precise answer could be calculated for SRAW depending on known; // bits in the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:229,Modifiability,extend,extended,229,"// riscv_masked_{atomicrmw_*,cmpxchg} intrinsics represent an emulated; // narrow atomic operation. These are implemented using atomic; // operations at the minimum supported atomicrmw/cmpxchg width whose; // result is then sign extended to XLEN. With +A, the minimum width is; // 32 for both 64 and 32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Usability,Simpl,Simple,3,"// Simple case, LLA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,Integrability,wrap,wrapped,102,"// To read the 64-bit cycle CSR on a 32-bit target, we read the two halves.; // Should the count have wrapped while it was being read, we need to try; // again.; // ...; // read:; // rdcycleh x3 # load high word of cycle; // rdcycle x2 # load low word of cycle; // rdcycleh x4 # load high word of cycle; // bne x3, x4, read # check if high word reads match, otherwise try again; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:197,Performance,load,load,197,"// To read the 64-bit cycle CSR on a 32-bit target, we read the two halves.; // Should the count have wrapped while it was being read, we need to try; // again.; // ...; // read:; // rdcycleh x3 # load high word of cycle; // rdcycle x2 # load low word of cycle; // rdcycleh x4 # load high word of cycle; // bne x3, x4, read # check if high word reads match, otherwise try again; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:238,Performance,load,load,238,"// To read the 64-bit cycle CSR on a 32-bit target, we read the two halves.; // Should the count have wrapped while it was being read, we need to try; // again.; // ...; // read:; // rdcycleh x3 # load high word of cycle; // rdcycle x2 # load low word of cycle; // rdcycleh x4 # load high word of cycle; // bne x3, x4, read # check if high word reads match, otherwise try again; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:279,Performance,load,load,279,"// To read the 64-bit cycle CSR on a 32-bit target, we read the two halves.; // Should the count have wrapped while it was being read, we need to try; // again.; // ...; // read:; // rdcycleh x3 # load high word of cycle; // rdcycle x2 # load low word of cycle; // rdcycleh x4 # load high word of cycle; // bne x3, x4, read # check if high word reads match, otherwise try again; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:949,Integrability,depend,depend,949,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:1058,Integrability,depend,depend,1058,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:474,Performance,optimiz,optimize,474,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:771,Safety,safe,safe,771,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:907,Security,access,access,907,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the new block which will contain the Phi nodes for the selects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the new block which will contain the Phi nodes for the selects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,Integrability,depend,dependency,11,// Add FRM dependency to any instructions with dynamic rounding mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:592,Availability,avail,available,592,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:1057,Integrability,depend,depending,1057,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:160,Safety,avoid,avoid,160,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:247,Usability,simpl,simply,247,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:298,Usability,simpl,simple,298,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:20,Availability,mask,mask,20,// Assign the first mask argument to V0.; // This is an interim calling convention and it may be changed in the; // future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Availability,failure,failure,63,// Implements the RISC-V calling convention. Returns true upon failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:114,Availability,avail,available,114,// Any return value split in to more than two values can't be returned; // directly. Vectors are returned via the available vector registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:137,Availability,avail,available,137,"// UseGPRForF16_F32 if targeting one of the soft-float ABIs, if passing a; // variadic argument, or if no F16/F32 argument registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:136,Availability,avail,available,136,"// UseGPRForF64 if targeting soft-float ABIs or an FLEN=32 ABI, if passing a; // variadic argument, or if no F64 argument registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:84,Modifiability,variab,variables,84,"// From this point on, rely on UseGPRForF16_F32, UseGPRForF64 and; // similar local variables rather than directly checking against the target; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,Availability,avail,available,16,"// Depending on available argument GPRS, f64 may be passed in a pair of; // GPRs, split between a GPR and the stack, or passed completely on the; // stack. LowerCall/LowerFormalArguments/LowerReturn must recognise these; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Integrability,Depend,Depending,3,"// Depending on available argument GPRS, f64 may be passed in a pair of; // GPRs, split between a GPR and the stack, or passed completely on the; // stack. LowerCall/LowerFormalArguments/LowerReturn must recognise these; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable-vector,57,// Fixed-length vectors are located in the corresponding scalable-vector; // container types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate to a register if possible, or else a stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Performance,load,loading,33,// The caller is responsible for loading the full value if the argument is; // passed with CCValAssign::Indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:20,Modifiability,extend,extended,20,"// If input is sign extended from 32 bits, note it for the SExtWRemoval pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Modifiability,extend,extended,17,// An input zero extended from i31 can also be considered sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,Modifiability,extend,extended,63,// An input zero extended from i31 can also be considered sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,Performance,load,loading,33,// The caller is responsible for loading the full value if the argument is; // passed with CCValAssign::Indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,Performance,scalab,scalable,23,"// When the value is a scalable vector, we save the pointer which points to; // the scalable vector value in the stack. The ValVT will be the pointer; // type, instead of the scalable vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:84,Performance,scalab,scalable,84,"// When the value is a scalable vector, we save the pointer which points to; // the scalable vector value in the stack. The ValVT will be the pointer; // type, instead of the scalable vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:175,Performance,scalab,scalable,175,"// When the value is a scalable vector, we save the pointer which points to; // the scalable vector value in the stack. The ValVT will be the pointer; // type, instead of the scalable vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Performance,perform,performance,27,"// FastCC has less than 1% performance improvement for some particular; // benchmark. But theoretically, it may has benenfit for some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,Testability,benchmark,benchmark,75,"// FastCC has less than 1% performance improvement for some particular; // benchmark. But theoretically, it may has benenfit for some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Availability,avail,available,24,// Check if there is an available GPR before hitting the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:57,Performance,scalab,scalable-vector,57,// Fixed-length vectors are located in the corresponding scalable-vector; // container types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,Performance,scalab,scalable,14,// Can't pass scalable vectors on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:98,Performance,load,load,98,"// If the original argument was split and passed by reference (e.g. i128; // on RV32), we need to load all parts of it here (using the same; // address). Vectors may be partly split to registers and partly to the; // stack, in which case the base address is partly offset and subsequent; // stores are relative to that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,Energy Efficiency,allocate,allocated,24,"// If all registers are allocated, then all varargs must be passed on the; // stack and we don't need to save any argregs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument; // which is a value necessary to VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,Performance,optimiz,optimization,94,/// isEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization.; /// Note: This is modelled after ARM's IsEligibleForTailCallOptimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:240,Availability,avail,available,240,"// Do not tail call opt if any parameters need to be passed indirectly.; // Since long doubles (fp128) and i128 are larger than 2*XLEN, they are; // passed indirectly. So the address of the value will be passed in a; // register, or if not available, then the address is put on the stack. In; // order to pass indirectly, space on the stack often needs to be allocated; // in order to store the value. In this case the CCInfo.getNextStackOffset(); // != 0 check is not enough and we need to check if any CCValAssign ArgsLocs; // are passed CCValAssign::Indirect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:359,Energy Efficiency,allocate,allocated,359,"// Do not tail call opt if any parameters need to be passed indirectly.; // Since long doubles (fp128) and i128 are larger than 2*XLEN, they are; // passed indirectly. So the address of the value will be passed in a; // register, or if not available, then the address is put on the stack. In; // order to pass indirectly, space on the stack often needs to be allocated; // in order to store the value. In this case the CCInfo.getNextStackOffset(); // != 0 check is not enough and we need to check if any CCValAssign ArgsLocs; // are passed CCValAssign::Indirect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:165,Energy Efficiency,efficient,efficient,165,// Byval parameters hand the function a pointer directly into the stack area; // we want to reuse during a tail call. Working around this *is* possible; // but less efficient and uglier in LowerCall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:105,Performance,perform,performing,105,// Calculate the total size to store. We don't have access to what we're; // actually storing other than performing the loop and collecting the; // info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:52,Security,access,access,52,// Calculate the total size to store. We don't have access to what we're; // actually storing other than performing the loop and collecting the; // info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Queue,Queue,3,// Queue up the argument copies and emit them at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:98,Availability,error,error,98,"// Validate that none of the argument registers have been marked as; // reserved, if so report an error. Do the same for the return address if this; // is not a tailcall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Security,Validat,Validate,3,"// Validate that none of the argument registers have been marked as; // reserved, if so report an error. Do the same for the return address if this; // is not a tailcall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue node if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Integrability,rout,routines,21,// Interrupt service routines use different return instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:93,Performance,perform,perform,93,"// Check if the result of the node is only used as a return value, as; // otherwise we can't perform a tail-call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:91,Performance,perform,perform,91,"// If the ISD::CopyToReg has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:83,Safety,safe,safe,83,"// If the ISD::CopyToReg has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:251,Availability,avail,available,251,"// Since TargetLowering::getRegForInlineAsmConstraint uses the name of the; // TableGen record rather than the AsmName to choose registers for InlineAsm; // constraints, plus we want to match those names to the widest floating point; // register type available, manually select floating point registers here.; //; // The second case is the ABI name of the register, so that frontends can also; // use the ABI names in register constraint lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 12-bit signed immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create an integer zero operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 5-bit unsigned immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:152,Availability,mask,mask,152,"// In the case of an atomicrmw xchg with a constant 0/-1 operand, replace; // the atomic instruction with an AtomicRMWInst::And/Or with appropriate; // mask, as this produces better code than the LR/SC loop emitted by; // int_riscv_masked_atomicrmw_xchg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:45,Modifiability,extend,extend,45,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass XLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:307,Modifiability,extend,extend,307,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass XLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:56,Performance,load,loaded,56,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass XLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,Performance,perform,performing,82,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass XLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:80,Modifiability,extend,extended,80,// We have indexed loads for all legal index types. Indices are always; // zero extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,Performance,load,loads,19,// We have indexed loads for all legal index types. Indices are always; // zero extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:48,Energy Efficiency,reduce,reduce,48,"// If we are using the small code model, we can reduce size of jump table; // entry to 4 bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,Energy Efficiency,power,power,65,"// We define vscale to be VLEN/RVVBitsPerBlock. VLEN is always a power; // of two >= 64, and RVVBitsPerBlock is 64. Thus, vscale must be; // a power of two as well.; // FIXME: This doesn't work for zve32, but that's already broken; // elsewhere for the same reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:143,Energy Efficiency,power,power,143,"// We define vscale to be VLEN/RVVBitsPerBlock. VLEN is always a power; // of two >= 64, and RVVBitsPerBlock is 64. Thus, vscale must be; // a power of two as well.; // FIXME: This doesn't work for zve32, but that's already broken; // elsewhere for the same reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,Performance,load,loads,35,// Target does not support indexed loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Deployability,update,updates,17,"// Post-indexing updates the base, so it's not a valid transform; // if that's not the same as the load's pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:99,Performance,load,load,99,"// Post-indexing updates the base, so it's not a valid transform; // if that's not the same as the load's pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:12,Performance,optimiz,optimization,12,// Omit the optimization if the sub target has the M extension and the data; // size exceeds XLen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the MUL to (SH*ADD x, (SLLI x, bits)) if Imm is not simm12.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,Security,access,access,47,"// Note: We lower an unmasked unaligned vector access to an equally sized; // e8 element type access. Given this, we effectively support all unmasked; // misaligned accesses. TODO: Work through the codegen implications of; // allowing such accesses to be formed, and considered fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,Security,access,access,94,"// Note: We lower an unmasked unaligned vector access to an equally sized; // e8 element type access. Given this, we effectively support all unmasked; // misaligned accesses. TODO: Work through the codegen implications of; // allowing such accesses to be formed, and considered fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:165,Security,access,accesses,165,"// Note: We lower an unmasked unaligned vector access to an equally sized; // e8 element type access. Given this, we effectively support all unmasked; // misaligned accesses. TODO: Work through the codegen implications of; // allowing such accesses to be formed, and considered fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:240,Security,access,accesses,240,"// Note: We lower an unmasked unaligned vector access to an equally sized; // e8 element type access. Given this, we effectively support all unmasked; // misaligned accesses. TODO: Work through the codegen implications of; // allowing such accesses to be formed, and considered fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:366,Performance,load,load,366,"// We use LMUL1 memory operations here for a non-obvious reason. Our caller; // has an expansion threshold, and we want the number of hardware memory; // operations to correspond roughly to that threshold. LMUL>1 operations; // are typically expanded linearly internally, and thus correspond to more; // than one actual memory operation. Note that store merging and load; // combining will typically form larger LMUL operations from the LMUL1; // operations emitted here, and that's okay because combining isn't; // introducing new memory operations; it's just merging existing ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:52,Safety,avoid,avoid,52,"// Prefer i8 for non-zero memset as it allows us to avoid materializing; // a large scalar constant and instead use vmv.v.x/i to do the; // broadcast. For everything else, prefer ELenVT to minimize VL and thus; // maximize the chance we can encode the size in the vsetvli.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,Modifiability,extend,extend,27,"// Cast the [b]f16 to i16, extend to i32, pad with ones to make a float; // nan, and cast to f32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,Performance,optimiz,optimizing,21,"// When aggressively optimizing for code size, we prefer to use a div; // instruction, as it is usually smaller than the alternative sequence.; // TODO: Add vector division?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,Security,access,access,29,// Sometimes the interleaved access pass picks up splats as interleaves of; // one element. Don't lower these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:25,Performance,load,load,25,"/// Lower an interleaved load into a vlsegN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.riscv.seg2.load.v4i32.p0.i64(; /// %ptr, i64 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:91,Performance,load,load,91,"/// Lower an interleaved load into a vlsegN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.riscv.seg2.load.v4i32.p0.i64(; /// %ptr, i64 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,Performance,load,load,127,"/// Lower an interleaved load into a vlsegN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.riscv.seg2.load.v4i32.p0.i64(; /// %ptr, i64 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:380,Performance,load,load,380,"/// Lower an interleaved load into a vlsegN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.riscv.seg2.load.v4i32.p0.i64(; /// %ptr, i64 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Performance,perform,perform,31,// Lower SDIV as SDIV; // Only perform this transform if short forward branch opt is supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:50,Integrability,Interface,Interface,50,"//===-- RISCVISelLowering.h - RISC-V DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that RISC-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- RISCVISelLowering.h - RISC-V DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that RISC-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:46,Usability,simpl,simply,46,// 32-bit operations from RV64M that can't be simply matched with a pattern; // at instruction selection time. These have undefined behavior for division; // by 0 or overflow (divw) like their target independent counterparts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:229,Modifiability,extend,extended,229,"// FPR<->GPR transfer operations when the FPR is smaller than XLEN, needed as; // XLEN is the only legal integer width.; //; // FMV_H_X matches the semantics of the FMV.H.X.; // FMV_X_ANYEXTH is similar to FMV.X.H but has an any-extended result.; // FMV_X_SIGNEXTH is similar to FMV.X.H and has a sign-extended result.; // FMV_W_X_RV64 matches the semantics of the FMV.W.X.; // FMV_X_ANYEXTW_RV64 is similar to FMV.X.W but has an any-extended result.; //; // This is a more convenient semantic for producing dagcombines that remove; // unnecessary GPR->FPR->GPR moves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:302,Modifiability,extend,extended,302,"// FPR<->GPR transfer operations when the FPR is smaller than XLEN, needed as; // XLEN is the only legal integer width.; //; // FMV_H_X matches the semantics of the FMV.H.X.; // FMV_X_ANYEXTH is similar to FMV.X.H but has an any-extended result.; // FMV_X_SIGNEXTH is similar to FMV.X.H and has a sign-extended result.; // FMV_W_X_RV64 matches the semantics of the FMV.W.X.; // FMV_X_ANYEXTW_RV64 is similar to FMV.X.W but has an any-extended result.; //; // This is a more convenient semantic for producing dagcombines that remove; // unnecessary GPR->FPR->GPR moves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:434,Modifiability,extend,extended,434,"// FPR<->GPR transfer operations when the FPR is smaller than XLEN, needed as; // XLEN is the only legal integer width.; //; // FMV_H_X matches the semantics of the FMV.H.X.; // FMV_X_ANYEXTH is similar to FMV.X.H but has an any-extended result.; // FMV_X_SIGNEXTH is similar to FMV.X.H and has a sign-extended result.; // FMV_W_X_RV64 matches the semantics of the FMV.W.X.; // FMV_X_ANYEXTW_RV64 is similar to FMV.X.W but has an any-extended result.; //; // This is a more convenient semantic for producing dagcombines that remove; // unnecessary GPR->FPR->GPR moves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:100,Modifiability,extend,extended,100,// FP to 32 bit int conversions for RV64. These are used to keep track of the; // result being sign extended to 64 bit. These saturate out of range inputs.; // Used for FP_TO_S/UINT and FP_TO_S/UINT_SAT lowering. Rounding mode; // is passed as a TargetConstant operand using the RISCVFPRndMode enum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:82,Modifiability,extend,extended,82,// VMV_X_S matches the semantics of vmv.x.s. The result is always XLenVT sign; // extended from the vector element size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:135,Performance,load,load,135,// Splats an 64-bit value that has been split into two i32 parts. This is; // expanded late to two scalar stores and a stride 0 vector load.; // The first operand is passthru operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:81,Availability,mask,mask,81,// Truncates a RVV integer vector by one power-of-two. Carries both an extra; // mask and VL operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:41,Energy Efficiency,power,power-of-two,41,// Truncates a RVV integer vector by one power-of-two. Carries both an extra; // mask and VL operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:217,Availability,mask,mask,217,"// Matches the semantics of vslideup/vslidedown. The first operand is the; // pass-thru operand, the second is the source vector, the third is the XLenVT; // index (either constant or non-constant), the fourth is the mask, the fifth; // is the VL and the sixth is the policy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:198,Availability,mask,mask,198,"// Matches the semantics of vslide1up/slide1down. The first operand is; // passthru operand, the second is source vector, third is the XLenVT scalar; // value. The fourth and fifth operands are the mask and VL operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:247,Availability,mask,mask,247,"// Matches the semantics of vfslide1up/vfslide1down. The first operand is; // passthru operand, the second is source vector, third is a scalar value; // whose type matches the element type of the vectors. The fourth and fifth; // operands are the mask and VL operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:58,Availability,mask,mask,58,"// Matches the semantics of the vid.v instruction, with a mask and VL; // operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:221,Availability,mask,mask,221,"// Matches the semantics of the vfcnvt.rod function (Convert double-width; // float to single-width float, rounding towards odd). Takes a double-width; // float vector and produces a single-width float vector. Also has a mask and; // VL operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:755,Availability,mask,mask,755,"// These nodes match the semantics of the corresponding RVV vector reduction; // instructions. They produce a vector result which is the reduction; // performed over the second vector operand plus the first element of the; // third vector operand. The first operand is the pass-thru operand. The; // second operand is an unconstrained vector type, and the result, first, and; // third operand's types are expected to be the corresponding full-width; // LMUL=1 type for the second operand:; // nxv8i8 = vecreduce_add nxv8i8, nxv32i8, nxv8i8; // nxv2i32 = vecreduce_add nxv2i32, nxv8i32, nxv2i32; // The different in types does introduce extra vsetvli instructions but; // similarly it reduces the number of registers consumed per reduction.; // Also has a mask and VL operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:684,Energy Efficiency,reduce,reduces,684,"// These nodes match the semantics of the corresponding RVV vector reduction; // instructions. They produce a vector result which is the reduction; // performed over the second vector operand plus the first element of the; // third vector operand. The first operand is the pass-thru operand. The; // second operand is an unconstrained vector type, and the result, first, and; // third operand's types are expected to be the corresponding full-width; // LMUL=1 type for the second operand:; // nxv8i8 = vecreduce_add nxv8i8, nxv32i8, nxv8i8; // nxv2i32 = vecreduce_add nxv2i32, nxv8i32, nxv2i32; // The different in types does introduce extra vsetvli instructions but; // similarly it reduces the number of registers consumed per reduction.; // Also has a mask and VL operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:151,Performance,perform,performed,151,"// These nodes match the semantics of the corresponding RVV vector reduction; // instructions. They produce a vector result which is the reduction; // performed over the second vector operand plus the first element of the; // third vector operand. The first operand is the pass-thru operand. The; // second operand is an unconstrained vector type, and the result, first, and; // third operand's types are expected to be the corresponding full-width; // LMUL=1 type for the second operand:; // nxv8i8 = vecreduce_add nxv8i8, nxv32i8, nxv8i8; // nxv2i32 = vecreduce_add nxv2i32, nxv8i32, nxv2i32; // The different in types does introduce extra vsetvli instructions but; // similarly it reduces the number of registers consumed per reduction.; // Also has a mask and VL operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:56,Availability,mask,mask,56,"// Vector binary ops with a merge as a third operand, a mask as a fourth; // operand, and VL as a fifth operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:27,Availability,mask,mask,27,// Vector unary ops with a mask as a second operand and VL as a third operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:25,Availability,mask,mask,25,// Vector FMA ops with a mask as a fourth operand and VL as a fifth operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:34,Availability,mask,mask,34,// Vector widening FMA ops with a mask as a fourth operand and VL as a fifth; // operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:63,Availability,mask,mask,63,"// Widening instructions with a merge value a third operand, a mask as a; // fourth operand, and VL as a fifth operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:38,Availability,mask,mask,38,// Widening ternary operations with a mask as the fourth operand and VL as the; // fifth operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:77,Availability,mask,mask,77,"// Narrowing logical shift right.; // Operands are (source, shift, passthru, mask, vl)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:13,Testability,log,logical,13,"// Narrowing logical shift right.; // Operands are (source, shift, passthru, mask, vl)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:30,Availability,mask,mask,30,// Vector compare producing a mask. Fourth operand is input mask. Fifth; // operand is VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:60,Availability,mask,mask,60,// Vector compare producing a mask. Fourth operand is input mask. Fifth; // operand is VL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:28,Availability,mask,mask,28,"// General vmerge node with mask, true, false, passthru, and vl operands.; // Tail agnostic vselect can be implemented by setting passthru to undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:3,Availability,Mask,Mask,3,// Mask binary operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:7,Availability,mask,mask,7,// Set mask vector to all zeros or ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:127,Availability,mask,mask,127,"// Matches the semantics of vrgather.vx and vrgather.vv with extra operands; // for passthru and VL. Operands are (src, index, mask, passthru, vl).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:43,Availability,mask,mask,43,// Vector sign/zero extend with additional mask & VL operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:20,Modifiability,extend,extend,20,// Vector sign/zero extend with additional mask & VL operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:27,Availability,mask,mask,27,// vcpop.m with additional mask and VL operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:28,Availability,mask,mask,28,// vfirst.m with additional mask and VL operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:6,Availability,mask,maskc,6,// vt.maskc for XVentanaCondOps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:6,Availability,mask,maskcn,6,// vt.maskcn for XVentanaCondOps.; // FP to 32 bit int conversions for RV64. These are used to keep track of the; // result being sign extended to 64 bit. These saturate out of range inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:135,Modifiability,extend,extended,135,// vt.maskcn for XVentanaCondOps.; // FP to 32 bit int conversions for RV64. These are used to keep track of the; // result being sign extended to 64 bit. These saturate out of range inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:37,Availability,mask,mask,37,"/// Return true if the given shuffle mask can be codegen'd directly, or if it; /// should be stack expanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:240,Safety,avoid,avoids,240,"// If the pair to store is a mixture of float and int values, we will; // save two bitwise instructions and one float-to-int instruction and; // increase one store instruction. There is potentially a more; // significant benefit because it avoids the float->int domain switch; // for input value. So It is more likely a win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:231,Testability,test,testcase,231,"// If the pair only contains int values, we will save two bitwise; // instructions and increase one store instruction (costing one more; // store buffer). Since the benefit is more blurred we leave such a pair; // out until we get testcase to prove it is a win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:128,Performance,load,load,128,"// If we can replace 4 or more scalar stores, there will be a reduction; // in instructions even after we add a vector constant load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:257,Security,access,access,257,/// Returns the register with the specified architectural or ABI name. This; /// method is necessary to lower the llvm.read_register.* and; /// llvm.write_register.* intrinsics. Allocatable registers must be reserved; /// with the clang -ffixed-xX flag for access to be allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:55,Security,access,accesses,55,/// Returns true if the target allows unaligned memory accesses of the; /// specified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:79,Performance,scalab,scalable,79,"// Return inclusive (low, high) bounds on the value of VLMAX for the; // given scalable container type given known bounds on VLEN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:46,Performance,load,load,46,// Scaled addressing not supported on indexed load/stores,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:52,Performance,load,load,52,/// Returns whether or not generating a interleaved load/store intrinsic for; /// this type will be legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:28,Performance,load,load,28,/// Return true if a stride load store of the given result type and; /// alignment is legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:52,Modifiability,extend,extends,52,/// RISCVCCAssignFn - This target-specific function extends the default; /// CCValAssign with additional information used to lower RISC-V calling; /// conventions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:13,Availability,error,error,13,/// Generate error diagnostics if any register used by CC has been marked; /// reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:197,Performance,perform,perform,197,"/// Disable normalizing; /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and; /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)); /// RISC-V doesn't have flags so it's better to perform the and/or in a GPR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:8,Availability,avail,available,8,/// For available scheduling models FDIV + two independent FMULs are much; /// faster than two FDIVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:18,Energy Efficiency,schedul,scheduling,18,/// For available scheduling models FDIV + two independent FMULs are much; /// faster than two FDIVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMachineFunctionInfo.h:34,Modifiability,extend,extended,34,/// Registers that have been sign extended from i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:730,Availability,avail,available,730,"//===-- RISCVMakeCompressible.cpp - Make more instructions compressible ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:1076,Availability,avail,available,1076,"e Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the c",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:1301,Availability,avail,available,1301,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:1738,Availability,avail,available,1738,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:2162,Energy Efficiency,reduce,reduced,2162,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:2061,Performance,optimiz,optimization,2061,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:1819,Security,access,accessed,1819,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:32,Performance,load,load,32,// Return log2(widthInBytes) of load/store done by Opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:12,Availability,mask,mask,12,// Return a mask for the offset bits of a non-stack-pointer based compressed; // load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:81,Performance,load,load,81,// Return a mask for the offset bits of a non-stack-pointer based compressed; // load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:74,Performance,load,load,74,// Return true if Offset fits within a compressed stack-pointer based; // load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:25,Performance,load,load,25,"// Given an offset for a load/store, return the adjustment required to the base; // register such that the address can be accessed with a compressible offset.; // This will return 0 if the offset is already compressible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:122,Security,access,accessed,122,"// Given an offset for a load/store, return the adjustment required to the base; // register such that the address can be accessed with a compressible offset.; // This will return 0 if the offset is already compressible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:26,Performance,load,load,26,// Return true if MI is a load for which there exists a compressed version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:434,Performance,optimiz,optimization,434,"// Find a single register and/or large offset which, if compressible, would; // allow the given instruction to be compressed.; //; // Possible return values:; //; // {Reg, 0} - Uncompressed Reg needs replacing with a compressed; // register.; // {Reg, N} - Reg needs replacing with a compressed register and; // N needs adding to the new register. (Reg may be; // compressed or uncompressed).; // {RISCV::NoRegister, 0} - No suitable optimization found for this; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:10,Security,access,accesses,10,// Memory accesses via the stack pointer do not have a requirement for; // either of the registers to be compressible and can take a larger offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:7,Performance,load,loads,7,"// For loads, we can only change the base register since dest is defined; // rather than used.; //; // For stores, we can change SrcDest (and Base if SrcDest == Base) but; // cannot resolve an uncompressible offset in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:300,Availability,avail,available,300,"// Check all uses after FirstMI of the given register, keeping a vector of; // instructions that would be compressible if the given register (and offset if; // applicable) were compressible.; //; // If there are enough uses for this optimization to improve code size and a; // compressed register is available, return that compressed register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:233,Performance,optimiz,optimization,233,"// Check all uses after FirstMI of the given register, keeping a vector of; // instructions that would be compressible if the given register (and offset if; // applicable) were compressible.; //; // If there are enough uses for this optimization to improve code size and a; // compressed register is available, return that compressed register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:65,Performance,optimiz,optimize,65,"// If RegImm.Reg is modified by this instruction, then we cannot optimize; // past this instruction. If the register is already compressed, then it may; // possible to optimize a large offset in the current instruction - this; // will have been detected by the preceeding call to; // getRegImmPairPreventingCompression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:168,Performance,optimiz,optimize,168,"// If RegImm.Reg is modified by this instruction, then we cannot optimize; // past this instruction. If the register is already compressed, then it may; // possible to optimize a large offset in the current instruction - this; // will have been detected by the preceeding call to; // getRegImmPairPreventingCompression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:245,Safety,detect,detected,245,"// If RegImm.Reg is modified by this instruction, then we cannot optimize; // past this instruction. If the register is already compressed, then it may; // possible to optimize a large offset in the current instruction - this; // will have been detected by the preceeding call to; // getRegImmPairPreventingCompression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:46,Availability,avail,available,46,// Find a compressible register which will be available from the first; // instruction we care about to the last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update uses of the old register in the given instruction to the new register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:19,Modifiability,extend,extended,19,"// If this pass is extended to support more instructions, the check for; // definedness may need to be strengthened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:110,Safety,avoid,avoid,110,"// Skip the first (value) operand to a store instruction (except if the store; // offset is zero) in order to avoid an incorrect transformation.; // e.g. sd a0, 808(a0) to addi a2, a0, 768; sd a2, 40(a2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:10,Deployability,update,update,10,"// Do not update operands that define the old register.; //; // The new register was scavenged for the range of instructions that are; // being updated, therefore it should not be defined within this range; // except possibly in the final instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:144,Deployability,update,updated,144,"// Do not update operands that define the old register.; //; // The new register was scavenged for the range of instructions that are; // being updated, therefore it should not be defined within this range; // except possibly in the final instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update reg,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update offset,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:18,Performance,optimiz,optimization,18,// This is a size optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:8,Performance,optimiz,optimization,8,"// This optimization only makes sense if compressed instructions are emitted.; // FIXME: Support Zca, Zcf, Zcd granularity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:151,Performance,load,loads,151,"// If we are looking at replacing an FPR register we don't expect to; // have any offset. The only compressible FP instructions with an offset; // are loads and stores, for which the offset applies to the GPR operand; // not the FPR operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:3,Deployability,Update,Update,3,// Update the set of instructions to use the compressed register and; // compressible offset instead. These instructions should now be; // compressible.; // TODO: Update all uses if RegImm.Imm == 0? Not just those that are; // expected to become compressible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:163,Deployability,Update,Update,163,// Update the set of instructions to use the compressed register and; // compressible offset instead. These instructions should now be; // compressible.; // TODO: Update all uses if RegImm.Imm == 0? Not just those that are; // expected to become compressible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:49,Performance,Optimiz,Optimization,49,/// Returns an instance of the Make Compressible Optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Safety,Detect,Detect,3,"// Detect either of the patterns:; //; // 1. (medlow pattern):; // lui vreg1, %hi(s); // addi vreg2, vreg1, %lo(s); //; // 2. (medany pattern):; // .Lpcrel_hi1:; // auipc vreg1, %pcrel_hi(s); // addi vreg2, vreg1, %pcrel_lo(.Lpcrel_hi1); //; // The pattern is only accepted if:; // 1) The first instruction has only one use, which is the ADDI.; // 2) The address operands have the appropriate type, reflecting the; // lowering of a global address or constant pool using medlow or medany.; // 3) The offset value in the Global Address or Constant Pool is 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Deployability,Update,Update,3,// Update the offset in Hi and Lo instructions.; // Delete the tail instruction and update all the uses to use the; // output from Lo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:84,Deployability,update,update,84,// Update the offset in Hi and Lo instructions.; // Delete the tail instruction and update all the uses to use the; // output from Lo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:107,Deployability,update,updates,107,"// Detect patterns for large offsets that are passed into an ADD instruction.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailAdd and the instructions that produced the offset.; //; // Base address lowering is of the form:; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // / \; // / \; // / \; // / The large offset can be of two forms: \; // 1) Offset that has non zero bits in lower 2) Offset that has non zero; // 12 bits and upper 20 bits bits in upper 20 bits only; // OffseLUI: lui vreg3, 4; // OffsetTail: addi voff, vreg3, 188 OffsetTail: lui voff, 128; // \ /; // \ /; // \ /; // \ /; // TailAdd: add vreg4, vreg2, voff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Safety,Detect,Detect,3,"// Detect patterns for large offsets that are passed into an ADD instruction.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailAdd and the instructions that produced the offset.; //; // Base address lowering is of the form:; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // / \; // / \; // / \; // / The large offset can be of two forms: \; // 1) Offset that has non zero bits in lower 2) Offset that has non zero; // 12 bits and upper 20 bits bits in upper 20 bits only; // OffseLUI: lui vreg3, 4; // OffsetTail: addi voff, vreg3, 188 OffsetTail: lui voff, 128; // \ /; // \ /; // \ /; // \ /; // TailAdd: add vreg4, vreg2, voff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:69,Safety,Detect,Detect,69,// The offset value has non zero bits in both %hi and %lo parts.; // Detect an ADDI that feeds from a LUI instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:46,Modifiability,extend,extends,46,// RV32 ignores the upper 32 bits. ADDIW sign extends the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:313,Deployability,update,updates,313,"// Detect patterns for offsets that are passed into a SHXADD instruction.; // The offset has 1, 2, or 3 trailing zeros and fits in simm13, simm14, simm15.; // The constant is created with addi voff, x0, C, and shXadd is used to; // fill insert the trailing zeros and do the addition.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailShXAdd and the instructions that produced the offset.; //; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // OffsetTail: addi voff, x0, C; // TailAdd: shXadd vreg4, voff, vreg2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Safety,Detect,Detect,3,"// Detect patterns for offsets that are passed into a SHXADD instruction.; // The offset has 1, 2, or 3 trailing zeros and fits in simm13, simm14, simm15.; // The constant is created with addi voff, x0, C, and shXadd is used to; // fill insert the trailing zeros and do the addition.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailShXAdd and the instructions that produced the offset.; //; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // OffsetTail: addi voff, x0, C; // TailAdd: shXadd vreg4, voff, vreg2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:13,Usability,simpl,simply,13,// Offset is simply an immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:7,Performance,load,load,7,// All load/store instructions must use the same offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:33,Deployability,Update,Update,33,// We found a common offset.; // Update the offsets in global address lowering.; // We may have already folded some arithmetic so we need to add to any; // existing offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Deployability,Update,Update,3,// Update the immediate in the load/store instructions to add the offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:31,Performance,load,load,31,// Update the immediate in the load/store instructions to add the offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:49,Performance,Optimiz,Optimization,49,/// Returns an instance of the Merge Base Offset Optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:414,Performance,perform,performs,414,"//===-- RISCVMoveMerger.cpp - RISC-V move merge pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that performs move related peephole optimizations; // as Zcmp has specified. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:445,Performance,optimiz,optimizations,445,"//===-- RISCVMoveMerger.cpp - RISC-V move merge pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that performs move related peephole optimizations; // as Zcmp has specified. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:22,Integrability,depend,depends,22,"// The order of S-reg depends on which instruction holds A0, instead of; // the order of register pair.; // e,g.; // mv a1, s1; // mv a0, s2 => cm.mva01s s2,s1; //; // mv a0, s2; // mv a1, s1 => cm.mva01s s2,s1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:3,Deployability,Update,Update,3,// Update modified / used register units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:136,Performance,optimiz,optimize,136,// Resize the modified and used register unit trackers. We do this once; // per function and then clear the register units each time we optimize a; // move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:98,Usability,clear,clear,98,// Resize the modified and used register unit trackers. We do this once; // per function and then clear the register units each time we optimize a; // move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:923,Energy Efficiency,reduce,reduce,923,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:731,Integrability,depend,dependent,731,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:536,Modifiability,extend,extended,536,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:604,Modifiability,extend,extended,604,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:46,Performance,optimiz,optimizations,46,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:402,Performance,optimiz,optimizations,402,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:930,Testability,test,test,930,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:77,Integrability,depend,depends,77,"// these overwrite higher input bits, otherwise the lower word of output; // depends only on the lower word of input. So check their uses read W.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:32,Modifiability,extend,extended,32,// Operand 1 is implicitly zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:56,Integrability,depend,depends,56,"// For these, lower word of output in these operations, depends only on; // the lower word of input. So, we check all uses only read lower word.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:59,Modifiability,extend,extended,59,// shifting right sufficiently makes the value 32-bit sign-extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:43,Modifiability,extend,extended,43,"// The LI pattern ADDI rd, X0, imm is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:27,Modifiability,extend,extended,27,// A bseti with X0 is sign extended if the immediate is less than 31.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:21,Modifiability,extend,extending,21,// If this is a sign extending operation we don't need to look any further.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:47,Modifiability,extend,extend,47,// Is this an instruction that propagates sign extend?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:88,Modifiability,extend,extended,88,"// If this is the entry block and the register is livein, see if we know; // it is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:63,Modifiability,extend,extended,63,"// For these, we just need to check if the 1st operand is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:178,Modifiability,extend,extended,178,"// |Remainder| is always <= |Dividend|. If D is 32-bit, then so is R.; // DIV doesn't work because of the edge case 0xf..f 8000 0000 / (long)-1; // Logical operations use a sign extended 12-bit immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:148,Testability,Log,Logical,148,"// |Remainder| is always <= |Dividend|. If D is 32-bit, then so is R.; // DIV doesn't work because of the edge case 0xf..f 8000 0000 / (long)-1; // Logical operations use a sign extended 12-bit immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:110,Modifiability,extend,extended,110,// Returns operand 4 or an ADDW/SUBW/etc. of operands 5 and 6. We only; // need to check if operand 4 is sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:35,Modifiability,extend,extended,35,"// If all incoming values are sign-extended, the output of AND, OR, XOR,; // MIN, MAX, or PHI is also sign-extended.; // The input registers for PHI are operand 1, 3, ...; // The input registers for PseudoCCMOVGPR are 4 and 5.; // The input registers for PseudoCCAND/OR/XOR are 4, 5, and 6.; // The input registers for others are operand 1 and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:107,Modifiability,extend,extended,107,"// If all incoming values are sign-extended, the output of AND, OR, XOR,; // MIN, MAX, or PHI is also sign-extended.; // The input registers for PHI are operand 1, 3, ...; // The input registers for PseudoCCMOVGPR are 4 and 5.; // The input registers for PseudoCCAND/OR/XOR are 4, 5, and 6.; // The input registers for others are operand 1 and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:57,Modifiability,extend,extended,57,// Instructions return zero or operand 1. Result is sign extended if; // operand 1 is sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:91,Modifiability,extend,extended,91,// Instructions return zero or operand 1. Result is sign extended if; // operand 1 is sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:62,Modifiability,extend,extended,62,"// If we get here, then every node we visited produces a sign extended value; // or propagated sign extended values. So the result must be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:100,Modifiability,extend,extended,100,"// If we get here, then every node we visited produces a sign extended value; // or propagated sign extended values. So the result must be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:144,Modifiability,extend,extended,144,"// If we get here, then every node we visited produces a sign extended value; // or propagated sign extended values. So the result must be sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:56,Availability,redundant,redundant,56,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:150,Availability,redundant,redundant,150,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:110,Modifiability,extend,extend,110,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:56,Safety,redund,redundant,56,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:150,Safety,redund,redundant,150,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPostRAExpandPseudoInsts.cpp:559,Energy Efficiency,schedul,scheduling,559,"//===-- RISCVPostRAExpandPseudoInsts.cpp - Expand pseudo instrs ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands the pseudo instruction pseudolisimm32; // into target instructions. This pass should be run during the post-regalloc; // passes, before post RA scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPostRAExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPostRAExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:57,Deployability,pipeline,pipeline,57,"// Since Pseudo instruction lowering happen later in the pipeline,; // this will detect all ret instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:81,Safety,detect,detect,81,"// Since Pseudo instruction lowering happen later in the pipeline,; // this will detect all ret instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:3,Deployability,Update,Update,3,// Update modified / used register units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:39,Safety,abort,abort,39,"// If Zcmp extension is not supported, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:51,Safety,abort,abort,51,"// If frame pointer elimination has been disabled, abort to avoid breaking the; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:60,Safety,avoid,avoid,60,"// If frame pointer elimination has been disabled, abort to avoid breaking the; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:98,Usability,clear,clear,98,// Resize the modified and used register unit trackers. We do this once; // per function and then clear the register units each time we determine; // correct return value for the POP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:82,Performance,optimiz,optimization,82,/// createRISCVPushPopOptimizationPass - returns an instance of the; /// Push/Pop optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp:10,Availability,redundant,redundant,10,// Remove redundant Copy instructions unless TargetReg is modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp:10,Safety,redund,redundant,10,// Remove redundant Copy instructions unless TargetReg is modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp:3,Usability,Clear,Clear,3,// Clear any kills of TargetReg between CondBr and the last removed COPY.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:72,Energy Efficiency,allocate,allocate,72,// fp; // Reserve the base register if we need to realign the stack and allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:85,Modifiability,variab,variable-sized,85,// fp; // Reserve the base register if we need to realign the stack and allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:3,Performance,Optimiz,Optimize,3,// Optimize for constant VLEN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:58,Performance,load,loads,58,// Split a VSPILLx_Mx pseudo into multiple whole register loads separated by; // LMUL*VLENB bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:3,Performance,Optimiz,Optimize,3,// Optimize for constant VLEN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:28,Performance,scalab,scalable,28,"// For an exact VLEN value, scalable offsets become constant and thus; // can be converted entirely into fixed offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:268,Usability,clear,clear,268,// We chose to emit the canonical immediate sequence rather than folding; // the offset into the using add under the theory that doing so doesn't; // save dynamic instruction count and some target may fuse the canonical; // 32 bit immediate sequence. We still need to clear the portion of the; // offset encoded in the immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:163,Performance,optimiz,optimizations,163,"// Handle spill/fill of synthetic register classes for segment operations to; // ensure correctness in the edge case one gets spilled. There are many; // possible optimizations here, but given the extreme rarity of such spills,; // we prefer simplicity of implementation for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:242,Usability,simpl,simplicity,242,"// Handle spill/fill of synthetic register classes for segment operations to; // ensure correctness in the edge case one gets spilled. There are many; // possible optimizations here, but given the extreme rarity of such spills,; // we prefer simplicity of implementation for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:82,Performance,load,load,82,"// For RISC-V, The machine instructions that include a FrameIndex operand; // are load/store, ADDI instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:47,Performance,load,loads,47,"// We only generate virtual base registers for loads and stores, so; // return false for everything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:54,Integrability,interface,interface,54,// Add fixed-sized offset using existing DIExpression interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.h:3,Deployability,Update,Update,3,"// Update DestReg to have the value SrcReg plus an offset. This is; // used during frame layout, and we may need to ensure that if we; // split the offset internally that the DestReg is always aligned,; // assuming that source reg was.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:1579,Availability,redundant,redundant,1579,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to side step a MachineCSE; // optimization quality problem but need to convert back before; // TwoAddressInstruction. See pr64282 for context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:949,Energy Efficiency,allocate,allocated,949," undef vector value to pseudo ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to sid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:640,Modifiability,rewrite,rewrites,640,"//===- RISCVRVVInitUndef.cpp - Initialize undef vector value to pseudo ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // ope",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:1873,Modifiability,rewrite,rewrites,1873,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to side step a MachineCSE; // optimization quality problem but need to convert back before; // TwoAddressInstruction. See pr64282 for context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:2065,Performance,optimiz,optimization,2065,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to side step a MachineCSE; // optimization quality problem but need to convert back before; // TwoAddressInstruction. See pr64282 for context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:1579,Safety,redund,redundant,1579,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to side step a MachineCSE; // optimization quality problem but need to convert back before; // TwoAddressInstruction. See pr64282 for context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:26,Deployability,update,update,26,"// We don't have a way to update dead lanes, so keep track of the; // new register so that we avoid querying it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:94,Safety,avoid,avoid,94,"// We don't have a way to update dead lanes, so keep track of the; // new register so that we avoid querying it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:18,Performance,Tune,TuneInfo,18,"// If there is no TuneInfo for this CPU, we fail back to generic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:3,Performance,Load,Loading,3,"// Loading integer from constant pool needs two instructions (the reason why; // the minimum cost is 2): an address calculation instruction and a load; // instruction. Usually, address calculation and instructions used for; // building integers (addi, slli, etc.) can be done in one cycle, so here we; // set the default cost to (LoadLatency + 1) if no threshold is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:146,Performance,load,load,146,"// Loading integer from constant pool needs two instructions (the reason why; // the minimum cost is 2): an address calculation instruction and a load; // instruction. Usually, address calculation and instructions used for; // building integers (addi, slli, etc.) can be done in one cycle, so here we; // set the default cost to (LoadLatency + 1) if no threshold is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:330,Performance,Load,LoadLatency,330,"// Loading integer from constant pool needs two instructions (the reason why; // the minimum cost is 2): an address calculation instruction and a load; // instruction. Usually, address calculation and instructions used for; // building integers (addi, slli, etc.) can be done in one cycle, so here we; // set the default cost to (LoadLatency + 1) if no threshold is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:97,Performance,load,load,97,// FIXME: Enable subregister liveness by default for RVV to better handle; // LMUL>1 and segment load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp:72,Energy Efficiency,schedul,scheduling,72,"/// Enable use of alias analysis during code generation (during MI; /// scheduling, DAGCombine, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.h:42,Safety,Avoid,Avoid,42,/// Returns RISC-V processor family.; /// Avoid this function! CPU specifics should be kept local to this class; /// and preferably modeled with SubtargetFeatures or properties in; /// initializeProperties().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:96,Security,access,accesses,96,"// A RISC-V hart has a single byte-addressable address space of 2^XLEN bytes; // for all memory accesses, so it is reasonable to assume that an; // implementation has no-op address space casts. If an implementation makes a; // change to this, they can override it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:43,Energy Efficiency,schedul,schedule,43,"// TODO: It would potentially be better to schedule copy propagation after; // expanding pseudos (in addPreEmitPass2). However, performing copy; // propagation after the machine outliner (which runs after addPreEmitPass); // currently leads to incorrect code-gen, where copies to registers within; // outlined functions are removed erroneously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:128,Performance,perform,performing,128,"// TODO: It would potentially be better to schedule copy propagation after; // expanding pseudos (in addPreEmitPass2). However, performing copy; // propagation after the machine outliner (which runs after addPreEmitPass); // currently leads to incorrect code-gen, where copies to registers within; // outlined functions are removed erroneously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule PushPop Optimization before expansion of Pseudo instruction,; // ensuring return instruction is detected correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:20,Performance,Optimiz,Optimization,20,"// Schedule PushPop Optimization before expansion of Pseudo instruction,; // ensuring return instruction is detected correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:108,Safety,detect,detected,108,"// Schedule PushPop Optimization before expansion of Pseudo instruction,; // ensuring return instruction is detected correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LR/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:63,Safety,avoid,avoiding,63,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LR/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:21,Performance,load,loaded,21,// A address must be loaded from a small section if its size is less than the; // small section size threshold. Data in this section could be addressed by; // using gp_rel operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:15,Modifiability,variab,variables,15,"// Only global variables, not functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:10,Modifiability,variab,variable,10,"// If the variable has an explicit section, it is placed in that section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:26,Modifiability,variab,variable,26,// Explicitly placing any variable in the small data section overrides; // the global -G value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:32,Modifiability,variab,variable,32,// Otherwise reject putting the variable to small section if it has an; // explicit section name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:86,Availability,mask,mask,86,"// (and (shl x, c2), c1) will be matched to (srli (slli x, c2+c3), c3) if c1; // is a mask shifted by c2 bits with c3 leading zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:3,Energy Efficiency,Power,Power,3,// Power of 2 is a shift. Negated power of 2 is a shift and a negate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:34,Energy Efficiency,power,power,34,// Power of 2 is a shift. Negated power of 2 is a shift and a negate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:27,Energy Efficiency,power,power,27,// One more or less than a power of 2 can use SLLI+ADD/SUB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:53,Performance,scalab,scalable-vector,53,"// Currently, the ExpandReductions pass can't expand scalable-vector; // reductions, but we still request expansion as RVV doesn't support certain; // reductions and the SelectionDAG can't legalize them either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:54,Performance,load,load,54,// Add a cost of address generation + the cost of the load. The address; // is expected to be a PC relative offset to a constant pool entry; // using auipc/addi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:131,Performance,scalab,scalable,131,"// First, handle cases where having a fixed length vector enables us to; // give a more accurate cost than falling back to generic scalable codegen.; // TODO: Each of these cases hints at a modeling gap around scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:210,Performance,scalab,scalable,210,"// First, handle cases where having a fixed length vector enables us to; // give a more accurate cost than falling back to generic scalable codegen.; // TODO: Each of these cases hints at a modeling gap around scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:37,Availability,mask,mask,37,// vrgather + cost of generating the mask constant.; // We model this for an unknown mask with a single vrgather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:85,Availability,mask,mask,85,// vrgather + cost of generating the mask constant.; // We model this for an unknown mask with a single vrgather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:42,Availability,mask,mask,42,// 2 x (vrgather + cost of generating the mask constant) + cost of mask; // register for the second vrgather. We model this for an unknown; // (shuffle) mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:67,Availability,mask,mask,67,// 2 x (vrgather + cost of generating the mask constant) + cost of mask; // register for the second vrgather. We model this for an unknown; // (shuffle) mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:153,Availability,mask,mask,153,// 2 x (vrgather + cost of generating the mask constant) + cost of mask; // register for the second vrgather. We model this for an unknown; // (shuffle) mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:10,Performance,scalab,scalable,10,// Handle scalable vectors (and fixed vectors legalized to scalable vectors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:59,Performance,scalab,scalable,59,// Handle scalable vectors (and fixed vectors legalized to scalable vectors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:165,Availability,mask,mask,165,"// Example sequence:; // li a0, 90; // vsetivli zero, 8, e8, mf2, ta, ma (ignored); // vmv.s.x v0, a0; // vmerge.vvm v8, v9, v8, v0; // We use 2 for the cost of the mask materialization as this is the true; // cost for small masks and most shuffles are small. At worst, this cost; // should be a very small constant for the constant pool load. As such,; // we may bias towards large selects slightly more than truely warranted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:225,Availability,mask,masks,225,"// Example sequence:; // li a0, 90; // vsetivli zero, 8, e8, mf2, ta, ma (ignored); // vmv.s.x v0, a0; // vmerge.vvm v8, v9, v8, v0; // We use 2 for the cost of the mask materialization as this is the true; // cost for small masks and most shuffles are small. At worst, this cost; // should be a very small constant for the constant pool load. As such,; // we may bias towards large selects slightly more than truely warranted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:338,Performance,load,load,338,"// Example sequence:; // li a0, 90; // vsetivli zero, 8, e8, mf2, ta, ma (ignored); // vmv.s.x v0, a0; // vmerge.vvm v8, v9, v8, v0; // We use 2 for the cost of the mask materialization as this is the true; // cost for small masks and most shuffles are small. At worst, this cost; // should be a very small constant for the constant pool load. As such,; // we may bias towards large selects slightly more than truely warranted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:3,Availability,Mask,Mask,3,// Mask operation additionally required extend and truncate,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:40,Modifiability,extend,extend,40,// Mask operation additionally required extend and truncate,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:83,Performance,load,load,83,// The interleaved memory access pass will lower interleaved memory ops (i.e; // a load and store followed by a specific shuffle) to vlseg/vsseg; // intrinsics. In those cases then we can treat it as if it's just one (legal); // memory op,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:26,Security,access,access,26,// The interleaved memory access pass will lower interleaved memory ops (i.e; // a load and store followed by a specific shuffle) to vlseg/vsseg; // intrinsics. In those cases then we can treat it as if it's just one (legal); // memory op,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:176,Availability,mask,mask,176,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:253,Availability,mask,mask,253,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:330,Availability,mask,mask,330,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:18,Performance,load,load,18,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:73,Performance,load,load,73,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:552,Availability,mask,mask,552,"// TODO: Model for NF > 2; // We'll need to enhance getShuffleCost to model shuffles that are just; // inserts and extracts into subvectors, since they won't have the full cost; // of a vrgather.; // An interleaved store for 3 vectors of 4 lanes will look like; // %11 = shufflevector <4 x i32> %4, <4 x i32> %6, <8 x i32> <0...7>; // %12 = shufflevector <4 x i32> %9, <4 x i32> poison, <8 x i32> <0...3>; // %13 = shufflevector <8 x i32> %11, <8 x i32> %12, <12 x i32> <0...11>; // %interleaved.vec = shufflevector %13, poison, <12 x i32> <interleave mask>; // store <12 x i32> %interleaved.vec, ptr %10, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:44,Modifiability,enhance,enhance,44,"// TODO: Model for NF > 2; // We'll need to enhance getShuffleCost to model shuffles that are just; // inserts and extracts into subvectors, since they won't have the full cost; // of a vrgather.; // An interleaved store for 3 vectors of 4 lanes will look like; // %11 = shufflevector <4 x i32> %4, <4 x i32> %6, <8 x i32> <0...7>; // %12 = shufflevector <4 x i32> %9, <4 x i32> poison, <8 x i32> <0...3>; // %13 = shufflevector <8 x i32> %11, <8 x i32> %12, <12 x i32> <0...11>; // %interleaved.vec = shufflevector %13, poison, <12 x i32> <interleave mask>; // store <12 x i32> %interleaved.vec, ptr %10, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:46,Performance,perform,perform,46,"// For an interleaving store of 2 vectors, we perform one large interleaving; // shuffle that goes into the wide store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:76,Performance,scalab,scalable,76,"// Cost is proportional to the number of memory operations implied. For; // scalable vectors, we use an estimate on that number since we don't; // know exactly what VL will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:35,Performance,throughput,throughput,35,"// Currently, these represent both throughput and codesize costs; // for the respective intrinsics. The costs in this table are simply; // instruction counts with the following adjustments made:; // * One vsetvli is considered free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:128,Usability,simpl,simply,128,"// Currently, these represent both throughput and codesize costs; // for the respective intrinsics. The costs in this table are simply; // instruction counts with the following adjustments made:; // * One vsetvli is considered free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:44,Availability,mask,mask,44,"// We do not use vsext/vzext to extend from mask vector.; // Instead we use the following instructions to extend from mask vector:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:118,Availability,mask,mask,118,"// We do not use vsext/vzext to extend from mask vector.; // Instead we use the following instructions to extend from mask vector:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:32,Modifiability,extend,extend,32,"// We do not use vsext/vzext to extend from mask vector.; // Instead we use the following instructions to extend from mask vector:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:106,Modifiability,extend,extend,106,"// We do not use vsext/vzext to extend from mask vector.; // Instead we use the following instructions to extend from mask vector:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:46,Availability,mask,mask,46,"// We do not use several vncvt to truncate to mask vector. So we could; // not use PowDiff to calculate it.; // Instead we use the following instructions to truncate to mask vector:; // vand.vi v8, v8, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:169,Availability,mask,mask,169,"// We do not use several vncvt to truncate to mask vector. So we could; // not use PowDiff to calculate it.; // Instead we use the following instructions to truncate to mask vector:; // vand.vi v8, v8, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:34,Availability,mask,mask,34,"// The cost of convert from or to mask vector is different from other; // cases. We could not use PowDiff to calculate it.; // For mask vector to fp, we should use the following instructions:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0; // vfcvt.f.x.v v8, v8; // And for fp vector to mask, we use:; // vfncvt.rtz.x.f.w v9, v8; // vand.vi v8, v9, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:131,Availability,mask,mask,131,"// The cost of convert from or to mask vector is different from other; // cases. We could not use PowDiff to calculate it.; // For mask vector to fp, we should use the following instructions:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0; // vfcvt.f.x.v v8, v8; // And for fp vector to mask, we use:; // vfncvt.rtz.x.f.w v9, v8; // vand.vi v8, v9, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:288,Availability,mask,mask,288,"// The cost of convert from or to mask vector is different from other; // cases. We could not use PowDiff to calculate it.; // For mask vector to fp, we should use the following instructions:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0; // vfcvt.f.x.v v8, v8; // And for fp vector to mask, we use:; // vfncvt.rtz.x.f.w v9, v8; // vand.vi v8, v9, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:35,Availability,mask,mask,35,"// vcpop sequences, see vreduction-mask.ll. umax, smin actually only; // cost 2, but we don't have enough info here so we slightly over cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:35,Availability,mask,mask,35,"// vcpop sequences, see vreduction-mask.ll",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:81,Security,access,accessed,81,// Assume memory ops cost scale with the number of vector registers; // possible accessed by the instruction. Note that BasicTTI already; // handles the LT.first term for us.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:177,Performance,scalab,scalable,177,"// If we do not support the input floating point vector type, use the base; // one which will calculate as:; // ScalarizeCost + Num * Cost for fixed vector,; // InvalidCost for scalable vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:30,Safety,predict,predicted,30,// Branches are assumed to be predicted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:102,Performance,load,loads,102,"// Extract/InsertElement with non-constant index is very costly when; // scalarized; estimate cost of loads/stores sequence via the stack:; // ExtractElement cost: store vector to stack, load scalar;; // InsertElement cost: store vector to stack, store scalar, load vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:187,Performance,load,load,187,"// Extract/InsertElement with non-constant index is very costly when; // scalarized; estimate cost of loads/stores sequence via the stack:; // ExtractElement cost: store vector to stack, load scalar;; // InsertElement cost: store vector to stack, store scalar, load vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:261,Performance,load,load,261,"// Extract/InsertElement with non-constant index is very costly when; // scalarized; estimate cost of loads/stores sequence via the stack:; // ExtractElement cost: store vector to stack, load scalar;; // InsertElement cost: store vector to stack, store scalar, load vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:19,Performance,scalab,scalable,19,// For unsupported scalable vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:3,Availability,Mask,Mask,3,// Mask vector extract/insert is expanded via e8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:563,Integrability,depend,dependecies,563,"// In the basic model we take into account GEP instructions only; // (although here can come alloca instruction, a value, constants and/or; // constant expressions, PHIs, bitcasts ... whatever allowed to be used as a; // pointer). Typically, if Base is a not a GEP-instruction and all the; // pointers are relative to the same base address, all the rest are; // either GEP instructions, PHIs, bitcasts or constants. When we have same; // base, we just calculate cost of each non-Base GEP as an ADD operation if; // any their index is a non-const.; // If no known dependecies between the pointers cost is calculated as a sum; // of costs of GEP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:118,Performance,perform,performance,118,// TODO: More tuning on benchmarks and metrics with changes as needed; // would apply to all settings below to enable performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:24,Testability,benchmark,benchmarks,24,// TODO: More tuning on benchmarks and metrics with changes as needed; // would apply to all settings below to enable performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:49,Integrability,depend,dependant,49,"// Enable Upper bound unrolling universally, not dependant upon the conditions; // below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:60,Safety,predict,predictor,60,// Limit the CFG of the loop body for targets with a branch predictor.; // Allowing 4 blocks permits if-then-else diamonds in the body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:81,Integrability,rout,routine,81,"// Return how many elements can fit in getRegisterBitwidth. This is the; // same routine as used in LoopVectorizer. We should probably be; // accounting for whether we actually have instructions with the right; // lane type, but we don't have enough information to do that without; // some additional plumbing which hasn't been justified yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:167,Performance,scalab,scalable,167,"/// This function returns an estimate for VL to be used in VL based terms; /// of the cost model. For fixed length vectors, this is simply the; /// vector length. For scalable vectors, we return results consistent; /// with getVScaleForTuning under the assumption that clients are also; /// using that when comparing costs between scalar and vector representation.; /// This does unfortunately mean that we can both undershoot and overshot; /// the true cost significantly if getVScaleForTuning is wildly off for the; /// actual target hardware.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:132,Usability,simpl,simply,132,"/// This function returns an estimate for VL to be used in VL based terms; /// of the cost model. For fixed length vectors, this is simply the; /// vector length. For scalable vectors, we return results consistent; /// with getVScaleForTuning under the assumption that clients are also; /// using that when comparing costs between scalar and vector representation.; /// This does unfortunately mean that we can both undershoot and overshot; /// the true cost significantly if getVScaleForTuning is wildly off for the; /// actual target hardware.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:23,Security,access,accessing,23,/// Return the cost of accessing a constant pool entry of the specified; /// type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:190,Performance,tune,tuned,190,// Epilogue vectorization is usually unprofitable - tail folding or; // a smaller VF would have been better. This a blunt hammer - we; // should re-examine this once vectorization is better tuned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:13,Availability,mask,masked,13,// Scalarize masked gather for RV64 if EEW=64 indices aren't supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:13,Availability,mask,masked,13,// Scalarize masked scatter for RV64 if EEW=64 indices aren't supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:57,Performance,scalab,scalable,57,// Don't interleave if the loop has been vectorized with scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:120,Availability,mask,mask,120,"// Although there are 32 vector registers, v0 is special in that it is the; // only register that can be used to hold a mask.; // FIXME: Should we conservatively return 31 as the number of usable; // vector registers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:189,Usability,usab,usable,189,"// Although there are 32 vector registers, v0 is special in that it is the; // only register that can be used to hold a mask.; // FIXME: Should we conservatively return 31 as the number of usable; // vector registers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:120,Performance,perform,performed,120,"// Helper to actually emit an instruction to the MCStreamer. Also, when; // possible, compression of the instruction is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:25,Performance,load,load,25,// Helper to emit pseudo load/store instruction with a symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:35,Modifiability,extend,extend,35,// Helper to emit pseudo sign/zero extend instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:222,Performance,perform,performed,222,"/// Helper for processing MC instructions that have been successfully matched; /// by MatchAndEmitInstruction. Modifications to the emitted instructions,; /// like the expansion of pseudo instructions (e.g., ""li""), can be performed; /// in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:150,Availability,error,error,150,/// Helper to reset target features for a new arch string. It; /// also records the new arch string that is expanded by RISCVISAInfo; /// and reports error for invalid arch string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:77,Availability,error,error,77,"// Use computeTargetABI to check if ABIName is valid. If invalid, output; // error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:83,Integrability,message,message,83,"// Use computeTargetABI to check if ABIName is valid. If invalid, output; // error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:54,Modifiability,extend,extend,54,"// If this a RV32 and the immediate is a uimm32, sign extend it to 32 bits.; // This allows writing 'addi a0, a0, 0xffffffff'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:28,Availability,error,error,28,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:34,Integrability,message,message,34,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:151,Availability,failure,failure,151,"// Attempts to match Name as a register (either using the default name or; // alternative ABI names), setting RegNo to the matching register. Upon; // failure, returns a non-valid MCRegister. If IsRVE, then registers x16-x31; // will be rejected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:3,Safety,Avoid,Avoid,3,"// Avoid parsing the register in `call rd, foo` as a call symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:307,Testability,log,logical,307,"// Parsing jal operands is fiddly due to the `jal foo` and `jal ra, foo`; // both being acceptable forms. When parsing `jal ra, foo` this function; // will be called for the `ra` register operand in an attempt to match the; // single-operand alias. parseJALOffset must fail for this case. It would; // seem logical to try parse the operand using parseImmediate and return; // NoMatch if the next token is a comma (meaning we must be parsing a jal in; // the second form rather than the first). We can't do this as there's no; // way of rewinding the lexer state. Instead, return NoMatch if this operand; // is an identifier and is followed by a comma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:52,Availability,error,error,52,"// Create a RISCVOperand for checking later (so the error messages are; // nicer), but we don't add it to Operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:58,Integrability,message,messages,58,"// Create a RISCVOperand for checking later (so the error messages are; // nicer), but we don't add it to Operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:57,Availability,error,error,57,// Deferred Handling of non-zero offsets. This makes the error messages nicer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:63,Integrability,message,messages,63,// Deferred Handling of non-zero offsets. This makes the error messages nicer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:177,Availability,reliab,reliably,177,"// Ensure that if the instruction occurs when relaxation is enabled,; // relocations are forced for the file. Ideally this would be done when there; // is enough information to reliably determine if the instruction itself may; // cause relaxations. Unfortunately instruction processing stage occurs in the; // same pass as relocation emission, so it's too late to set a 'sticky bit'; // for the entire file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:85,Integrability,depend,depend,85,// It is invalid to disable an extension that there are other enabled; // extensions depend on it.; // TODO: Make use of RISCVISAInfo to handle this,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load local address pseudo-instruction ""lla"" is used in PC-relative; // addressing of local symbols:; // lla rdest, symbol; // expands to; // TmpLabel: AUIPC rdest, %pcrel_hi(symbol); // ADDI rdest, rdest, %pcrel_lo(TmpLabel)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load global address pseudo-instruction ""lga"" is used in GOT-indirect; // addressing of global symbols:; // lga rdest, symbol; // expands to; // TmpLabel: AUIPC rdest, %got_pcrel_hi(symbol); // Lx rdest, %pcrel_lo(TmpLabel)(rdest)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load address pseudo-instruction ""la"" is used in PC-relative and; // GOT-indirect addressing of global symbols:; // la rdest, symbol; // is an alias for either (for non-PIC); // lla rdest, symbol; // or (for PIC); // lga rdest, symbol",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load TLS IE address pseudo-instruction ""la.tls.ie"" is used in; // initial-exec TLS model addressing of global symbols:; // la.tls.ie rdest, symbol; // expands to; // TmpLabel: AUIPC rdest, %tls_ie_pcrel_hi(symbol); // Lx rdest, %pcrel_lo(TmpLabel)(rdest)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load TLS GD address pseudo-instruction ""la.tls.gd"" is used in; // global-dynamic TLS model addressing of global symbols:; // la.tls.gd rdest, symbol; // expands to; // TmpLabel: AUIPC rdest, %tls_gd_pcrel_hi(symbol); // ADDI rdest, rdest, %pcrel_lo(TmpLabel)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:7,Performance,load,load,7,"// The load/store pseudo-instruction does a pc-relative load with; // a symbol.; //; // The expansion looks like this; //; // TmpLabel: AUIPC tmp, %pcrel_hi(symbol); // [S|L]X rd, %pcrel_lo(TmpLabel)(tmp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:56,Performance,load,load,56,"// The load/store pseudo-instruction does a pc-relative load with; // a symbol.; //; // The expansion looks like this; //; // TmpLabel: AUIPC tmp, %pcrel_hi(symbol); // [S|L]X rd, %pcrel_lo(TmpLabel)(tmp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:87,Integrability,depend,dependent,87,"// The sign/zero extend pseudo-instruction does two shifts, with the shift; // amounts dependent on the XLEN.; //; // The expansion looks like this; //; // SLLI rd, rs, XLEN - Width; // SR[A|R]I rd, rd, XLEN - Width",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:17,Modifiability,extend,extend,17,"// The sign/zero extend pseudo-instruction does two shifts, with the shift; // amounts dependent on the XLEN.; //; // The expansion looks like this; //; // SLLI rd, rs, XLEN - Width; // SR[A|R]I rd, rd, XLEN - Width",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:3,Availability,mask,masked,3,"// masked va >= x, vd != v0; //; // pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t; // expansion: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:3,Availability,mask,masked,3,"// masked va >= x, vd == v0; //; // pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t, vt; // expansion: vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:3,Availability,mask,masked,3,"// masked va >= x, any vd; //; // pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t, vt; // expansion: vmslt{u}.vx vt, va, x; vmandn.mm vt, v0, vt;; // vmandn.mm vd, vd, v0; vmor.mm vd, vt, vd",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:62,Performance,load,load,62,// The encoding with rd1 == rd2 == rs1 is reserved for XTHead load pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:78,Integrability,depend,depending,78,// The last operand of XTHeadMemPair instructions must be constant 3 or 4; // depending on the data width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:60,Availability,mask,mask,60,"// vadc, vsbc are special cases. These instructions have no mask register.; // The destination register could not be V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:14,Availability,mask,masked,14,"// Regardless masked or unmasked version, the number of operands is the; // same. For example, ""viota.m v0, v2"" is ""viota.m v0, v2, NoRegister""; // actually. We need to check the last operand to ensure whether it is; // masked or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:220,Availability,mask,masked,220,"// Regardless masked or unmasked version, the number of operands is the; // same. For example, ""viota.m v0, v2"" is ""viota.m v0, v2, NoRegister""; // actually. We need to check the last operand to ensure whether it is; // masked or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:112,Performance,perform,performed,112,// On RV32 the immediate here can either be a signed or an unsigned; // 32-bit number. Sign extension has to be performed to ensure that Imm; // represents the expected signed 64-bit number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp:8,Modifiability,extend,extend,8,// Sign-extend the number in the bottom N bits of Imm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp:8,Modifiability,extend,extend,8,// Sign-extend the number in the bottom N bits of Imm after accounting for; // the fact that the N bit immediate is stored in N-1 bits (the LSB is; // always zero),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp:3,Performance,Cache,Cache,3,// Cache the SP register vreg if we need it more than once in this call site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp:19,Performance,scalab,scalable,19,/// Return true if scalable vector with ScalarTy is legal for lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp:24,Energy Efficiency,allocate,allocated,24,"// If all registers are allocated, then all varargs must be passed on the; // stack and we don't need to save any argregs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument which is a value; // necessary to G_VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:172,Modifiability,variab,variable,172,"// FIXME: This is necessary because DAGISel uses ""Subtarget->"" and GlobalISel; // uses ""STI."" in the code generated by TableGen. We need to unify the name of; // Subtarget variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:47,Availability,mask,mask,47,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:33,Performance,optimiz,optimized,33,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:3,Usability,Simpl,SimplifyDemandedBits,3,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:80,Safety,avoid,avoid,80,"// If we are shifting by X+N where N == 0 mod Size, then just shift by X; // to avoid the ADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:21,Availability,mask,mask,21,"// (and (shl y, c2), mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:22,Availability,mask,mask,22,"// (and (lshr y, c2), mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:27,Availability,mask,mask,27,"// Given (and (shl y, c2), mask) in which mask has no leading zeros and; // c3 trailing zeros. We can use an SRLI by c3 - c2 followed by a SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:42,Availability,mask,mask,42,"// Given (and (shl y, c2), mask) in which mask has no leading zeros and; // c3 trailing zeros. We can use an SRLI by c3 - c2 followed by a SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:28,Availability,mask,mask,28,"// Given (and (lshr y, c2), mask) in which mask has c2 leading zeros and; // c3 trailing zeros. We can use an SRLI by c2 + c3 followed by a SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:43,Availability,mask,mask,43,"// Given (and (lshr y, c2), mask) in which mask has c2 leading zeros and; // c3 trailing zeros. We can use an SRLI by c2 + c3 followed by a SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:16,Availability,mask,mask,16,"// (shl (and y, mask), c2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:17,Availability,mask,mask,17,"// (lshr (and y, mask), c2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:22,Availability,mask,mask,22,"// Given (shl (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c1 + c3 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:42,Availability,mask,mask,42,"// Given (shl (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c1 + c3 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:23,Availability,mask,mask,23,"// Given (lshr (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c3 - c1 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:43,Availability,mask,mask,43,"// Given (lshr (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c3 - c1 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:27,Availability,mask,mask,27,"// Given (and (shl x, c2), mask) in which mask is a shifted mask with; // 32 - ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2 - ShAmt followed by SHXADD_UW with ShAmt for x amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:42,Availability,mask,mask,42,"// Given (and (shl x, c2), mask) in which mask is a shifted mask with; // 32 - ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2 - ShAmt followed by SHXADD_UW with ShAmt for x amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:60,Availability,mask,mask,60,"// Given (and (shl x, c2), mask) in which mask is a shifted mask with; // 32 - ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2 - ShAmt followed by SHXADD_UW with ShAmt for x amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:61,Performance,Optimiz,Optimize,61,// TODO: Use constant pool for complext constants.; // TODO: Optimize +0.0 to use fcvt.d.w for s64 on rv32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:45,Modifiability,variab,variables,45,"// When HWASAN is used and tagging of global variables is enabled; // they should be accessed via the GOT, since the tagged address of a global; // is incompatible with existing code models. This also applies to non-pic; // mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:85,Security,access,accessed,85,"// When HWASAN is used and tagging of global variables is enabled; // they should be accessed via the GOT, since the tagged address of a global; // is incompatible with existing code models. This also applies to non-pic; // mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the symbol. This generates the; // pattern (PseudoLLA sym), which expands to (addi (auipc %pcrel_hi(sym)); // %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:74,Performance,load,load,74,"// Use PC-relative addressing to access the GOT for this symbol, then; // load the address from the GOT. This generates the pattern (PseudoLGA; // sym), which expands to (ld (addi (auipc %got_pcrel_hi(sym)); // %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:33,Security,access,access,33,"// Use PC-relative addressing to access the GOT for this symbol, then; // load the address from the GOT. This generates the pattern (PseudoLGA; // sym), which expands to (ld (addi (auipc %got_pcrel_hi(sym)); // %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:136,Security,access,access,136,"// An extern weak symbol may be undefined, i.e. have value 0, which may; // not be within 2GiB of PC, so use GOT-indirect addressing to access the; // symbol. This generates the pattern (PseudoLGA sym), which expands to; // (ld (addi (auipc %got_pcrel_hi(sym)) %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:27,Security,access,accessing,27,"// Generate a sequence for accessing addresses within any 2GiB range; // within the address space. This generates the pattern (PseudoLLA sym),; // which expands to (addi (auipc %pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:28,Integrability,synchroniz,synchronize,28,"// singlethread fences only synchronize with signal handlers on the same; // thread and thus only need to preserve instruction order, not actually; // enforce memory ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:9,Deployability,release,release,9,"// fence release -> fence rw, w",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp:3,Performance,Load,Load,3,// Load the source va_list,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp:67,Usability,simpl,simply,67,"// Turn LLVM IR's floating point classes to that in RISC-V,; // by simply rotating the 10-bit immediate right by two bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:185,Modifiability,refactor,refactor,185,"/// Returns whether opcode \p Opc is a pre-isel generic floating-point opcode,; /// having only floating-point operands.; /// FIXME: this is copied from target AArch64. Needs some code refactor here to; /// put this function in GlobalISel/Utils.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:19,Testability,log,logic,19,// Try the default logic for non-generic instructions that are either copies; // or already have some operands assigned to banks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:21,Performance,load,loads,21,// Use FPR64 for s64 loads on rv32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:17,Performance,load,load,17,"// Check if that load feeds fp instructions.; // In that case, we want the default mapping to be on FPR; // instead of blind map every scalar to GPR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp:96,Performance,load,load,96,"// If we have at least one direct use in a FP instruction,; // assume this was a floating point load in the IR. If it was; // not, we would have had a bitcast before reaching that; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:3,Testability,assert,assertion,3,// assertion prevents us from needing llvm_unreachable in the StringSwitch; // below,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:3,Testability,assert,assertion,3,// assertion prevents us from needing llvm_unreachable in the StringSwitch; // below,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:126,Integrability,depend,depends,126,"// getBaseInfo works with (Opcode, LMUL, 0) if no SEW instrument,; // or (Opcode, LMUL, SEW) if SEW instrument is active, and depends on LMUL; // and SEW, or (Opcode, LMUL, 0) if does not depend on SEW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:188,Integrability,depend,depend,188,"// getBaseInfo works with (Opcode, LMUL, 0) if no SEW instrument,; // or (Opcode, LMUL, SEW) if SEW instrument is active, and depends on LMUL; // and SEW, or (Opcode, LMUL, 0) if does not depend on SEW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:15,Integrability,depend,depends,15,// Check if it depends on LMUL and SEW,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp:15,Integrability,depend,depends,15,// Check if it depends only on LMUL,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h:615,Energy Efficiency,schedul,scheduling,615,"//===-------------------- RISCVCustomBehaviour.h -----------------*-C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines the RISCVCustomBehaviour class which inherits from; /// CustomBehaviour. This class is used by the tool llvm-mca to enforce; /// target specific behaviour that is not expressed well enough in the; /// scheduling model for mca to enforce it automatically.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h:451,Modifiability,inherit,inherits,451,"//===-------------------- RISCVCustomBehaviour.h -----------------*-C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines the RISCVCustomBehaviour class which inherits from; /// CustomBehaviour. This class is used by the tool llvm-mca to enforce; /// target specific behaviour that is not expressed well enough in the; /// scheduling model for mca to enforce it automatically.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCA/RISCVCustomBehaviour.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp:40,Modifiability,extend,extended,40,"// Jalr will add UpperImm with the sign-extended 12-bit LowerImm,; // we need to add 0x800ULL before extract upper bits to reflect the; // effect of the sign extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp:43,Availability,error,error,43,"// MCAssembler::evaluateFixup will emit an error for this case when it sees; // the %pcrel_hi, so don't duplicate it when also seeing the %pcrel_lo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp:80,Usability,simpl,simply,80,// Calculate total Nops we need to insert. If there are none to insert; // then simply return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp:6,Safety,avoid,avoid,6,"// To avoid the BP value clobbered by a function call, we need to choose a; // callee saved register to save the value. RV32E only has X8 and X9 as callee; // saved registers and X8 will be used as fp. So we choose X9 as bp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp:280,Availability,mask,mask,280,// namespace RISCVFeatures; // Encode VTYPE into the binary format used by the the VSETVLI instruction which; // is used by our MC layer representation.; //; // Bits | Name | Description; // -----+------------+------------------------------------------------; // 7 | vma | Vector mask agnostic; // 6 | vta | Vector tail agnostic; // 5:3 | vsew[2:0] | Standard element width (SEW) setting; // 2:0 | vlmul[2:0] | Vector register group multiplier (LMUL) setting,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:36,Availability,mask,mask,36,"// Does this instruction care about mask policy. If it is not, the mask policy; // could be either agnostic or undisturbed. For example, unmasked, store, and; // reduction operations result would not be affected by mask policy, so; // compiler has free to select either one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:67,Availability,mask,mask,67,"// Does this instruction care about mask policy. If it is not, the mask policy; // could be either agnostic or undisturbed. For example, unmasked, store, and; // reduction operations result would not be affected by mask policy, so; // compiler has free to select either one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:215,Availability,mask,mask,215,"// Does this instruction care about mask policy. If it is not, the mask policy; // could be either agnostic or undisturbed. For example, unmasked, store, and; // reduction operations result would not be affected by mask policy, so; // compiler has free to select either one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:52,Modifiability,extend,extended,52,"// Indicates that the result can be considered sign extended from bit 31. Some; // instructions with this flag aren't W instructions, but are either sign; // extended from a smaller size, always outputs a small integer, or put zeros; // in bits 63:31. Used by the SExtWRemoval pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:158,Modifiability,extend,extended,158,"// Indicates that the result can be considered sign extended from bit 31. Some; // instructions with this flag aren't W instructions, but are either sign; // extended from a smaller size, always outputs a small integer, or put zeros; // in bits 63:31. Used by the SExtWRemoval pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:21,Availability,mask,mask,21,/// \returns true if mask policy is valid for the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:142,Availability,mask,mask,142,// Is the first def operand tied to the first use operand. This is true for; // vector pseudo instructions that have a merge operand for tail/mask; // undisturbed. It's also true for vector FMA instructions where one of the; // operands is also the destination register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:65,Security,Access,Access,65,"// FIXME: add these additional fields when needed.; // Privilege Access: Read, Write, Read-Only.; // unsigned ReadWrite;; // Privilege Mode: User, System or Machine.; // unsigned Mode;; // Check field name.; // unsigned Extra;; // Register number without the privilege bits.; // unsigned Number;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:3,Security,Validat,Validates,3,// Validates if the given combination of features are valid for the target; // triple. Exits with report_fatal_error if not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp:36,Deployability,update,update,36,"// TODO: this is very conservative, update once RISC-V psABI requirements; // are clarified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Integrability,Depend,Depending,3,"// Depending on the active bits in the immediate Value v, the following; // instruction sequences are emitted:; //; // v == 0 : ADDI; // v[0,12) != 0 && v[12,32) == 0 : ADDI; // v[0,12) == 0 && v[12,32) != 0 : LUI; // v[0,32) != 0 : LUI+ADDI(W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:576,Modifiability,extend,extended,576,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:560,Performance,perform,performs,560,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:959,Performance,perform,performed,959,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:1398,Performance,perform,performed,1398,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:376,Usability,simpl,simply,376,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:67,Energy Efficiency,reduce,reduce,67,"// If the remaining bits don't fit in 12 bits, we might be able to reduce the; // shift amount in order to use LUI which will zero the lower 12 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the shift amount and add zeros to the LSBs so it will match LUI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Energy Efficiency,Reduce,Reduce,3,"// Reduce the shift amount and add zeros to the LSBs so it will match; // LUI, then shift left with SLLI.UW to clear the upper 32 set bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:111,Usability,clear,clear,111,"// Reduce the shift amount and add zeros to the LSBs so it will match; // LUI, then shift left with SLLI.UW to clear the upper 32 set bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:40,Usability,clear,clear,40,"// Use LUI+ADDI or LUI to compose, then clear the upper 32 bits with; // SLLI_UW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:102,Availability,mask,masks,102,// Fill in the bits that will be shifted out with 1s. An example where this; // helps is trailing one masks with 32 or more ones. This will generate; // ADDI -1 and an SRLI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:142,Modifiability,extend,extended,142,"// If the low 12 bits are non-zero, the first expansion may end with an ADDI; // or ADDIW. If there are trailing zeros, try generating a sign extended; // constant with no trailing zeros and use a final SLLI to restore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:81,Performance,optimiz,optimizations,81,"// If the constant is negative, trying inverting and using our trailing zero; // optimizations. Use an xori to invert the final value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Performance,Perform,Perform,3,// Perform optimization with BCLRI/BSETI in the Zbs extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:11,Performance,optimiz,optimization,11,// Perform optimization with BCLRI/BSETI in the Zbs extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Usability,Clear,Clear,3,// Clear lowest set bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Performance,Perform,Perform,3,// Perform optimization with SH*ADD in the Zba extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:11,Performance,optimiz,optimization,11,// Perform optimization with SH*ADD in the Zba extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:123,Performance,optimiz,optimization,123,// For Val that has zero Lo12 (implies Val equals to Hi52) should has; // already been processed to LUI+SH*ADD by previous optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Performance,Perform,Perform,3,// Perform optimization with rori in the Zbb and th.srri in the XTheadBb; // extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:11,Performance,optimiz,optimization,11,// Perform optimization with rori in the Zbb and th.srri in the XTheadBb; // extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.h:163,Usability,simpl,simple,163,// Helper to generate an instruction sequence that will materialise the given; // immediate value into a register. A sequence of instructions represented by a; // simple struct is produced rather than directly emitting the instructions in; // order to allow this helper to be used from both the MC layer and during; // instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp:30,Usability,simpl,simple,30,// Expand PseudoAddTPRel to a simple ADD with the correct relocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp:250,Availability,error,error,250,// tprel_add is only used to indicate that a relocation should be emitted; // for an add instruction used in TP-relative addressing. It should not be; // expanded as if representing an actual instruction operand and so to; // encounter it here is an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp:3,Usability,Clear,Clear,3,// Clear the state of all defined registers for instructions that we don't; // explicitly support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp:393,Usability,simpl,simple,393,"//===-- DelaySlotFiller.cpp - SPARC delay slot filler ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a simple local pass that attempts to fill delay slots with useful; // instructions. If no instructions can be moved into the delay slot, then a; // NOP is placed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp:57,Modifiability,extend,extended,57,"// TODO: If we ever want to support v7, this needs to be extended; // to cover all floating point operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp:3,Testability,assert,assert,3,"// assert that MBBI is a ""restore %g0, %g0, %g0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/DelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:232,Performance,Load,Load,232,//*****************************************************************************; //**** InsertNOPLoad pass; //*****************************************************************************; // This pass fixes the incorrectly working Load instructions that exists for; // some earlier versions of the LEON processor line. NOP instructions must; // be inserted after the load instruction to ensure that the Load instruction; // behaves as expected for these processors.; //; // This pass inserts a NOP after any LD or LDF instruction.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:368,Performance,load,load,368,//*****************************************************************************; //**** InsertNOPLoad pass; //*****************************************************************************; // This pass fixes the incorrectly working Load instructions that exists for; // some earlier versions of the LEON processor line. NOP instructions must; // be inserted after the load instruction to ensure that the Load instruction; // behaves as expected for these processors.; //; // This pass inserts a NOP after any LD or LDF instruction.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:404,Performance,Load,Load,404,//*****************************************************************************; //**** InsertNOPLoad pass; //*****************************************************************************; // This pass fixes the incorrectly working Load instructions that exists for; // some earlier versions of the LEON processor line. NOP instructions must; // be inserted after the load instruction to ensure that the Load instruction; // behaves as expected for these processors.; //; // This pass inserts a NOP after any LD or LDF instruction.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:88,Safety,Detect,DetectRoundChange,88,"//*****************************************************************************; //**** DetectRoundChange pass; //*****************************************************************************; // To prevent any explicit change of the default rounding mode, this pass; // detects any call of the fesetround function.; // A warning is generated to ensure the user knows this has happened.; //; // Detects an erratum in UT699 LEON 3 processor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:271,Safety,detect,detects,271,"//*****************************************************************************; //**** DetectRoundChange pass; //*****************************************************************************; // To prevent any explicit change of the default rounding mode, this pass; // detects any call of the fesetround function.; // A warning is generated to ensure the user knows this has happened.; //; // Detects an erratum in UT699 LEON 3 processor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:395,Safety,Detect,Detects,395,"//*****************************************************************************; //**** DetectRoundChange pass; //*****************************************************************************; // To prevent any explicit change of the default rounding mode, this pass; // detects any call of the fesetround function.; // A warning is generated to ensure the user knows this has happened.; //; // Detects an erratum in UT699 LEON 3 processor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:726,Deployability,pipeline,pipeline,726,"//*****************************************************************************; //**** FixAllFDIVSQRT pass; //*****************************************************************************; // This pass fixes the incorrectly working FDIVx and FSQRTx instructions that; // exist for some earlier versions of the LEON processor line. Five NOP; // instructions need to be inserted after these instructions to ensure the; // correct result is placed in the destination registers before they are used.; //; // This pass implements two fixes:; // 1) fixing the FSQRTS and FSQRTD instructions.; // 2) fixing the FDIVS and FDIVD instructions.; //; // FSQRTS and FDIVS are converted to FDIVD and FSQRTD respectively earlier in; // the pipeline when this option is enabled, so this pass needs only to deal; // with the changes that still need implementing for the ""double"" versions; // of these instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:208,Deployability,pipeline,pipeline,208,// Note: FDIVS and FSQRTS cannot be generated when this erratum fix is; // switched on so we don't need to check for them here. They will; // already have been converted to FSQRTD or FDIVD earlier in the; // pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.h:44,Energy Efficiency,allocate,allocate,44,// this vector holds free registers that we allocate in groups for some of the; // LEON passes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h:28,Integrability,interface,interface,28,"//===-- Sparc.h - Top-level interface for Sparc representation --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // Sparc back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h:9,Usability,Clear,Clear,9,// Carry Clear/Great or Equal Unsigned,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h:12,Usability,Clear,Clear,12,// Overflow Clear,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Sparc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- SparcAsmPrinter.cpp - Sparc LLVM assembly writer ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to GAS-format SPARC assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp:8,Performance,load,load,8,// Just load the address of GOT to MCRegOP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp:23,Performance,load,load,23,// Use register %o7 to load the lower 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp:100,Performance,optimiz,optimization,100,"// TODO find out whether it is possible to store PC; // in other registers, to enable leaf function optimization.; // (On the other hand, approx. over 97.8% of GETPCXes happen; // in non-leaf functions, so would this be worth the effort?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:72,Availability,avail,available,72,// Emit this the hard way. This clobbers G1 which we always know is; // available here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:3,Deployability,Update,Update,3,// Update stack size with corrected value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:44,Availability,avail,available,44,// This clobbers G1 which we always know is available here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:38,Modifiability,variab,variable,38,// Reserve call frame if there are no variable sized objects on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:134,Modifiability,variab,variable,134,// hasFP - Return true if the specified function should have a dedicated frame; // pointer register. This is true if the function has variable sized allocas or; // if frame pointer elimination is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:33,Security,access,accessed,33,"// Addressable stack objects are accessed using neg. offsets from; // %fp, or positive offsets from %sp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:149,Availability,avail,available,149,"// Sparc uses FP-based references in general, even when ""hasFP"" is; // false. That function is rather a misnomer, because %fp is; // actually always available, unless isLeafProc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:23,Security,access,access,23,"// Otherwise, argument access should always use %fp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite MBB's Live-ins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:493,Energy Efficiency,allocate,allocated,493,"// Re-assemble i64 arguments split up in SelectionDAGBuilder's; // visitInlineAsm / GetRegistersForValue functions.; //; // Note: This function was copied from, and is essentially identical; // to ARMISelDAGToDAG::SelectInlineAsm. It is very unfortunate that; // such hacking-up is necessary; a rethink of how inline asm operands; // are handled may be in order to make doing this more sane.; //; // TODO: fix inline asm support so I can simply tell it that 'i64'; // inputs to asm need to be allocated to the IntPair register type,; // and have that work. Then, delete this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:438,Usability,simpl,simply,438,"// Re-assemble i64 arguments split up in SelectionDAGBuilder's; // visitInlineAsm / GetRegistersForValue functions.; //; // Note: This function was copied from, and is essentially identical; // to ARMISelDAGToDAG::SelectInlineAsm. It is very unfortunate that; // such hacking-up is necessary; a rethink of how inline asm operands; // are handled may be in order to make doing this more sane.; //; // TODO: fix inline asm support so I can simply tell it that 'i64'; // inputs to asm need to be allocated to the IntPair register type,; // and have that work. Then, delete this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the original glue user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:42,Security,expose,expose,42,// FIXME: should use a custom expander to expose the SRA to the dag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:114,Energy Efficiency,schedul,scheduling,114,"/// createSparcISelDag - This pass converts a legalized DAG into a; /// SPARC-specific DAG, ready for instruction scheduling.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:408,Integrability,interface,interfaces,408,"//===-- SparcISelLowering.cpp - Sparc DAG Lowering Implementation ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interfaces that Sparc uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a full-sized argument for the 64-bit ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:18,Energy Efficiency,allocate,allocated,18,// Stack space is allocated for all arguments starting from [%fp+BIAS+128].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate a half-sized argument for the 64-bit ABI.; //; // This is used when passing { float, int } structs by value in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:46,Modifiability,extend,extended,46,// Integer return values must be sign or zero extended by the callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the flag if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:44,Usability,simpl,simple,44,"/// LowerFormalArguments32 - V8 uses a very simple ABI, where all values are; /// passed in either one or two GPRs, including FP values. TODO: we should; /// pass FP values in FP registers for fastcc functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:38,Performance,load,load,38,"// If it is double-word aligned, just load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:50,Testability,Assert,Assert,50,"// The caller promoted the argument, so insert an Assert?ext SDNode so we; // won't promote the value again in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:25,Availability,down,down,25,// Truncate the register down to the argument type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:21,Modifiability,extend,extended,21,"// Adjust offset for extended arguments, SPARC is big-endian.; // The caller will have written the full slot with extended bytes, but we; // prefer our own extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:114,Modifiability,extend,extended,114,"// Adjust offset for extended arguments, SPARC is big-endian.; // The caller will have written the full slot with extended bytes, but we; // prefer our own extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:156,Modifiability,extend,extending,156,"// Adjust offset for extended arguments, SPARC is big-endian.; // The caller will have written the full slot with extended bytes, but we; // prefer our own extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:166,Performance,load,loads,166,"// Adjust offset for extended arguments, SPARC is big-endian.; // The caller will have written the full slot with extended bytes, but we; // prefer our own extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:23,Modifiability,variab,variable,23,"// This function takes variable arguments, some of which may have been passed; // in registers %i0-%i5. Variable floating point arguments are never passed; // in floating point registers. They go on %i0-%i5 or on the stack like; // integer arguments.; //; // The va_start intrinsic needs to know the offset to the first variable; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:104,Modifiability,Variab,Variable,104,"// This function takes variable arguments, some of which may have been passed; // in registers %i0-%i5. Variable floating point arguments are never passed; // in floating point registers. They go on %i0-%i5 or on the stack like; // integer arguments.; //; // The va_start intrinsic needs to know the offset to the first variable; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:320,Modifiability,variab,variable,320,"// This function takes variable arguments, some of which may have been passed; // in registers %i0-%i5. Variable floating point arguments are never passed; // in floating point registers. They go on %i0-%i5 or on the stack like; // integer arguments.; //; // The va_start intrinsic needs to know the offset to the first variable; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:12,Modifiability,variab,variable,12,// Save the variable arguments that were passed in registers.; // The caller is required to reserve stack space for 6 arguments regardless; // of how many arguments were actually passed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:94,Performance,optimiz,optimization,94,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:143,Energy Efficiency,allocate,allocate,143,// Do not tail call opt if the stack is used to pass parameters.; // 64-bit targets have a slightly higher limit since the ABI requires; // to allocate some space even when all the parameters fit inside registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:99,Safety,avoid,avoid,99,// Adjust the stack pointer to make room for the arguments.; // FIXME: Use hasReservedCallFrame to avoid %sp adjustments around all calls; // with more than 6 arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Performance,Load,Load,3,// Load into Reg and Reg+1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:174,Safety,avoid,avoid,174,"// When returning 'inreg {i32, i32 }', two consecutive i32 arguments can; // reside in the same register in the high and low bits. Reuse the; // CopyFromReg previous node to avoid duplicate copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:54,Testability,Assert,Assert,54,"// The callee promoted the return value, so insert an Assert?ext SDNode so; // we won't promote the value again in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:25,Availability,down,down,25,// Truncate the register down to the return value type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:14,Modifiability,extend,extending,14,// Truncating/extending stores/loads are also not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:31,Performance,load,loads,31,// Truncating/extending stores/loads are also not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:12,Performance,load,load,12,"// However, load and store *are* legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:30,Performance,load,loads,30,// And we need to promote i64 loads/stores into vector load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:55,Performance,load,load,55,// And we need to promote i64 loads/stores into vector load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:56,Performance,LOAD,LOAD,56,"// Sadly, this doesn't work:; // AddPromotedToType(ISD::LOAD, MVT::i64, MVT::v2i32);; // AddPromotedToType(ISD::STORE, MVT::i64, MVT::v2i32);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:24,Performance,load,load,24,// Turn FP extload into load/fpextend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:30,Modifiability,extend,extending,30,// Sparc doesn't have i1 sign extending load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:40,Performance,load,load,40,// Sparc doesn't have i1 sign extending load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:23,Performance,LOAD,LOAD,23,// Custom Lower Atomic LOAD/STORE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:26,Availability,avail,available,26,// These libcalls are not available in 32-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:49,Security,access,accesses,49,// VAARG needs to be lowered to not do unaligned accesses for doubles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:58,Availability,Mask,Mask,58,/// isMaskedValueZeroForTargetNode - Return true if 'Op & Mask' is known to; /// be zero. Op is expected to be a target specific node. Used by DAG; /// combiner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:59,Modifiability,variab,variable,59,// Handle PIC mode first. SPARC needs a got load for every variable!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:44,Performance,load,load,44,// Handle PIC mode first. SPARC needs a got load for every variable!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Performance,Load,Load,3,// Load RetPtr to get the return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Performance,Load,Load,3,// Load the actual argument out of the pointer VAList.; // We can't count on greater alignment than the word size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:16,Performance,load,load,16,// Lower a f128 load into two f64 loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:34,Performance,load,loads,34,// Lower a f128 load into two f64 loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:13,Performance,load,load,13,// Monotonic load/stores are legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:25,Availability,error,error,25,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:31,Integrability,message,message,31,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:25,Availability,error,error,25,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:31,Integrability,message,message,31,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the fN constraint according to the value type if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:42,Performance,load,load,42,"// Custom handling only for i64: turn i64 load into a v2i32 load,; // and a bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:60,Performance,load,load,60,"// Custom handling only for i64: turn i64 load into a v2i32 load,; // and a bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:30,Modifiability,variab,variable,30,// Override to disable global variable loading on Linux.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:39,Performance,load,loading,39,// Override to disable global variable loading on Linux.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:49,Integrability,Interface,Interface,49,"//===-- SparcISelLowering.h - Sparc DAG Lowering Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Sparc uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- SparcISelLowering.h - Sparc DAG Lowering Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Sparc uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:41,Safety,predict,prediction,41,"// Branch to dest on icc condition, with prediction (64-bit only).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:41,Safety,predict,prediction,41,"// Branch to dest on xcc condition, with prediction (64-bit only).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:3,Performance,Load,Load,3,// Load operation w/ gdop relocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:82,Availability,Mask,Mask,82,/// computeKnownBitsForTargetNode - Determine which of the bits specified; /// in Mask are known to be either zero or one and return them in the; /// KnownZero/KnownOne bitsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:47,Performance,load,loading,47,/// Override to support customized stack guard loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp:38,Availability,avail,available,38,// Unaliased double registers are not available in non-V9 targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp:155,Integrability,depend,depending,155,"// Sparc has no architectural need for stack realignment support,; // except that LLVM unfortunately currently implements overaligned; // stack objects by depending upon stack realignment support.; // If that ever changes, this can probably be deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp:310,Security,access,access,310,"// Sparc always has a fixed frame pointer register, so don't need to; // worry about needing to reserve it. [even if we don't have a frame; // pointer for our frame, it still cannot be used for other things,; // or register window traps will be SADNESS.]; // If there's a reserved call frame, we can use SP to access locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcSubtarget.h:43,Availability,avail,available,43,// ReserveRegister[i] - Register #i is not available as a general purpose; // register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp:30,Deployability,Configurat,Configuration,30,/// Sparc Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp:30,Modifiability,Config,Configuration,30,/// Sparc Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp:29,Testability,stub,stub,29,// Add information about the stub reference to ELFMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp:66,Testability,stub,stub,66,// Add information about the stub reference to ELFMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:17,Integrability,interface,interface,17,/// }; // public interface of the MCTargetAsmParser.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:285,Usability,clear,clearing,285,"// The low bits require touching in 3 cases:; // * A non-immediate value will always require both instructions.; // * An effectively imm13 value needs only an 'or' instruction.; // * Otherwise, an immediate that is not effectively imm13 requires the; // 'or' only if bits remain after clearing the 22 bits that 'sethi' set.; // If the low bits are known zeros, there's nothing to do.; // In the second case, and only in that case, must we NOT clear; // bits of the immediate value via the %lo() assembler function.; // Note also, the 'or' instruction doesn't mind a large value in the case; // where the operand to 'set' was 0xFFFFFzzz - it does exactly what you mean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:443,Usability,clear,clear,443,"// The low bits require touching in 3 cases:; // * A non-immediate value will always require both instructions.; // * An effectively imm13 value needs only an 'or' instruction.; // * Otherwise, an immediate that is not effectively imm13 requires the; // 'or' only if bits remain after clearing the 22 bits that 'sethi' set.; // If the low bits are known zeros, there's nothing to do.; // In the second case, and only in that case, must we NOT clear; // bits of the immediate value via the %lo() assembler function.; // Note also, the 'or' instruction doesn't mind a large value in the case; // where the operand to 'set' was 0xFFFFFzzz - it does exactly what you mean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:74,Performance,optimiz,optimization,74,"// For compatibility, ignore this directive.; // (It's supposed to be an ""optimization"" in the Sun assembler)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:107,Availability,error,error,107,"// If there wasn't a custom match, try the generic matcher below. Otherwise,; // there was a match, but an error occurred, in which case, just return that; // the operand parsing failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:11,Deployability,patch,patch,11,"// Here we patch the MEM operand from [base + %g0] into [base + 0]; // as memory operations with ASI tag stored in %asi register needs; // to use immediate offset. We need to do this because Reg addressing; // will be parsed as Reg+G0 initially.; // This allows forms such as `ldxa [%o0] %asi, %o0` to parse correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:208,Performance,Load,LoadASI,208,"// Eat the identifier.; // In this context, we convert the register operand into; // a plain ""%asi"" token since the register access is already; // implicit in the instruction definition and encoding.; // See LoadASI/StoreASI in SparcInstrInfo.td.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:125,Security,access,access,125,"// Eat the identifier.; // In this context, we convert the register operand into; // a plain ""%asi"" token since the register access is already; // implicit in the instruction definition and encoding.; // See LoadASI/StoreASI in SparcInstrInfo.td.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Disassembler/SparcDisassembler.cpp:78,Integrability,depend,depending,78,"// This is used for the type ""ptr_rc"", which is either IntRegs or I64Regs; // depending on SparcRegisterInfo::getPointerRegClass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/Disassembler/SparcDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/Disassembler/SparcDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp:39,Safety,Predict,Prediction,39,// A.3 Branch on Integer Register with Prediction (BPr); // Inst{21-20} = d16hi;; // Inst{13-0} = d16lo;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the bits; // from the fixup value. The Value has been ""split up"" into the; // appropriate bitfields above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRV.h:28,Integrability,interface,interface,28,"//===-- SPIRV.h - Top-level interface for SPIR-V representation -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRV.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRV.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- SPIRVAsmPrinter.cpp - SPIR-V LLVM assembly writer ------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the SPIR-V assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:43,Usability,clear,clear,43,// Emit OpFunctionEnd at the end of MF and clear BBNumToRegMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:74,Integrability,interface,interfaces,74,"// Before the OpEntryPoints' output, we need to add the entry point's; // interfaces. The interface is a list of IDs of global OpVariable instructions.; // These declare the set of global variables from a module that form; // the interface of this entry point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:90,Integrability,interface,interface,90,"// Before the OpEntryPoints' output, we need to add the entry point's; // interfaces. The interface is a list of IDs of global OpVariable instructions.; // These declare the set of global variables from a module that form; // the interface of this entry point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:230,Integrability,interface,interface,230,"// Before the OpEntryPoints' output, we need to add the entry point's; // interfaces. The interface is a list of IDs of global OpVariable instructions.; // These declare the set of global variables from a module that form; // the interface of this entry point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:188,Modifiability,variab,variables,188,"// Before the OpEntryPoints' output, we need to add the entry point's; // interfaces. The interface is a list of IDs of global OpVariable instructions.; // These declare the set of global variables from a module that form; // the interface of this entry point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:27,Integrability,interface,interface,27,"// Before version 1.4, the interface's storage classes are limited to; // the Input and Output storage classes. Starting with version 1.4,; // the interface's storage classes are all storage classes used in; // declaring all global variables referenced by the entry point call tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:147,Integrability,interface,interface,147,"// Before version 1.4, the interface's storage classes are limited to; // the Input and Output storage classes. Starting with version 1.4,; // the interface's storage classes are all storage classes used in; // declaring all global variables referenced by the entry point call tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:232,Modifiability,variab,variables,232,"// Before version 1.4, the interface's storage classes are limited to; // the Input and Output storage classes. Starting with version 1.4,; // the interface's storage classes are all storage classes used in; // declaring all global variables referenced by the entry point call tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:31,Integrability,interface,interface,31,// Output OpEntryPoints adding interface args to all of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:3,Safety,Abort,Abort,3,// Abort here if not all requirements can be satisfied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:50,Modifiability,variab,variable,50,// Process llvm.global.annotations special global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:73,Modifiability,variab,variable,73,// The first field of the struct contains a pointer to; // the annotated variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:40,Testability,Log,Logical,40,"// Output instructions according to the Logical Layout of a Module:; // 1,2. All OpCapability instructions, then optional OpExtension instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:100,Modifiability,variab,variable,100,"// 9. All type declarations (OpTypeXXX instructions), all constant; // instructions, and all global variable declarations. This section is; // the first section to allow use of: OpLine and OpNoLine debug information;; // non-semantic instructions with OpExtInst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:723,Integrability,Wrap,Wrapper,723,"// namespace SPIRV; //===----------------------------------------------------------------------===//; // Misc functions for looking up builtins and veryfying requirements using; // TableGen records; //===----------------------------------------------------------------------===//; /// Looks up the demangled builtin call in the SPIRVBuiltins.td records using; /// the provided \p DemangledCall and specified \p Set.; ///; /// The lookup follows the following algorithm, returning the first successful; /// match:; /// 1. Search with the plain demangled name (expecting a 1:1 match).; /// 2. Search with the prefix before or suffix after the demangled name; /// signyfying the type of the first argument.; ///; /// \returns Wrapper around the demangled call and found builtin definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:300,Integrability,depend,depending,300,//===----------------------------------------------------------------------===//; // Helper functions for building misc instructions; //===----------------------------------------------------------------------===//; /// Helper function building either a resulting scalar or vector bool register; /// depending on the expected \p ResultType.; ///; /// \returns Tuple of the resulting register and its type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:83,Integrability,depend,depending,83,/// Helper function for building either a vector or scalar select instruction; /// depending on the expected \p ResultType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:35,Performance,load,load,35,/// Helper function for building a load instruction loading into the; /// \p DestinationReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:52,Performance,load,loading,52,/// Helper function for building a load instruction loading into the; /// \p DestinationReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:86,Modifiability,variab,variable,86,/// Helper function for building a load instruction for loading a builtin global; /// variable of \p BuiltinValue value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:35,Performance,load,load,35,/// Helper function for building a load instruction for loading a builtin global; /// variable of \p BuiltinValue value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:56,Performance,load,loading,56,/// Helper function for building a load instruction for loading a builtin global; /// variable of \p BuiltinValue value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:34,Modifiability,variab,variable,34,// Load the value from the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:3,Performance,Load,Load,3,// Load the value from the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:43,Performance,load,load,43,/// Helper function for building an atomic load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:43,Performance,load,load,43,/// Helper function for building an atomic load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:14,Modifiability,extend,extended,14,// Lookup the extended instruction number in the TableGen records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:9,Modifiability,extend,extended,9,// Build extended instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:272,Integrability,depend,depending,272,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:312,Modifiability,extend,extending,312,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:1102,Modifiability,extend,extend,1102,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:686,Performance,load,loadedVec,686,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:813,Performance,load,loadedVec,813,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:911,Performance,load,loadedVec,911,"// These queries ask for a single size_t result for a given dimension index, e.g; // size_t get_global_id(uint dimindex). In SPIR-V, the builtins corresonding to; // these values are all vec3 types, so we need to extract the correct index or; // return defaultVal (0 or 1 depending on the query). We also handle extending; // or tuncating in case size_t does not match the expected result type's; // bitwidth.; //; // For a constant index >= 3 we generate:; // %res = OpConstant %SizeT 0; //; // For other indices we generate:; // %g = OpVariable %ptr_V3_SizeT Input; // OpDecorate %g BuiltIn XXX; // OpDecorate %g LinkageAttributes ""__spirv_BuiltInXXX""; // OpDecorate %g Constant; // %loadedVec = OpLoad %V3_SizeT %g; //; // Then, if the index is constant < 3, we generate:; // %res = OpCompositeExtract %SizeT %loadedVec idx; // If the index is dynamic, we generate:; // %tmp = OpVectorExtractDynamic %SizeT %loadedVec %idx; // %cmp = OpULessThan %bool %idx %const_3; // %res = OpSelect %SizeT %cmp %tmp %const_0; //; // If the bitwidth of %res does not match the expected return type, we add an; // extend or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:104,Integrability,depend,depending,104,"// If it's out of range (max dimension is 3), we can just return the constant; // default value (0 or 1 depending on which query function).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:39,Performance,load,load,39,"// If it could be in range, we need to load from the given builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:109,Performance,Load,LoadedVector,109,"// Use Intrinsic::spv_extractelt so dynamic vs static extraction is; // handled later: extr = spv_extractelt LoadedVector, IndexRegister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:46,Integrability,depend,depending,46,// Get constant for the default value (0 or 1 depending on which; // function).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:22,Modifiability,variab,variable,22,// Lookup the builtin variable record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:44,Modifiability,variab,variable,44,// Build a load instruction for the builtin variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:11,Performance,load,load,11,// Build a load instruction for the builtin variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:15,Usability,simpl,simplify,15,// TODO: Maybe simplify generation of the type of the fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:266,Modifiability,variab,variable,266,"// In principle, this information should be passed to us from Clang via; // an elementtype attribute. However, said attribute requires that; // the function call be an intrinsic, which is not. Instead, we rely on being; // able to trace this to the declaration of a variable: OpenCL C specification; // section 6.12.5 should guarantee that we can do this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:21,Performance,load,load,21,// Lookup the vector load/store builtin in the TableGen records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:9,Modifiability,extend,extended,9,// Build extended instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:33,Performance,load,load,33,// Add a pointer to the value to load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:3,Modifiability,Parameteriz,Parameterized,3,"// Parameterized SPIR-V builtins names follow this format:; // e.g. %spirv.Image._void_1_0_0_0_0_0_0, %spirv.Pipe._0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:533,Deployability,release,release,533,"// In LLVM IR, SPIR-V and OpenCL builtin types are represented as either; // target(...) target extension types or pointers-to-opaque-structs. The; // approach relying on structs is deprecated and works only in the non-opaque; // pointer mode (-opaque-pointers=0).; // In order to maintain compatibility with LLVM IR generated by older versions; // of Clang and LLVM/SPIR-V Translator, the pointers-to-opaque-structs are; // ""translated"" to target extension types. This translation is temporary and; // will be removed in the future release of LLVM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp:19,Security,access,access,19,// Read argument's access qualifier from metadata or default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp:102,Integrability,depend,dependencies,102,// Emit the type info and forward function declaration to the first MBB; // to ensure VReg definition dependencies are valid across all MBBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:89,Integrability,depend,dependency,89,"// The friend class needs to have access to the internal storage; // to be able to build dependency graph, can't declare only one; // function a 'friend' due to the incomplete declaration at this point; // and mutual dependency problems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:217,Integrability,depend,dependency,217,"// The friend class needs to have access to the internal storage; // to be able to build dependency graph, can't declare only one; // function a 'friend' due to the incomplete declaration at this point; // and mutual dependency problems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:34,Security,access,access,34,"// The friend class needs to have access to the internal storage; // to be able to build dependency graph, can't declare only one; // function a 'friend' due to the incomplete declaration at this point; // and mutual dependency problems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:52,Integrability,depend,dependency,52,"// NOTE: using MOs instead of regs to get rid of MF dependency to be able; // to use flat data structure.; // NOTE: replacing DenseMap with MapVector doesn't affect overall correctness; // but makes LITs more stable, should prefer DenseMap still due to; // significant perf difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp:364,Modifiability,variab,variable,364,"// This pass performs the following transformation on LLVM IR level required; // for the following translation to SPIR-V:; // - replaces direct usages of aggregate constants with target-specific; // intrinsics;; // - replaces aggregates-related instructions (extract/insert, ld/st, etc); // with a target-specific intrinsics;; // - emits intrinsics for the global variable initializers since IRTranslator; // doesn't handle them and it's not very convenient to translate them; // ourselves;; // - emits intrinsics to keep track of the string names assigned to the values;; // - emits intrinsics to keep track of constants (this is necessary to have an; // LLVM IR constant after the IRTranslation is completed) for their further; // deduplication;; // - emits intrinsics to keep track of original LLVM types of the values; // to be able to emit proper SPIR-V types eventually.; //; // TODO: consider removing spv.track.constant in favor of spv.assign.type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp:13,Performance,perform,performs,13,"// This pass performs the following transformation on LLVM IR level required; // for the following translation to SPIR-V:; // - replaces direct usages of aggregate constants with target-specific; // intrinsics;; // - replaces aggregates-related instructions (extract/insert, ld/st, etc); // with a target-specific intrinsics;; // - emits intrinsics for the global variable initializers since IRTranslator; // doesn't handle them and it's not very convenient to translate them; // ourselves;; // - emits intrinsics to keep track of the string names assigned to the values;; // - emits intrinsics to keep track of constants (this is necessary to have an; // LLVM IR constant after the IRTranslation is completed) for their further; // deduplication;; // - emits intrinsics to keep track of original LLVM types of the values; // to be able to emit proper SPIR-V types eventually.; //; // TODO: consider removing spv.track.constant in favor of spv.assign.type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp:26,Modifiability,variab,variable,26,// Skip special artifical variable llvm.global.annotations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVEmitIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:739,Modifiability,variab,variables,739,"//===-- SPIRVGlobalRegistry.cpp - SPIR-V Global Registry --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation of the SPIRVGlobalRegistry class,; // which is used to maintain rich type information required for SPIR-V even; // after lowering from LLVM IR to GMIR. It can convert an llvm::Type into; // an OpTypeXXX instruction, and map it to a virtual register. Also it builds; // and supports consistency of constants and global variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:79,Availability,error,error,79,// SpvScalConst should be created before SpvVecConst to avoid undefined ID; // error on validation.; // TODO: can moved below once sorting of types/consts/defs is implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:56,Safety,avoid,avoid,56,// SpvScalConst should be created before SpvVecConst to avoid undefined ID; // error on validation.; // TODO: can moved below once sorting of types/consts/defs is implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:88,Security,validat,validation,88,// SpvScalConst should be created before SpvVecConst to avoid undefined ID; // error on validation.; // TODO: can moved below once sorting of types/consts/defs is implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:84,Modifiability,variab,variable,84,"// If GV is not passed explicitly, use the name to find or construct; // the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:103,Safety,avoid,avoiding,103,"// ISel may introduce a new register on this step, so we need to add it to; // DT and correct its type avoiding fails on the next stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:20,Modifiability,variab,variable,20,"// If it's a global variable with name, output OpName for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h:677,Modifiability,variab,variables,677,"//===-- SPIRVGlobalRegistry.h - SPIR-V Global Registry ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SPIRVGlobalRegistry is used to maintain rich type information required for; // SPIR-V even after lowering from LLVM IR to GMIR. It can convert an llvm::Type; // into an OpTypeXXX instruction, and map it to a virtual register. Also it; // builds and supports consistency of constants and global variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h:56,Modifiability,variab,variables,56,// Return the number of bits SPIR-V pointers and size_t variables require.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp:1271,Integrability,rout,routine,1271,"// Analyze the branching code at the end of MBB, returning; // true if it cannot be understood (e.g. it's a switch dispatch or isn't; // implemented for a target). Upon success, this returns false and returns; // with the following information in various cases:; //; // 1. If this block ends with no branches (it just falls through to its succ); // just return false, leaving TBB/FBB null.; // 2. If this block ends with only an unconditional branch, it sets TBB to be; // the destination block.; // 3. If this block ends with a conditional branch and it falls through to a; // successor block, it sets TBB to be the branch destination block and a; // list of operands that evaluate the condition. These operands can be; // passed to other TargetInstrInfo methods to create new branches.; // 4. If this block ends with a conditional branch followed by an; // unconditional branch, it returns the 'true' destination in TBB, the; // 'false' destination in FBB, and a list of operands that evaluate the; // condition. These operands can be passed to other TargetInstrInfo; // methods to create new branches.; //; // Note that removeBranch and insertBranch must be implemented to support; // cases where this method returns success.; //; // If AllowModify is true, then this routine is allowed to modify the basic; // block (e.g. delete instructions after the unconditional branch).; //; // The CFG information in MBB.Predecessors and MBB.Successors must be valid; // before calling this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp:280,Safety,safe,safely,280,"// Actually we don't need this COPY instruction. However if we do nothing with; // it, post RA pseudo instrs expansion just removes it and we get the code; // with undef registers. Therefore, we need to replace all uses of dst with; // the src register. COPY instr itself will be safely removed later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:74,Modifiability,variab,variables,74,"// Currently, we get G_PTR_ADD only as a result of translating; // global variables, initialized with constant expressions like GV + Const; // (see test opencl/basic/progvar_prog_scope_init.ll).; // TODO: extend the handler once we have other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:205,Modifiability,extend,extend,205,"// Currently, we get G_PTR_ADD only as a result of translating; // global variables, initialized with constant expressions like GV + Const; // (see test opencl/basic/progvar_prog_scope_init.ll).; // TODO: extend the handler once we have other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:148,Testability,test,test,148,"// Currently, we get G_PTR_ADD only as a result of translating; // global variables, initialized with constant expressions like GV + Const; // (see test opencl/basic/progvar_prog_scope_init.ll).; // TODO: extend the handler once we have other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:60,Testability,test,test,60,// TODO: Changed as it's implemented in the translator. See test/atomicrmw.ll; // auto ScSem =; // getMemSemanticsForStorageClass(GR.getPointerStorageClass(Ptr));,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:388,Safety,safe,safe,388,"// In SPIR-V address space casting can only happen to and from the Generic; // storage class. We can also only case Workgroup, CrossWorkgroup, or Function; // pointers to and from Generic pointers. As such, we can convert e.g. from; // Workgroup to Function by going via a Generic pointer as an intermediary. All; // other combinations can only be done by a bitcast, and are probably not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:36,Safety,abort,abort,36,"// Return the logical operation, or abort if none exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:14,Testability,log,logical,14,"// Return the logical operation, or abort if none exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:6,Modifiability,extend,extend,6,"// To extend a bool, we need to use OpSelect between constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:188,Security,Access,AccessChain,188,"// OpAccessChain could be used for OpenCL, but the SPIRV-LLVM Translator only; // relies on PtrAccessChain, so we'll try not to deviate. For Vulkan however,; // we have to use Op[InBounds]AccessChain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:344,Usability,simpl,simply,344,"// InstructionSelector walks backwards through the instructions. For an; // explicit conditional branch with no fallthrough, we use both a G_BR and a; // G_BRCOND to create an OpBranchConditional. We should hit G_BR first, and; // generate the OpBranchConditional in selectBranch above.; //; // If an OpBranchConditional has been generated, we simply return, as the work; // is alread done. If there is no OpBranchConditional, LLVM must be relying on; // implicit fallthrough to the next basic block, so we need to create an; // OpBranchConditional with an explicit ""false"" argument pointing to the next; // basic block that LLVM would fall through to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:36,Testability,test,tests,36,// We have functions as operands in tests with blocks of instruction e.g. in; // transcoding/global_block.ll. These operands are not used and should be; // substituted by zero constants. Their type is expected to be always; // OpTypePointer Function %uchar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:45,Modifiability,Extend,Extended,45,"// There is no log10 instruction in the GLSL Extended Instruction set, so it; // is implemented as:; // log10(x) = log2(x) * (1 / log2(10)); // = log2(x) * 0.30103",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp:13,Safety,avoid,avoids,13,// This code avoids CallLowering fail inside getVectorTypeBreakdown; // on v3i1 arguments. Maybe we need to return 1 for all types.; // TODO: remove it once this case is supported by the default implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp:13,Safety,avoid,avoids,13,// This code avoids CallLowering fail inside getVectorTypeBreakdown; // on v3i1 arguments. Maybe we need to return i32 for all types.; // TODO: remove it once this case is supported by the default implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h:50,Integrability,Interface,Interface,50,"//===-- SPIRVISelLowering.h - SPIR-V DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that SPIR-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- SPIRVISelLowering.h - SPIR-V DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that SPIR-V uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVLegalizerInfo.cpp:43,Modifiability,Extend,Extended,43,"// TODO: Review the target OpenCL and GLSL Extended Instruction Set specs to; // tighten these requirements. Many of these math functions are only legal on; // specific bitwidths, so they are not selectable for; // allFloatScalarsAndVectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:468,Performance,perform,performs,468,"//===- SPIRVModuleAnalysis.cpp - analysis of global instrs & regs - C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The analysis collects instructions that should be output at the module level; // and performs the global register numbering.; //; // The results of this analysis are used in AsmPrinter to rename registers; // globally and to output required instructions at the module level.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:61,Deployability,configurat,configuratoin,61,// TODO: determine memory model and source language from the configuratoin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:61,Modifiability,config,configuratoin,61,// TODO: determine memory model and source language from the configuratoin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:3,Deployability,Update,Update,3,"// Update required capabilities for this memory model, addressing model and; // source language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:115,Modifiability,variab,variable,115,"// Look for IDs declared with Import linkage, and map the corresponding function; // to the register defining that variable (which will usually be the result of; // an OpFunction). This lets us call externally imported functions using; // the correct ID registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:80,Security,hash,hash,80,"// Returns a representation of an instruction as a vector of MachineOperand; // hash values, see llvm::hash_value(const MachineOperand &MO) for details.; // This creates a signature of the instruction with the same content; // that MachineOperand::isIdenticalTo uses for comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:177,Safety,detect,detecting,177,// Collect the given instruction in the specified MS. We assume global register; // numbering has already occurred by this point. We can directly compare reg; // arguments when detecting duplicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:18,Availability,error,errors,18,// Report as many errors as possible before aborting the compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:44,Safety,abort,aborting,44,// Report as many errors as possible before aborting the compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:16,Security,access,access,16,// Has optional access qualifier.; // TODO: check if it's OpenCL's kernel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:468,Performance,perform,performs,468,"//===- SPIRVModuleAnalysis.h - analysis of global instrs & regs -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The analysis collects instructions that should be output at the module level; // and performs the global register numbering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:21,Testability,log,logical,21,// The enum contains logical module sections for the instruction collection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:15,Availability,Avail,AvailableCaps,15,// AllCaps and AvailableCaps are related but different. AllCaps is a subset of; // AvailableCaps. AvailableCaps is the complete set of capabilities that are; // available to the current target. AllCaps is the set of capabilities that; // are required by the current module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:83,Availability,Avail,AvailableCaps,83,// AllCaps and AvailableCaps are related but different. AllCaps is a subset of; // AvailableCaps. AvailableCaps is the complete set of capabilities that are; // available to the current target. AllCaps is the set of capabilities that; // are required by the current module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:98,Availability,Avail,AvailableCaps,98,// AllCaps and AvailableCaps are related but different. AllCaps is a subset of; // AvailableCaps. AvailableCaps is the complete set of capabilities that are; // available to the current target. AllCaps is the set of capabilities that; // are required by the current module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:161,Availability,avail,available,161,// AllCaps and AvailableCaps are related but different. AllCaps is a subset of; // AvailableCaps. AvailableCaps is the complete set of capabilities that are; // available to the current target. AllCaps is the set of capabilities that; // are required by the current module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:121,Safety,abort,abort,121,"// Add the given requirements to the lists. If constraints conflict, or these; // requirements cannot be satisfied, then abort the compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:90,Safety,abort,abort,90,"// Check if all the requirements can be satisfied for the given subtarget, and; // if not abort compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:33,Availability,avail,available,33,// Add the given capabilities to available and all their implicitly defined; // capabilities too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:73,Security,access,access,73,// The struct contains results of the module analysis and methods; // to access them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:594,Safety,avoid,avoid,594,"//===-- SPIRVPreLegalizer.cpp - prepare IR for legalization -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The pass prepares IR for legalization: it assigns SPIR-V types to registers; // and removes intrinsics which holded these types during IR translation.; // Also it processes constants and registers them in GR to avoid duplication.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:27,Availability,redundant,redundant,27,"// If the bitcast would be redundant, replace all uses with the source; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:27,Safety,redund,redundant,27,"// If the bitcast would be redundant, replace all uses with the source; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:14,Modifiability,rewrite,rewrite,14,// We need to rewrite dst types for ASSIGN_TYPE instrs to be able; // to perform tblgen'erated selection and we can't do that on Legalizer; // as it operates on gMIR only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:73,Performance,perform,perform,73,// We need to rewrite dst types for ASSIGN_TYPE instrs to be able; // to perform tblgen'erated selection and we can't do that on Legalizer; // as it operates on gMIR only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:917,Availability,redundant,redundant,917,"// Before IRTranslator pass, calls to spv_switch intrinsic are inserted before; // each switch instruction. IRTranslator lowers switches to G_ICMP + G_BRCOND; // + G_BR triples. A switch with two cases may be transformed to this MIR; // sequence:; //; // intrinsic(@llvm.spv.switch), %CmpReg, %Const0, %Const1; // %Dst0 = G_ICMP intpred(eq), %CmpReg, %Const0; // G_BRCOND %Dst0, %bb.2; // G_BR %bb.5; // bb.5.entry:; // %Dst1 = G_ICMP intpred(eq), %CmpReg, %Const1; // G_BRCOND %Dst1, %bb.3; // G_BR %bb.4; // bb.2.sw.bb:; // ...; // bb.3.sw.bb1:; // ...; // bb.4.sw.epilog:; // ...; //; // Sometimes (in case of range-compare switches), additional G_SUBs; // instructions are inserted before G_ICMPs. Those need to be additionally; // processed.; //; // This function modifies spv_switch call's operands to include destination; // MBBs (default and for each constant value).; //; // At the end, the function removes redundant [G_SUB] + G_ICMP + G_BRCOND +; // G_BR sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:917,Safety,redund,redundant,917,"// Before IRTranslator pass, calls to spv_switch intrinsic are inserted before; // each switch instruction. IRTranslator lowers switches to G_ICMP + G_BRCOND; // + G_BR triples. A switch with two cases may be transformed to this MIR; // sequence:; //; // intrinsic(@llvm.spv.switch), %CmpReg, %Const0, %Const1; // %Dst0 = G_ICMP intpred(eq), %CmpReg, %Const0; // G_BRCOND %Dst0, %bb.2; // G_BR %bb.5; // bb.5.entry:; // %Dst1 = G_ICMP intpred(eq), %CmpReg, %Const1; // G_BRCOND %Dst1, %bb.3; // G_BR %bb.4; // bb.2.sw.bb:; // ...; // bb.3.sw.bb1:; // ...; // bb.4.sw.epilog:; // ...; //; // Sometimes (in case of range-compare switches), additional G_SUBs; // instructions are inserted before G_ICMPs. Those need to be additionally; // processed.; //; // This function modifies spv_switch call's operands to include destination; // MBBs (default and for each constant value).; //; // At the end, the function removes redundant [G_SUB] + G_ICMP + G_BRCOND +; // G_BR sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:11,Availability,redundant,redundant,11,"// Collect redundant MIs from [G_SUB] + G_ICMP + G_BRCOND + G_BR sequences.; // After updating spv_switches, the instructions can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:11,Safety,redund,redundant,11,"// Collect redundant MIs from [G_SUB] + G_ICMP + G_BRCOND + G_BR sequences.; // After updating spv_switches, the instructions can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:3,Deployability,Update,Update,3,// Update each spv_switch with destination MBBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:244,Availability,down,down,244,"// If G_ICMP + G_BRCOND + G_BR were the only MIs in MBB, erase this MBB. It; // can be safely assumed, there are no breaks or phis directing into this; // MBB. However, we need to remove this MBB from the CFG graph. MBBs must be; // erased top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:87,Safety,safe,safely,87,"// If G_ICMP + G_BRCOND + G_BR were the only MIs in MBB, erase this MBB. It; // can be safely assumed, there are no breaks or phis directing into this; // MBB. However, we need to remove this MBB from the CFG graph. MBBs must be; // erased top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:39,Safety,detect,detected,39,"// Branching SPIR-V intrinsics are not detected by this generic method.; // Thus, we can only trust negative result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:108,Usability,simpl,simply,108,"// It is valid for MachineBasicBlocks to not finish with a branch instruction.; // In such cases, they will simply fallthrough their immediate successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:170,Integrability,wrap,wrap,170,"// For @llvm.memset.* intrinsic cases with constant value and length arguments; // are emulated via ""storing"" a constant array to the destination. For other; // cases we wrap the intrinsic in @spirv.llvm_memset_* function and expand the; // intrinsic to a loop via expandMemSetAsLoop().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:97,Usability,simpl,simply,97,"// Get a separate function - otherwise, we'd have to rework the CFG of the; // current one. Then simply replace the intrinsic uses with a call to the new; // function.; // Generate LLVM IR for i* @spirv.llvm_fsh?_i* (i* %a, i* %b, i* %c)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:40,Testability,log,logic,40,"// Build the actual funnel shift rotate logic.; // In the comments, ""int"" is used interchangeably with ""vector of int; // elements"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:5,Usability,simpl,simple,5,// A simple binary addition of the shifted ints yields the final result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:44,Testability,log,logic,44,"// Build the actual unsigned multiplication logic with the overflow; // indication. Do unsigned multiplication Mul = A * B. Then check; // if unsigned division Div = Mul / A is not equal to B. If so,; // then overflow has happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:97,Usability,simpl,simply,97,"// Get a separate function - otherwise, we'd have to rework the CFG of the; // current one. Then simply replace the intrinsic uses with a call to the new; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp:98,Availability,redundant,redundant,98,// This required for .td selection patterns to work or we'd end up with RegClass; // checks being redundant as all the classes would be mapped to the same bank.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp:98,Safety,redund,redundant,98,// This required for .td selection patterns to work or we'd end up with RegClass; // checks being redundant as all the classes would be mapped to the same bank.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp:490,Availability,redundant,redundant,490,"// Since SPIR-V cannot represent constant expression, constant expressions; // in LLVM IR need to be lowered to instructions. For each function,; // the constant expressions used by instructions of the function are replaced; // by instructions placed in the entry block since it dominates all other BBs.; // Each constant expression only needs to be lowered once in each function; // and all uses of it by instructions in that function are replaced by; // one instruction.; // TODO: remove redundant instructions for common subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp:490,Safety,redund,redundant,490,"// Since SPIR-V cannot represent constant expression, constant expressions; // in LLVM IR need to be lowered to instructions. For each function,; // the constant expressions used by instructions of the function are replaced; // by instructions placed in the entry block since it dominates all other BBs.; // Each constant expression only needs to be lowered once in each function; // and all uses of it by instructions in that function are replaced by; // one instruction.; // TODO: remove redundant instructions for common subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp:52,Usability,simpl,simple,52,// Check if all arguments have the same type - it's simple case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp:10,Modifiability,extend,extended,10,// Handle extended instruction sets from extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h:24,Availability,avail,available,24,"// TODO: Initialise the available extensions, extended instruction sets; // based on the environment settings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h:46,Modifiability,extend,extended,46,"// TODO: Initialise the available extensions, extended instruction sets; // based on the environment settings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h:183,Testability,Log,Logical,183,"// TODO: this environment is not implemented in Triple, we need to decide; // how to standardize its support. For now, let's assume SPIR-V with physical; // addressing is OpenCL, and Logical addressing is Vulkan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:50,Testability,Log,Logical,50,"// TODO: this probably needs to be revisited:; // Logical SPIR-V has no pointer size, so any fixed pointer size would be; // wrong. The choice to default to 32 or 64 is just motivated by another; // memory model used for graphics: PhysicalStorageBuffer64. But it shouldn't; // mean anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:30,Deployability,Configurat,Configuration,30,// SPIR-V Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:30,Modifiability,Config,Configuration,30,// SPIR-V Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:108,Deployability,pipeline,pipeline,108,"// namespace; // We do not use physical registers, and maintain virtual registers throughout; // the entire pipeline, so return nullptr to disable register allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:168,Usability,Simpl,Simplify,168,"// Once legalized, we need to structurize the CFG to follow the spec.; // This is done through the following 8 steps.; // TODO(#75801): add the remaining steps.; // 1. Simplify loop for subsequent transformations. After this steps, loops; // have the following properties:; // - loops have a single entry edge (pre-header to loop header).; // - all loop exits are dominated by the loop pre-header.; // - loops have a single back-edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.cpp:17,Usability,simpl,simple,17,// Otherwise use simple demangling to return the function name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h:101,Testability,log,logic,101,// Read the series of integer operands back as a null-terminated string using; // the reverse of the logic in addStringImm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h:117,Deployability,Update,Updates,117,"// Find def instruction for the given ConstReg, walking through; // spv_track_constant and ASSIGN_TYPE instructions. Updates ConstReg by def; // of OpConstant instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h:13,Security,Access,AccessQualifier,13,// namespace AccessQualifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h:143,Testability,log,logic,143,// Return a string representation of the operands from startIndex onwards.; // Templated to allow both MachineInstr and MCInst to use the same logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp:13,Integrability,interface,interface,13,"// Print the interface ID operands, skipping the name's string; // literal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp:91,Modifiability,variab,variable,91,// The last fixed operand along with any variadic operands that follow; // are part of the variable value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:28,Integrability,Interface,Interface,28,"//==- SystemZ.h - Top-Level Interface for SystemZ representation -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in; // the LLVM SystemZ backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for integer and floating-point; // comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for floating-point comparisons only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for arithmetical operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for logical operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:39,Testability,log,logical,39,// Condition-code mask assignments for logical operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for CS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for a completed SRST loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for TEST UNDER MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:50,Availability,MASK,MASK,50,// Condition-code mask assignments for TEST UNDER MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:39,Testability,TEST,TEST,39,// Condition-code mask assignments for TEST UNDER MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for TRANSACTION_BEGIN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for TRANSACTION_END.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for vector comparisons (and similar; // operations).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,Availability,mask,mask,18,// Condition-code mask assignments for Test Data Class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
